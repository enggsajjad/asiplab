<?xml version="1.0" encoding="UTF-8" ?>
<!-- Modified by T.Hamabe on 2006/12/05 -->
<!-- Modified by T.Hamabe on 2006/11/30 -->
<FHM>
  <model_name> pcu </model_name>

  <model>
    <design_level> behavior </design_level>
    <version> 1.0 </version>
    <author> <![CDATA[ Kyoko UEDA ]]> </author>
    <affiliation> <![CDATA[ Osaka Univ. ]]> </affiliation>
    <model_info> <![CDATA[
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                %
%    Copyright 2008 ASIP Solutions, Inc. All rights reserved.    %
%              Copyright 2002-2005 PEAS Project                  %
%                                                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
]]> </model_info>
    
    <parameter>
      <parameter_value key="bit_width">
        <value> 4 </value>
        <value> 8 </value>
        <value> 16 </value>
        <value> 32 </value>
        <value> 64 </value>
        <value> 128 </value>
      </parameter_value>
      <parameter_value key="increment_step">
        <value> 1 </value>
        <value> 2 </value>
        <value> 4 </value>
        <value> 8 </value>
      </parameter_value>
    </parameter>

    <function_description>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates function definition for pcu in behavior level
# parameter : bit_width increment_step

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width increment_step\n";
    exit (100);
}

$bit_width = $ARGV[0];
$inc_step  = $ARGV[1];

@bit_widths = (4, 8, 16, 32, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

@inc_steps = (1, 2, 4, 8, 16, 32, 64, 128);
if (! grep($_ eq $inc_step, @inc_steps)){
    print "increment_step $inc_step is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;
{
    print <<FHM_DL_FUNCTION
unsigned add(unsigned a, unsigned b);

model pcu${bit_width}{
  port{
    clock clock;
    in async_reset, load, reset, hold, data_in[$w_1:0];
    out data_out[$w_1:0];
  }
  storage{
    register reg[$w_1:0];
  }
  default_control{
    load  = '0';
    reset = '0';
    hold  = '1';
  }

  /** no operation*/
  function nop : idle{
    control{
      in load, reset, hold;
    }
    protocol{
      [load == 0 && reset == 0 && hold == 1]{
      }
    }
  }

  /** reset */
  function reset : reset{
    assignment{
      reg = 0;
    }
    control{
      in reset;
    }
    protocol{
      [reset == 1]{
	store reg;
      }
    }
  }

  /** increment */
  function inc{
    assignment{
      reg = add(reg, $inc_step);
    }
  }

  /** write : set program counter value */
  function write{
    input{
      bit_vector data_in;
    }
    assignment{
      reg = data_in;
    }
    control{
      in bit load;
    }
    protocol{
      [load = '1' && hold data_in]{
	store reg;
      }
    }
  }

  /** read : read program counter value */
  function read{
    output{
      bit_vector data_out;
    }
  }

  priority{ ( reset > ( inc | write ) ), read}
}
FHM_DL_FUNCTION
}
exit (0);
        ]]>
      </script>
    </function_description>

    <function_conv>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates function definition for pcu in behavior level
# parameter : bit_width increment_step

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width increment_step\n";
    exit (100);
}

$bit_width     = $ARGV[0];
$inc_step      = $ARGV[1];

@bit_widths = (4, 8, 16, 32, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

@inc_steps = (1, 2, 4, 8, 16, 32, 64, 128);
if (! grep($_ eq $inc_step, @inc_steps)){
    print "increment_step $inc_step is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;
{
    print <<FHM_DL_FUNCTION
/** no operation */
function nop{
  input{
  }

  output{
  }

  control{
    in bit load;
    in bit reset;
    in bit hold;
  }

  protocol{
    single_cycle_protocol{
      load  = '0';
      reset = '0';
      hold  = '1';
    }
  }
}

/** reset */
function reset{
  input{
  }

  output{
  }

  control{
    in bit reset;
  }

  protocol{
    single_cycle_protocol{
      reset = '1';
    }
  }
}

/** increment */
function inc{
  input{
  }

  output{
  }

  control{
    in bit hold;
  }

  protocol{
    single_cycle_protocol{
      hold = '0';
    }
  }
}

/** write : set program counter value */
function write{
  input{
    bit [$w_1:0] data_in;
  }

  output{
  }

  control{
    in bit load;
  }

  protocol{
    single_cycle_protocol{
      load = '1';
    }
  }
}

/** read : read program counter value */
function read{
  input{
  }

  output{
    bit [$w_1:0] data_out;
  }

  control{
  }

  protocol{
  }
}
FHM_DL_FUNCTION
}
exit (0);
        ]]>
      </script>
    </function_conv>

    <function_port>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates port information for pcu in behavior level
# parameter : bit_width increment_step

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width increment_step\n";
    exit (100);
}

$bit_width     = $ARGV[0];
$inc_step      = $ARGV[1];

@bit_widths = (4, 8, 16, 32, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

@inc_steps = (1, 2, 4, 8, 16, 32, 64, 128);
if (! grep($_ eq $inc_step, @inc_steps)){
    print "increment_step $inc_step is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;
{
    print <<FHM_DL_PORT
clock	in	bit		clock
async_reset	in	bit		reset
load	in	bit		ctrl
reset	in	bit		ctrl
hold	in	bit		ctrl
data_in	in	bit_vector   $w_1   0	data
data_out	out	bit_vector   $w_1   0	data
FHM_DL_PORT
}
exit (0);
        ]]>
      </script>
    </function_port>

    <design>
      <design_lang> vhdl </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates instance for pcu in behavior level
# parameter : instance_name bit_width increment_step

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width increment_step\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$inc_step      = $ARGV[2];

@bit_widths = (4, 8, 16, 32, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

@inc_steps = (1, 2, 4, 8, 16, 32, 64, 128);
if (! grep($_ eq $inc_step, @inc_steps)){
    print "increment_step $inc_step is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;
$zs = '0' x $bit_width;
{
    print <<FHM_DL_INSTANCE
-- Module	: $bit_width-bit program counter unit
--                $inc_step increment step
-- Refereces	:
-- Author	: Designed by M. Itoh (c)1998
-- Version	: 1.0 :

-- Functionality : behavior level
-- port
--  clock       : clock 
--  async_reset : asynchronous reset ('1' active)
--  load        : '1' then set counter value
--  reset       : synchronous reset ('1' active)
--  hold        : '1' then hold counter value
--  data_in     : data to register
--  data_out    : registered data

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;

entity $instance_name is
  port (
    clock       : in  std_logic;
    async_reset : in  std_logic;
    load        : in  std_logic;
    reset       : in  std_logic;
    hold        : in  std_logic;
    data_in     : in  std_logic_vector($w_1 downto 0);
    data_out    : out std_logic_vector($w_1 downto 0));
end $instance_name;

architecture behavior of $instance_name is
begin
  
  process(async_reset, clock)
    variable count : std_logic_vector($w_1 downto 0);
  begin
    if(async_reset = '1') then
      count := "$zs";
    elsif(clock'event and clock='1') then
      if (reset = '1') then
        count := (others => '0');
      elsif (load = '1') then
        count := data_in;
      elsif (hold = '0') then 
        count := count + $inc_step;
      end if;
    end if;
    data_out <= count;
  end process;
end behavior;
FHM_DL_INSTANCE
}
exit (0);
          ]]>
        </script>
      </instance>

      <entity></entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>

      <synthesis></synthesis>
    </design>

    <design>
      <design_lang> Verilog </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates instance for pcu in behavior level
# parameter : instance_name bit_width increment_step

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width increment_step\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$inc_step      = $ARGV[2];

@bit_widths = (4, 8, 16, 32, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

@inc_steps = (1, 2, 4, 8, 16, 32, 64, 128);
if (! grep($_ eq $inc_step, @inc_steps)){
    print "increment_step $inc_step is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;
$zs = '0' x $bit_width;
{
    print <<FHM_DL_INSTANCE
// Module	: $bit_width-bit program counter unit
//                $inc_step increment step
// Refereces	:
// Author	: Designed by M. Itoh (c)1998
// Version	: 1.0 :
\n
// Functionality : behavior level
// port
//  clock       : clock 
//  async_reset : asynchronous reset ('1' active)
//  load        : '1' then set counter value
//  reset       : synchronous reset ('1' active)
//  hold        : '1' then hold counter value
//  data_in     : data to register
//  data_out    : registered data
\n
module $instance_name (
  clock       ,
  async_reset ,
  load        ,
  reset       ,
  hold        ,
  data_in     ,
  data_out    ) ;
\n
input         clock       ;
input         async_reset ;
input         load        ;
input         reset       ;
input         hold        ;
input  [$w_1:0] data_in     ;
output [$w_1:0] data_out    ;
\n
wire         clock       ;
wire         async_reset ;
wire         load        ;
wire         reset       ;
wire         hold        ;
wire  [$w_1:0] data_in      ;
reg  [$w_1:0] data_out     ;
\n
always@(posedge clock or posedge async_reset)
begin
    if(async_reset == 1'b1)
      data_out <= \{$bit_width\{1'b0}};
    else
    begin
      if (reset == 1'b1)
        data_out <= \{$bit_width\{1'b0}};
      else if (load == 1'b1)
        data_out <= data_in;
      else if (hold == 1'b0) 
        data_out <= data_out + $inc_step;
    end
end
endmodule
FHM_DL_INSTANCE
}
exit (0);
          ]]>
        </script>
      </instance>

      <entity></entity>

      <testvector></testvector>

      <synthesis></synthesis>
    </design>

    <design>
      <design_lang> SystemC Header </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates instance for pcu in behavior level
# parameter : name_space instance_name bit_width increment_step

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script name_space instance_name bit_width increment_step\n";
    exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];
$inc_step      = $ARGV[3];

@bit_widths = (4, 8, 16, 32, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

@inc_steps = (1, 2, 4, 8, 16, 32, 64, 128);
if (! grep($_ eq $inc_step, @inc_steps)){
    print "increment_step $inc_step is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;
$zs = '0' x $bit_width;

if ($bit_width <= 64) {
    $data_type = "sc_dt::sc_uint<" . $bit_width . ">";
} else {
    $data_type = "sc_dt::sc_biguint<" . $bit_width . ">";
}

$macro = "__" . uc($name_space) . "_" . uc($instance_name) . "_H__";
{
    print <<FHM_DL_INSTANCE
#ifndef $macro
#define $macro 1

// Module	: $bit_width-bit program counter unit
//                $inc_step increment step
// Refereces	:
// Author	: Designed by M. Itoh (c)1998
// Version	: 1.0 :

// Functionality : behavior level
// port
//  clock       : clock 
//  async_reset : asynchronous reset ('1' active)
//  load        : '1' then set counter value
//  reset       : synchronous reset ('1' active)
//  hold        : '1' then hold counter value
//  data_in     : data to register
//  data_out    : registered data

#include <systemc>

namespace $name_space {
  SC_MODULE($instance_name) {
    sc_core::sc_in< bool > clock;
    sc_core::sc_in< bool > async_reset;
    sc_core::sc_in< bool > load;
    sc_core::sc_in< bool > reset;
    sc_core::sc_in< bool > hold;
    sc_core::sc_in< $data_type > data_in;
    sc_core::sc_out< $data_type > data_out;

    $data_type count;

    SC_CTOR($instance_name) :
      clock("clock"),
      async_reset("async_reset"),
      load("load"),
      reset("reset"),
      hold("hold"),
      data_in("data_in"),
      data_out("data_out")
    {
      SC_METHOD(process);
      sensitive << async_reset << clock.pos();
    }

    void process();
  };
};

#endif // $macro
FHM_DL_INSTANCE
}

exit (0);

          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <design>
      <design_lang> SystemC Program </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates instance for pcu in behavior level
# parameter : name_space instance_name bit_width increment_step

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script name_space instance_name bit_width increment_step\n";
    exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];
$inc_step      = $ARGV[3];

@bit_widths = (4, 8, 16, 32, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

@inc_steps = (1, 2, 4, 8, 16, 32, 64, 128);
if (! grep($_ eq $inc_step, @inc_steps)){
    print "increment_step $inc_step is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;
$zs = '0' x $bit_width;

if ($bit_width <= 64) {
    $data_type = "sc_dt::sc_uint<" . $bit_width . ">";
} else {
    $data_type = "sc_dt::sc_biguint<" . $bit_width . ">";
}

{
    print <<FHM_DL_INSTANCE
#include "$instance_name.h"

// Module	: $bit_width-bit program counter unit
//                $inc_step increment step
// Refereces	:
// Author	: Designed by M. Itoh (c)1998
// Version	: 1.0 :

// Functionality : behavior level
// port
//  clock       : clock 
//  async_reset : asynchronous reset ('1' active)
//  load        : '1' then set counter value
//  reset       : synchronous reset ('1' active)
//  hold        : '1' then hold counter value
//  data_in     : data to register
//  data_out    : registered data

void ${name_space}::${instance_name}::process()
{
  if (async_reset.read() == true) {
    count = 0;
  } else if (clock.event() && clock.read() == true) {
    if ( reset.read() == true ) {
      count = 0;
    } else if ( load.read() == true ) {
      count = data_in.read();
    } else if ( hold.read() == false ) {
      count += $inc_step;
    }
  }
  data_out.write( count );
}
FHM_DL_INSTANCE
}
exit (0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <estimation>
    </estimation>

  </model>

  <model>
    <design_level> synthesis </design_level>
    <version> 1.0 </version>
    <author> <![CDATA[ Kyoko UEDA ]]> </author>
    <affiliation> <![CDATA[ Osaka Univ. ]]> </affiliation>
    <model_info> <![CDATA[
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                %
%    Copyright 2008 ASIP Solutions, Inc. All rights reserved.    %
%              Copyright 2002-2005 PEAS Project                  %
%                                                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
]]> </model_info>

    <parameter>
      <parameter_value key="bit_width">
        <value> 4 </value>
        <value> 8 </value>
        <value> 16 </value>
        <value> 32 </value>
        <value> 64 </value>
        <value> 128 </value>
      </parameter_value>
      <parameter_value key="increment_step">
        <value> 1 </value>
        <value> 2 </value>
        <value> 4 </value>
        <value> 8 </value>
      </parameter_value>
      <parameter_value key="adder_algorithm">
        <value> default </value>
      </parameter_value>
    </parameter>

    <function_description>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates function definition for pcu in synthesis level
# parameter : bit_width increment_step adder_algorithm

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width increment_step adder_algorithm\n";
    exit (100);
}

$bit_width = $ARGV[0];
$inc_step  = $ARGV[1];
$add_algo  = $ARGV[2];

@bit_widths = (4, 8, 16, 32, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

@inc_steps = (1, 2, 4, 8, 16, 32, 64, 128);
if (! grep($_ eq $inc_step, @inc_steps)){
    print "increment_step $inc_step is not supported.\n";
    exit (100);
}

@add_algos = ("default");
if (! grep($_ eq $add_algo, @add_algos)){
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;
{
    print <<FHM_DL_FUNCTION
unsigned add(unsigned a, unsigned b);

model pcu${bit_width}{
  port{
    clock clock;
    in async_reset, load, reset, hold, data_in[$w_1:0];
    out data_out[$w_1:0];
  }
  storage{
    register reg[$w_1:0];
  }
  default_control{
    load  = '0';
    reset = '0';
    hold  = '1';
  }

  /** no operation*/
  function nop : idle{
    control{
      in load, reset, hold;
    }
    protocol{
      [load == 0 && reset == 0 && hold == 1]{
      }
    }
  }

  /** reset */
  function reset : reset{
    assignment{
      reg = 0;
    }
    control{
      in reset;
    }
    protocol{
      [reset == 1]{
	store reg;
      }
    }
  }

  /** increment */
  function inc{
    assignment{
      reg = add(reg, $inc_step);
    }
  }

  /** write : set program counter value */
  function write{
    input{
      bit_vector data_in;
    }
    assignment{
      reg = data_in;
    }
    control{
      in bit load;
    }
    protocol{
      [load = '1' && hold data_in]{
	store reg;
      }
    }
  }

  /** read : read program counter value */
  function read{
    output{
      bit_vector data_out;
    }
  }

  priority{ ( reset > ( inc | write ) ), read}
}
FHM_DL_FUNCTION
}
exit (0);
        ]]>
      </script>
    </function_description>

    <function_conv>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates function definition for pcu in synthesis level
# parameter : bit_width increment_step adder_algorithm

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width increment_step adder_algorithm\n";
    exit (100);
}

$bit_width = $ARGV[0];
$inc_step  = $ARGV[1];
$add_algo  = $ARGV[2];

@bit_widths = (4, 8, 16, 32, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

@inc_steps = (1, 2, 4, 8, 16, 32, 64, 128);
if (! grep($_ eq $inc_step, @inc_steps)){
    print "increment_step $inc_step is not supported.\n";
    exit (100);
}

@add_algos = ("default");
if (! grep($_ eq $add_algo, @add_algos)){
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;
{
    print <<FHM_DL_FUNCTION
/** no operation */
function nop{
  input{
  }

  output{
  }

  control{
    in bit load;
    in bit reset;
    in bit hold;
  }

  protocol{
    single_cycle_protocol{
      load  = '0';
      reset = '0';
      hold  = '1';
    }
  }
}

/** reset */
function reset{
  input{
  }

  output{
  }

  control{
    in bit reset;
  }

  protocol{
    single_cycle_protocol{
      reset = '1';
    }
  }
}

/** increment */
function inc{
  input{
  }

  output{
  }

  control{
    in bit hold;
  }

  protocol{
    single_cycle_protocol{
      hold = '0';
    }
  }
}

/** write : set program counter value */
function write{
  input{
    bit [$w_1:0] data_in;
  }

  output{
  }

  control{
    in bit load;
  }

  protocol{
    single_cycle_protocol{
      load = '1';
    }
  }
}

/** read : read program counter value */
function read{
  input{
  }

  output{
    bit [$w_1:0] data_out;
  }

  control{
  }

  protocol{
  }
}
FHM_DL_FUNCTION
}
exit (0);
        ]]>
      </script>
    </function_conv>

    <function_port>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates port information for pcu in synthesis level
# parameter : bit_width increment_step adder_algorithm

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width increment_step adder_algorithm\n";
    exit (100);
}

$bit_width     = $ARGV[0];
$inc_step      = $ARGV[1];
$add_algo      = $ARGV[2];

@bit_widths = (4, 8, 16, 32, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

@inc_steps = (1, 2, 4, 8, 16, 32, 64, 128);
if (! grep($_ eq $inc_step, @inc_steps)){
    print "increment_step $inc_step is not supported.\n";
    exit (100);
}

@add_algos = ("default");
if (! grep($_ eq $add_algo, @add_algos)){
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;

print <<FHM_DL_PCU
clock	in	bit		clock
async_reset	in	bit		reset
load	in	bit		ctrl
reset	in	bit		ctrl
hold	in	bit		ctrl
data_in	in	bit_vector   $w_1   0	data
data_out	out	bit_vector   $w_1   0	data
FHM_DL_PCU
        ]]>
      </script>
    </function_port>

    <design>
      <design_lang> vhdl </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates instance for pcu in synthesis level
# parameter : instance_name bit_width increment_step adder_algorithm

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width increment_step adder_algorithm\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$inc_step      = $ARGV[2];
$add_algo      = $ARGV[3];

@bit_widths = (4, 8, 16, 32, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

@inc_steps = (1, 2, 4, 8, 16, 32, 64, 128);
if (! grep($_ eq $inc_step, @inc_steps)){
    print "increment_step $inc_step is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;

$instance_name_add = $instance_name."_add$bit_width";

if ("$add_algo" eq "default"){
    if ($bit_width == 1){
	$data1 = "";
	$data2 = "(0)";
    }
    else{
	$w = $bit_width - 1;
	$data1 = "_vector($w downto 0)";
	$data2 = "($w downto 0)";
    }

    {
	print <<FHM_DL_INSTANCE
-- Module     : $bit_width-bit unsigned adder
-- References :
-- Author     : Designed by T.Morifuji (c)1996.
-- Version    : 1.0

-- Functionality : behavior level
--  port
--   a, b   : add datas
--   cin    : carry in
--   result : result of a + b + c
--   cout   : '1' when result > 2^$bit_width-1

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity $instance_name_add is
  port (a, b   : in std_logic$data1;
        cin    : in std_logic;
        result : out std_logic$data1;
        cout   : out std_logic);
end $instance_name_add;

architecture synthesis of $instance_name_add is

begin  -- behavior

  addition: process (a, b, cin)
    variable int_a, int_b : std_logic_vector($bit_width downto 0);
    variable int_result   : std_logic_vector($bit_width downto 0);
  begin
    int_a      := '0' & a;
    int_b      := '0' & b;

    int_result := int_a + int_b + cin;

    result     <= int_result$data2;
    cout       <= int_result($bit_width);

  end process addition;

end synthesis;

FHM_DL_INSTANCE
    }
}
else{
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

print "\n--%%\n\n";

{
    $zeros = 0 x $bit_width;
    print <<FHM_DL_REG
-- Module     : $bit_width-bit positive edge trigger register
-- References :
-- Author     : Designed by T.Morifuji (c)1997.
-- Version    : 1.0  :

-- Functionality : synthesis level
--  port
--   clock       : clock
--   async_reset : asynchronous reset
--   reset       : synchronous reset
--   enb         : '1' then register data
--   data_in     : data to register
--   data_out    : registered data

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_reg$bit_width is
  port (clock       : in  std_logic;
        async_reset : in  std_logic;
        reset       : in  std_logic;
        enb         : in  std_logic;
        data_in     : in  std_logic_vector($w_1 downto 0);
        data_out    : out std_logic_vector($w_1 downto 0) );
end ${instance_name}_reg$bit_width;

architecture synthesis of ${instance_name}_reg$bit_width is
begin

  process (async_reset, clock)
  begin
    if (async_reset = '1') then
      data_out <= "$zeros";
    elsif (clock'event and clock = '1') then
      if (reset = '1') then
        data_out <= (others => '0');
      elsif (enb = '1') then
        data_out <= data_in;
      end if;
    end if;
  end process;

end synthesis;

--%%
FHM_DL_REG
}
($step, $dummy) = &print_2_comp($inc_step, $bit_width);
{
print <<FHM_DL_PCU
-- Module	: $bit_width-bit program counter unit
--                $inc_step increment step and
--                using $add_algo for adder algorithm
-- Refereces	:
-- Author	: Designed by M. Itoh (c)1998
-- Version	: 1.0 :

-- Functionality : synthesis level
-- port
--  clock      	: clock
--  async_reset : asynchronous reset ('1' active)
--  load	: '1' then set counter value
--  reset	: synchronous reset ('1' active)
--  hold	: '1' then hold counter value
--  data_in	: data to register
--  data_out	: registered data

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;

entity $instance_name is
  port(
    clock       : in  std_logic;
    async_reset : in  std_logic;
    load        : in  std_logic;
    reset       : in  std_logic;
    hold        : in  std_logic;
    data_in     : in  std_logic_vector($w_1 downto 0);
    data_out    : out std_logic_vector($w_1 downto 0));
end $instance_name;

architecture synthesis of $instance_name is
component $instance_name_add
  port (
    a, b   : in  std_logic_vector($w_1 downto 0);
    cin    : in  std_logic;
    result : out std_logic_vector($w_1 downto 0);
    cout   : out std_logic );
end component;

component ${instance_name}_reg$bit_width
  port (
    clock       : in  std_logic;
    async_reset : in  std_logic;
    reset       : in  std_logic;
    enb	        : in  std_logic;
    data_in     : in  std_logic_vector($w_1 downto 0);
    data_out    : out std_logic_vector($w_1 downto 0)
  );
end component;

signal zero, one	: std_logic;
signal pc, next_pc, inc_pc	: std_logic_vector($w_1 downto 0);
signal step	: std_logic_vector($w_1 downto 0);

signal	cout	: std_logic;

begin
  zero <= '0';
  one  <= '1';
  step <= "$step";
  
  next_pc <= data_in when load = '1' else
             pc when hold = '1' else
             inc_pc;
  
  add1 : $instance_name_add
  port map(
    a	   => pc,
    b	   => step,
    cin	   => zero,
    result => inc_pc,
    cout   => open);

  reg1 : ${instance_name}_reg$bit_width
  port map (
    clock       => clock,
    async_reset => async_reset,
    reset       => reset,
    enb         => one,
    data_in     => next_pc,
    data_out    => pc);

  data_out <= pc;
end synthesis;
FHM_DL_PCU
}

sub print_2_comp{
  my (@buf) = ();
  my ($num) = $_[0];
  my ($bit_width) = $_[1];
  my ($over) = 0;

  for ($i=1; $i<$bit_width; $i++){
    $buf[$i] = $num % 2;
    $num = ($num - $buf[$i]) / 2;
  }
  $buf[$i] = $num % 2;
  if (($num / 2) >= 1){
      $over = 1;
  }
  return (join("", reverse(@buf)), $over);
}
          ]]>
        </script>
      </instance>

      <entity></entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>

      <synthesis>
        <parameter></parameter>
        <synthesis_script>
          <script>
            <![CDATA[
#!/usr/bin/perl
# this script generates synthesis script for pcu in synthesis level
# parameter : instance_name priority bit_width increment_step adder_algorithm

if ($#ARGV != 4){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name priority bit_width increment_step adder_algorithm\n";
    exit (100);
}

$instance_name = $ARGV[0];
$priority      = $ARGV[1];
$bit_width     = $ARGV[2];
$inc_step      = $ARGV[3];
$add_algo      = $ARGV[4];

if ($priority eq "area"){
    $priority_const = "set_max_area 0";
}
elsif ($priority eq "performance"){
    $priority_const = "set_max_delay -from all_inputs() -to all_outputs() 0";
}
elsif ($priority eq "power"){
    $priority_const = "";
}
elsif ($priority eq "none"){
    $priority_const = "";
}
else{
    print "priority $priority is not supported.\n";
    exit (100);
}

@bit_widths = (4, 8, 16, 32, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

@inc_steps = (1, 2, 4, 8, 16, 32, 64, 128);
if (! grep($_ eq $inc_step, @inc_steps)){
    print "increment_step $inc_step is not supported.\n";
    exit (100);
}

@add_algos = ("default");
if (! grep($_ eq $add_algo, @add_algos)){
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

{
print <<FHM_DL_SCRIPT
hdlin_auto_save_templates = TRUE

analyze -f vhdl $instance_name.vhd

elaborate $instance_name
uniquify

$priority_const

create_clock -period 10 -waveform{0 5} clock

compile 

write -hierarchy -output $instance_name.db

report_area
report_timing

quit
FHM_DL_SCRIPT
}
exit (0);
            ]]>
          </script>
        </synthesis_script>
      </synthesis>
    </design>

    <design>
      <design_lang> Verilog </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates instance for pcu in synthesis level
# parameter : instance_name bit_width increment_step adder_algorihm


if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width increment_step adder_algorithm\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$inc_step      = $ARGV[2];
$add_algo      = $ARGV[3];

@bit_widths = (4, 8, 16, 32, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

@inc_steps = (1, 2, 4, 8, 16, 32, 64, 128);
if (! grep($_ eq $inc_step, @inc_steps)){
    print "increment_step $inc_step is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;

$instance_name_add = $instance_name."_add$bit_width";

if ("$add_algo" eq "default"){
    if ($bit_width == 1){
	$data1 = "";
	$data2 = "[0]";
    }
    else{
	$w = $bit_width - 1;
	$data1 = "[$w:0]";
	$data2 = "[$w:0]";
    }
{
print <<FHM_DL_INSTANCE
// Module     : $bit_width-bit unsigned adder
// References :
// Author     : Designed by T.Morifuji (c)1996.
// Version    : 1.0
\n
// Functionality : behavior level
//  port
//   a, b   : add datas
//   cin    : carry in
//   result : result of a + b + c
//   cout   : '1' when result > 2^${bit_width}-1
\n
module $instance_name_add (
  a      ,
  b      ,
  cin    ,
  result ,
  cout   ) ;
\n
input  $data1 a      ;
input  $data1 b      ;
input         cin    ;
output $data1 result ;
output        cout   ;
\n
assign {cout, result} = a + b + cin ;
\n
endmodule
FHM_DL_INSTANCE
}
}#default
else{
  print "adder_alogrithm $add_algo is not supported.\n";
  exit(100)
}

print " \n//%%\n";
print " \n";
{
   $zeros = 0 x $bit_width;
   print <<FHM_DL_REG
// Module     : $bit_width-bit positive edge trigger register
// References :
// Author     : Designed by T.Morifuji (c)1997.
// Version    : 1.0  :
\n
// Functionality : synthesis level
//  port
//   clock       : clock
//   async_reset : asynchronous reset
//   reset       : synchronous reset
//   enb         : '1' then register data
//   data_in     : data to register
//   data_out    : registered data
\n
module ${instance_name}_reg$bit_width (
  clock       ,
  async_reset ,
  reset       ,
  enb         ,
  data_in     ,
  data_out    ) ;
\n
input         clock       ;
input         async_reset ;
input         reset       ;
input         enb         ;
input  [$w_1:0] data_in     ;
output [$w_1:0] data_out    ;
\n
reg [$w_1:0] data_out ;
\n
always @(posedge clock or posedge async_reset)
begin
  if (async_reset == 1'b1)
    data_out <= {$bit_width\{1'b0}} ;
  else
  begin
    if (reset == 1'b1)
      data_out <= {$bit_width\{1'b0}} ;
    else if (enb == 1'b1)
      data_out <= data_in ;
  end
end
\n
endmodule
\n
//%%
FHM_DL_REG
}
($step, $dummy) = &print_2_comp($inc_step, $bit_width);
{
print <<FHM_DL_PCU
// Module	: $bit_width-bit program counter unit
//                4 increment step and
//                using default for adder algorithm
// Refereces	:
// Author	: Designed by M. Itoh (c)1998
// Version	: 1.0 :
\n
// Functionality : synthesis level
// port
//  clock      	: clock
//  async_reset : asynchronous reset ('1' active)
//  load	: '1' then set counter value
//  reset	: synchronous reset ('1' active)
//  hold	: '1' then hold counter value
//  data_in	: data to register
//  data_out	: registered data
\n
module $instance_name (
  clock       ,
  async_reset ,
  load        ,
  reset       ,
  hold        ,
  data_in     ,
  data_out    ) ;
\n
input         clock       ;
input         async_reset ;
input         load        ;
input         reset       ;
input         hold        ;
input  [$w_1:0] data_in     ;
output [$w_1:0] data_out    ;
\n
wire        zero    ;
wire        one     ;
wire [$w_1:0] pc      ;
wire [$w_1:0] next_pc ;
wire [$w_1:0] inc_pc  ;
wire [$w_1:0] step    ;
wire        cout    ;
\n
assign zero = 1'b0 ;
assign one  = 1'b1 ;
assign step = ${bit_width}'b$step ;
\n  
assign next_pc = (load == 1'b1) ? data_in :
                 (hold == 1'b1) ? pc : inc_pc ;
\n  
$instance_name_add ADD1 (
    .a     (pc)     ,
    .b     (step)   ,
    .cin   (zero)   ,
    .result(inc_pc) ,
    .cout  (open)   ) ;
\n
${instance_name}_reg$bit_width REG1 (
    .clock      (clock)       ,
    .async_reset(async_reset) ,
    .reset      (reset)       ,
    .enb        (one)         ,
    .data_in    (next_pc)     ,
    .data_out   (pc)          ) ;
\n
assign data_out = pc ;
\n
endmodule
\n
FHM_DL_PCU
}
exit(0);
#---------------------
sub print_2_comp{
  my (@buf) = ();
  my ($num) = $_[0];
  my ($bit_width) = $_[1];
  my ($over) = 0;

  for ($i=1; $i<$bit_width; $i++){
    $buf[$i] = $num % 2;
    $num = ($num - $buf[$i]) / 2;
  }
  $buf[$i] = $num % 2;
  if (($num / 2) >= 1){
      $over = 1;
  }
  return (join("", reverse(@buf)), $over);
}
          ]]>
        </script>
      </instance>

      <entity></entity>

      <testvector></testvector>

      <synthesis></synthesis>
    </design>

    <design>
      <design_lang> SystemC Header </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates instance for pcu in synthesis level
# parameter : name_space instance_name bit_width increment_step adder_algorithm

if ($#ARGV != 4){
    print "number of parameters is wrong.\n";
    print "usage : this_script name_space instance_name bit_width increment_step adder_algorithm\n";
    exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];
$inc_step      = $ARGV[3];
$add_algo      = $ARGV[4];

@bit_widths = (4, 8, 16, 32, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

@inc_steps = (1, 2, 4, 8, 16, 32, 64, 128);
if (! grep($_ eq $inc_step, @inc_steps)){
    print "increment_step $inc_step is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;

$instance_name_add = $instance_name."_add$bit_width";

if ($bit_width == 1) {
    $data_type = "bool";
} elsif ($bit_width <= 64) {
    $data_type = "sc_dt::sc_uint<" . $bit_width . ">";
} else {
    $data_type = "sc_dt::sc_biguint<" . $bit_width . ">";
}
$w = $bit_width - 1;

if ($bit_width + 1 <= 64) {
    $tmp_type = "sc_dt::sc_uint<" . ($bit_width + 1) . ">";
} else {
    $tmp_type = "sc_dt::sc_biguint<" . ($bit_width + 1) . ">";
}

$macro = "__" . uc($name_space) . "_" . uc($instance_name) . "_H__";

if ("$add_algo" eq "default"){
    {
	print <<FHM_DL_INSTANCE
#ifndef $macro
#define $macro 1

// Module     : $bit_width-bit unsigned adder
// References :
// Author     : Designed by T.Morifuji (c)1996.
// Version    : 1.0

// Functionality : behavior level
//  port
//   a, b   : add datas
//   cin    : carry in
//   result : result of a + b + c
//   cout   : '1' when result > 2^$bit_width-1

#include <systemc>

namespace $name_space {
  SC_MODULE($instance_name_add) {
    sc_core::sc_in< $data_type > a, b;
    sc_core::sc_in< bool > cin;
    sc_core::sc_out< $data_type > result;
    sc_core::sc_out< bool > cout;

    SC_CTOR($instance_name_add) :
      a("a"), b("b"), cin("cin"),
      result("result"), cout("cout")
    {
       SC_METHOD(process);
       sensitive << a << b << cin;
    }

    void process();
  };
};
FHM_DL_INSTANCE
    }
}
else{
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

print "\n// %%\n\n";

{
    $zeros = 0 x $bit_width;
    print <<FHM_DL_REG
// Module     : $bit_width-bit positive edge trigger register
// References :
// Author     : Designed by T.Morifuji (c)1997.
// Version    : 1.0  :

// Functionality : synthesis level
//  port
//   clock       : clock
//   async_reset : asynchronous reset
//   reset       : synchronous reset
//   enb         : '1' then register data
//   data_in     : data to register
//   data_out    : registered data

namespace $name_space {
  SC_MODULE(${instance_name}_reg$bit_width) {
    sc_core::sc_in< bool > clock;
    sc_core::sc_in< bool > async_reset;
    sc_core::sc_in< bool > reset;
    sc_core::sc_in< bool > enb;
    sc_core::sc_in< $data_type > data_in;
    sc_core::sc_out< $data_type > data_out;

    SC_CTOR(${instance_name}_reg$bit_width) :
      clock("clock"),
      async_reset("async_reset"),
      reset("reset"),
      enb("enb"),
      data_in("data_in"),
      data_out("data_out")
    {
      SC_METHOD(process);
      sensitive << async_reset << clock.pos();
    }

    void process();
  };
};

// %%
FHM_DL_REG
}
($step, $dummy) = &print_2_comp($inc_step, $bit_width);
{
print <<FHM_DL_PCU
// Module	: $bit_width-bit program counter unit
//                $inc_step increment step and
//                using $add_algo for adder algorithm
// Refereces	:
// Author	: Designed by M. Itoh (c)1998
// Version	: 1.0 :

// Functionality : synthesis level
// port
//  clock      	: clock
//  async_reset : asynchronous reset ('1' active)
//  load	: '1' then set counter value
//  reset	: synchronous reset ('1' active)
//  hold	: '1' then hold counter value
//  data_in	: data to register
//  data_out	: registered data

namespace $name_space {
  SC_MODULE($instance_name) {
    sc_core::sc_in< bool > clock;
    sc_core::sc_in< bool > async_reset;
    sc_core::sc_in< bool > load;
    sc_core::sc_in< bool > reset;
    sc_core::sc_in< bool > hold;
    sc_core::sc_in< $data_type > data_in;
    sc_core::sc_out< $data_type > data_out;

    sc_core::sc_signal< bool > zero, one;
    sc_core::sc_signal< $data_type > pc, next_pc, inc_pc;
    sc_core::sc_signal< $data_type > step;
    sc_core::sc_signal< bool > cout;
    sc_core::sc_signal< bool > open;

    $instance_name_add add1;
    ${instance_name}_reg$bit_width reg1;

    SC_CTOR($instance_name) :
      clock("clock"),
      async_reset("async_reset"),
      load("load"),
      reset("reset"),
      hold("hold"),
      data_in("data_in"),
      data_out("data_out"),
      zero("zero"),
      one("one"),
      pc("pc"),
      next_pc("next_pc"),
      inc_pc("inc_pc"),
      step("step"),
      cout("cout"),
      add1("add1"),
      reg1("reg1")
    {
      add1.a(pc);
      add1.b(step);
      add1.cin(zero);
      add1.result(inc_pc);
      add1.cout(open);

      reg1.clock(clock);
      reg1.async_reset(async_reset);
      reg1.reset(reset);
      reg1.enb(one);
      reg1.data_in(next_pc);
      reg1.data_out(pc);

      SC_METHOD(initialize);

      SC_METHOD(process);
      sensitive << data_in << load << pc << hold << inc_pc;
    }

    void initialize();
    void process();
  };
};

#endif // $macro
FHM_DL_PCU
}

sub print_2_comp{
  my (@buf) = ();
  my ($num) = $_[0];
  my ($bit_width) = $_[1];
  my ($over) = 0;

  for ($i=1; $i<$bit_width; $i++){
    $buf[$i] = $num % 2;
    $num = ($num - $buf[$i]) / 2;
  }
  $buf[$i] = $num % 2;
  if (($num / 2) >= 1){
      $over = 1;
  }
  return (join("", reverse(@buf)), $over);
}
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <design>
      <design_lang> SystemC Program </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates instance for pcu in synthesis level
# parameter : name_space instance_name bit_width increment_step adder_algorithm

if ($#ARGV != 4){
    print "number of parameters is wrong.\n";
    print "usage : this_script name_space instance_name bit_width increment_step adder_algorithm\n";
    exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];
$inc_step      = $ARGV[3];
$add_algo      = $ARGV[4];

@bit_widths = (4, 8, 16, 32, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

@inc_steps = (1, 2, 4, 8, 16, 32, 64, 128);
if (! grep($_ eq $inc_step, @inc_steps)){
    print "increment_step $inc_step is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;

$instance_name_add = $instance_name."_add$bit_width";

if ($bit_width == 1) {
    $data_type = "bool";
} elsif ($bit_width <= 64) {
    $data_type = "sc_dt::sc_uint<" . $bit_width . ">";
} else {
    $data_type = "sc_dt::sc_biguint<" . $bit_width . ">";
}
$w = $bit_width - 1;

if ($bit_width + 1 <= 64) {
    $tmp_type = "sc_dt::sc_uint<" . ($bit_width + 1) . ">";
} else {
    $tmp_type = "sc_dt::sc_biguint<" . ($bit_width + 1) . ">";
}

if ("$add_algo" eq "default"){
    {
	print <<FHM_DL_INSTANCE
#include "$instance_name.h"

// Module     : $bit_width-bit unsigned adder
// References :
// Author     : Designed by T.Morifuji (c)1996.
// Version    : 1.0

// Functionality : behavior level
//  port
//   a, b   : add datas
//   cin    : carry in
//   result : result of a + b + c
//   cout   : '1' when result > 2^$bit_width-1

void ${name_space}::${instance_name_add}::process()
{
  $tmp_type tmp_a(a.read());

  tmp_a += b.read();
  tmp_a += cin.read();
  result.write( tmp_a($w, 0) );
  cout.write( tmp_a[$bit_width] );
}

FHM_DL_INSTANCE
    }
}
else{
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

print "\n//%%\n\n";

{
    $zeros = 0 x $bit_width;
    print <<FHM_DL_REG
// Module     : $bit_width-bit positive edge trigger register
// References :
// Author     : Designed by T.Morifuji (c)1997.
// Version    : 1.0  :

// Functionality : synthesis level
//  port
//   clock       : clock
//   async_reset : asynchronous reset
//   reset       : synchronous reset
//   enb         : '1' then register data
//   data_in     : data to register
//   data_out    : registered data

void ${name_space}::${instance_name}_reg${bit_width}::process()
{
  if ( async_reset.read() == true ) {
    data_out.write( 0 );
  } else if ( clock.event() && clock.read() == true ) {
    if ( reset.read() == true ) {
      data_out.write( 0 );
    } else if ( enb.read() == true ) {
      data_out.write( data_in.read() );
    }
  }
}

// %%
FHM_DL_REG
}
($step, $dummy) = &print_2_comp($inc_step, $bit_width);
{
print <<FHM_DL_PCU
// Module	: $bit_width-bit program counter unit
//                $inc_step increment step and
//                using $add_algo for adder algorithm
// Refereces	:
// Author	: Designed by M. Itoh (c)1998
// Version	: 1.0 :

// Functionality : synthesis level
// port
//  clock      	: clock
//  async_reset : asynchronous reset ('1' active)
//  load	: '1' then set counter value
//  reset	: synchronous reset ('1' active)
//  hold	: '1' then hold counter value
//  data_in	: data to register
//  data_out	: registered data

void ${name_space}::${instance_name}::initialize()
{
  zero.write( 0 );
  one.write( 1 );
  step.write( "0bus$step" );
}

void ${name_space}::${instance_name}::process()
{
  if (load.read() == true) {
    next_pc.write( data_in.read() );
  } else if ( hold.read() == true ) {
    next_pc.write( pc.read() );
  } else {
    next_pc.write( inc_pc.read() );
  }

  data_out.write( pc.read() );
}

FHM_DL_PCU
}

sub print_2_comp{
  my (@buf) = ();
  my ($num) = $_[0];
  my ($bit_width) = $_[1];
  my ($over) = 0;

  for ($i=1; $i<$bit_width; $i++){
    $buf[$i] = $num % 2;
    $num = ($num - $buf[$i]) / 2;
  }
  $buf[$i] = $num % 2;
  if (($num / 2) >= 1){
      $over = 1;
  }
  return (join("", reverse(@buf)), $over);
}


          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <estimation>
      <estimation_data>
        <library name="OSAKA">

          <est_type name="shape">
            <est_index name="area">
              <unit> mm2 </unit>
              <translate>
                <translate_value key="gate"> 4201.68 </translate_value>
                <translate_value key="mm2">  1 </translate_value>
              </translate>

              <parameters name="1,default">
                <max>
                  <data bit_width="4"> 0.0405599043715847 </data>
                  <data bit_width="8"> 0.0741406506445041 </data>
                  <data bit_width="16"> 0.146113269930123 </data>
                  <data bit_width="32"> 0.292957274233164 </data>
                  <data bit_width="64"> 0.602695759077321 </data>
                  <data bit_width="128"> 1.27950819291331 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.0324934695169551 </data>
                  <data bit_width="8"> 0.0616712079453933 </data>
                  <data bit_width="16"> 0.119720831905333 </data>
                  <data bit_width="32"> 0.235446331467413 </data>
                  <data bit_width="64"> 0.488618261742922 </data>
                  <data bit_width="128"> 1.03452073884732 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.0324934695169551 </data>
                    <data bit_width="8"> 0.0616712079453933 </data>
                    <data bit_width="16"> 0.119720831905333 </data>
                    <data bit_width="32"> 0.235446331467413 </data>
                    <data bit_width="64"> 0.488618261742922 </data>
                    <data bit_width="128"> 1.04681667142667 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.0329174142247863 </data>
                    <data bit_width="8"> 0.0623661640105862 </data>
                    <data bit_width="16"> 0.121348744073799 </data>
                    <data bit_width="32"> 0.239501222130196 </data>
                    <data bit_width="64"> 0.493710393461663 </data>
                    <data bit_width="128"> 1.03452073884732 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.0405599043715847 </data>
                    <data bit_width="8"> 0.0741406506445041 </data>
                    <data bit_width="16"> 0.146113269930123 </data>
                    <data bit_width="32"> 0.292957274233164 </data>
                    <data bit_width="64"> 0.602695759077321 </data>
                    <data bit_width="128"> 1.27950819291331 </data>
                  </priority>
                </typ>
              </parameters>
              <parameters name="2,default">
                <max>
                  <data bit_width="4"> 0.0405599043715847 </data>
                  <data bit_width="8"> 0.0741406506445041 </data>
                  <data bit_width="16"> 0.146317336160774 </data>
                  <data bit_width="32"> 0.292957274233164 </data>
                  <data bit_width="64"> 0.602695759077321 </data>
                  <data bit_width="128"> 1.27950819291331 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.0324934695169551 </data>
                  <data bit_width="8"> 0.0616712079453933 </data>
                  <data bit_width="16"> 0.119720831905333 </data>
                  <data bit_width="32"> 0.235446331467413 </data>
                  <data bit_width="64"> 0.488618261742922 </data>
                  <data bit_width="128"> 1.03452073884732 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.0324934695169551 </data>
                    <data bit_width="8"> 0.0616712079453933 </data>
                    <data bit_width="16"> 0.119720831905333 </data>
                    <data bit_width="32"> 0.235446331467413 </data>
                    <data bit_width="64"> 0.488618261742922 </data>
                    <data bit_width="128"> 1.04681667142667 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.0329174142247863 </data>
                    <data bit_width="8"> 0.0623661640105862 </data>
                    <data bit_width="16"> 0.121348744073799 </data>
                    <data bit_width="32"> 0.239501222130196 </data>
                    <data bit_width="64"> 0.493710393461663 </data>
                    <data bit_width="128"> 1.03452073884732 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.0405599043715847 </data>
                    <data bit_width="8"> 0.0741406506445041 </data>
                    <data bit_width="16"> 0.146317336160774 </data>
                    <data bit_width="32"> 0.292957274233164 </data>
                    <data bit_width="64"> 0.602695759077321 </data>
                    <data bit_width="128"> 1.27950819291331 </data>
                  </priority>
                </typ>
              </parameters>
              <parameters name="4,default">
                <max>
                  <data bit_width="4"> 0.0405599043715847 </data>
                  <data bit_width="8"> 0.0741406506445041 </data>
                  <data bit_width="16"> 0.146317336160774 </data>
                  <data bit_width="32"> 0.292957274233164 </data>
                  <data bit_width="64"> 0.602695759077321 </data>
                  <data bit_width="128"> 1.27950819291331 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.0324934695169551 </data>
                  <data bit_width="8"> 0.0616712079453933 </data>
                  <data bit_width="16"> 0.119720831905333 </data>
                  <data bit_width="32"> 0.235446331467413 </data>
                  <data bit_width="64"> 0.488618261742922 </data>
                  <data bit_width="128"> 1.03452073884732 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.0324934695169551 </data>
                    <data bit_width="8"> 0.0616712079453933 </data>
                    <data bit_width="16"> 0.119720831905333 </data>
                    <data bit_width="32"> 0.235446331467413 </data>
                    <data bit_width="64"> 0.488618261742922 </data>
                    <data bit_width="128"> 1.04681667142667 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.0329174142247863 </data>
                    <data bit_width="8"> 0.0623661640105862 </data>
                    <data bit_width="16"> 0.121348744073799 </data>
                    <data bit_width="32"> 0.239501222130196 </data>
                    <data bit_width="64"> 0.493710393461663 </data>
                    <data bit_width="128"> 1.03452073884732 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.0405599043715847 </data>
                    <data bit_width="8"> 0.0741406506445041 </data>
                    <data bit_width="16"> 0.146317336160774 </data>
                    <data bit_width="32"> 0.292957274233164 </data>
                    <data bit_width="64"> 0.602695759077321 </data>
                    <data bit_width="128"> 1.27950819291331 </data>
                  </priority>
                </typ>
              </parameters>
              <parameters name="8,default">
                <max>
                  <data bit_width="4"> 0.0405599043715847 </data>
                  <data bit_width="8"> 0.0741406506445041 </data>
                  <data bit_width="16"> 0.146317336160774 </data>
                  <data bit_width="32"> 0.292957274233164 </data>
                  <data bit_width="64"> 0.602695759077321 </data>
                  <data bit_width="128"> 1.27950819291331 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.0324934695169551 </data>
                  <data bit_width="8"> 0.0616712079453933 </data>
                  <data bit_width="16"> 0.119720831905333 </data>
                  <data bit_width="32"> 0.235446331467413 </data>
                  <data bit_width="64"> 0.488618261742922 </data>
                  <data bit_width="128"> 1.03452073884732 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.0324934695169551 </data>
                    <data bit_width="8"> 0.0616712079453933 </data>
                    <data bit_width="16"> 0.119720831905333 </data>
                    <data bit_width="32"> 0.235446331467413 </data>
                    <data bit_width="64"> 0.488618261742922 </data>
                    <data bit_width="128"> 1.04681667142667 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.0329174142247863 </data>
                    <data bit_width="8"> 0.0623661640105862 </data>
                    <data bit_width="16"> 0.121348744073799 </data>
                    <data bit_width="32"> 0.239501222130196 </data>
                    <data bit_width="64"> 0.493710393461663 </data>
                    <data bit_width="128"> 1.03452073884732 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.0405599043715847 </data>
                    <data bit_width="8"> 0.0741406506445041 </data>
                    <data bit_width="16"> 0.146317336160774 </data>
                    <data bit_width="32"> 0.292957274233164 </data>
                    <data bit_width="64"> 0.602695759077321 </data>
                    <data bit_width="128"> 1.27950819291331 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>

            <est_index name="aspect_ratio">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="height">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="width">
              <!-- Dummy yet -->
            </est_index>
          </est_type>

          <est_type name="timing">
            <est_index name="delay">
              <unit> ns </unit>

              <parameters name="1,default">
                <max>
                  <data bit_width="4"> 0.87 </data>
                  <data bit_width="8"> 0.87 </data>
                  <data bit_width="16"> 0.87 </data>
                  <data bit_width="32"> 0.87 </data>
                  <data bit_width="64"> 0.88 </data>
                  <data bit_width="128"> 0.89 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.83 </data>
                  <data bit_width="8"> 0.83 </data>
                  <data bit_width="16"> 0.83 </data>
                  <data bit_width="32"> 0.83 </data>
                  <data bit_width="64"> 0.84 </data>
                  <data bit_width="128"> 0.85 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.87 </data>
                    <data bit_width="8"> 0.87 </data>
                    <data bit_width="16"> 0.87 </data>
                    <data bit_width="32"> 0.87 </data>
                    <data bit_width="64"> 0.88 </data>
                    <data bit_width="128"> 0.89 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.83 </data>
                    <data bit_width="8"> 0.83 </data>
                    <data bit_width="16"> 0.83 </data>
                    <data bit_width="32"> 0.83 </data>
                    <data bit_width="64"> 0.84 </data>
                    <data bit_width="128"> 0.85 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.87 </data>
                    <data bit_width="8"> 0.87 </data>
                    <data bit_width="16"> 0.87 </data>
                    <data bit_width="32"> 0.87 </data>
                    <data bit_width="64"> 0.88 </data>
                    <data bit_width="128"> 0.89 </data>
                  </priority>
                </typ>
              </parameters>
              <parameters name="2,default">
                <max>
                  <data bit_width="4"> 0.87 </data>
                  <data bit_width="8"> 0.87 </data>
                  <data bit_width="16"> 0.87 </data>
                  <data bit_width="32"> 0.87 </data>
                  <data bit_width="64"> 0.88 </data>
                  <data bit_width="128"> 0.89 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.83 </data>
                  <data bit_width="8"> 0.83 </data>
                  <data bit_width="16"> 0.83 </data>
                  <data bit_width="32"> 0.83 </data>
                  <data bit_width="64"> 0.84 </data>
                  <data bit_width="128"> 0.85 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.87 </data>
                    <data bit_width="8"> 0.87 </data>
                    <data bit_width="16"> 0.87 </data>
                    <data bit_width="32"> 0.87 </data>
                    <data bit_width="64"> 0.88 </data>
                    <data bit_width="128"> 0.89 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.83 </data>
                    <data bit_width="8"> 0.83 </data>
                    <data bit_width="16"> 0.83 </data>
                    <data bit_width="32"> 0.83 </data>
                    <data bit_width="64"> 0.84 </data>
                    <data bit_width="128"> 0.85 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.87 </data>
                    <data bit_width="8"> 0.87 </data>
                    <data bit_width="16"> 0.87 </data>
                    <data bit_width="32"> 0.87 </data>
                    <data bit_width="64"> 0.88 </data>
                    <data bit_width="128"> 0.89 </data>
                  </priority>
                </typ>
              </parameters>
              <parameters name="4,default">
                <max>
                  <data bit_width="4"> 0.87 </data>
                  <data bit_width="8"> 0.87 </data>
                  <data bit_width="16"> 0.87 </data>
                  <data bit_width="32"> 0.87 </data>
                  <data bit_width="64"> 0.88 </data>
                  <data bit_width="128"> 0.89 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.83 </data>
                  <data bit_width="8"> 0.83 </data>
                  <data bit_width="16"> 0.83 </data>
                  <data bit_width="32"> 0.83 </data>
                  <data bit_width="64"> 0.84 </data>
                  <data bit_width="128"> 0.85 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.87 </data>
                    <data bit_width="8"> 0.87 </data>
                    <data bit_width="16"> 0.87 </data>
                    <data bit_width="32"> 0.87 </data>
                    <data bit_width="64"> 0.88 </data>
                    <data bit_width="128"> 0.89 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.83 </data>
                    <data bit_width="8"> 0.83 </data>
                    <data bit_width="16"> 0.83 </data>
                    <data bit_width="32"> 0.83 </data>
                    <data bit_width="64"> 0.84 </data>
                    <data bit_width="128"> 0.85 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.87 </data>
                    <data bit_width="8"> 0.87 </data>
                    <data bit_width="16"> 0.87 </data>
                    <data bit_width="32"> 0.87 </data>
                    <data bit_width="64"> 0.88 </data>
                    <data bit_width="128"> 0.89 </data>
                  </priority>
                </typ>
              </parameters>
              <parameters name="8,default">
                <max>
                  <data bit_width="4"> 0.87 </data>
                  <data bit_width="8"> 0.87 </data>
                  <data bit_width="16"> 0.87 </data>
                  <data bit_width="32"> 0.87 </data>
                  <data bit_width="64"> 0.88 </data>
                  <data bit_width="128"> 0.89 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.83 </data>
                  <data bit_width="8"> 0.83 </data>
                  <data bit_width="16"> 0.83 </data>
                  <data bit_width="32"> 0.83 </data>
                  <data bit_width="64"> 0.84 </data>
                  <data bit_width="128"> 0.85 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.87 </data>
                    <data bit_width="8"> 0.87 </data>
                    <data bit_width="16"> 0.87 </data>
                    <data bit_width="32"> 0.87 </data>
                    <data bit_width="64"> 0.88 </data>
                    <data bit_width="128"> 0.89 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.83 </data>
                    <data bit_width="8"> 0.83 </data>
                    <data bit_width="16"> 0.83 </data>
                    <data bit_width="32"> 0.83 </data>
                    <data bit_width="64"> 0.84 </data>
                    <data bit_width="128"> 0.85 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.87 </data>
                    <data bit_width="8"> 0.87 </data>
                    <data bit_width="16"> 0.87 </data>
                    <data bit_width="32"> 0.87 </data>
                    <data bit_width="64"> 0.88 </data>
                    <data bit_width="128"> 0.89 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>

            <est_index name="delay_fullpath">
              <unit> ns </unit>

              <parameters name="1,default">
                <max>
                  <data bit_width="4">
                    inport	 data_in	 0
                    outport	 reg1	 0.62
                    internal	 1.65
                  </data>
                  <data bit_width="8">
                    inport	 data_in	 0
                    outport	 reg1	 0.62
                    internal	 2.35
                  </data>
                  <data bit_width="16">
                    inport	 data_in	 0.67
                    outport	 reg1	 0.70
                    internal	 3.49
                  </data>
                  <data bit_width="32">
                    inport	 data_in	 0.62
                    outport	 reg1	 0.65
                    internal	 3.94
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    inport	 data_in	 0.00
                    outport	 reg1	 0.62
                    internal	 1.65
                  </data>
                  <data bit_width="8">
                    inport	 data_in	 0.00
                    outport	 reg1	 0.62
                    internal	 2.35
                  </data>
                  <data bit_width="16">
                    inport	 data_in	 0.67
                    outport	 reg1	 0.70
                    internal	 3.49
                  </data>
                  <data bit_width="32">
                    inport	 data_in	 0.62
                    outport	 reg1	 0.65
                    internal	 3.94
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      inport	 data_in	 0.24
                      outport	 reg1	 0.51
                      internal	 1.68
                    </data>
                    <data bit_width="8">
                      inport	 data_in	 0.24
                      outport	 reg1	 0.53
                      internal	 2.23
                    </data>
                    <data bit_width="16">
                      inport	 data_in	 0.31
                      outport	 reg1	 0.59
                      internal	 2.51
                    </data>
                    <data bit_width="32">
                      inport	 data_in	 0.31
                      outport	 reg1	 0.56
                      internal	 3.18
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      inport	 data_in	 0.39
                      outport	 reg1	 0.59
                      internal	 0.96
                    </data>
                    <data bit_width="8">
                      inport	 data_in	 0.64
                      outport	 reg1	 0.76
                      internal	 1.14
                    </data>
                    <data bit_width="16">
                      inport	 data_in	 0.67
                      outport	 reg1	 0.69
                      internal	 1.27
                    </data>
                    <data bit_width="32">
                      inport	 data_in	 0.58
                      outport	 reg1	 0.80
                      internal	 1.49
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      inport	 data_in	 0.00
                      outport	 reg1	 0.62
                      internal	 1.65
                    </data>
                    <data bit_width="8">
                      inport	 data_in	 0.00
                      outport	 reg1	 0.62
                      internal	 2.35
                    </data>
                    <data bit_width="16">
                      inport	 data_in	 0.67
                      outport	 reg1	 0.70
                      internal	 3.49
                    </data>
                    <data bit_width="32">
                      inport	 data_in	 0.62
                      outport	 reg1	 0.65
                      internal	 3.94
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="2,default">
                <max>
                  <data bit_width="4">
                    inport	 data_in	 0.25
                    outport	 reg1	 0.61
                    internal	 1.29
                  </data>
                  <data bit_width="8">
                    inport	 data_in	 0.25
                    outport	 reg1	 0.70
                    internal	 2.20
                  </data>
                  <data bit_width="16">
                    inport	 data_in	 0.53
                    outport	 reg1	 0.63
                    internal	 3.42
                  </data>
                  <data bit_width="32">
                    inport	 data_in	 0.60
                    outport	 reg1	 0.65
                    internal	 4.21
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    inport	 data_in	 0.25
                    outport	 reg1	 0.61
                    internal	 1.29
                  </data>
                  <data bit_width="8">
                    inport	 data_in	 0.25
                    outport	 reg1	 0.70
                    internal	 2.20
                  </data>
                  <data bit_width="16">
                    inport	 data_in	 0.53
                    outport	 reg1	 0.63
                    internal	 3.42
                  </data>
                  <data bit_width="32">
                    inport	 data_in	 0.60
                    outport	 reg1	 0.65
                    internal	 4.21
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      inport	 data_in	 0.24
                      outport	 reg1	 0.51
                      internal	 1.33
                    </data>
                    <data bit_width="8">
                      inport	 data_in	 0.24
                      outport	 reg1	 0.53
                      internal	 2.14
                    </data>
                    <data bit_width="16">
                      inport	 data_in	 0.31
                      outport	 reg1	 0.57
                      internal	 2.40
                    </data>
                    <data bit_width="32">
                      inport	 data_in	 0.31
                      outport	 reg1	 0.56
                      internal	 3.00
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      inport	 data_in	 0.48
                      outport	 reg1	 0.74
                      internal	 0.96
                    </data>
                    <data bit_width="8">
                      inport	 data_in	 0.64
                      outport	 reg1	 0.78
                      internal	 1.16
                    </data>
                    <data bit_width="16">
                      inport	 data_in	 0.40
                      outport	 reg1	 0.68
                      internal	 1.29
                    </data>
                    <data bit_width="32">
                      inport	 data_in	 0.65
                      outport	 reg1	 0.73
                      internal	 1.45
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      inport	 data_in	 0.25
                      outport	 reg1	 0.61
                      internal	 1.29
                    </data>
                    <data bit_width="8">
                      inport	 data_in	 0.25
                      outport	 reg1	 0.70
                      internal	 2.20
                    </data>
                    <data bit_width="16">
                      inport	 data_in	 0.53
                      outport	 reg1	 0.63
                      internal	 3.42
                    </data>
                    <data bit_width="32">
                      inport	 data_in	 0.60
                      outport	 reg1	 0.65
                      internal	 4.21
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="4,default">
                <max>
                  <data bit_width="4">
                    inport	 data_in	 0.25
                    outport	 reg1	 0.54
                    internal	 1.15
                  </data>
                  <data bit_width="8">
                    inport	 data_in	 0.25
                    outport	 reg1	 0.62
                    internal	 2.22
                  </data>
                  <data bit_width="16">
                    inport	 data_in	 0.67
                    outport	 reg1	 0.63
                    internal	 3.42
                  </data>
                  <data bit_width="32">
                    inport	 data_in	 0.62
                    outport	 reg1	 0.65
                    internal	 4.00
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    inport	 data_in	 0.25
                    outport	 reg1	 0.54
                    internal	 1.15
                  </data>
                  <data bit_width="8">
                    inport	 data_in	 0.25
                    outport	 reg1	 0.62
                    internal	 2.22
                  </data>
                  <data bit_width="16">
                    inport	 data_in	 0.67
                    outport	 reg1	 0.63
                    internal	 3.42
                  </data>
                  <data bit_width="32">
                    inport	 data_in	 0.62
                    outport	 reg1	 0.65
                    internal	 4.00
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      inport	 data_in	 0.24
                      outport	 reg1	 0.51
                      internal	 1.32
                    </data>
                    <data bit_width="8">
                      inport	 data_in	 0.24
                      outport	 reg1	 0.51
                      internal	 2.05
                    </data>
                    <data bit_width="16">
                      inport	 data_in	 0.31
                      outport	 reg1	 0.58
                      internal	 2.37
                    </data>
                    <data bit_width="32">
                      inport	 data_in	 0.35
                      outport	 reg1	 0.58
                      internal	 3.12
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      inport	 data_in	 0.50
                      outport	 reg1	 0.48
                      internal	 0.81
                    </data>
                    <data bit_width="8">
                      inport	 data_in	 0.40
                      outport	 reg1	 0.64
                      internal	 1.15
                    </data>
                    <data bit_width="16">
                      inport	 data_in	 0.52
                      outport	 reg1	 0.72
                      internal	 1.29
                    </data>
                    <data bit_width="32">
                      inport	 data_in	 0.52
                      outport	 reg1	 0.71
                      internal	 1.51
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      inport	 data_in	 0.25
                      outport	 reg1	 0.54
                      internal	 1.15
                    </data>
                    <data bit_width="8">
                      inport	 data_in	 0.25
                      outport	 reg1	 0.62
                      internal	 2.22
                    </data>
                    <data bit_width="16">
                      inport	 data_in	 0.67
                      outport	 reg1	 0.63
                      internal	 3.42
                    </data>
                    <data bit_width="32">
                      inport	 data_in	 0.62
                      outport	 reg1	 0.65
                      internal	 4.00
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="8,default">
                <max>
                  <data bit_width="4">
                    inport	 data_in	 0.25
                    outport	 reg1	 0.50
                    internal	 0.76
                  </data>
                  <data bit_width="8">
                    inport	 data_in	 0.25
                    outport	 reg1	 0.62
                    internal	 1.90
                  </data>
                  <data bit_width="16">
                    inport	 data_in	 0.25
                    outport	 reg1	 0.63
                    internal	 2.63
                  </data>
                  <data bit_width="32">
                    inport	 data_in	 0.56
                    outport	 reg1	 0.65
                    internal	 4.33
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    inport	 data_in	 0.25
                    outport	 reg1	 0.50
                    internal	 0.76
                  </data>
                  <data bit_width="8">
                    inport	 data_in	 0.25
                    outport	 reg1	 0.62
                    internal	 1.90
                  </data>
                  <data bit_width="16">
                    inport	 data_in	 0.25
                    outport	 reg1	 0.63
                    internal	 2.63
                  </data>
                  <data bit_width="32">
                    inport	 data_in	 0.56
                    outport	 reg1	 0.65
                    internal	 4.33
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      inport	 data_in	 0.24
                      outport	 reg1	 0.47
                      internal	 0.90
                    </data>
                    <data bit_width="8">
                      inport	 data_in	 0.24
                      outport	 reg1	 0.51
                      internal	 1.89
                    </data>
                    <data bit_width="16">
                      inport	 data_in	 0.24
                      outport	 reg1	 0.53
                      internal	 2.41
                    </data>
                    <data bit_width="32">
                      inport	 data_in	 0.35
                      outport	 reg1	 0.56
                      internal	 3.00
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      inport	 data_in	 0.39
                      outport	 reg1	 0.45
                      internal	 0.74
                    </data>
                    <data bit_width="8">
                      inport	 data_in	 0.40
                      outport	 reg1	 0.66
                      internal	 1.08
                    </data>
                    <data bit_width="16">
                      inport	 data_in	 0.74
                      outport	 reg1	 0.78
                      internal	 1.26
                    </data>
                    <data bit_width="32">
                      inport	 data_in	 0.63
                      outport	 reg1	 0.72
                      internal	 1.46
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      inport	 data_in	 0.25
                      outport	 reg1	 0.50
                      internal	 0.76
                    </data>
                    <data bit_width="8">
                      inport	 data_in	 0.25
                      outport	 reg1	 0.62
                      internal	 1.90
                    </data>
                    <data bit_width="16">
                      inport	 data_in	 0.25
                      outport	 reg1	 0.63
                      internal	 2.63
                    </data>
                    <data bit_width="32">
                      inport	 data_in	 0.56
                      outport	 reg1	 0.65
                      internal	 4.33
                    </data>
                  </priority>
                </typ>
              </parameters>

            </est_index>
          </est_type>

          <est_type name="power">
            <est_index name="static_power">
              <unit> mW </unit>

              <parameters name="1,default">
                <max>
                  <data bit_width="4"> 3.4206 </data>
                  <data bit_width="8"> 6.6119 </data>
                  <data bit_width="16"> 13.0182 </data>
                  <data bit_width="32"> 26.4831 </data>
                  <data bit_width="64"> 52.1683 </data>
                  <data bit_width="128"> 108.5214 </data>
                </max>
                <min>
                  <data bit_width="4"> 3.2638 </data>
                  <data bit_width="8"> 6.2600 </data>
                  <data bit_width="16"> 12.2552 </data>
                  <data bit_width="32"> 24.4422 </data>
                  <data bit_width="64"> 49.8268 </data>
                  <data bit_width="128"> 106.7643 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 3.4189 </data>
                    <data bit_width="8"> 6.2937 </data>
                    <data bit_width="16"> 12.3591 </data>
                    <data bit_width="32"> 24.9581 </data>
                    <data bit_width="64"> 50.6417 </data>
                    <data bit_width="128"> 106.7643 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 3.4206 </data>
                    <data bit_width="8"> 6.6119 </data>
                    <data bit_width="16"> 13.0182 </data>
                    <data bit_width="32"> 26.4831 </data>
                    <data bit_width="64"> 52.1683 </data>
                    <data bit_width="128"> 108.5214 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 3.2638 </data>
                    <data bit_width="8"> 6.2600 </data>
                    <data bit_width="16"> 12.2552 </data>
                    <data bit_width="32"> 24.4422 </data>
                    <data bit_width="64"> 49.8268 </data>
                    <data bit_width="128"> 106.8199 </data>
                  </priority>
                </typ>
              </parameters>
              <parameters name="2,default">
                <max>
                  <data bit_width="4"> 3.3798 </data>
                  <data bit_width="8"> 6.6087 </data>
                  <data bit_width="16"> 13.0168 </data>
                  <data bit_width="32"> 26.4763 </data>
                  <data bit_width="64"> 52.1663 </data>
                  <data bit_width="128"> 108.5231 </data>
                </max>
                <min>
                  <data bit_width="4"> 3.2096 </data>
                  <data bit_width="8"> 6.2603 </data>
                  <data bit_width="16"> 12.2542 </data>
                  <data bit_width="32"> 24.4407 </data>
                  <data bit_width="64"> 49.8275 </data>
                  <data bit_width="128"> 106.7626 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 3.3781 </data>
                    <data bit_width="8"> 6.2926 </data>
                    <data bit_width="16"> 12.3606 </data>
                    <data bit_width="32"> 24.9536 </data>
                    <data bit_width="64"> 50.6465 </data>
                    <data bit_width="128"> 106.7626 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 3.3798 </data>
                    <data bit_width="8"> 6.6087 </data>
                    <data bit_width="16"> 13.0168 </data>
                    <data bit_width="32"> 26.4763 </data>
                    <data bit_width="64"> 52.1663 </data>
                    <data bit_width="128"> 108.5231 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 3.2096 </data>
                    <data bit_width="8"> 6.2603 </data>
                    <data bit_width="16"> 12.2542 </data>
                    <data bit_width="32"> 24.4407 </data>
                    <data bit_width="64"> 49.8275 </data>
                    <data bit_width="128"> 106.8209 </data>
                  </priority>
                </typ>
              </parameters>
              <parameters name="4,default">
                <max>
                  <data bit_width="4"> 3.3798 </data>
                  <data bit_width="8"> 6.6087 </data>
                  <data bit_width="16"> 13.0168 </data>
                  <data bit_width="32"> 26.4763 </data>
                  <data bit_width="64"> 52.1663 </data>
                  <data bit_width="128"> 108.5231 </data>
                </max>
                <min>
                  <data bit_width="4"> 3.2096 </data>
                  <data bit_width="8"> 6.2603 </data>
                  <data bit_width="16"> 12.2542 </data>
                  <data bit_width="32"> 24.4407 </data>
                  <data bit_width="64"> 49.8275 </data>
                  <data bit_width="128"> 106.7626 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 3.3781 </data>
                    <data bit_width="8"> 6.2926 </data>
                    <data bit_width="16"> 12.3606 </data>
                    <data bit_width="32"> 24.9536 </data>
                    <data bit_width="64"> 50.6465 </data>
                    <data bit_width="128"> 106.7626 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 3.3798 </data>
                    <data bit_width="8"> 6.6087 </data>
                    <data bit_width="16"> 13.0168 </data>
                    <data bit_width="32"> 26.4763 </data>
                    <data bit_width="64"> 52.1663 </data>
                    <data bit_width="128"> 108.5231 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 3.2096 </data>
                    <data bit_width="8"> 6.2603 </data>
                    <data bit_width="16"> 12.2542 </data>
                    <data bit_width="32"> 24.4407 </data>
                    <data bit_width="64"> 49.8275 </data>
                    <data bit_width="128"> 106.8209 </data>
                  </priority>
                </typ>
              </parameters>
              <parameters name="8,default">
                <max>
                  <data bit_width="4"> 3.3798 </data>
                  <data bit_width="8"> 6.6087 </data>
                  <data bit_width="16"> 13.0168 </data>
                  <data bit_width="32"> 26.4763 </data>
                  <data bit_width="64"> 52.1663 </data>
                  <data bit_width="128"> 108.5231 </data>
                </max>
                <min>
                  <data bit_width="4"> 3.2096 </data>
                  <data bit_width="8"> 6.2603 </data>
                  <data bit_width="16"> 12.2542 </data>
                  <data bit_width="32"> 24.4407 </data>
                  <data bit_width="64"> 49.8275 </data>
                  <data bit_width="128"> 106.7626 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 3.3781 </data>
                    <data bit_width="8"> 6.2926 </data>
                    <data bit_width="16"> 12.3606 </data>
                    <data bit_width="32"> 24.9536 </data>
                    <data bit_width="64"> 50.6465 </data>
                    <data bit_width="128"> 106.7626 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 3.3798 </data>
                    <data bit_width="8"> 6.6087 </data>
                    <data bit_width="16"> 13.0168 </data>
                    <data bit_width="32"> 26.4763 </data>
                    <data bit_width="64"> 52.1663 </data>
                    <data bit_width="128"> 108.5231 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 3.2096 </data>
                    <data bit_width="8"> 6.2603 </data>
                    <data bit_width="16"> 12.2542 </data>
                    <data bit_width="32"> 24.4407 </data>
                    <data bit_width="64"> 49.8275 </data>
                    <data bit_width="128"> 106.8209 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>
          </est_type>

          <est_type name="function_cycle">
            <unit> cycle </unit>

            <est_index name="cycle">
              <parameters name="1,default">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="inc">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                 <function name="write">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                <function name="read">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="2,default">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="inc">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                 <function name="write">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                <function name="read">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="4,default">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="inc">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                 <function name="write">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                <function name="read">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="8,default">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="inc">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                 <function name="write">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                <function name="read">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>
            </est_index>

            <est_index name="latency">
              <parameters name="1,default">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="inc">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                 <function name="write">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                <function name="read">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="2,default">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="inc">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                 <function name="write">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                <function name="read">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="4,default">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="inc">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                 <function name="write">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                <function name="read">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="8,default">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="inc">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                 <function name="write">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                <function name="read">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>
            </est_index>

            <est_index name="throughput">
              <parameters name="1,default">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="inc">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                 <function name="write">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                <function name="read">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="2,default">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="inc">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                 <function name="write">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                <function name="read">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="4,default">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="inc">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                 <function name="write">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                <function name="read">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="8,default">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="inc">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                 <function name="write">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                <function name="read">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>
            </est_index>

          </est_type>

          <est_type name="function_power">
            <!-- Dummy yet -->
          </est_type>
        </library>
      </estimation_data>

      <estimation_method>
         
        <est_type name="shape">

          <est_index name="area">

            <parameters name="1,default">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for pcu(1,cla) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[4]")) {
    print STDOUT ("Data file '$ARGV[4]' not found.\n");
    exit(100);
}

$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);
$bit_width = $ARGV[1];
for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	exit(0);
    }
}
if ($bit_width < $bit[0]) {
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    
    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}
elsif ($bit[$i-1] < $bit_width) {
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }
    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}
else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }
    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);
sub data_round {
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));
    return($output_data);
}
                ]]>
              </script>
            </parameters>

            <parameters name="2,default">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for pcu(2,cla) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[4]")) {
    print STDOUT ("Data file '$ARGV[4]' not found.\n");
    exit(100);
}

$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);
$bit_width = $ARGV[1];
for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	exit(0);
    }
}
if ($bit_width < $bit[0]) {
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    
    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}
elsif ($bit[$i-1] < $bit_width) {
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }
    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}
else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }
    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);
sub data_round {
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));
    return($output_data);
}
                ]]>
              </script>
            </parameters>

            <parameters name="4,default">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for pcu(4,cla) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[4]")) {
    print STDOUT ("Data file '$ARGV[4]' not found.\n");
    exit(100);
}

$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);
$bit_width = $ARGV[1];
for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	exit(0);
    }
}
if ($bit_width < $bit[0]) {
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    
    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}
elsif ($bit[$i-1] < $bit_width) {
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }
    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}
else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }
    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);
sub data_round {
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));
    return($output_data);
}
                ]]>
              </script>
            </parameters>

            <parameters name="8,default">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for pcu(8,cla) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[4]")) {
    print STDOUT ("Data file '$ARGV[4]' not found.\n");
    exit(100);
}

$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);
$bit_width = $ARGV[1];
for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	exit(0);
    }
}
if ($bit_width < $bit[0]) {
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    
    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}
elsif ($bit[$i-1] < $bit_width) {
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }
    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}
else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }
    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);
sub data_round {
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));
    return($output_data);
}
                ]]>
              </script>
            </parameters>

          </est_index>

           <est_index name="aspect_ratio">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="height">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="width">

             <!-- Dummy yet -->

           </est_index>
		
        </est_type>

        <est_type name="timing">

          <est_index name="delay">

            <parameters name="1,default">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for pcu(1,default) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[4]")) {
    print STDOUT ("Data file '$ARGV[4]' not found.\n");
    exit(100);
}

$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);
$bit_width = $ARGV[1];
for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	exit(0);
    }
}
if ($bit_width < $bit[0]) {
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    
    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}
elsif ($bit[$i-1] < $bit_width) {
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }
    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}
else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }
    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);
sub data_round {
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));
    return($output_data);
}
                ]]>
              </script>
            </parameters>

            <parameters name="2,default">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for pcu(2,default) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[4]")) {
    print STDOUT ("Data file '$ARGV[4]' not found.\n");
    exit(100);
}

$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);
$bit_width = $ARGV[1];
for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	exit(0);
    }
}
if ($bit_width < $bit[0]) {
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    
    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}
elsif ($bit[$i-1] < $bit_width) {
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }
    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}
else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }
    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);
sub data_round {
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));
    return($output_data);
}
                ]]>
              </script>
            </parameters>

            <parameters name="4,default">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for pcu(4,default) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[4]")) {
    print STDOUT ("Data file '$ARGV[4]' not found.\n");
    exit(100);
}

$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);
$bit_width = $ARGV[1];
for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	exit(0);
    }
}
if ($bit_width < $bit[0]) {
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    
    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}
elsif ($bit[$i-1] < $bit_width) {
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }
    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}
else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }
    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);
sub data_round {
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));
    return($output_data);
}
                ]]>
              </script>
            </parameters>

            <parameters name="8,default">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for pcu(8,default) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[4]")) {
    print STDOUT ("Data file '$ARGV[4]' not found.\n");
    exit(100);
}

$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);
$bit_width = $ARGV[1];
for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	exit(0);
    }
}
if ($bit_width < $bit[0]) {
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    
    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}
elsif ($bit[$i-1] < $bit_width) {
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }
    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}
else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }
    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);
sub data_round {
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));
    return($output_data);
}
                ]]>
              </script>
            </parameters>

          </est_index>

          <est_index name="delay_fullpath">

            <parameters name="1,default">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay_fullpath for pcu(1,default) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[4]")) {
    print STDOUT ("Data file '$ARGV[4]' not found.\n");
    exit(100);
}

$Round = 1;

$n = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>/ ) {
	$bit_width = $1;
	$bit[$n]   = $bit_width;
	$n++;
	$_ = <TMP>;
	$i = 0;
	while (! /\<\s*\/data\s*\>/ ) {
	    if ( /path\s+(\w+)\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "path\t $1\t $2\t ";
		$delay{$bit_width}[$i] = $3; 
		$i++;
	    }
	    if ( /inport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "inport\t $1\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }
	    if ( /outport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "outport\t $1\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }
	    if ( /internal\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "internal\t ";
		$delay{$bit_width}[$i] = $1;
		$i++;
	    }
	    $_ = <TMP>;
	}
    }
}
close(TMP);
$bit_width = $ARGV[1];
$line_num = $i;
for ($k = 0; $k < $line_num; $k++) {
    for ($j = 0; $j < $n; $j++) {
	if ($bit_width == $bit[$j]) {
	    $ret_data = $delay{$bit_width}[$k];
	    $ret_data = &data_round($ret_data, $Round);
	    print "$line{$bit_width}[$k] $ret_data\n";
	    goto NEXT;
	}
    }
    if ($bit_width < $bit[0]) {
	if ( $bit[1] - $bit[0] ) {
	    exit(100);
	}
	$ret_data = $delay{$bit[0]}[$k] - (($delay{$bit[1]}[$k] - $delay{$bit[0]}[$k]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
    }
    elsif ($bit[$n-1] < $bit_width) {
	if ( $bit[$n-1] - $bit[$n-2] ) {
	    exit(100);
	}
	$ret_data = $delay{$bit[$n-1]}[$k] + (($delay{$bit[$n-1]}[$k] - $delay{$bit[$n-2]}[$k]) / ($bit[$n-1] - $bit[$n-2])) * ($bit_width - $bit[$n-1]);
    }
    else {
	$j = 0;
	while ($bit[$j] < $bit_width) {
	    $j++;
	}
	if ( $bit[$j] - $bit[$j-1] ) {
	    exit(100);
	}
	$ret_data = $delay{$bit[$j-1]}[$k] + (($delay{$bit[$j]}[$k] - $delay{$bit[$j-1]}[$k]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
    }
    $ret_data = &data_round($ret_data, $Round);
    print "$line{$bit[0]}[$k] $ret_data\n";
  NEXT:
}

exit(0);

sub data_round{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));
    return($output_data);
}

            </parameters>

            <parameters name="2,default">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay_fullpath for pcu(2,default) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[4]")) {
    print STDOUT ("Data file '$ARGV[4]' not found.\n");
    exit(100);
}

$Round = 1;

$n = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>/ ) {
	$bit_width = $1;
	$bit[$n]   = $bit_width;
	$n++;
	$_ = <TMP>;
	$i = 0;
	while (! /\<\s*\/data\s*\>/ ) {
	    if ( /path\s+(\w+)\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "path\t $1\t $2\t ";
		$delay{$bit_width}[$i] = $3; 
		$i++;
	    }
	    if ( /inport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "inport\t $1\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }
	    if ( /outport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "outport\t $1\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }
	    if ( /internal\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "internal\t ";
		$delay{$bit_width}[$i] = $1;
		$i++;
	    }
	    $_ = <TMP>;
	}
    }
}
close(TMP);
$bit_width = $ARGV[1];
$line_num = $i;
for ($k = 0; $k < $line_num; $k++) {
    for ($j = 0; $j < $n; $j++) {
	if ($bit_width == $bit[$j]) {
	    $ret_data = $delay{$bit_width}[$k];
	    $ret_data = &data_round($ret_data, $Round);
	    print "$line{$bit_width}[$k] $ret_data\n";
	    goto NEXT;
	}
    }
    if ($bit_width < $bit[0]) {
	if ( $bit[1] - $bit[0] ) {
	    exit(100);
	}
	$ret_data = $delay{$bit[0]}[$k] - (($delay{$bit[1]}[$k] - $delay{$bit[0]}[$k]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
    }
    elsif ($bit[$n-1] < $bit_width) {
	if ( $bit[$n-1] - $bit[$n-2] ) {
	    exit(100);
	}
	$ret_data = $delay{$bit[$n-1]}[$k] + (($delay{$bit[$n-1]}[$k] - $delay{$bit[$n-2]}[$k]) / ($bit[$n-1] - $bit[$n-2])) * ($bit_width - $bit[$n-1]);
    }
    else {
	$j = 0;
	while ($bit[$j] < $bit_width) {
	    $j++;
	}
	if ( $bit[$j] - $bit[$j-1] ) {
	    exit(100);
	}
	$ret_data = $delay{$bit[$j-1]}[$k] + (($delay{$bit[$j]}[$k] - $delay{$bit[$j-1]}[$k]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
    }
    $ret_data = &data_round($ret_data, $Round);
    print "$line{$bit[0]}[$k] $ret_data\n";
  NEXT:
}

exit(0);

sub data_round{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));
    return($output_data);
}

            </parameters>

            <parameters name="4,default">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay_fullpath for pcu(4,default) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[4]")) {
    print STDOUT ("Data file '$ARGV[4]' not found.\n");
    exit(100);
}

$Round = 1;

$n = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>/ ) {
	$bit_width = $1;
	$bit[$n]   = $bit_width;
	$n++;
	$_ = <TMP>;
	$i = 0;
	while (! /\<\s*\/data\s*\>/ ) {
	    if ( /path\s+(\w+)\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "path\t $1\t $2\t ";
		$delay{$bit_width}[$i] = $3; 
		$i++;
	    }
	    if ( /inport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "inport\t $1\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }
	    if ( /outport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "outport\t $1\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }
	    if ( /internal\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "internal\t ";
		$delay{$bit_width}[$i] = $1;
		$i++;
	    }
	    $_ = <TMP>;
	}
    }
}
close(TMP);
$bit_width = $ARGV[1];
$line_num = $i;
for ($k = 0; $k < $line_num; $k++) {
    for ($j = 0; $j < $n; $j++) {
	if ($bit_width == $bit[$j]) {
	    $ret_data = $delay{$bit_width}[$k];
	    $ret_data = &data_round($ret_data, $Round);
	    print "$line{$bit_width}[$k] $ret_data\n";
	    goto NEXT;
	}
    }
    if ($bit_width < $bit[0]) {
	if ( $bit[1] - $bit[0] ) {
	    exit(100);
	}
	$ret_data = $delay{$bit[0]}[$k] - (($delay{$bit[1]}[$k] - $delay{$bit[0]}[$k]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
    }
    elsif ($bit[$n-1] < $bit_width) {
	if ( $bit[$n-1] - $bit[$n-2] ) {
	    exit(100);
	}
	$ret_data = $delay{$bit[$n-1]}[$k] + (($delay{$bit[$n-1]}[$k] - $delay{$bit[$n-2]}[$k]) / ($bit[$n-1] - $bit[$n-2])) * ($bit_width - $bit[$n-1]);
    }
    else {
	$j = 0;
	while ($bit[$j] < $bit_width) {
	    $j++;
	}
	if ( $bit[$j] - $bit[$j-1] ) {
	    exit(100);
	}
	$ret_data = $delay{$bit[$j-1]}[$k] + (($delay{$bit[$j]}[$k] - $delay{$bit[$j-1]}[$k]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
    }
    $ret_data = &data_round($ret_data, $Round);
    print "$line{$bit[0]}[$k] $ret_data\n";
  NEXT:
}

exit(0);

sub data_round{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));
    return($output_data);
}

            </parameters>

            <parameters name="8,default">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay_fullpath for pcu(8,default) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[4]")) {
    print STDOUT ("Data file '$ARGV[4]' not found.\n");
    exit(100);
}

$Round = 1;

$n = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>/ ) {
	$bit_width = $1;
	$bit[$n]   = $bit_width;
	$n++;
	$_ = <TMP>;
	$i = 0;
	while (! /\<\s*\/data\s*\>/ ) {
	    if ( /path\s+(\w+)\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "path\t $1\t $2\t ";
		$delay{$bit_width}[$i] = $3; 
		$i++;
	    }
	    if ( /inport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "inport\t $1\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }
	    if ( /outport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "outport\t $1\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }
	    if ( /internal\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "internal\t ";
		$delay{$bit_width}[$i] = $1;
		$i++;
	    }
	    $_ = <TMP>;
	}
    }
}
close(TMP);
$bit_width = $ARGV[1];
$line_num = $i;
for ($k = 0; $k < $line_num; $k++) {
    for ($j = 0; $j < $n; $j++) {
	if ($bit_width == $bit[$j]) {
	    $ret_data = $delay{$bit_width}[$k];
	    $ret_data = &data_round($ret_data, $Round);
	    print "$line{$bit_width}[$k] $ret_data\n";
	    goto NEXT;
	}
    }
    if ($bit_width < $bit[0]) {
	if ( $bit[1] - $bit[0] ) {
	    exit(100);
	}
	$ret_data = $delay{$bit[0]}[$k] - (($delay{$bit[1]}[$k] - $delay{$bit[0]}[$k]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
    }
    elsif ($bit[$n-1] < $bit_width) {
	if ( $bit[$n-1] - $bit[$n-2] ) {
	    exit(100);
	}
	$ret_data = $delay{$bit[$n-1]}[$k] + (($delay{$bit[$n-1]}[$k] - $delay{$bit[$n-2]}[$k]) / ($bit[$n-1] - $bit[$n-2])) * ($bit_width - $bit[$n-1]);
    }
    else {
	$j = 0;
	while ($bit[$j] < $bit_width) {
	    $j++;
	}
	if ( $bit[$j] - $bit[$j-1] ) {
	    exit(100);
	}
	$ret_data = $delay{$bit[$j-1]}[$k] + (($delay{$bit[$j]}[$k] - $delay{$bit[$j-1]}[$k]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
    }
    $ret_data = &data_round($ret_data, $Round);
    print "$line{$bit[0]}[$k] $ret_data\n";
  NEXT:
}

exit(0);

sub data_round{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));
    return($output_data);
}

            </parameters>

          </est_index>

        </est_type>

        <est_type name="power">

          <est_index name="static_power">

            <parameters name="1,default">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for pcu(1,default) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[4]")) {
    print STDOUT ("Data file '$ARGV[4]' not found.\n");
    exit(100);
}

$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);
$bit_width = $ARGV[1];
for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	exit(0);
    }
}
if ($bit_width < $bit[0]) {
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    
    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}
elsif ($bit[$i-1] < $bit_width) {
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }
    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}
else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }
    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);
sub data_round {
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));
    return($output_data);
}
                ]]>
              </script>
            </parameters>

            <parameters name="2,default">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for pcu(2,default) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[4]")) {
    print STDOUT ("Data file '$ARGV[4]' not found.\n");
    exit(100);
}

$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);
$bit_width = $ARGV[1];
for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	exit(0);
    }
}
if ($bit_width < $bit[0]) {
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    
    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}
elsif ($bit[$i-1] < $bit_width) {
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }
    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}
else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }
    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);
sub data_round {
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));
    return($output_data);
}
                ]]>
              </script>
            </parameters>

            <parameters name="4,default">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for pcu(4,default) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[4]")) {
    print STDOUT ("Data file '$ARGV[4]' not found.\n");
    exit(100);
}

$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);
$bit_width = $ARGV[1];
for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	exit(0);
    }
}
if ($bit_width < $bit[0]) {
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    
    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}
elsif ($bit[$i-1] < $bit_width) {
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }
    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}
else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }
    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);
sub data_round {
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));
    return($output_data);
}
                ]]>
              </script>
            </parameters>

            <parameters name="8,default">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for pcu(8,default) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[4]")) {
    print STDOUT ("Data file '$ARGV[4]' not found.\n");
    exit(100);
}

$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);
$bit_width = $ARGV[1];
for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	exit(0);
    }
}
if ($bit_width < $bit[0]) {
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    
    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}
elsif ($bit[$i-1] < $bit_width) {
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }
    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}
else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }
    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);
sub data_round {
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));
    return($output_data);
}
                ]]>
              </script>
            </parameters>

          </est_index>

        </est_type>

        <est_type name="function_cycle">
          <est_index name="cycle">
            <parameters name="1,default">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[3]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;
print "$tmp";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="2,default">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[3]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;
print "$tmp";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="4,default">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[3]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;
print "$tmp";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="8,default">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[3]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;
print "$tmp";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

          <est_index name="latency">
            <parameters name="1,default">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[3]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;
print "$tmp";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="2,default">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[3]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;
print "$tmp";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="4,default">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[3]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;
print "$tmp";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="8,default">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[3]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;
print "$tmp";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

          <est_index name="throughput">
            <parameters name="1,default">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[3]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;
print "$tmp";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="2,default">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[3]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;
print "$tmp";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="4,default">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[3]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;
print "$tmp";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="8,default">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[3]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;
print "$tmp";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

        </est_type>

        <est_type name="function_power">

        </est_type>

    
      </estimation_method>

    </estimation>

  </model>
</FHM>
