<?xml version="1.0" encoding="UTF-8" ?>
<!-- Modified by KITA(ASIPS) on 2007/09/12 -->
<!-- Modified by T.Hamabe on 2006/12/05 -->
<!-- Modified by T.Hamabe on 2006/11/30 -->
<FHM>
  <model_name> wire_out </model_name>

  <model>
    <design_level> behavior </design_level>
    <version> 1.0 </version>
    <author> <![CDATA[ Yuki Kobayashi ]]> </author>
    <affiliation> <![CDATA[ Osaka Univ. ]]> </affiliation>
    <model_info> <![CDATA[
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                %
%    Copyright 2008 ASIP Solutions, Inc. All rights reserved.    %
%                 Copyright 2005 PEAS Project                    %
%                                                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
]]> </model_info>

    <parameter>
      <parameter_value key="bit_width">
        <value> 1 </value>
        <value> 2 </value>
        <value> 3 </value>
        <value> 4 </value>
        <value> 5 </value>
        <value> 6 </value>
        <value> 7 </value>
        <value> 8 </value>
        <value> 9 </value>
        <value> 10 </value>
        <value> 11 </value>
        <value> 12 </value>
        <value> 13 </value>
        <value> 14 </value>
        <value> 15 </value>
        <value> 16 </value>
        <value> 17 </value>
        <value> 18 </value>
        <value> 19 </value>
        <value> 20 </value>
        <value> 21 </value>
        <value> 22 </value>
        <value> 23 </value>
        <value> 24 </value>
        <value> 25 </value>
        <value> 26 </value>
        <value> 27 </value>
        <value> 28 </value>
        <value> 29 </value>
        <value> 30 </value>
        <value> 31 </value>
        <value> 32 </value>
        <value> 33 </value>
        <value> 34 </value>
        <value> 35 </value>
        <value> 36 </value>
        <value> 37 </value>
        <value> 38 </value>
        <value> 39 </value>
        <value> 40 </value>
        <value> 41 </value>
        <value> 42 </value>
        <value> 43 </value>
        <value> 44 </value>
        <value> 45 </value>
        <value> 46 </value>
        <value> 47 </value>
        <value> 48 </value>
        <value> 49 </value>
        <value> 50 </value>
        <value> 51 </value>
        <value> 52 </value>
        <value> 53 </value>
        <value> 54 </value>
        <value> 55 </value>
        <value> 56 </value>
        <value> 57 </value>
        <value> 58 </value>
        <value> 59 </value>
        <value> 60 </value>
        <value> 61 </value>
        <value> 62 </value>
        <value> 63 </value>
        <value> 64 </value>
        <value> 65 </value>
        <value> 66 </value>
        <value> 67 </value>
        <value> 68 </value>
        <value> 69 </value>
        <value> 70 </value>
        <value> 71 </value>
        <value> 72 </value>
        <value> 73 </value>
        <value> 74 </value>
        <value> 75 </value>
        <value> 76 </value>
        <value> 77 </value>
        <value> 78 </value>
        <value> 79 </value>
        <value> 80 </value>
        <value> 128 </value>
      </parameter_value>
      <parameter_value key="default_output">
        <value> fix_to_0 </value>
        <value> fix_to_1 </value>
        <value> keep </value>
      </parameter_value>
    </parameter>

    <function_description>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates wire_out function description in behavior level
# parameter : bit_width default_output

if ($#ARGV != 1) {
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width default_output\n";
    exit (100);
}

$bit_width    = $ARGV[0];
$default_out  = $ARGV[1];

if ($bit_width > 80) {
    if ($bit_width != 128) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
    }
}
elsif ($bit_width < 1) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$bit_width" == "1") {
    $range = "";
    $vec   = "";
    $val_symbol = "'";
}
else {
    $W1 = $bit_width - 1;
    $range = "[$W1:0]";
    $vec   = "_vector";
    $val_symbol = "\"";
}

if ($default_out eq "fix_to_0"){
    $default_val = $val_symbol . "0" x $bit_width . $val_symbol;
}
elsif ($default_out eq "fix_to_1"){
    $default_val = $val_symbol . "1" x $bit_width . $val_symbol;
}
elsif ($default_out ne "keep"){
    print "ERROR: \"$default_out\" is not supported for the value of default_output.\n";
    exit (100);
}

{
    print <<FHM_DL_FUNC_DESC_1;
/** $bit_width-bit output wire */
model wire_out_${bit_width}{
  port{
FHM_DL_FUNC_DESC_1
}
{
    print <<FHM_DL_FUNC_DESC_3;
    in    int_port$range;
    out   ext_port$range;
    in    wmode;
  }
FHM_DL_FUNC_DESC_3
}

if ($default_out eq "keep"){
    print <<FHM_DL_FUNC_DESC;
  storage{
    register reg;
  }
FHM_DL_FUNC_DESC
}
{
    print <<FHM_DL_FUNC_DESC_3;
  /** no operation */
  function nop : idle{
    control {
FHM_DL_FUNC_DESC_3
}
if ($default_out eq "keep"){
    print "      in reset;\n";
}
{
    print <<FHM_DL_FUNC_DESC_4;
      in wmode;
    }
    protocol {
FHM_DL_FUNC_DESC_4
}
if ($default_out eq "keep"){
    print <<FHM_DL_FUNC_DESC_5;
      [reset == '0' && wmode == '0']{
        ext_port = reg;
      }
FHM_DL_FUNC_DESC_5
}
else{
    print <<FHM_DL_FUNC_DESC_5;
      [wmode == '0']{
        ext_port = $default_val
      }
FHM_DL_FUNC_DESC_5
}
{
    print <<FHM_DL_FUNC_DESC;
    }
  }

FHM_DL_FUNC_DESC
}

if ($default_out eq "keep"){
    print <<FHM_DL_FUNC_DESC;
 /** reset */
  function reset: reset{
    assignment{
      reg = 0;
    }
    control{
      in reset;
    }
    protocol{
      [reset == 1]{
        store reg;
      }
    }
  }

  /** write */
  function write {
    input {
     bit$vec int_port;
    }
    assignment{
      reg = int_port;
    }
    control {
      bit wmode;
    }
    protocol {
      [reset == '0' && wmode == '1']{
        store reg;
      }
    }
  }
}
FHM_DL_FUNC_DESC
}
else{
    print <<FHM_DL_FUNC_DESC_6;
  /** write */
  function write {
    input {
     bit$vec int_port;
    }
    control {
      bit wmode;
    }
    protocol {
      [wmode == '1']{
        ext_port = int_port;
      }
    }
  }
}
FHM_DL_FUNC_DESC_6
}
exit (0);
        ]]>
      </script>
    </function_description>

    <function_conv>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates wire_out function conv in behavior level
# parameter : bit_width default_output

if ($#ARGV != 1) {
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width default_output\n";
    exit (100);
}

$bit_width    = $ARGV[0];
$default_out  = $ARGV[1];

if ($bit_width > 80) {
    if ($bit_width != 128) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
    }
}
elsif ($bit_width < 1) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$bit_width" == "1") {
    $range = "";
}
else {
    $W1 = $bit_width - 1;
    $range = "[$W1:0]";
}

{
    print <<FHM_DL_FUNC_CONV_1;
/** No operation */
function nop {
  input {
  }
  output {
  }
  control {
    in bit wmode;
FHM_DL_FUNC_CONV_1
}
if ($default_out eq "keep"){
    print "    in bit reset;\n";
}
{
    print <<FHM_DL_FUNC_CONV_2;
  }
  protocol {
    single_cycle_protocol {
      wmode = '0';
FHM_DL_FUNC_CONV_2
}
if ($default_out eq "keep"){
    print "      reset = '0';\n";
}
{
    print <<FHM_DL_FUNC_CONV_3;
    }
  }
}

FHM_DL_FUNC_CONV_3
}

if ($default_out eq "keep"){
    print <<FHM_DL_FUNC_CONV_4;
/** reset */
function reset {
  input {
  }
  output {
  }
  control {
    in bit reset;
  }
  protocol {
    single_cycle_protocol {
      reset = '1';
    }
  }
}

FHM_DL_FUNC_CONV_4
}
{
    print <<FHM_DL_FUNC_CONV_5;
/** write */
function write {
  input {
    bit $range int_port;
  }
  output {
  }
  control {
    in bit wmode;
  }
  protocol {
    single_cycle_protocol {
      wmode = '1';
    }
  }
}
FHM_DL_FUNC_CONV_5
}
exit (0);
        ]]>
      </script>
    </function_conv>

    <function_port>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates wire_out port information in behavior level
# parameter : bit_width default_output

if ($#ARGV != 1) {
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width default_output\n";
    exit (100);
}

$bit_width   = $ARGV[0];
$default_out = $ARGV[1];

if ($bit_width > 80) {
    if ($bit_width != 128) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
    }
}
elsif ($bit_width < 1) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

$msb = $bit_width-1;
if ($default_out eq "keep"){
    print <<FHM_DL_PORT_1;
clock	in	bit	clock
async_reset	in	bit	reset
reset	in	bit	ctrl
FHM_DL_PORT_1
}
if ("$bit_width" == "1") {
    print <<FHM_DL_PORT_2;
int_port	in	bit	data
ext_port	out	bit	data
wmode	in	bit	ctrl
FHM_DL_PORT_2
}
else {
    print <<FHM_DL_PORT_3
int_port	in	bit_vector $msb 0	data
ext_port	out	bit_vector $msb 0	data
wmode	in	bit	ctrl
FHM_DL_PORT_3
}
exit (0);
        ]]>
      </script>
    </function_port>

    <design>
      <design_lang> vhdl </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# This script generates wire_out instance in synthesis level
# parameter : instance_name bit_width default_output

if ($#ARGV != 2) {
  print "number of parameters is wrong.\n";
  print "usage : this_script instance_name bit_width default_output\n";
  exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$default_out   = $ARGV[2];

if ($bit_width == 1){
    $port_type = "std_logic";
    $val_symbol = "'";
    $ap_0 = "'0'";
}
else{
    $b_1 = $bit_width - 1;
    $port_type = "std_logic_vector($b_1 downto 0)";
    $val_symbol = "\"";
    $ap_0 = "(others => '0')";
}

if ($default_out eq "fix_to_0"){
    $default_val = $val_symbol . "0" x $bit_width . $val_symbol;
}
elsif ($default_out eq "fix_to_1"){
    $default_val = $val_symbol . "1" x $bit_width . $val_symbol;
}
elsif ($default_out eq "keep"){
    $zs = $val_symbol . "0" x $bit_width . $val_symbol;
}
else{
    print "ERROR: \"$default_out\" is not supported for the value of default_output.\n";
    exit (100);
}

{
    print <<FHM_DL_INSTANCE_1;
-- Module     : $bit_width-bit output wire
-- Feature    : 
-- References : refer to wire.fhm by Y.Kobayashi (c)2003.
-- Author     : Designed by K.Ueda (c)2004.
-- Version    : 1.0 :
-- Functionality :
--  port
FHM_DL_INSTANCE_1
}
if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE_2;
--   clock       : clock port
--   async_reset : asynchronous reset port
--   reset       : synchronous reset port
FHM_DL_INSTANCE_2
}
{
    print <<FHM_DL_INSTANCE_3;
--   int_port    : internal port
--   ext_port    : external port
--   wmode       : write mode
--              '1' : write data of int_port
FHM_DL_INSTANCE_3
}

if ($default_out eq "keep"){
    print "--              '0' : keep pervious value\n";
}
else{
    print "--              '0' : write default data ($default_val)\n";
}

{
    print <<FHM_DL_INSTANCE_4;
-- Comment :

library IEEE;
use IEEE.std_logic_1164.all;

entity $instance_name is
  port (
FHM_DL_INSTANCE_4
}
if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE_5;
    clock       : in  std_logic;
    async_reset : in  std_logic;
    reset       : in  std_logic;
FHM_DL_INSTANCE_5
}
{
    print <<FHM_DL_INSTANCE_6;
    int_port    : in  $port_type;
    ext_port    : out $port_type;
    wmode       : in  std_logic);
end $instance_name;

architecture synthesis of $instance_name is
FHM_DL_INSTANCE_6
}

if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE_7;
  signal reg_out : $port_type;
begin
  process (async_reset, clock)
  begin
    if (async_reset = '1') then
      reg_out <= $zs;
    elsif (clock'event and clock = '1') then
      if (reset = '1') then
        reg_out <= $ap_0;
      elsif (wmode = '1') then
        reg_out <= int_port;
      end if;
    end if;
  end process;

  ext_port <= int_port when wmode = '1' else
              reg_out;
end synthesis;
FHM_DL_INSTANCE_7
}
else{
    print <<FHM_DL_INSTANCE_8;
begin
  ext_port <= int_port when (wmode = '1') else
              $default_val;
end synthesis;
FHM_DL_INSTANCE_8
}

exit(0);
          ]]>
        </script>
      </instance>

      <entity></entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <design>
      <design_lang> Verilog </design_lang>
                                                                                
      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# This script generates wire_out instance in synthesis level
# parameter : instance_name bit_width default_output

if ($#ARGV != 2) {
  print "number of parameters is wrong.\n";
  print "usage : this_script instance_name bit_width default_output\n";
  exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$default_out   = $ARGV[2];

if ($bit_width == 1){
    $port_type = " ";
    $ap_0 = "1'b0";
}
else{
    $b_1 = $bit_width - 1;
    $port_type = "[${b_1}:0]";
    $ap_0 = "\{${bit_width}\{1'b0\}\}";
}

if ($default_out eq "fix_to_0"){
   if ($bit_width == 1){
     $default_val = "1'b0";
   }
   else{
     $default_val = "\{${bit_width}\{1'b0\}\}";
   }
}
elsif ($default_out eq "fix_to_1"){
   if ($bit_width == 1){
     $default_val = "1'b1";
   }
   else{
     $default_val = "\{${bit_width}\{1'b1\}\}";
   }
}
elsif ($default_out eq "keep"){
   if ($bit_width == 1){
     $zs = "1'b0";
   }
   else{
     $zs = "\{${bit_width}\{1'b0\}\}";
   }
}
else{
    print "ERROR: \"$default_out\" is not supported for the value of default_output.\n";
    exit (100);
}

{
    print <<FHM_DL_INSTANCE;
// Module     : $bit_width-bit output wire
// Feature    : 
// References : refer to wire.fhm by Y.Kobayashi (c)2003.
// Author     : Designed by K.Ueda (c)2004.
// Version    : 1.0 :
// Functionality :
//  port
FHM_DL_INSTANCE
}
if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE;
//   clock       : clock port
//   async_reset : asynchronous reset port
//   reset       : synchronous reset port
FHM_DL_INSTANCE
}
{
    print <<FHM_DL_INSTANCE;
//   int_port    : internal port
//   ext_port    : external port
//   wmode       : write mode
//              '1' : write data of int_port
FHM_DL_INSTANCE
}

if ($default_out eq "keep"){
    print "//              '0' : keep pervious value\n";
}
else{
    print "//              '0' : write default data ($default_val)\n";
}

{
    print <<FHM_DL_INSTANCE;
// Comment :
\n
module $instance_name (
FHM_DL_INSTANCE
}
if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE;
  clock       ,
  async_reset ,
  reset       ,
FHM_DL_INSTANCE
}
{
    print <<FHM_DL_INSTANCE;
  int_port    ,
  ext_port    ,
  wmode       );
\n
FHM_DL_INSTANCE
}

if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE;
input         clock       ;
input         async_reset ;
input         reset       ;
FHM_DL_INSTANCE
}
{
    print <<FHM_DL_INSTANCE;
input  $port_type int_port    ;
output $port_type ext_port    ;
input         wmode       ;
\n
FHM_DL_INSTANCE
}

if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE;
wire          clock       ;
wire          async_reset ;
wire          reset       ;
FHM_DL_INSTANCE
}
{
    print <<FHM_DL_INSTANCE;
wire   $port_type int_port    ;
wire   $port_type ext_port    ;
wire          wmode       ;
\n

FHM_DL_INSTANCE
}

if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE;
reg    $port_type reg_out     ;
\n
always@ (posedge async_reset or posedge clock)
begin
    if (async_reset == 1'b1)
      reg_out <= $zs;
    else
    begin
      if (reset == 1'b1)
        reg_out <= $ap_0;
      else if (wmode == 1'b1)
        reg_out <= int_port;
    end
end
\n
assign  ext_port = (wmode == 1'b1) ? int_port : reg_out ;
\n
endmodule
FHM_DL_INSTANCE
}
else{
    print <<FHM_DL_INSTANCE;
assign  ext_port = (wmode == 1'b1) ? int_port : $default_val ;
\n
endmodule
FHM_DL_INSTANCE
}

exit(0);
          ]]>
        </script>
      </instance>
                                                                                
      <entity></entity>
                                                                                
      <testvector></testvector>
                                                                                
      <synthesis></synthesis>
    </design>

    <design>
      <design_lang> SystemC Header </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# This script generates wire_out instance in synthesis level
# parameter : instance_name bit_width default_output

if ($#ARGV != 3) {
  print "number of parameters is wrong.\n";
  print "usage : this_script name_space instance_name bit_width default_output\n";
  exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];
$default_out   = $ARGV[3];

if ($bit_width == 1){
    $port_type = "bool";
}
elsif ( $bit_width <= 64 ) {
    $port_type = "sc_dt::sc_uint<${bit_width}>";
}
else{
    $port_type = "sc_dt::sc_biguint<${bit_width}>";
}

if ($default_out eq "fix_to_0"){
    $default_val = 0;
}
elsif ($default_out eq "fix_to_1"){
    $default_val = 1;
}
elsif ($default_out eq "keep"){
    $zs = 0;
}
else{
    print "ERROR: \"$default_out\" is not supported for the value of default_out.\n";
    exit (100);
}

$macro = "__" . uc($name_space) . "_" . uc($instance_name) . "_H__";

{
    print <<FHM_DL_INSTANCE_1;
#ifndef $macro
#define $macro 1

// Module     : $bit_width-bit output wire
// Feature    : 
// References : refer to wire.fhm by Y.Kobayashi (c)2003.
// Author     : Designed by K.Ueda (c)2004.
// Version    : 1.0 :
// Functionality :
//  port
FHM_DL_INSTANCE_1
}

if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE;
//   clock       : clock port
//   async_reset : asynchronous reset port
//   reset       : synchronous reset port
FHM_DL_INSTANCE
}

{
print <<FHM_DL_INSTANCE;
//   int_port    : internal port
//   ext_port    : external port
//   wmode       : write mode (when '1', write data of int_port)
FHM_DL_INSTANCE
}

if ($default_out eq "keep"){
    print "//              '0' : keep pervious value\n";
}
else{
    print "//              '0' : write default data ($default_val)\n";
}


{
    print <<FHM_DL_INSTANCE;
// Comment :

#include <systemc>

namespace ${name_space} {
  SC_MODULE(${instance_name}) {
FHM_DL_INSTANCE
}

if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE;
    sc_core::sc_in< bool > clock;
    sc_core::sc_in< bool > async_reset;
    sc_core::sc_in< bool > reset;
FHM_DL_INSTANCE
}

{
    print <<FHM_DL_INSTANCE
    sc_core::sc_in< $port_type > int_port;
    sc_core::sc_out< $port_type > ext_port;
    sc_core::sc_in< bool > wmode;
FHM_DL_INSTANCE
}

if ( $default_out eq "keep" ) {
    print <<FHM_DL_INSTANCE

    sc_core::sc_signal< $port_type > reg_out;
FHM_DL_INSTANCE
}

{
    print <<FHM_DL_INSTANCE

    SC_CTOR(${instance_name}) {
FHM_DL_INSTANCE
}

if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE_7;
      SC_METHOD(process);
      sensitive << async_reset << clock.pos();

      SC_METHOD(p_ext_port);
      sensitive << int_port << wmode << reg_out;
    }

    void process();
    void p_ext_port();
FHM_DL_INSTANCE_7
}
else{
    print <<FHM_DL_INSTANCE_8;
       SC_METHOD(p_ext_port);
       sensitive << int_port << wmode;
    }

    void p_ext_port();
FHM_DL_INSTANCE_8
}

{
    print <<FHM_DL_INSTANCE
  };
};

#endif // $macro
FHM_DL_INSTANCE
}

exit(0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <design>
      <design_lang> SystemC Program </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# This script generates wire_out instance in synthesis level
# parameter : instance_name bit_width default_output

if ($#ARGV != 3) {
  print "number of parameters is wrong.\n";
  print "usage : this_script name_space instance_name bit_width default_output\n";
  exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];
$default_out   = $ARGV[3];

if ($bit_width == 1){
    $port_type = "bool";
}
elsif ( $bit_width <= 64 ) {
    $port_type = "sc_dt::sc_uint<${bit_width}>";
}
else{
    $port_type = "sc_dt::sc_biguint<${bit_width}>";
}

if ($default_out eq "fix_to_0"){
    $default_val = 0;
}
elsif ($default_out eq "fix_to_1"){
    $default_val = -1;
}
elsif ($default_out eq "keep"){
    $zs = 0;
}
else{
    print "ERROR: \"$default_out\" is not supported for the value of default_out.\n";
    exit (100);
}

{
    print <<FHM_DL_INSTANCE_1;
#include "${instance_name}.h"

// Module     : $bit_width-bit output wire
// Feature    : 
// References : refer to wire.fhm by Y.Kobayashi (c)2003.
// Author     : Designed by K.Ueda (c)2004.
// Version    : 1.0 :
// Functionality :
//  port
FHM_DL_INSTANCE_1
}

if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE;
//   clock       : clock port
//   async_reset : asynchronous reset port
//   reset       : synchronous reset port
FHM_DL_INSTANCE
}

{
print <<FHM_DL_INSTANCE;
//   int_port    : internal port
//   ext_port    : external port
//   wmode       : write mode (when '1', write data of int_port)
FHM_DL_INSTANCE
}

if ($default_out eq "keep"){
    print "//              '0' : keep pervious value\n";
}
else{
    print "//              '0' : write default data ($default_val)\n";
}

{
    print <<FHM_DL_INSTANCE_4;
// Comment :

FHM_DL_INSTANCE_4
}

if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE_7;
void ${name_space}::${instance_name}::process()
{
  if (async_reset.read() == true) {
    reg_out.write( 0 );
  } else if (clock.event() && clock.read() == true) {
    if (reset.read() == true)
      reg_out.write( 0 );
    else if (wmode.read() == true)
      reg_out.write( int_port.read() );
  }
}

void ${name_space}::${instance_name}::p_ext_port()
{
  if ( wmode.read() == true )
    ext_port.write( int_port.read() );
  else
    ext_port.write( reg_out.read() );
}
FHM_DL_INSTANCE_7
}
else{
    print <<FHM_DL_INSTANCE_8;
void ${name_space}::${instance_name}::p_ext_port()
{
  if ( wmode.read() == true )
    ext_port.write( int_port.read() );
  else
    ext_port.write( $default_val );
}
FHM_DL_INSTANCE_8
}

exit(0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[

          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <estimation>
      <estimation_data>
        <library name="OSAKA">

          <est_type name="shape">
            <est_index name="area">
              <unit> mm2 </unit>
              <translate>
                <translate_value key="gate"> 4201.68 </translate_value>
                <translate_value key="mm2">  1 </translate_value>
              </translate>

              <parameters name="fix_to_0">
                <max>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </max>
                <min>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="fix_to_1">
                <max>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </max>
                <min>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="keep">
                <max>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </max>
                <min>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>

            <est_index name="aspect_ratio">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="height">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="width">
              <!-- Dummy yet -->
            </est_index>
          </est_type>

          <est_type name="timing">
            <est_index name="delay">
              <unit> ns </unit>

              <parameters name="fix_to_0">
                <max>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </max>
                <min>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="fix_to_1">
                <max>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </max>
                <min>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="keep">
                <max>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </max>
                <min>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>

            <est_index name="delay_fullpath">
            <!-- Dummy yet -->
            </est_index>
          </est_type>

          <est_type name="power">
            <est_index name="static_power">
              <unit> mW </unit>
              <parameters name="fix_to_0">
                <max>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </max>
                <min>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="fix_to_1">
                <max>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </max>
                <min>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="keep">
                <max>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </max>
                <min>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>
          </est_type>

          <est_type name="function_cycle">
            <!-- Dummy yet -->
          </est_type>

          <est_type name="function_power">
            <!-- Dummy yet -->
          </est_type>
        </library>
      </estimation_data>


      <estimation_method>
         
        <est_type name="shape">

          <est_index name="area">

            <parameters name="">
               <script>
                 <![CDATA[
#!/usr/bin/perl
print "0.0\n";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

           <est_index name="aspect_ratio">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="height">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="width">

             <!-- Dummy yet -->

           </est_index>
		
        </est_type>

        <est_type name="timing">

          <est_index name="delay">

            <parameters name="">
               <script>
                 <![CDATA[
#!/usr/bin/perl
print "0.0\n";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

          <est_index name="delay_fullpath">

            <parameters name="">
               <script>
                 <![CDATA[
#!/usr/bin/perl
print "0.0\n";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

        </est_type>

        <est_type name="power">

          <est_index name="static_power">

            <parameters name="">
               <script>
                 <![CDATA[
#!/usr/bin/perl
print "0.0\n";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

        </est_type>

        <est_type name="function_cycle">
          <est_index name="cycle">
            <parameters name="">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0.0\n";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

          <est_index name="latency">
            <parameters name="">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0.0\n";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

          <est_index name="throughput">
            <parameters name="">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0.0\n";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>
        </est_type>

        <est_type name="function_power">
        </est_type>

    
      </estimation_method>
    </estimation>
  </model>

  <model>
    <design_level> synthesis </design_level>
    <version> 1.0 </version>
    <author> <![CDATA[ Yuki Kobayashi ]]> </author>
    <affiliation> <![CDATA[ Osaka Univ. ]]> </affiliation>
    <model_info> <![CDATA[
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                %
%    Copyright 2008 ASIP Solutions, Inc. All rights reserved.    %
%                 Copyright 2004 PEAS Project                    %
%                                                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
]]> </model_info>

    <parameter>
      <parameter_value key="bit_width">
        <value> 1 </value>
        <value> 2 </value>
        <value> 3 </value>
        <value> 4 </value>
        <value> 5 </value>
        <value> 6 </value>
        <value> 7 </value>
        <value> 8 </value>
        <value> 9 </value>
        <value> 10 </value>
        <value> 11 </value>
        <value> 12 </value>
        <value> 13 </value>
        <value> 14 </value>
        <value> 15 </value>
        <value> 16 </value>
        <value> 17 </value>
        <value> 18 </value>
        <value> 19 </value>
        <value> 20 </value>
        <value> 21 </value>
        <value> 22 </value>
        <value> 23 </value>
        <value> 24 </value>
        <value> 25 </value>
        <value> 26 </value>
        <value> 27 </value>
        <value> 28 </value>
        <value> 29 </value>
        <value> 30 </value>
        <value> 31 </value>
        <value> 32 </value>
        <value> 33 </value>
        <value> 34 </value>
        <value> 35 </value>
        <value> 36 </value>
        <value> 37 </value>
        <value> 38 </value>
        <value> 39 </value>
        <value> 40 </value>
        <value> 41 </value>
        <value> 42 </value>
        <value> 43 </value>
        <value> 44 </value>
        <value> 45 </value>
        <value> 46 </value>
        <value> 47 </value>
        <value> 48 </value>
        <value> 49 </value>
        <value> 50 </value>
        <value> 51 </value>
        <value> 52 </value>
        <value> 53 </value>
        <value> 54 </value>
        <value> 55 </value>
        <value> 56 </value>
        <value> 57 </value>
        <value> 58 </value>
        <value> 59 </value>
        <value> 60 </value>
        <value> 61 </value>
        <value> 62 </value>
        <value> 63 </value>
        <value> 64 </value>
        <value> 65 </value>
        <value> 66 </value>
        <value> 67 </value>
        <value> 68 </value>
        <value> 69 </value>
        <value> 70 </value>
        <value> 71 </value>
        <value> 72 </value>
        <value> 73 </value>
        <value> 74 </value>
        <value> 75 </value>
        <value> 76 </value>
        <value> 77 </value>
        <value> 78 </value>
        <value> 79 </value>
        <value> 80 </value>
        <value> 128 </value>
      </parameter_value>
      <parameter_value key="default_output">
        <value> fix_to_0 </value>
        <value> fix_to_1 </value>
        <value> keep </value>
      </parameter_value>
    </parameter>

    <function_description>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates wire_out function description in synthesis level
# parameter : bit_width default_output

if ($#ARGV != 1) {
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width default_output\n";
    exit (100);
}

$bit_width    = $ARGV[0];
$default_out  = $ARGV[1];

if ($bit_width > 80) {
    if ($bit_width != 128) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
    }
}
elsif ($bit_width < 1) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$bit_width" == "1") {
    $range = "";
    $vec   = "";
    $val_symbol = "'";
}
else {
    $W1 = $bit_width - 1;
    $range = "[$W1:0]";
    $vec   = "_vector";
    $val_symbol = "\"";
}

if ($default_out eq "fix_to_0"){
    $default_val = $val_symbol . "0" x $bit_width . $val_symbol;
}
elsif ($default_out eq "fix_to_1"){
    $default_val = $val_symbol . "1" x $bit_width . $val_symbol;
}
elsif ($default_out ne "keep"){
    print "ERROR: \"$default_out\" is not supported for the value of default_output.\n";
    exit (100);
}

{
    print <<FHM_DL_FUNC_DESC_1;
/** $bit_width-bit output wire */
model wire_out_${bit_width}{
  port{
FHM_DL_FUNC_DESC_1
}
{
    print <<FHM_DL_FUNC_DESC_3;
    in    int_port$range;
    out   ext_port$range;
    in    wmode;
  }
FHM_DL_FUNC_DESC_3
}

if ($default_out eq "keep"){
    print <<FHM_DL_FUNC_DESC;
  storage{
    register reg;
  }
FHM_DL_FUNC_DESC
}
{
    print <<FHM_DL_FUNC_DESC_3;
  /** no operation */
  function nop : idle{
    control {
FHM_DL_FUNC_DESC_3
}
if ($default_out eq "keep"){
    print "      in reset;\n";
}
{
    print <<FHM_DL_FUNC_DESC_4;
      in wmode;
    }
    protocol {
FHM_DL_FUNC_DESC_4
}
if ($default_out eq "keep"){
    print <<FHM_DL_FUNC_DESC_5;
      [reset == '0' && wmode == '0']{
        ext_port = reg;
      }
FHM_DL_FUNC_DESC_5
}
else{
    print <<FHM_DL_FUNC_DESC_5;
      [wmode == '0']{
        ext_port = $default_val
      }
FHM_DL_FUNC_DESC_5
}
{
    print <<FHM_DL_FUNC_DESC;
    }
  }

FHM_DL_FUNC_DESC
}

if ($default_out eq "keep"){
    print <<FHM_DL_FUNC_DESC;
 /** reset */
  function reset: reset{
    assignment{
      reg = 0;
    }
    control{
      in reset;
    }
    protocol{
      [reset == 1]{
        store reg;
      }
    }
  }

  /** write */
  function write {
    input {
     bit$vec int_port;
    }
    assignment{
      reg = int_port;
    }
    control {
      bit wmode;
    }
    protocol {
      [reset == '0' && wmode == '1']{
        store reg;
      }
    }
  }
}
FHM_DL_FUNC_DESC
}
else{
    print <<FHM_DL_FUNC_DESC_6;
  /** write */
  function write {
    input {
     bit$vec int_port;
    }
    control {
      bit wmode;
    }
    protocol {
      [wmode == '1']{
        ext_port = int_port;
      }
    }
  }
}
FHM_DL_FUNC_DESC_6
}
exit (0);
        ]]>
      </script>
    </function_description>

    <function_conv>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates wire_out function conv in synthesis level
# parameter : bit_width default_output

if ($#ARGV != 1) {
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width default_output\n";
    exit (100);
}

$bit_width    = $ARGV[0];
$default_out  = $ARGV[1];

if ($bit_width > 80) {
    if ($bit_width != 128) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
    }
}
elsif ($bit_width < 1) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$bit_width" == "1") {
    $range = "";
}
else {
    $W1 = $bit_width - 1;
    $range = "[$W1:0]";
}

{
    print <<FHM_DL_FUNC_CONV_1;
/** No operation */
function nop {
  input {
  }
  output {
  }
  control {
    in bit wmode;
FHM_DL_FUNC_CONV_1
}
if ($default_out eq "keep"){
    print "    in bit reset;\n";
}
{
    print <<FHM_DL_FUNC_CONV_2;
  }
  protocol {
    single_cycle_protocol {
      wmode = '0';
FHM_DL_FUNC_CONV_2
}
if ($default_out eq "keep"){
    print "      reset = '0';\n";
}
{
    print <<FHM_DL_FUNC_CONV_3;
    }
  }
}

FHM_DL_FUNC_CONV_3
}

if ($default_out eq "keep"){
    print <<FHM_DL_FUNC_CONV_4;
/** reset */
function reset {
  input {
  }
  output {
  }
  control {
    in bit reset;
  }
  protocol {
    single_cycle_protocol {
      reset = '1';
    }
  }
}

FHM_DL_FUNC_CONV_4
}
{
    print <<FHM_DL_FUNC_CONV_5;
/** write */
function write {
  input {
    bit $range int_port;
  }
  output {
  }
  control {
    in bit wmode;
  }
  protocol {
    single_cycle_protocol {
      wmode = '1';
    }
  }
}
FHM_DL_FUNC_CONV_5
}
exit (0);
        ]]>
      </script>
    </function_conv>

    <function_port>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates wire_out port information in synthesis level
# parameter : bit_width default_output

if ($#ARGV != 1) {
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width default_output\n";
    exit (100);
}

$bit_width   = $ARGV[0];
$default_out = $ARGV[1];

if ($bit_width > 80) {
    if ($bit_width != 128) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
    }
}
elsif ($bit_width < 1) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

$msb = $bit_width-1;

if ($default_out eq "keep"){
    print <<FHM_DL_PORT_1;
clock	in	bit	clock
async_reset	in	bit	reset
reset	in	bit	ctrl
FHM_DL_PORT_1
}
if ("$bit_width" == "1") {
    print <<FHM_DL_PORT_2;
int_port	in	bit	data
ext_port	out	bit	data
wmode	in	bit	ctrl
FHM_DL_PORT_2
}
else {
    print <<FHM_DL_PORT_3
int_port	in	bit_vector $msb 0	data
ext_port	out	bit_vector $msb 0	data
wmode	in	bit	ctrl
FHM_DL_PORT_3
}
exit (0);
        ]]>
      </script>
    </function_port>

    <design>
      <design_lang> vhdl </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# This script generates wire_out instance in synthesis level
# parameter : instance_name bit_width default_output

if ($#ARGV != 2) {
  print "number of parameters is wrong.\n";
  print "usage : this_script instance_name bit_width default_output\n";
  exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$default_out   = $ARGV[2];

if ($bit_width == 1){
    $port_type = "std_logic";
    $val_symbol = "'";
    $ap_0 = "'0'";
}
else{
    $b_1 = $bit_width - 1;
    $port_type = "std_logic_vector($b_1 downto 0)";
    $val_symbol = "\"";
    $ap_0 = "(others => '0')";
}

if ($default_out eq "fix_to_0"){
    $default_val = $val_symbol . "0" x $bit_width . $val_symbol;
}
elsif ($default_out eq "fix_to_1"){
    $default_val = $val_symbol . "1" x $bit_width . $val_symbol;
}
elsif ($default_out eq "keep"){
    $zs = $val_symbol . "0" x $bit_width . $val_symbol;
}
else{
    print "ERROR: \"$default_out\" is not supported for the value of default_output.\n";
    exit (100);
}

{
    print <<FHM_DL_INSTANCE_1;
-- Module     : $bit_width-bit output wire
-- Feature    : 
-- References : refer to wire.fhm by Y.Kobayashi (c)2003.
-- Author     : Designed by K.Ueda (c)2004.
-- Version    : 1.0 :
-- Functionality :
--  port
FHM_DL_INSTANCE_1
}
if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE_2;
--   clock       : clock port
--   async_reset : asynchronous reset port
--   reset       : synchronous reset port
FHM_DL_INSTANCE_2
}
{
    print <<FHM_DL_INSTANCE_3;
--   int_port    : internal port
--   ext_port    : external port
--   wmode       : write mode
--              '1' : write data of int_port
FHM_DL_INSTANCE_3
}

if ($default_out eq "keep"){
    print "--              '0' : keep pervious value\n";
}
else{
    print "--              '0' : write default data ($default_val)\n";
}

{
    print <<FHM_DL_INSTANCE_4;
-- Comment :

library IEEE;
use IEEE.std_logic_1164.all;

entity $instance_name is
  port (
FHM_DL_INSTANCE_4
}
if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE_5;
    clock       : in  std_logic;
    async_reset : in  std_logic;
    reset       : in  std_logic;
FHM_DL_INSTANCE_5
}
{
    print <<FHM_DL_INSTANCE_6;
    int_port    : in  $port_type;
    ext_port    : out $port_type;
    wmode       : in  std_logic);
end $instance_name;

architecture synthesis of $instance_name is
FHM_DL_INSTANCE_6
}

if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE_7;
  signal reg_out : $port_type;
begin
  process (async_reset, clock)
  begin
    if (async_reset = '1') then
      reg_out <= $zs;
    elsif (clock'event and clock = '1') then
      if (reset = '1') then
        reg_out <= $ap_0;
      elsif (wmode = '1') then
        reg_out <= int_port;
      end if;
    end if;
  end process;

  ext_port <= int_port when wmode = '1' else
              reg_out;
end synthesis;
FHM_DL_INSTANCE_7
}
else{
    print <<FHM_DL_INSTANCE_8;
begin
  ext_port <= int_port when (wmode = '1') else
              $default_val;
end synthesis;
FHM_DL_INSTANCE_8
}

exit(0);
          ]]>
        </script>
      </instance>

      <entity></entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>

      <synthesis>
        <parameter></parameter>
        <synthesis_script>
          <script>
            <![CDATA[
#!/usr/bin/perl
# This script generates wire_out synthesis script in synthesis level
# parameter : instance_name priority bit_width default_output

if ($#ARGV != 3) {
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name priority bit_width default_output\n";
    exit (100);
}

$instance_name = $ARGV[0];
$priority      = $ARGV[1];
$bit_width     = $ARGV[2];
$default_out   = $ARGV[3];

if ($bit_width > 80) {
    if ($bit_width != 128) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
    }
}
elsif ($bit_width < 1) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ($priority eq "area"){
  $priority_const = "set_max_area 0";
}
elsif ($priority eq "performance"){
  $priority_const = "set_max_delay -from all_inputs() -to all_outputs() 0";
}
elsif ($priority eq "power"){
  $priority_const = "";
}
elsif ($priority eq "none"){
  $priority_const = "";
}
else {
    print "priority $priority is not supported.\n";
    exit(100);
}

{
    print <<FHM_DL_END_OF_SCRIPT
hdlin_auto_save_templates = TRUE

analyze -f vhdl $instance_name.vhd

elaborate $instance_name
uniquify

$priority_const

compile

write -hierarchy -output $instance_name.db

report_area
report_timing

quit
FHM_DL_END_OF_SCRIPT
}
exit(0);
            ]]>
          </script>
        </synthesis_script>
      </synthesis>
    </design>

    <design>
      <design_lang> Verilog </design_lang>
                                                                                
      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# This script generates wire_out instance in synthesis level
# parameter : instance_name bit_width default_output

if ($#ARGV != 2) {
  print "number of parameters is wrong.\n";
  print "usage : this_script instance_name bit_width default_output\n";
  exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$default_out   = $ARGV[2];

if ($bit_width == 1){
    $port_type = " ";
    $ap_0 = "1'b0";
}
else{
    $b_1 = $bit_width - 1;
    $port_type = "[${b_1}:0]";
    $ap_0 = "\{${bit_width}\{1'b0\}\}";
}

if ($default_out eq "fix_to_0"){
   if ($bit_width == 1){
     $default_val = "1'b0";
   }
   else{
     $default_val = "\{${bit_width}\{1'b0\}\}";
   }
}
elsif ($default_out eq "fix_to_1"){
   if ($bit_width == 1){
     $default_val = "1'b1";
   }
   else{
     $default_val = "\{${bit_width}\{1'b1\}\}";
   }
}
elsif ($default_out eq "keep"){
   if ($bit_width == 1){
     $zs = "1'b0";
   }
   else{
     $zs = "\{${bit_width}\{1'b0\}\}";
   }
}
else{
    print "ERROR: \"$default_out\" is not supported for the value of default_output.\n";
    exit (100);
}

{
    print <<FHM_DL_INSTANCE;
// Module     : $bit_width-bit output wire
// Feature    : 
// References : refer to wire.fhm by Y.Kobayashi (c)2003.
// Author     : Designed by K.Ueda (c)2004.
// Version    : 1.0 :
// Functionality :
//  port
FHM_DL_INSTANCE
}
if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE;
//   clock       : clock port
//   async_reset : asynchronous reset port
//   reset       : synchronous reset port
FHM_DL_INSTANCE
}
{
    print <<FHM_DL_INSTANCE;
//   int_port    : internal port
//   ext_port    : external port
//   wmode       : write mode
//              '1' : write data of int_port
FHM_DL_INSTANCE
}

if ($default_out eq "keep"){
    print "//              '0' : keep pervious value\n";
}
else{
    print "//              '0' : write default data ($default_val)\n";
}

{
    print <<FHM_DL_INSTANCE;
// Comment :
\n
module $instance_name (
FHM_DL_INSTANCE
}
if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE;
  clock       ,
  async_reset ,
  reset       ,
FHM_DL_INSTANCE
}
{
    print <<FHM_DL_INSTANCE;
  int_port    ,
  ext_port    ,
  wmode       );
\n
FHM_DL_INSTANCE
}

if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE;
input         clock       ;
input         async_reset ;
input         reset       ;
FHM_DL_INSTANCE
}
{
    print <<FHM_DL_INSTANCE;
input  $port_type int_port    ;
output $port_type ext_port    ;
input         wmode       ;
\n
FHM_DL_INSTANCE
}

if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE;
wire          clock       ;
wire          async_reset ;
wire          reset       ;
FHM_DL_INSTANCE
}
{
    print <<FHM_DL_INSTANCE;
wire   $port_type int_port    ;
wire   $port_type ext_port    ;
wire          wmode       ;
\n

FHM_DL_INSTANCE
}

if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE;
reg    $port_type reg_out     ;
\n
always@ (posedge async_reset or posedge clock)
begin
    if (async_reset == 1'b1)
      reg_out <= $zs;
    else
    begin
      if (reset == 1'b1)
        reg_out <= $ap_0;
      else if (wmode == 1'b1)
        reg_out <= int_port;
    end
end
\n
assign  ext_port = (wmode == 1'b1) ? int_port : reg_out ;
\n
endmodule
FHM_DL_INSTANCE
}
else{
    print <<FHM_DL_INSTANCE;
assign  ext_port = (wmode == 1'b1) ? int_port : $default_val ;
\n
endmodule
FHM_DL_INSTANCE
}

exit(0);
          ]]>
        </script>
      </instance>
                                                                                
      <entity></entity>
                                                                                
      <testvector></testvector>
                                                                                
      <synthesis></synthesis>
    </design>

    <design>
      <design_lang> SystemC Header </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# This script generates wire_out instance in synthesis level
# parameter : instance_name bit_width default_output

if ($#ARGV != 3) {
  print "number of parameters is wrong.\n";
  print "usage : this_script name_space instance_name bit_width default_output\n";
  exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];
$default_out   = $ARGV[3];

if ($bit_width == 1){
    $port_type = "bool";
}
elsif ( $bit_width <= 64 ) {
    $port_type = "sc_dt::sc_uint<${bit_width}>";
}
else{
    $port_type = "sc_dt::sc_biguint<${bit_width}>";
}

if ($default_out eq "fix_to_0"){
    $default_val = 0;
}
elsif ($default_out eq "fix_to_1"){
    $default_val = 1;
}
elsif ($default_out eq "keep"){
    $zs = 0;
}
else{
    print "ERROR: \"$default_out\" is not supported for the value of default_out.\n";
    exit (100);
}

$macro = "__" . uc($name_space) . "_" . uc($instance_name) . "_H__";

{
    print <<FHM_DL_INSTANCE_1;
#ifndef $macro
#define $macro 1

// Module     : $bit_width-bit output wire
// Feature    : 
// References : refer to wire.fhm by Y.Kobayashi (c)2003.
// Author     : Designed by K.Ueda (c)2004.
// Version    : 1.0 :
// Functionality :
//  port
FHM_DL_INSTANCE_1
}

if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE;
//   clock       : clock port
//   async_reset : asynchronous reset port
//   reset       : synchronous reset port
FHM_DL_INSTANCE
}

{
print <<FHM_DL_INSTANCE;
//   int_port    : internal port
//   ext_port    : external port
//   wmode       : write mode (when '1', write data of int_port)
FHM_DL_INSTANCE
}

if ($default_out eq "keep"){
    print "//              '0' : keep pervious value\n";
}
else{
    print "//              '0' : write default data ($default_val)\n";
}


{
    print <<FHM_DL_INSTANCE;
// Comment :

#include <systemc>

namespace ${name_space} {
  SC_MODULE(${instance_name}) {
FHM_DL_INSTANCE
}

if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE;
    sc_core::sc_in< bool > clock;
    sc_core::sc_in< bool > async_reset;
    sc_core::sc_in< bool > reset;
FHM_DL_INSTANCE
}

{
    print <<FHM_DL_INSTANCE
    sc_core::sc_in< $port_type > int_port;
    sc_core::sc_out< $port_type > ext_port;
    sc_core::sc_in< bool > wmode;
FHM_DL_INSTANCE
}

if ( $default_out eq "keep" ) {
    print <<FHM_DL_INSTANCE

    sc_core::sc_signal< $port_type > reg_out;
FHM_DL_INSTANCE
}

{
    print <<FHM_DL_INSTANCE

    SC_CTOR(${instance_name}) {
FHM_DL_INSTANCE
}

if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE_7;
      SC_METHOD(process);
      sensitive << async_reset << clock.pos();

      SC_METHOD(p_ext_port);
      sensitive << int_port << wmode << reg_out;
    }

    void process();
    void p_ext_port();
FHM_DL_INSTANCE_7
}
else{
    print <<FHM_DL_INSTANCE_8;
       SC_METHOD(p_ext_port);
       sensitive << int_port << wmode;
    }

    void p_ext_port();
FHM_DL_INSTANCE_8
}

{
    print <<FHM_DL_INSTANCE
  };
};

#endif // $macro
FHM_DL_INSTANCE
}

exit(0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <design>
      <design_lang> SystemC Program </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# This script generates wire_out instance in synthesis level
# parameter : instance_name bit_width default_output

if ($#ARGV != 3) {
  print "number of parameters is wrong.\n";
  print "usage : this_script name_space instance_name bit_width default_output\n";
  exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];
$default_out   = $ARGV[3];

if ($bit_width == 1){
    $port_type = "bool";
}
elsif ( $bit_width <= 64 ) {
    $port_type = "sc_dt::sc_uint<${bit_width}>";
}
else{
    $port_type = "sc_dt::sc_biguint<${bit_width}>";
}

if ($default_out eq "fix_to_0"){
    $default_val = 0;
}
elsif ($default_out eq "fix_to_1"){
    $default_val = -1;
}
elsif ($default_out eq "keep"){
    $zs = 0;
}
else{
    print "ERROR: \"$default_out\" is not supported for the value of default_out.\n";
    exit (100);
}

{
    print <<FHM_DL_INSTANCE_1;
#include "${instance_name}.h"

// Module     : $bit_width-bit output wire
// Feature    : 
// References : refer to wire.fhm by Y.Kobayashi (c)2003.
// Author     : Designed by K.Ueda (c)2004.
// Version    : 1.0 :
// Functionality :
//  port
FHM_DL_INSTANCE_1
}

if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE;
//   clock       : clock port
//   async_reset : asynchronous reset port
//   reset       : synchronous reset port
FHM_DL_INSTANCE
}

{
print <<FHM_DL_INSTANCE;
//   int_port    : internal port
//   ext_port    : external port
//   wmode       : write mode (when '1', write data of int_port)
FHM_DL_INSTANCE
}

if ($default_out eq "keep"){
    print "//              '0' : keep pervious value\n";
}
else{
    print "//              '0' : write default data ($default_val)\n";
}

{
    print <<FHM_DL_INSTANCE_4;
// Comment :

FHM_DL_INSTANCE_4
}

if ($default_out eq "keep"){
    print <<FHM_DL_INSTANCE_7;
void ${name_space}::${instance_name}::process()
{
  if (async_reset.read() == true) {
    reg_out.write( 0 );
  } else if (clock.event() && clock.read() == true) {
    if (reset.read() == true)
      reg_out.write( 0 );
    else if (wmode.read() == true)
      reg_out.write( int_port.read() );
  }
}

void ${name_space}::${instance_name}::p_ext_port()
{
  if ( wmode.read() == true )
    ext_port.write( int_port.read() );
  else
    ext_port.write( reg_out.read() );
}
FHM_DL_INSTANCE_7
}
else{
    print <<FHM_DL_INSTANCE_8;
void ${name_space}::${instance_name}::p_ext_port()
{
  if ( wmode.read() == true )
    ext_port.write( int_port.read() );
  else
    ext_port.write( $default_val );
}
FHM_DL_INSTANCE_8
}

exit(0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <estimation>
      <estimation_data>
        <library name="OSAKA">

          <est_type name="shape">
            <est_index name="area">
              <unit> mm2 </unit>
              <translate>
                <translate_value key="gate"> 4201.68 </translate_value>
                <translate_value key="mm2">  1 </translate_value>
              </translate>

              <parameters name="fix_to_0">
                <max>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </max>
                <min>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="fix_to_1">
                <max>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </max>
                <min>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="keep">
                <max>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </max>
                <min>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>

            <est_index name="aspect_ratio">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="height">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="width">
              <!-- Dummy yet -->
            </est_index>
          </est_type>

          <est_type name="timing">
            <est_index name="delay">
              <unit> ns </unit>

              <parameters name="fix_to_0">
                <max>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </max>
                <min>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="fix_to_1">
                <max>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </max>
                <min>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="keep">
                <max>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </max>
                <min>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>

            <est_index name="delay_fullpath">
            </est_index>
          </est_type>

          <est_type name="power">
            <est_index name="static_power">
              <unit> mW </unit>
              <parameters name="fix_to_0">
                <max>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </max>
                <min>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="fix_to_1">
                <max>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </max>
                <min>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="keep">
                <max>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </max>
                <min>
                  <data bit_width="1"> 0.00 </data>
                  <data bit_width="4"> 0.00 </data>
                  <data bit_width="8"> 0.00 </data>
                  <data bit_width="16"> 0.00 </data>
                  <data bit_width="32"> 0.00 </data>
                  <data bit_width="128"> 0.00 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1"> 0.00 </data>
                    <data bit_width="4"> 0.00 </data>
                    <data bit_width="8"> 0.00 </data>
                    <data bit_width="16"> 0.00 </data>
                    <data bit_width="32"> 0.00 </data>
                    <data bit_width="128"> 0.00 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>
          </est_type>

          <est_type name="function_cycle">
            <unit> cycle </unit>

            <est_index name="cycle">
              <parameters name="fix_to_0">
                <function name="nop">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
                <function name="reset">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
                <function name="write">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
              </parameters>
              <parameters name="fix_to_1">
                <function name="nop">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
                <function name="reset">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
                <function name="write">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
              </parameters>
              <parameters name="keep">
                <function name="nop">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
                <function name="reset">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
                <function name="write">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
              </parameters>
            </est_index>

            <est_index name="latency">
              <parameters name="fix_to_0">
                <function name="nop">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
                <function name="reset">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
                <function name="write">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
              </parameters>
              <parameters name="fix_to_1">
                <function name="nop">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
                <function name="reset">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
                <function name="write">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
              </parameters>
              <parameters name="keep">
                <function name="nop">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
                <function name="reset">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
                <function name="write">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
              </parameters>
            </est_index>

            <est_index name="throughput">
              <parameters name="fix_to_0">
                <function name="nop">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
                <function name="reset">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
                <function name="write">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
              </parameters>
              <parameters name="fix_to_1">
                <function name="nop">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
                <function name="reset">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
                <function name="write">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
              </parameters>
              <parameters name="keep">
                <function name="nop">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
                <function name="reset">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
                <function name="write">
                  <priority name="area"><data bit_width="0"></data></priority>
                  <priority name="delay"><data bit_width="0"></data></priority>
                  <priority name="power"><data bit_width="0"></data></priority>
                </function>
              </parameters>
            </est_index>
          </est_type>

          <est_type name="function_power">
            <!-- Dummy yet -->
          </est_type>
        </library>
      </estimation_data>

      <estimation_method>
         
        <est_type name="shape">

          <est_index name="area">

            <parameters name="fix_to_0">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for wire_out.
#
# Author : PEAS Project
# Date   : 2004/06
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>){
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ){
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);
$n = $i;

$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++){
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;
$nume_2 = &sum(@bit) * &sum(@data);
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++){
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;
$deno_2 = &sum(@bit) * &sum(@bit);

if ($deno_1 == $deno_2 || $n == 0){
    exit(100);
}

$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;
$ret_data = $a * $ARGV[1] + $b;

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);

sub sum{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < $#data; $i++){
	$ret_data += $data[$i];
    }
    return($ret_data);
}

sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}
                ]]>
              </script>
            </parameters>

            <parameters name="fix_to_1">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for wire_out.
#
# Author : PEAS Project
# Date   : 2004/06
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>){
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ){
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);
$n = $i;

$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++){
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;
$nume_2 = &sum(@bit) * &sum(@data);
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++){
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;
$deno_2 = &sum(@bit) * &sum(@bit);

if ($deno_1 == $deno_2 || $n == 0){
    exit(100);
}

$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;
$ret_data = $a * $ARGV[1] + $b;

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);

sub sum{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < $#data; $i++){
	$ret_data += $data[$i];
    }
    return($ret_data);
}

sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}
                ]]>
              </script>
            </parameters>

            <parameters name="keep">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for wire_out.
#
# Author : PEAS Project
# Date   : 2004/06
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>){
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ){
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);
$n = $i;

$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++){
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;
$nume_2 = &sum(@bit) * &sum(@data);
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++){
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;
$deno_2 = &sum(@bit) * &sum(@bit);

if ($deno_1 == $deno_2 || $n == 0){
    exit(100);
}

$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;
$ret_data = $a * $ARGV[1] + $b;

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);

sub sum{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < $#data; $i++){
	$ret_data += $data[$i];
    }
    return($ret_data);
}

sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}
                ]]>
              </script>
            </parameters>
          </est_index>

           <est_index name="aspect_ratio">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="height">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="width">

             <!-- Dummy yet -->

           </est_index>
		
        </est_type>

        <est_type name="timing">

          <est_index name="delay">

            <parameters name="fix_to_0">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for wire_out.
#
# Author : PEAS Project
# Date   : 2004/06
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>){
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ){
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);
$n = $i;

$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++){
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;
$nume_2 = &sum(@bit) * &sum(@data);
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++){
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;
$deno_2 = &sum(@bit) * &sum(@bit);

if ($deno_1 == $deno_2 || $n == 0){
    exit(100);
}

$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;
$ret_data = $a * $ARGV[1] + $b;

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);

sub sum{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < $#data; $i++){
	$ret_data += $data[$i];
    }
    return($ret_data);
}

sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}
                ]]>
              </script>
            </parameters>

            <parameters name="fix_to_1">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for wire_out.
#
# Author : PEAS Project
# Date   : 2004/06
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>){
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ){
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);
$n = $i;

$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++){
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;
$nume_2 = &sum(@bit) * &sum(@data);
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++){
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;
$deno_2 = &sum(@bit) * &sum(@bit);

if ($deno_1 == $deno_2 || $n == 0){
    exit(100);
}

$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;
$ret_data = $a * $ARGV[1] + $b;

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);

sub sum{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < $#data; $i++){
	$ret_data += $data[$i];
    }
    return($ret_data);
}

sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}
                ]]>
              </script>
            </parameters>

            <parameters name="keep">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for wire_out.
#
# Author : PEAS Project
# Date   : 2004/06
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>){
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ){
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);
$n = $i;

$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++){
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;
$nume_2 = &sum(@bit) * &sum(@data);
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++){
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;
$deno_2 = &sum(@bit) * &sum(@bit);

if ($deno_1 == $deno_2 || $n == 0){
    exit(100);
}

$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;
$ret_data = $a * $ARGV[1] + $b;

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);

sub sum{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < $#data; $i++){
	$ret_data += $data[$i];
    }
    return($ret_data);
}

sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}
                ]]>
              </script>
            </parameters>
          </est_index>

          <est_index name="delay_fullpath">

            <parameters name="fix_to_0">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay_fullpath for wire_out.
#
# Author : PEAS Project
# Date   : 2004/06
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>){
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ){
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);
$n = $i;

$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++){
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;
$nume_2 = &sum(@bit) * &sum(@data);
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++){
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;
$deno_2 = &sum(@bit) * &sum(@bit);

if ($deno_1 == $deno_2 || $n == 0){
    exit(100);
}

$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;
$ret_data = $a * $ARGV[1] + $b;

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);

sub sum{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < $#data; $i++){
	$ret_data += $data[$i];
    }
    return($ret_data);
}

sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}
                ]]>
              </script>
            </parameters>

            <parameters name="fix_to_1">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay_fullpath for wire_out.
#
# Author : PEAS Project
# Date   : 2004/06
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>){
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ){
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);
$n = $i;

$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++){
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;
$nume_2 = &sum(@bit) * &sum(@data);
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++){
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;
$deno_2 = &sum(@bit) * &sum(@bit);

if ($deno_1 == $deno_2 || $n == 0){
    exit(100);
}

$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;
$ret_data = $a * $ARGV[1] + $b;

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);

sub sum{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < $#data; $i++){
	$ret_data += $data[$i];
    }
    return($ret_data);
}

sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}
                ]]>
              </script>
            </parameters>

            <parameters name="keep">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay_fullpath for wire_out.
#
# Author : PEAS Project
# Date   : 2004/06
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>){
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ){
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);
$n = $i;

$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++){
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;
$nume_2 = &sum(@bit) * &sum(@data);
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++){
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;
$deno_2 = &sum(@bit) * &sum(@bit);

if ($deno_1 == $deno_2 || $n == 0){
    exit(100);
}

$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;
$ret_data = $a * $ARGV[1] + $b;

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);

sub sum{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < $#data; $i++){
	$ret_data += $data[$i];
    }
    return($ret_data);
}

sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}
                ]]>
              </script>
            </parameters>
          </est_index>

        </est_type>

        <est_type name="power">

          <est_index name="static_power">

            <parameters name="fix_to_0">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for wire_out.
#
# Author : PEAS Project
# Date   : 2004/06
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>){
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ){
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);
$n = $i;

$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++){
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;
$nume_2 = &sum(@bit) * &sum(@data);
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++){
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;
$deno_2 = &sum(@bit) * &sum(@bit);

if ($deno_1 == $deno_2 || $n == 0){
    exit(100);
}

$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;
$ret_data = $a * $ARGV[1] + $b;

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);

sub sum{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < $#data; $i++){
	$ret_data += $data[$i];
    }
    return($ret_data);
}

sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}
                ]]>
              </script>
            </parameters>

            <parameters name="fix_to_1">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for wire_out.
#
# Author : PEAS Project
# Date   : 2004/06
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>){
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ){
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);
$n = $i;

$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++){
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;
$nume_2 = &sum(@bit) * &sum(@data);
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++){
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;
$deno_2 = &sum(@bit) * &sum(@bit);

if ($deno_1 == $deno_2 || $n == 0){
    exit(100);
}

$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;
$ret_data = $a * $ARGV[1] + $b;

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);

sub sum{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < $#data; $i++){
	$ret_data += $data[$i];
    }
    return($ret_data);
}

sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}
                ]]>
              </script>
            </parameters>

            <parameters name="keep">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for wire_out.
#
# Author : PEAS Project
# Date   : 2004/06
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>){
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ){
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);
$n = $i;

$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++){
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;
$nume_2 = &sum(@bit) * &sum(@data);
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++){
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;
$deno_2 = &sum(@bit) * &sum(@bit);

if ($deno_1 == $deno_2 || $n == 0){
    exit(100);
}

$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;
$ret_data = $a * $ARGV[1] + $b;

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);

sub sum{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < $#data; $i++){
	$ret_data += $data[$i];
    }
    return($ret_data);
}

sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}
                ]]>
              </script>
            </parameters>
          </est_index>

        </est_type>

        <est_type name="function_cycle">
          <est_index name="cycle">
            <parameters name="fix_to_0">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0\n";
exit(0);
                ]]>
              </script>
            </parameters>
            <parameters name="fix_to_1">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0\n";
exit(0);
                ]]>
              </script>
            </parameters>
            <parameters name="keep">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0\n";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

          <est_index name="latency">
            <parameters name="fix_to_0">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0\n";
exit(0);
                ]]>
              </script>
            </parameters>
            <parameters name="fix_to_1">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0\n";
exit(0);
                ]]>
              </script>
            </parameters>
            <parameters name="keep">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0\n";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

          <est_index name="throughput">
            <parameters name="fix_to_0">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0\n";
exit(0);
                ]]>
              </script>
            </parameters>
            <parameters name="fix_to_1">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0\n";
exit(0);
                ]]>
              </script>
            </parameters>
            <parameters name="keep">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0\n";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

        </est_type>

        <est_type name="function_power">
        </est_type>

    
      </estimation_method>
    </estimation>
  </model>
</FHM>
