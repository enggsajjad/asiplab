<?xml version="1.0" encoding="UTF-8" ?>
<!-- Modified by T.Hamabe on 2006/12/05 -->
<!-- Modified by T.Hamabe on 2006/11/30 -->
<FHM>
  <model_name> divider </model_name>

  <model>
    <design_level> behavior </design_level>
    <version> 1.0 </version>
    <author> <![CDATA[ Kyoko UEDA ]]> </author>
    <affiliation> <![CDATA[ Osaka Univ. ]]> </affiliation>
    <model_info> <![CDATA[
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                %
%    Copyright 2008 ASIP Solutions, Inc. All rights reserved.    %
%              Copyright 2002-2005 PEAS Project                  %
%                                                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
]]> </model_info>

    <parameter>
      <parameter_value key="bit_width">
        <value> 4 </value>
        <value> 8 </value>
        <value> 12 </value>
        <value> 16 </value>
        <value> 20 </value>
        <value> 24 </value>
        <value> 28 </value>
        <value> 32 </value>
        <value> 36 </value>
        <value> 40 </value>
        <value> 44 </value>
        <value> 48 </value>
        <value> 52 </value>
        <value> 56 </value>
        <value> 60 </value>
        <value> 64 </value>
        <value> 128 </value>
      </parameter_value>
      <parameter_value key="algorithm">
        <value> default </value>
        <value> seq </value>
        <value> array </value>
      </parameter_value>
      <parameter_value key="data_type">
        <value> two_complement </value>
        <value> abs </value>
        <value> unsigned </value>
      </parameter_value>
    </parameter>

    <function_description>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates function definition for divider in behavior level
# parameter : bit_width algorithm data_type

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$algorithm = $ARGV[1];
$data_type = $ARGV[2];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ( $algorithm eq "seq" ) {
    $cycle = "multi";
} elsif ( $algorithm eq "default" || $algorithm eq "array" ) {
    $cycle = "single";
} else {
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;

if ("$data_type" eq "two_complement"){
    print <<FHM_DL_TWOCOMP_BASIC_FUNC
twoscomp div(twoscomp a, towscomp b);
unsigned div(unsigned a, unsigned b);
twoscomp mod(twoscomp a, towscomp b);
unsigned mod(unsigned a, unsigned b);
Boolean  flag_div(twoscomp a, towscomp b);
Boolean  flag_div(unsigned a, unsigned b);
FHM_DL_TWOCOMP_BASIC_FUNC
}
elsif ("$data_type" eq "abs"){
    print <<FHM_DL_ABS_BASIC_FUNC
signmagn div(signmagn a, signmagn b);
signmagn mod(signmagn a, signmagn b);
Boolean  flag_div(signmagn a, signmagn b);
FHM_DL_ABS_BASIC_FUNC
}
elsif ("$data_type" eq "unsigned"){
    print <<FHM_DL_UN_BASIC_FUNC
unsigned div(unsigned a, unsigned b);
unsigned mod(unsigned a, unsigned b);
Boolean  flag_div(unsigned a, unsigned b);
FHM_DL_UN_BASIC_FUNC
}
{
    print <<FHM_DL_FUNC

/** $bit_width-bit $data_type divider */
model ${data_type}_div${bit_width}{
  port{
    clock clock;
    in async_reset, reset, clear, start;
    in a[$w_1:0], b[$w_1:0];
    in mode;
    out q[$w_1:0], r[$w_1:0], flag;
    out fin;
  }
  default_control{
    reset = 0;
  }

  /** no operation */
  function nop : idle{
    control{
      in reset;
    }
    protocol{
      [reset == 0]{
      }
    }
  }

  /** reset */
  function reset : reset{
    control{
      in reset;
    }
    protocol{
      [reset == 1]{
      }
    }
  }

FHM_DL_FUNC
}

if ("$data_type" eq "two_complement"){
    &print_func("signed division", "div", "twoscomp", 1, 1);
    &print_func("unsigned division", "divu", "unsigned", 1, 0);
}
elsif ("$data_type" eq "abs"){
    &print_func("abs division", "diva", "signmagn", 0);
}
elsif ("$data_type" eq "unsigned"){
    &print_func("unsigned division", "divu", "unsigned", 0);
}
print "}\n";
exit (0);

# ---------------------------------

sub print_func{
    $comment   = $_[0];
    $func_name = $_[1];
    $d_type    = $_[2];
    $mode      = $_[3];
    $mode_val  = $_[4];

    {
	print <<FHM_DL_SUB_FUNC1
  /** $comment */
  function ${func_name}{
    input{
      $d_type a, b;
    }
    output{
      $d_type q = div(a, b);
      $d_type r = mod(a, b);
      Boolean flag = flag_div(a, b);
    }
FHM_DL_SUB_FUNC1
    }
    if ($mode == 1){
	print <<FHM_DL_SUB_SIGNED
    control{
      in mode;
      out fin;
    }
    protocol{
      [mode == $mode_val]{
	valid q, r, flag;
	fin = 1;
      }
    }
  }

FHM_DL_SUB_SIGNED
    }
    else{
	print <<FHM_DL_SUB_NOSIGNED
    control{
      out fin;
    }
    protocol{
      [true]{
	valid q, r, flag;
	fin = 1;
      }
    }
  }

FHM_DL_SUB_NOSIGNED
    }
}
exit(0);
        ]]>
      </script>
    </function_description>

    <function_conv>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates function definition for divider in behavior level
# parameter : bit_width algorithm data_type

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$algorithm = $ARGV[1];
$data_type = $ARGV[2];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

{
print <<FHM_DL_NOP_RESET
/** no operation */
function nop{
  input{
  }

  output{
  }

  control{
    in bit start;
    in bit reset;
    in bit clear;
  }

  protocol{
    single_cycle_protocol{
      start = '0';
      reset = '0';
      clear = '0';
    }
  }
}

/** reset */
function reset{
  input{
  }

  output{
  }

  control{
    in bit reset;
  }

  protocol{
    single_cycle_protocol{
      reset = '1';
    }
  }
}

FHM_DL_NOP_RESET
}

if ("$algorithm" eq "seq"){
    $multi = 1;
} else {
    $multi = 0;
}

$w_1 = $bit_width - 1;

if ("$data_type" eq "two_complement"){
    &print_func("signed division", "div", 1, 1);
    &print_func("unsigned division", "divu", 1, 0);
}
elsif ("$data_type" eq "abs"){
    &print_func("abs division", "diva", 0);
}
elsif ("$data_type" eq "unsigned"){
    &print_func("unsigned division", "divu", 0);
}
exit (0);

# ---------------------------------

sub print_func{
  $comment   = $_[0];
  $func_name = $_[1];
  $mode      = $_[2];
  $mode_val  = $_[3];

  {
    print <<FHM_DL_FUNC1
/** $comment */
function ${func_name}{
  input{
    bit [$w_1:0] a;
    bit [$w_1:0] b;
  }

  output{
    bit [$w_1:0] q;
    bit [$w_1:0] r;
    bit flag;
  }

  control{
FHM_DL_FUNC1
  }

  if ($mode == 1){
    print "    in  bit mode;\n";
  }

  if ($multi == 1){
  print <<FHM_DL_MULTI1
    in  bit start;
    in  bit clear;
    out bit fin;
FHM_DL_MULTI1
}

{
  print <<FHM_DL_FUNC2
  }

  protocol{
FHM_DL_FUNC2
  }

  if ($multi == 1){
    {
      print <<FHM_DL_MULTI2
    multi_cycle_protocol{
      start_signal  start = '1';
      fin_signal    fin   = '1';
      cancel_signal clear = '1';
FHM_DL_MULTI2
    }
    if ($mode == 1){
      print "\n";
    }
  }
  else{
      if ($mode == 1){
	  print "    single_cycle_protocol{\n";
      }
  }

  if ($mode == 1){
      print "      mode = '$mode_val';\n";
  }

  if ($mode == 1 || $multi == 1){
      print "    }\n";
  }

  print <<FHM_DL_FUNC4
  }
}

FHM_DL_FUNC4
}
        ]]>
      </script>
    </function_conv>

    <function_port>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generate port infomation for divider in behavior level
# parameter : bit_width algorithm data_type

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm data_type\n";
    exit (100);
}

$bit_width     = $ARGV[0];
$algorithm     = $ARGV[1];
$data_type     = $ARGV[2];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;

{
print <<FHM_DL_PORT
clock	in	bit		clock
async_reset	in	bit		reset
reset	in	bit		ctrl
clear	in	bit		ctrl
a	in	bit_vector   $w_1   0	data
b	in	bit_vector   $w_1   0	data
start	in	bit		ctrl
mode	in	bit		mode
q	out	bit_vector   $w_1   0	data
r	out	bit_vector   $w_1   0	data
flag	out	bit		data
fin	out	bit		ctrl
FHM_DL_PORT
}
exit (0);

        ]]>
      </script>
    </function_port>

    <design>
      <design_lang> vhdl </design_lang>

      <instance>
        <script>
           <![CDATA[
#!/usr/bin/perl
# this script generates multiplier instance in behavior level
# parameter : instance_name bit_width algorithm data_type

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width algorithm data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$algorithm     = $ARGV[2];
$data_type     = $ARGV[3];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w = $bit_width - 1;
$w2 = $bit_width*2-1;
$w3 = $bit_width - 2;
$xs = 'X' x $bit_width;

if ("$data_type" eq "two_complement"){
    $mode_comment = "\'1\' for signed multiplication\n--              '0' for unsigned multiplication";
}
else{
    $mode_comment = "(ignore)";
}

{
print <<FHM_DL_INSTANCE;
-- Module     : $bit_width-bit Divider
-- Feature    : 
-- References :
-- Author     : Designed by T.Morifuji (c) 1996,1999
--              Modified by K.Ueda (c)2002
-- Version    : 2.0  : change functionality

-- Functionality : behavioral level
--  port
--   clock    : (ignore)
--   async_reset    : (ignore)
--   reset    : (ignore)
--   clear    : (ignore)
--   a        : dividend
--   b        : divisor
--   start    : (ignore)
--   mode     : $mode_comment
--   q        : result of a / b
--   r        : reminder of a / b
--   flag     : '1' if b = 0
--   fin      : '1' when operation is over

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_signed.all;

entity $instance_name is
  port (clock  : in  std_logic;
        async_reset  : in  std_logic;
        reset  : in  std_logic;
	clear  : in  std_logic;
        a, b   : in  std_logic_vector($w downto 0);
        start  : in  std_logic;
        mode   : in  std_logic;
        q      : out std_logic_vector($w downto 0);
        r      : out std_logic_vector($w downto 0);
        flag   : out std_logic;
        fin    : out std_logic);
end $instance_name;

architecture behavior of $instance_name is
begin
  process (a, b, mode)
    variable tmp_a, tmp_b : std_logic_vector($w2 downto 0);
    variable tmp_result : std_logic_vector($w downto 0);
FHM_DL_INSTANCE
}
if ("$data_type" eq "two_complement"){
    print <<FHM_DL_INSTANCE2;
    variable sign : boolean;
  begin
    if (mode='1' and ((a($w) xor b($w)) = '1')) then
      sign := true;
    else
      sign := false;
    end if;
    if (mode='1' and a($w)='1') then
      tmp_a($w downto 0) := not a + 1;
    else
      tmp_a($w downto 0) := a;
    end if;
    tmp_a($w2 downto $bit_width) := (others => '0');
    
    if (mode='1' and b($w) = '1') then
      tmp_b($w2 downto $w) := '0' & (not b + 1);
    else
      tmp_b($w2 downto $w) := '0' & b;
    end if;
    tmp_b($w3 downto 0) := (others => '0');
FHM_DL_INSTANCE2
}
elsif("$data_type" eq "abs"){
    print <<FHM_DL_INSTANCE3;
  begin
    if (a($w) = '1') then
      tmp_a($w downto 0) := not a + 1;
    else
      tmp_a($w downto 0) := a;
    end if;
    tmp_a($w2 downto $bit_width) := (others => '0');
    if (b($w) = '1') then
      tmp_b($w2 downto $w) := '0' & (not b + 1);
    else
      tmp_b($w2 downto $w) := '0' & b;
    end if;
    tmp_b($w3 downto 0) := (others => '0');
FHM_DL_INSTANCE3
}
elsif ("$data_type" eq"unsigned"){
    print <<FHM_DL_INSTANCE4;
  begin
    tmp_a($w downto 0) := a;
    tmp_a($w2 downto $bit_width) := (others => '0');
    tmp_b($w2 downto $w) := '0' & b;
    tmp_b($w3 downto 0) := (others => '0');
FHM_DL_INSTANCE4
}
{
    print <<FHM_DL_INSTANCE5;
    
    for i in $w downto 0 loop
      if ((tmp_a /= 0) and (tmp_a - tmp_b >= 0)) then
        tmp_result(i) := '1';
        tmp_a := tmp_a - tmp_b;
      else
        tmp_result(i) := '0';
      end if;
      tmp_b := '0' & tmp_b($w2 downto 1);
    end loop;  -- i
FHM_DL_INSTANCE5
}
if ("$data_type" eq "two_complement"){
    print <<FHM_DL_INSTANCE6;

    if (sign) then
      tmp_result := not tmp_result + 1;
    end if;
    if (mode = '1' and a($w) = '1') then
      tmp_a := not tmp_a + 1;
    end if;
FHM_DL_INSTANCE6
}
{
	print <<FHM_DL_INSTANCE7;

    if (b = 0) then
      flag <= '1';
      q <= "$xs";
      r <= "$xs";
    else
      flag <= '0';
      -- divided
      q <= tmp_result;
      -- modulo
      r <= tmp_a($w downto 0);
    end if;
  end process;

  fin <= '1' and not start;
end behavior;
FHM_DL_INSTANCE7
}
exit (0);
          ]]>
       </script>
      </instance>

      <entity></entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>

      <synthesis></synthesis>
    </design>

    <design>
      <design_lang> Verilog </design_lang>
                                                                                
      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates multiplier instance in behavior level
# parameter : instance_name bit_width algorithm data_type

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width algorithm data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$algorithm     = $ARGV[2];
$data_type     = $ARGV[3];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w = $bit_width - 1;
$w2 = $bit_width*2-1;
$w3 = $bit_width - 2;
$xs = 'X' x $bit_width;

if ("$data_type" eq "two_complement"){
    $mode_comment = "\'1\' for signed multiplication\n//              '0' for unsigned multiplication";
}
else{
    $mode_comment = "(ignore)";
}

{
print <<FHM_DL_INSTANCE;
// Module     : $bit_width-bit Divider
// Feature    : 
// References :
// Author     : Designed by T.Morifuji (c) 1996,1999
//              Modified by K.Ueda (c)2002
// Version    : 2.0  : change functionality
\n
// Functionality : behavioral level
//  port
//   clock    : (ignore)
//   async_reset    : (ignore)
//   reset    : (ignore)
//   clear    : (ignore)
//   a        : dividend
//   b        : divisor
//   start    : (ignore)
//   mode     : $mode_comment
//   q        : result of a / b
//   r        : reminder of a / b
//   flag     : '1' if b = 0
//   fin      : '1' when operation is over
\n
module $instance_name (
  clock       ,
  async_reset ,
  reset       ,
  clear       ,
  a           ,
  b           ,
  start       ,
  mode        ,
  q           ,
  r           ,
  flag        ,
  fin         ) ;
\n
input         clock       ;
input         async_reset ;
input         reset       ;
input	      clear       ;
input signed [$w:0] a, b        ;
input         start       ;
input         mode        ;
output signed [$w:0] q           ;
output signed [$w:0] r           ;
output        flag        ;
output        fin         ;
\n
wire         clock       ;
wire         async_reset ;
wire         reset       ;
wire	     clear       ;
wire signed [$w:0] a, b        ;
wire         start       ;
wire         mode        ;
reg signed  [$w:0] q           ;
reg signed  [$w:0] r           ;
reg          flag        ;
\n
reg signed  [$w2:0] tmp_a, tmp_b ;
reg signed  [$w:0] tmp_result   ;
\n
integer      i            ;
FHM_DL_INSTANCE
}
if ("$data_type" eq "two_complement"){
    print <<FHM_DL_INSTANCE2;
reg          sign         ;
\n
always@ (a or b or mode)
begin
    if (mode == 1'b1 && ((a[$w] ^ b[$w]) == 1'b1))
      sign = 1'b1;
    else
      sign = 1'b0;
\n
    if (mode == 1'b1 && a[$w] == 1'b1)
      tmp_a[$w:0] = ~a + 1;
    else
      tmp_a[$w:0] = a;
    tmp_a[$w2:$bit_width] = \{$bit_width\{1'b0}};
    
    if (mode == 1'b1 && b[$w] == 1'b1)
      tmp_b[$w2:$w] = {1'b0 , (~b + 1)};
    else
      tmp_b[$w2:$w] = {1'b0 , b};
    tmp_b[$w3:0] = \{$w\{1'b0}};
FHM_DL_INSTANCE2
}
elsif("$data_type" eq "abs"){
    print <<FHM_DL_INSTANCE3;
\n
always@ (a or b or mode)
begin
    if (a[$w] == 1'b1)
      tmp_a[$w:0] = ~a + 1;
    else
      tmp_a[$w:0] = a;
    tmp_a[$w2:$bit_width] = \{$bit_width\{1'b0}};
\n
    if (b[$w] == 1'b1)
      tmp_b[$w2:$w] = {1'b0 , (~b + 1)};
    else
      tmp_b[$w2:$w] = {1'b0 , b};
    tmp_b[$w3:0] = \{$w\{1'b0}};
FHM_DL_INSTANCE3
}
elsif ("$data_type" eq"unsigned"){
    print <<FHM_DL_INSTANCE4;
\n
always@ (a or b or mode)
begin
    tmp_a[$w:0] = a;
    tmp_a[$w2:$bit_width] = \{$bit_width\{1'b0}};
    tmp_b[$w2:$w] = {1'b0 , b};
    tmp_b[$w3:0]  = \{$w\{1'b0}};
FHM_DL_INSTANCE4
}
{
    print <<FHM_DL_INSTANCE5;
    
    for (i = $w ; i >= 0 ;  i = i - 1)
    begin
      if ((tmp_a != 0) && (tmp_a - tmp_b >= 0))
      begin
        tmp_result[i] = 1'b1;
        tmp_a = tmp_a - tmp_b;
      end
      else
        tmp_result[i] = 1'b0;
      tmp_b = {1'b0 , tmp_b[$w2:1]};
    end
\n
FHM_DL_INSTANCE5
}
if ("$data_type" eq "two_complement"){
    print <<FHM_DL_INSTANCE6;

    if (sign == 1'b1)
      tmp_result = ~tmp_result + 1;
\n
    if (mode == 1'b1 && a[$w] == 1'b1)
      tmp_a = ~tmp_a + 1;
\n
FHM_DL_INSTANCE6
}
{
	print <<FHM_DL_INSTANCE7;

    if (b == \{$bit_width\{1'b0}}) 
    begin
      flag = 1'b1;
      q = \{$bit_width\{1'bX}};
      r = \{$bit_width\{1'bX}};
    end
    else
    begin
      flag = 1'b0;
      // divided
      q = tmp_result;
      // modulo
      r = tmp_a[$w:0];
    end
end
\n
assign fin = 1'b1 & ~ start;
\n
endmodule
FHM_DL_INSTANCE7
}
exit (0);
          ]]>
        </script>
      </instance>
                                                                                
      <entity></entity>
                                                                                
      <testvector></testvector>
                                                                                
      <synthesis></synthesis>
    </design>

    <design>
      <design_lang> SystemC Header </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates divider instance in behavior level
# parameter : name_space instance_name bit_width data_type

if ($#ARGV != 4){
    print "number of parameters is wrong.\n";
    print "usage : this_script name_space instance_name bit_width algorithm data_type\n";
    exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];
$algorithm     = $ARGV[3];
$data_type     = $ARGV[4];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

if ( $bit_width <= 64 ) {
    $input_type = "sc_dt::sc_uint<$bit_width>";
} else {
    $input_type = "sc_dt::sc_biguint<$bit_width>";
}

$w = $bit_width - 1;

if ("$data_type" eq "two_complement"){
    $mode_comment = "\'1\' for signed multiplication\n//              '0' for unsigned multiplication";
}
else{
    $mode_comment = "(ignore)";
}

$macro = "__" . uc($name_space) . "_" . uc($instance_name) . "_H__";


if ($algorithm ne "seq") {
    $sensitive_list = "sensitive << a << b << mode;";
    $proc_fin = "";
    $private_var = "";
} else {
    $sensitive_list = "sensitive << clock.pos() << async_reset;\n";
    $sensitive_list .= "      SC_METHOD(proc_fin);\n";
    $sensitive_list .= "      sensitive << start << div_fin;\n";
    $sensitive_list .= "      cycle_count = 0;";
    $proc_fin = "void proc_fin();";
    $private_var = "sc_core::sc_signal<bool> div_fin;\n";
    $private_var .= "    int cycle_count;";
}


{
print <<FHM_DL_INSTANCE;
#ifndef $macro
#define $macro 1

// Module     : $bit_width-bit Divider
// Feature    : 
// References : Start from scratch
// Author     : Designed by T.Morifuji (c)1996,1999
//              Modefied by K. Ueda (c)2002
// Version    : 2.0  :

// Functionality : behavioral level
//  port
//   clock   : (ignore)
//   async_reset   : (ignore)
//   reset   : (ignore)
//   clear   : (ignore)
//   a       : dividened
//   b       : divisor
//   start   : (ignore)
//   mode    : $mode_comment
//   q       : result of a / b
//   r       : reminder of a / b
//   flag    : '1' if b = 0
//   fin     : '1' when operation is over

// Comment :

#include <systemc>

namespace $name_space {
  SC_MODULE($instance_name) {
    sc_core::sc_in< bool > clock;
    sc_core::sc_in< bool > async_reset;
    sc_core::sc_in< bool > reset;
    sc_core::sc_in< bool > clear;
    sc_core::sc_in< $input_type > a, b;
    sc_core::sc_in< bool > start;
    sc_core::sc_in< bool > mode;
    sc_core::sc_out< $input_type > q, r;
    sc_core::sc_out< bool > flag;
    sc_core::sc_out< bool > fin;

    $private_var

    SC_CTOR($instance_name) :
      clock("clock"),
      async_reset("async_reset"),
      reset("reset"),
      clear("clear"),
      a("a"), b("b"),
      start("start"),
      mode("mode"),
      q("q"), r("r"),
      flag("flag"),
      fin("fin")
    {
      SC_METHOD(calc);
      $sensitive_list
    }

    void calc();
    $proc_fin
  };
};

#endif // $macro
FHM_DL_INSTANCE
}

exit (0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <design>
      <design_lang> SystemC Program </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates divider instance in behavior level
# parameter : name_space instance_name bit_width data_type

if ($#ARGV != 4){
    print "number of parameters is wrong.\n";
    print "usage : this_script name_space instance_name bit_width algorithm data_type\n";
    exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];
$algorithm     = $ARGV[3];
$data_type     = $ARGV[4];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

if ( $bit_width <= 64 ) {
    $input_type = "sc_dt::sc_uint<$bit_width>";
} else {
    $input_type = "sc_dt::sc_biguint<$bit_width>";
}

if ( $bit_width + 1 <= 64 ) {
    $tmp_input_type = "sc_dt::sc_int<" . ($bit_width + 1) . ">";
} else {
    $tmp_input_type = "sc_dt::sc_bigint<" . ($bit_width + 1) . ">";
}

$w = $bit_width - 1;

if ("$data_type" eq "two_complement"){
    $mode_comment = "\'1\' for signed multiplication\n//              '0' for unsigned multiplication";
}
else{
    $mode_comment = "(ignore)";
}


if ("$data_type" eq "two_complement") {
  $calc_read = "
  tmp_a = ((a.read()[$w] & mode.read()) , a.read());
  tmp_b = ((b.read()[$w] & mode.read()) , b.read());
  ";
} elsif("$data_type" eq "abs") {
  $calc_read = "
  if (a.read()[$w] == 1)
    tmp_a = - a.read();
  else
    tmp_a = a.read();
  if (b.read()[$w] == 1)
    tmp_b = - b.read();
  else
    tmp_b = b.read();
  ";
} elsif ("$data_type" eq "unsigned") {
  $calc_read = "
  tmp_a = a.read();
  tmp_b = b.read();
  ";
}


$calc_exec = "
  if ( tmp_b == 0 ) {
    flag.write( true );
    q.write( 0 );
    r.write( 0 );
  } else {
    flag.write( false );
    q.write( tmp_a / tmp_b );
    r.write( tmp_a % tmp_b );
  }
";


if ($algorithm ne "seq") {
  $proc_fin = "";
  $calc_body = "
    $calc_read
    $calc_exec
    fin.write( true );
  ";
} else {
  $proc_fin = "
void ${name_space}::${instance_name}::proc_fin()
{
  if(start.read()){
    fin.write(0);
  }else{
    fin.write(div_fin.read());
  }
}
  ";
  $calc_body = "
  if(async_reset.read() || reset.read() || clear.read()){
    div_fin.write(1);
    q.write(0);
    r.write(0);
    flag.write(0);
    cycle_count = 0;
  }else if(start.read()){
    div_fin.write(0);
    cycle_count = 1;
  }else if(cycle_count > 0){
    cycle_count++;
    if(cycle_count == ${bit_width} + 2){
      $calc_read
      $calc_exec

      div_fin.write(1);
      cycle_count = 0;
    }
  }
  ";
}


print <<FHM_DL_INSTANCE;
#include "${instance_name}.h"

// Module     : $bit_width-bit Divider
// Feature    : 
// References : Start from scratch
// Author     : Designed by T.Morifuji (c)1996,1999
//              Modefied by K. Ueda (c)2002
// Version    : 2.0  :

// Functionality : behavioral level
//  port
//   clock   : (ignore)
//   async_reset   : (ignore)
//   reset   : (ignore)
//   clear   : (ignore)
//   a       : dividend
//   b       : divisor
//   start   : (ignore)
//   mode    : $mode_comment
//   q       : result of a / b
//   r       : reminder of a / b
//   flag    : '1' when if b = 0
//   fin     : '1' when operation is over

// Comment :

$proc_fin

void ${name_space}::${instance_name}::calc()
{
  $tmp_input_type tmp_a, tmp_b;

  $calc_body
}
FHM_DL_INSTANCE


exit (0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <estimation>
      <estimation_data>
        <library name="OSAKA">

          <est_type name="shape">
            <est_index name="area">
              <unit> mm2 </unit>
              <translate>
                <translate_value key="gate"> 4201.68 </translate_value>
                <translate_value key="mm2">  1 </translate_value>
              </translate>

              <parameters name="unsigned">
                <max>
                  <data bit_width="4"> 0.15917487290798 </data>
                  <data bit_width="8"> 0.52657705989033 </data>
                  <data bit_width="16"> 1.66342851811656 </data>
                  <data bit_width="32"> 6.92948917909027 </data>
                  <data bit_width="60"> 40.6492536913806 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.0311440133470421 </data>
                  <data bit_width="8"> 0.128255306448849 </data>
                  <data bit_width="16"> 0.272370212867234 </data>
                  <data bit_width="32"> 0.558777779364445 </data>
                  <data bit_width="60"> 1.0497674999048 </data>
                </min>
                <typ>
                </typ>
              </parameters>

              <parameters name="abs">
                <max>
                  <data bit_width="4"> 0.15917487290798 </data>
                  <data bit_width="8"> 0.52657705989033 </data>
                  <data bit_width="16"> 1.66342851811656 </data>
                  <data bit_width="32"> 6.92948917909027 </data>
                  <data bit_width="60"> 40.6492536913806 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.0311440133470421 </data>
                  <data bit_width="8"> 0.128255306448849 </data>
                  <data bit_width="16"> 0.272370212867234 </data>
                  <data bit_width="32"> 0.558777779364445 </data>
                  <data bit_width="60"> 1.0497674999048 </data>
                </min>
                <typ>
                </typ>
              </parameters>

              <parameters name="two_complement">
                <max>
                  <data bit_width="4"> 0.15917487290798 </data>
                  <data bit_width="8"> 0.52657705989033 </data>
                  <data bit_width="16"> 1.66342851811656 </data>
                  <data bit_width="32"> 6.92948917909027 </data>
                  <data bit_width="60"> 40.6492536913806 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.0311440133470421 </data>
                  <data bit_width="8"> 0.128255306448849 </data>
                  <data bit_width="16"> 0.272370212867234 </data>
                  <data bit_width="32"> 0.558777779364445 </data>
                  <data bit_width="60"> 1.0497674999048 </data>
                </min>
                <typ>
                </typ>
              </parameters>
            </est_index>

            <est_index name="aspect_ratio">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="height">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="width">
              <!-- Dummy yet -->
            </est_index>
          </est_type>

          <est_type name="timing">
            <est_index name="delay">
              <unit> ns </unit>

              <parameters name="unsigned">
                <max>
                  <data bit_width="4"> 11.80 </data>
                  <data bit_width="8"> 39.00 </data>
                  <data bit_width="16"> 134.22 </data>
                  <data bit_width="32"> 504.67 </data>
                  <data bit_width="60"> 2648.91 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.34 </data>
                  <data bit_width="8"> 1.73 </data>
                  <data bit_width="16"> 2.12 </data>
                  <data bit_width="32"> 2.07 </data>
                  <data bit_width="60"> 2.49 </data>
                </min>
                <typ>
                </typ>
              </parameters>

              <parameters name="abs">
                <max>
                  <data bit_width="4"> 11.80 </data>
                  <data bit_width="8"> 39.00 </data>
                  <data bit_width="16"> 134.22 </data>
                  <data bit_width="32"> 504.67 </data>
                  <data bit_width="60"> 2648.91 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.34 </data>
                  <data bit_width="8"> 1.73 </data>
                  <data bit_width="16"> 2.12 </data>
                  <data bit_width="32"> 2.07 </data>
                  <data bit_width="60"> 2.49 </data>
                </min>
                <typ>
                </typ>
              </parameters>

              <parameters name="two_complement">
                <max>
                  <data bit_width="4"> 11.80 </data>
                  <data bit_width="8"> 39.00 </data>
                  <data bit_width="16"> 134.22 </data>
                  <data bit_width="32"> 504.67 </data>
                  <data bit_width="60"> 2648.91 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.34 </data>
                  <data bit_width="8"> 1.73 </data>
                  <data bit_width="16"> 2.12 </data>
                  <data bit_width="32"> 2.07 </data>
                  <data bit_width="60"> 2.49 </data>
                </min>
                <typ>
                </typ>
              </parameters>
            </est_index>

            <est_index name="delay_fullpath">
            <!-- Dummy yet -->
            </est_index>
          </est_type>

          <est_type name="power">
            <est_index name="static_power">
              <unit> mW </unit>
              <parameters name="unsigned">
                <max>
                  <data bit_width="4"> 61.6582 </data>
                  <data bit_width="8"> 237.1642 </data>
                  <data bit_width="16"> 762.7476 </data>
                  <data bit_width="32"> 3098.2 </data>
                  <data bit_width="60"> 15114.7 </data>
                </max>
                <min>
                  <data bit_width="4"> 6.9473 </data>
                  <data bit_width="8"> 12.4115 </data>
                  <data bit_width="16"> 23.1831 </data>
                  <data bit_width="32"> 47.7447 </data>
                  <data bit_width="60"> 90.3211 </data>
                </min>
                <typ>
                </typ>
              </parameters>

              <parameters name="abs">
                <max>
                  <data bit_width="4"> 61.6582 </data>
                  <data bit_width="8"> 237.1642 </data>
                  <data bit_width="16"> 762.7476 </data>
                  <data bit_width="32"> 3098.2 </data>
                  <data bit_width="60"> 15114.7 </data>
                </max>
                <min>
                  <data bit_width="4"> 6.9473 </data>
                  <data bit_width="8"> 12.4115 </data>
                  <data bit_width="16"> 23.1831 </data>
                  <data bit_width="32"> 47.7447 </data>
                  <data bit_width="60"> 90.3211 </data>
                </min>
                <typ>
                </typ>
              </parameters>

              <parameters name="two_complement">
                <max>
                  <data bit_width="4"> 61.6582 </data>
                  <data bit_width="8"> 237.1642 </data>
                  <data bit_width="16"> 762.7476 </data>
                  <data bit_width="32"> 3098.2 </data>
                  <data bit_width="60"> 15114.7 </data>
                </max>
                <min>
                  <data bit_width="4"> 6.9473 </data>
                  <data bit_width="8"> 12.4115 </data>
                  <data bit_width="16"> 23.1831 </data>
                  <data bit_width="32"> 47.7447 </data>
                  <data bit_width="60"> 90.3211 </data>
                </min>
                <typ>
                </typ>
              </parameters>
            </est_index>
          </est_type>

          <est_type name="function_cycle">
            <!-- Dummy yet -->
          </est_type>

          <est_type name="function_power">
            <!-- Dummy yet -->
          </est_type>
        </library>
      </estimation_data>

      <estimation_method>
         
        <est_type name="shape">

          <est_index name="area">

            <parameters name="abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

           <est_index name="aspect_ratio">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="height">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="width">

             <!-- Dummy yet -->

           </est_index>
		
        </est_type>

        <est_type name="timing">

          <est_index name="delay">

            <parameters name="abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

          <est_index name="delay_fullpath">

          </est_index>

        </est_type>

        <est_type name="power">

          <est_index name="static_power">

            <parameters name="abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

        </est_type>

        <est_type name="function_cycle">

        </est_type>

        <est_type name="function_power">

        </est_type>

    
      </estimation_method>

    </estimation>


  </model>

  <model>
    <design_level> synthesis </design_level>
    <version> 1.0 </version>
    <author> <![CDATA[ Kyoko UEDA ]]> </author>
    <affiliation> <![CDATA[ Osaka Univ. ]]> </affiliation>
    <model_info> <![CDATA[
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                %
%    Copyright 2008 ASIP Solutions, Inc. All rights reserved.    %
%              Copyright 2002-2005 PEAS Project                  %
%                                                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
]]> </model_info>

    <parameter>
      <parameter_value key="bit_width">
        <value> 4 </value>
        <value> 8 </value>
        <value> 12 </value>
        <value> 16 </value>
        <value> 20 </value>
        <value> 24 </value>
        <value> 28 </value>
        <value> 32 </value>
        <value> 36 </value>
        <value> 40 </value>
        <value> 44 </value>
        <value> 48 </value>
        <value> 52 </value>
        <value> 56 </value>
        <value> 60 </value>
        <value> 64 </value>
        <value> 128 </value>
      </parameter_value>
      <parameter_value key="algorithm">
        <value> seq </value>
        <value> array </value>
      </parameter_value>
      <parameter_value key="adder_algorithm">
        <value> default </value>
      </parameter_value>
      <parameter_value key="data_type">
        <value> unsigned </value>
        <value> abs </value>
        <value> two_complement </value>
      </parameter_value>
    </parameter>

    <function_description>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates function definition for divider in synthesis level
# parameter : bit_width algorithm adder_algorithm data_type

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$algorithm = $ARGV[1];
$add_algo  = $ARGV[2];
$data_type = $ARGV[3];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$algorithm" eq "seq"){
    $cycle = "multi";
}
elsif ("$algorithm" eq "array"){
    $cycle = "single";
}
else{
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$add_algo" ne "default"){
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;

if ("$data_type" eq "two_complement"){
    print <<FHM_DL_TWOCOMP_BASIC_FUNC
twoscomp div(twoscomp a, towscomp b);
unsigned div(unsigned a, unsigned b);
twoscomp mod(twoscomp a, towscomp b);
unsigned mod(unsigned a, unsigned b);
Boolean  flag_div(twoscomp a, towscomp b);
Boolean  flag_div(unsigned a, unsigned b);
FHM_DL_TWOCOMP_BASIC_FUNC
}
elsif ("$data_type" eq "abs"){
    print <<FHM_DL_ABS_BASIC_FUNC
signmagn div(signmagn a, signmagn b);
signmagn mod(signmagn a, signmagn b);
Boolean  flag_div(signmagn a, signmagn b);
FHM_DL_ABS_BASIC_FUNC
}
elsif ("$data_type" eq "unsigned"){
    print <<FHM_DL_UN_BASIC_FUNC
unsigned div(unsigned a, unsigned b);
unsigned mod(unsigned a, unsigned b);
Boolean  flag_div(unsigned a, unsigned b);
FHM_DL_UN_BASIC_FUNC
}

{
    print <<FHM_DL_FUNC;
/** $bit_width-bit $data_type $cycle cycle $algorithm divider : use $add_algo adder algorithm */
model ${algorithm}_${data_type}_div${bit_width}{
  port{
    clock clock;
    in async_reset, reset, clear, start;
    in a[$w_1:0], b[$w_1:0];
    in mode;
    out q[$w_1:0], r[$w_1:0], flag;
    out fin;
  }
FHM_DL_FUNC
}
if ($cycle eq "multi"){
    print <<FHM_DL_FUNC;
  default_control{
    reset = 0;
    clear = 0;
    start = 0;
  }

  /** no operation */
  function nop : idle{
    control{
      in start, reset, clear;
    }
    protocol{
      [start == 0 && reset == 0 && clear == 0]{
      }
    }
  }

  /** reset */
  function reset : reset{
    control{
      in reset;
    }
    protocol{
      [reset == 1 || clear == 1]{
      }
    }
  }

FHM_DL_FUNC
}
else{
    print <<FHM_DL_FUNC;
  /** reset : no action for single cycle model */
  function reset : reset{
  }

FHM_DL_FUNC
}


if ("$algorithm" eq "seq"){
    $multi = 1;
}
elsif ("$algorithm" eq "array"){
    $multi = 0;
}

if ("$data_type" eq "two_complement"){
    &print_func("signed division", "div", "twoscomp", 1, 1);
    &print_func("unsigned division", "divu", "unsigned", 1, 0);
    print <<FHM_DL_TWOCOMP_END
  priority{ reset > ( div | divu ) }
}
FHM_DL_TWOCOMP_END
}
elsif ("$data_type" eq "abs"){
    &print_func("abs division", "diva", "signmagn", 0);
    print <<FHM_DL_ABS_END
  priority{ reset > diva }
}
FHM_DL_ABS_END
}
elsif ("$data_type" eq "unsigned"){
    &print_func("unsigned division", "divu", "unsigned", 0);
    print <<FHM_DL_UN_END
  priority{ reset > divu }
}
FHM_DL_UN_END
}
exit (0);

# ---------------------------------

sub print_func{
    $comment   = $_[0];
    $func_name = $_[1];
    $d_type    = $_[2];
    $mode      = $_[3];
    $mode_val  = $_[4];

    {
	print <<FHM_DL_SUB_FUNC1
  /** $comment */
  function ${func_name}{
    input{
      $d_type a, b;
    }
    output{
      $d_type q = div(a, b);
      $d_type r = mod(a, b);
      Boolean flag = flag_div(a, b);
    }
FHM_DL_SUB_FUNC1
    }
    if ($multi == 1){
	{
	    print <<FHM_DL_SUB_SEQ1
    invariant{
      fin == 0;
    }
    control{
FHM_DL_SUB_SEQ1
        }
	if ($mode == 1){
	    print <<FHM_DL_SUB_SEQ2
      in start, clear, mode;
      out fin;
    }
    protocol{
      repeat [start == 1 && mode = 1 && hold a, b]
	until (fin == 1);

      while [start == 1]{
	fin = 1;
	valid q, r, flag;
      }
    }
  }

FHM_DL_SUB_SEQ2
	}
	else{
	    print <<FHM_DL_SUB_SEQ3
      in start, clear;
      out fin;
    }
    protocol{
      repeat [start == 1 && hold a, b]
	until (fin == 1);

      while [start == 1]{
	fin = 1;
	valid q, r, flag;
      }
    }
  }

FHM_DL_SUB_SEQ3
        }
    }
    else{
        if ($mode == 1){
	    print <<FHM_DL_SUB_AARAY1
    control{
      in mode;
      out fin;
    }
    protocol{
      [mode == $mode_val]{
	valid q, r, flag;
	fin = 1;
      }
    }
  }

FHM_DL_SUB_AARAY1
        }
	else{
	    print <<FHM_DL_SUB_ARRAY2
    control{
      out fin;
    }
    protocol{
      [true]{
	valid q, r, flag;
	fin = 1;
      }
    }
  }

FHM_DL_SUB_ARRAY2
        }
    }
}
exit(0);
        ]]>
      </script>
    </function_description>

    <function_conv>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates AUTOGEN description for divider in synthesis level
# parameter : bit_width algorithm adder_algorithm data_type

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$algorithm = $ARGV[1];
$add_algo  = $ARGV[2];
$data_type = $ARGV[3];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$algorithm" ne "seq" && "$algorithm" ne "array"){
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$add_algo" ne "default"){
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

{
print <<FHM_DL_NOP_RESET
/** no operation */
function nop{
  input{
  }

  output{
  }

  control{
    in bit start;
    in bit reset;
    in bit clear;
  }

  protocol{
    single_cycle_protocol{
      start = '0';
      reset = '0';
      clear = '0';
    }
  }
}

/** reset */
function reset{
  input{
  }

  output{
  }

  control{
    in bit reset;
  }

  protocol{
    single_cycle_protocol{
      reset = '1';
    }
  }
}

FHM_DL_NOP_RESET
}

if ("$algorithm" eq "seq"){
    $multi = 1;
}
elsif ("$algorithm" eq "array"){
    $multi = 0;
}

$w_1 = $bit_width - 1;

if ("$data_type" eq "two_complement"){
    &print_func("signed division", "div", 1, 1);
    &print_func("unsigned division", "divu", 1, 0);
}
elsif ("$data_type" eq "abs"){
    &print_func("abs division", "diva", 0);
}
elsif ("$data_type" eq "unsigned"){
    &print_func("unsigned division", "divu", 0);
}
exit (0);

# ---------------------------------

sub print_func{
  $comment   = $_[0];
  $func_name = $_[1];
  $mode      = $_[2];
  $mode_val  = $_[3];

  {
    print <<FHM_DL_FUNC1
/** $comment */
function ${func_name}{
  input{
    bit [$w_1:0] a;
    bit [$w_1:0] b;
  }

  output{
    bit [$w_1:0] q;
    bit [$w_1:0] r;
    bit flag;
  }

  control{
FHM_DL_FUNC1
  }

  if ($mode == 1){
    print "    in  bit mode;\n";
  }

  if ($multi == 1){
  print <<FHM_DL_MULTI1
    in  bit start;
    in  bit clear;
    out bit fin;
FHM_DL_MULTI1
}

{
  print <<FHM_DL_FUNC2
  }

  protocol{
FHM_DL_FUNC2
  }

  if ($multi == 1){
    {
      print <<FHM_DL_MULTI2
    multi_cycle_protocol{
      start_signal  start = '1';
      fin_signal    fin   = '1';
      cancel_signal clear = '1';
FHM_DL_MULTI2
    }
    if ($mode == 1){
      print "\n";
    }
  }
  else{
      if ($mode == 1){
	  print "    single_cycle_protocol{\n";
      }
  }

  if ($mode == 1){
      print "      mode = '$mode_val';\n";
  }

  if ($mode == 1 || $multi == 1){
      print "    }\n";
  }

  print <<FHM_DL_FUNC4
  }
}

FHM_DL_FUNC4
}
        ]]>
      </script>
    </function_conv>

    <function_port>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generate port infomation for divider in synthesis level
# parameter : bit_width algorithm adder_algorithm data_type

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$bit_width     = $ARGV[0];
$algorithm     = $ARGV[1];
$add_algo      = $ARGV[2];
$data_type     = $ARGV[3];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$algorithm" ne "seq" && "$algorithm" ne "array"){
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$add_algo" ne "default"){
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;
{
print <<FHM_DL_PORT
clock	in	bit		clock
async_reset	in	bit		reset
reset	in	bit		ctrl
clear	in	bit		ctrl
a	in	bit_vector   $w_1   0	data
b	in	bit_vector   $w_1   0	data
start	in	bit		ctrl
mode	in	bit		mode
q	out	bit_vector   $w_1   0	data
r	out	bit_vector   $w_1   0	data
flag	out	bit		data
fin	out	bit		ctrl
FHM_DL_PORT
}
exit (0);

        ]]>
      </script>
    </function_port>

    <design>
      <design_lang> vhdl </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates instance for divider in synthesis level
# parameter : instance_name bit_width algorithm adder_algorithm data_type

if ($#ARGV != 4){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$algorithm     = $ARGV[2];
$add_algo      = $ARGV[3];
$data_type     = $ARGV[4];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;
$w_2 = $bit_width - 2;

$zeros = 0 x $bit_width;
$zeros_1 = 0 x $w_1;

if ("$algorithm" ne "seq" && "$algorithm" ne "array"){
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$add_algo" ne "default"){
    print "add_algorithm $add_algo is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

# adder generation

$instance_name_add = $instance_name."_add$bit_width";
if ("$add_algo" eq "default"){
print <<FHM_DL_INSTANCE
-- Module     : $bit_width-bit unsigned adder
-- References :
-- Author     : Designed by T.Morifuji (c)1996.
-- Version    : 1.0

-- Functionality : behavior level
--  port
--   a, b   : add datas
--   cin    : carry in
--   result : result of a + b + c
--   cout   : '1' when result > 2^$bit_width-1

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity $instance_name_add is
  port (a, b   : in std_logic_vector($w_1 downto 0);
        cin    : in std_logic;
        result : out std_logic_vector($w_1 downto 0);
        cout   : out std_logic);
end $instance_name_add;

architecture synthesis of $instance_name_add is

begin  -- behavior

  addition: process (a, b, cin)
    variable int_a, int_b : std_logic_vector($bit_width downto 0);
    variable int_result   : std_logic_vector($bit_width downto 0);
  begin
    int_a      := '0' & a;
    int_b      := '0' & b;

    int_result := int_a + int_b + cin;

    result     <= int_result($w_1 downto 0);
    cout       <= int_result($bit_width);

  end process addition;

end synthesis;

FHM_DL_INSTANCE
}
else{
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

print "\n--%%\n\n";

# unsigned divider generation
if ("$algorithm" eq "seq") {
# sdiv generation

# register generation
# This script generates register instance in synthesis level

    $instance_name = $ARGV[0];
    $bit_width     = $ARGV[1];

    {
	print <<FHM_DL_SEQ_COMPS
-- Module     : $bit_width-bit positive edge trigger register
-- References :
-- Author     : Designed by T.Morifuji (c)1997.
-- Version    : 1.0  :

-- Functionality : synthesis level
--  port
--   clock    : clock
--   async_reset    : asynchronous reset
--   reset    : synchronous reset
--   enb      : '1' then register data
--   data_in  : data to register
--   data_out : registered data

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_reg$bit_width is
  port (clock    : in  std_logic;
        async_reset    : in  std_logic;
        reset    : in  std_logic;
        enb      : in  std_logic;
        data_in  : in  std_logic_vector($w_1 downto 0);
        data_out : out std_logic_vector($w_1 downto 0) );
end ${instance_name}_reg$bit_width;

architecture synthesis of ${instance_name}_reg$bit_width is
begin

  process (clock, async_reset)
  begin
    if (async_reset = '1') then
      data_out <= (others => '0');
    elsif (clock'event and clock = '1') then
      if (reset = '1') then
        data_out <= (others => '0');
      elsif (enb = '1') then
        data_out <= data_in;
      end if;
    end if;
  end process;

end synthesis;

--%%

-- Module     : 1-bit positive edge trigger register
-- References :
-- Author     : Designed by T.Morifuji (c)1997.
-- Version    : 1.0  :

-- Functionality : synthesis level
--  port
--   clock    : clock
--   async_reset    : asynchronous reset
--   reset    : synchronous reset
--   enb      : '1' then register data
--   data_in  : data to register
--   data_out : registered data

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_reg1 is
  port (clock    : in std_logic;
        async_reset    : in std_logic;
        reset    : in std_logic;
        enb      : in std_logic;
        data_in  : in std_logic;
        data_out : out std_logic );
end ${instance_name}_reg1;

architecture synthesis of ${instance_name}_reg1 is
begin

  process (clock, async_reset)
  begin
    if (async_reset = '1') then
      data_out <= '0';
    elsif (clock'event and clock = '1') then
      if (reset = '1') then
        data_out <= '0';
      elsif (enb = '1') then
        data_out <= data_in;
      end if;
    end if;
  end process;

end synthesis;

--%%

-- Module     : $bit_width-bit shift register for divider
-- References :
-- Author     : Designed by T.Morifuji (c)1996,1997.
--              Modified by K.Ueda (c)2002.
-- Version    : 1.0
--            : 2.0  : change algorithm

-- Functionality :
--  port
--   clock  : clock
--   async_reset  : asynchronous reset
--   reset  : synchronous reset
--   ld     : load datas when '1'
--   mode   : mode of register
--            "00" : no operation (ignore ld)
--            "01" : initialize register
--            "11" : validate ld and shift data
--   ain    : represent quotient
--   pin    : represent reminder
--   cin    : represent 1-bit of reminder
--   aout   : output of ain
--   pout   : output of pin
--   cout   : output of cin

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_lsftreg$bit_width is
  port (clock, reset : in  std_logic;
        async_reset  : in  std_logic;
        ld           : in  std_logic;
        mode         : in  std_logic_vector(1 downto 0);
        ain, pin     : in  std_logic_vector($w_1 downto 0);
        cin          : in  std_logic;
        aout, pout   : out std_logic_vector($w_1 downto 0);
        cout         : out std_logic );
end ${instance_name}_lsftreg$bit_width;

architecture synthesis of ${instance_name}_lsftreg$bit_width is

  component ${instance_name}_reg$bit_width
    port (
      clock    : in  std_logic;
      async_reset    : in  std_logic;
      reset    : in  std_logic;
      enb      : in  std_logic;
      data_in  : in  std_logic_vector($w_1 downto 0);
      data_out : out std_logic_vector($w_1 downto 0));
  end component;

  component ${instance_name}_reg1
    port (
      clock    : in  std_logic;
      async_reset    : in  std_logic;
      reset    : in  std_logic;
      enb      : in  std_logic;
      data_in  : in  std_logic;
      data_out : out std_logic );
  end component;

  signal pin_tmp, pout_tmp : std_logic_vector($w_1 downto 0);
  signal ain_tmp, aout_tmp : std_logic_vector($w_1 downto 0);
  signal cout_in_tmp, cout_tmp : std_logic;
  signal one : std_logic;

begin

  one <= '1';
  
  pout <= pout_tmp;
  aout <= aout_tmp;
  cout <= cout_tmp;

  pin_tmp <= "$zeros_1" & ain($w_1)
               when mode = "01" else
             pin($w_2 downto 0) & aout_tmp($w_1)
               when (mode = "11" and ld = '1') else
             pout_tmp($w_2 downto 0) & aout_tmp($w_1)
               when (mode = "11" and ld = '0') else
             pout_tmp;

  ain_tmp <= ain($w_2 downto 0) & '0'
               when mode = "01" else
             aout_tmp($w_2 downto 0) & cin
               when mode = "11" else
             aout_tmp;

  cout_in_tmp <= '0'
               when mode = "01" else
             pin($w_1)
               when (mode = "11" and ld = '1') else
             pout_tmp($w_1)
               when (mode = "11" and ld = '0') else
             cout_tmp;

  pout_reg : ${instance_name}_reg$bit_width
    port map (
      clock    => clock,
      async_reset    => async_reset,
      reset    => reset,
      enb      => one,
      data_in  => pin_tmp,
      data_out => pout_tmp);

  aout_reg : ${instance_name}_reg$bit_width
    port map (
      clock    => clock,
      async_reset    => async_reset,
      reset    => reset,
      enb      => one,
      data_in  => ain_tmp,
      data_out => aout_tmp);

  cout_reg : ${instance_name}_reg1
    port map (
      clock    => clock,
      async_reset    => async_reset,
      reset    => reset,
      enb      => one,
      data_in  => cout_in_tmp,
      data_out => cout_tmp);

end synthesis;

--%%

FHM_DL_SEQ_COMPS
    }
    {
	print <<FHM_DL_SDIV_TOP
-- Module     : Basic $bit_width-bit sequential unsigned divider
-- References :
-- Author     : Designed by T.Morifuji (c)1996,1997,1999.
--              Modified by K.Ueda (c)2002
-- Version    : 1.1
--              2.0 : change algorithm

-- Functionality :
--  port
--   clock  : clock
--   async_reset  : asynchronous reset
--   reset  : synchronous reset
--   clear  : cancel division
--   a      : dividend
--   b      : divisor
--   start  : '1' then start division
--   q      : result of a / b
--   r      : reminder of a / b
--   flag   : '1' when b = 0
--   fin    : '1' when operation is over

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;
  
entity ${instance_name}_sdiv$bit_width is
  port (clock : in std_logic;
        async_reset : in std_logic;
        reset : in std_logic;
        clear : in std_logic;
        a, b  : in std_logic_vector($w_1 downto 0);
        start : in std_logic;
        q, r  : out std_logic_vector($w_1 downto 0);
        flag  : out std_logic;
        fin   : out std_logic);
end ${instance_name}_sdiv$bit_width;

architecture synthesis of ${instance_name}_sdiv$bit_width is

  component ${instance_name}_lsftreg$bit_width
    port (clock, reset : in  std_logic;
          async_reset  : in  std_logic;
          ld           : in  std_logic;
          mode         : in  std_logic_vector(1 downto 0);
          ain, pin     : in  std_logic_vector($w_1 downto 0);
          cin          : in  std_logic;
          aout, pout   : out std_logic_vector($w_1 downto 0);
          cout         : out std_logic );
  end component;

  component ${instance_name_add}
    port (a, b   : in std_logic_vector($w_1 downto 0);
          cin    : in std_logic;
          result : out std_logic_vector($w_1 downto 0);
          cout   : out std_logic );
  end component;

  component ${instance_name}_reg$bit_width
    port (clock    : in std_logic;
          async_reset    : in std_logic;
          reset    : in std_logic;
          enb      : in std_logic;
          data_in  : in std_logic_vector($w_1 downto 0);
          data_out : out std_logic_vector($w_1 downto 0) );
  end component;

FHM_DL_SDIV_TOP
    }

    print "  type state is (st0, ";

    $i = 1;

    while ($i <= $bit_width) {
	print "st$i, ";
	$j = $i % 7;
	if ($j == 0) {
	    print  "\n";
	    print  "                 ";
	}
	$i= $i + 1;
    }

    $i= $bit_width + 1;
    print "st$i, stend);\n";
    {
	print <<FHM_DL_SDIV_CENTER
  --
  -- signals declaration
  --
  signal sft_mode       : std_logic_vector(1 downto 0);
  signal from_latch_out : std_logic_vector($w_1 downto 0);
  signal from_sft_aout  : std_logic_vector($w_1 downto 0);
  signal from_sft_pout  : std_logic_vector($w_1 downto 0);
  signal from_sft_cout  : std_logic;
  signal from_adder     : std_logic_vector($w_1 downto 0);
  signal add_cout       : std_logic;
  signal to_sft_ain     : std_logic_vector($w_1 downto 0);
  signal to_reg_in      : std_logic_vector($w_1 downto 0);
  signal one            : std_logic;
  signal current_state : state;
  signal next_state    : state;

begin  --  synthesis 

  one <= '1';

  q <= from_sft_aout($w_1 downto 0);
  r <= from_sft_cout & from_sft_pout($w_1 downto 1);

  flag <= '1' when b = "$zeros" else
          '0';

  to_reg_in <= not b;
  to_sft_ain <= a;
 
  process (current_state, start, clear)
  begin
    case current_state is
      when st0 =>
        if (start = '1' and clear = '0') then
          next_state <= st1;
        else
          next_state <= st0;
        end if;
        sft_mode <= "00";
        fin        <= '1' and not start;
      when st1 =>
        if (clear = '1') then
          next_state <= st0;
        else
          next_state <= st2;
        end if;
        sft_mode <= "01";
        fin        <= '0';
FHM_DL_SDIV_CENTER
    }
    $i=2;

    while ($i < $bit_width + 1) {
	print  "      when st$i =>\n";
	$i++;
	print <<FHM_DL_STATE
        if (clear = '1') then
          next_state <= st0;
        else
          next_state <= st$i;
        end if;
        sft_mode <= "11";
        fin        <= '0';
FHM_DL_STATE
    }

    print "      when st$i =>\n";
    {
	print <<FHM_DL_SDIV_BOTTOM
        if (clear = '1') then
          next_state <= st0;
        else
          next_state <= stend;
        end if;
        sft_mode <= "11";
        fin        <= '0';
      when stend =>
        next_state <= st0;
        sft_mode <= "00";
        fin        <= '1';
    end case;
  end process;

  process (clock, async_reset)
  begin
    if (async_reset = '1') then
      current_state <= st0;
    elsif (clock'event and clock = '1') then
      if (reset = '1') then
        current_state <= st0;
      else
        current_state <= next_state;
      end if;
    end if;
  end process;  

  lsftreg0 : ${instance_name}_lsftreg$bit_width

  port map (
    clock => clock,
    async_reset => async_reset,
    reset => reset,
    ld    => add_cout,
    mode  => sft_mode,
    ain   => to_sft_ain,
    pin   => from_adder,
    cin   => add_cout,
    aout  => from_sft_aout,
    pout  => from_sft_pout,
    cout  => from_sft_cout);
  
  add0 : ${instance_name}_add$bit_width
    port map (
      a      => from_sft_pout,
      b      => from_latch_out,
      cin    => one,
      result => from_adder,
      cout   => add_cout);

  reg0 : ${instance_name}_reg$bit_width
    port map (
      clock    => clock,
      async_reset    => async_reset,
      reset    => reset,
      enb      => start,
      data_in  => to_reg_in,
      data_out => from_latch_out);

end synthesis;
FHM_DL_SDIV_BOTTOM
    }
}
elsif ("$algorithm" eq "array") {
    print <<FHM_DL_ADIV
-- Module     : Basic $bit_width-bit array unsigned divider
-- References :
-- Author     : Designed by T.Morifuji (c)1996,1997.
-- Version    : 1.0  :

-- Functionality :
--  port
--   a      : dividend
--   b      : divisor
--   q      : result of a / b
--   r      : reminder of a / b
--   flag   : '1' when b = 0

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;
  use IEEE.std_logic_arith.all;

entity ${instance_name}_adiv$bit_width is
  port (a, b : in std_logic_vector($w_1 downto 0);
        q, r : out std_logic_vector($w_1 downto 0);
        flag : out std_logic );
end ${instance_name}_adiv$bit_width;

architecture synthesis of ${instance_name}_adiv$bit_width is

  -- component declaration
  -- adder
  component ${instance_name}_add$bit_width
    port (a, b   : in std_logic_vector($w_1 downto 0);
          cin    : in std_logic;
          result : out std_logic_vector($w_1 downto 0);
          cout   : out std_logic);
  end component;

  --  type definition
  type vectors is array (Natural range <>) of std_logic_vector($w_1 downto 0);

  --  signal declaration
  signal qout   : std_logic_vector($w_1 downto 0);
  signal conv_b	: std_logic_vector($w_1 downto 0);
  signal add_a	: vectors($w_1 downto 0);
  signal s	: vectors($w_1 downto 0);
  signal c	: std_logic_vector($w_1 downto 0);
  signal subr	: vectors(0 to $w_2);

  signal one	: std_logic;

begin  -- synthesis

  one <= '1';

  -- zero flag
  flag <= '1' when b = "$zeros" else
          '0';

  conv_b <= not b;
 
  a_connect : for i in 0 to $w_1 generate
    add_a0 : if (i = 0) generate
      input_0 : for j in $w_1 downto 1 generate
        add_a(i)(j) <= '0';
      end generate input_0;
        add_a(i)(0) <= a($w_1);

    end generate add_a0;
    
    add_as : if (0 < i and i < $w_1) generate
      input_0 : for j in $w_1 downto i+1 generate
        add_a(i)(j) <= '0';
      end generate input_0;
        add_a(i)(i downto 0) <= subr(i-1)(i-1 downto 0) & a($w_1-i);
    end generate add_as;

    add_aend : if (i = $w_1) generate
      add_a(i) <= subr($w_2)($w_2 downto 0) & a(0);
    end generate add_aend;
  end generate a_connect;

  sub_r : for i in 0 to $w_2 generate
    subs : for j in i downto 0 generate
      front : if (j /= 0) generate
	subr(i)(j) <=    (s(i)(j) and c(i))
                      or ((not c(i)) and subr(i-1)(j-1));
	
      end generate front;

      last : if (j = 0) generate
	subr(i)(j) <=    (s(i)(j) and c(i))
                     or ((not c(i)) and a($w_1-i));
      end generate last;
    end generate subs;
  end generate sub_r;

  rems : for j in $w_1 downto 0 generate
    rfront : if (j /= 0) generate
      r(j) <=    (s($w_1)(j) and c($w_1)) 
              or ((not c($w_1)) and subr($w_2)(j-1));
    end generate rfront;

    rlast : if (j = 0) generate
      r(j) <=    (s($w_1)(j) and c($w_1))
              or ((not c($w_1)) and a(0));
    end generate rlast;
  end generate rems;

  qui : for i in $w_1 downto 0 generate
    q(i) <= c($w_1-i);
  end generate qui;

  -- port mapping: adder
  add_connect : for i in 0 to $w_1 generate
   adds : ${instance_name}_add$bit_width
      port map (
        a      => add_a(i),
        b      => conv_b,
        cin    => one,
        result => s(i),
        cout   => c(i));
  end generate add_connect;

end synthesis;

FHM_DL_ADIV
}
print "\n--%%\n\n";

if ("$data_type" eq "two_complement" || "$data_type" eq "abs") {
    print <<FHM_DL_TCONV
-- Module     : $bit_width-bit 2's complement converter
-- References :
-- Author     : Designed by T.Morifuji (c)1996.
-- Version    : 1.0  :

-- Functionality :
--  port
--   data_in  : data for convert
--   conv     : '1' then convert data
--   data_out : converted data

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_tconv$bit_width is
  port (data_in  : in  std_logic_vector($w_1 downto 0);
        conv     : in std_logic;
        data_out : out std_logic_vector($w_1 downto 0));
end ${instance_name}_tconv$bit_width;

architecture synthesis of ${instance_name}_tconv$bit_width is

  -- adder
  component ${instance_name}_add$bit_width
    port (a, b   : in std_logic_vector($w_1 downto 0);
          cin    : in std_logic;
          result : out std_logic_vector($w_1 downto 0);
          cout   : out std_logic);
  end component;

  signal not_data_in  : std_logic_vector($w_1 downto 0);
  signal zero         : std_logic_vector($w_1 downto 0);
  signal tmp_data_out : std_logic_vector($w_1 downto 0);
  signal tmp_cout     : std_logic;

begin

  not_data_in <= not data_in;
  zero <= (others => '0');

  two_conv : ${instance_name}_add$bit_width
    port map (
      a      => not_data_in,
      b      => zero,
      cin    => conv,
      result => tmp_data_out,
      cout   => tmp_cout);
  
  data_out <= data_in when conv = '0' else
              tmp_data_out;

end synthesis;

--%%

FHM_DL_TCONV
}
if ("$algorithm" eq "seq"){
    $clock = "clock";
    $a_reset = "asynchronous reset";
    $reset = "synchronous reset";
    $clear = "cancel division";
    $start = "\'1\' then start division";
    $fin   = "\'1\' when operation is over";
}
elsif ("$algorithm" eq "array"){
    $clock = "(ignore)";
    $a_reset = "(ignore)";
    $reset = "(ignore)";
    $clear = "(ignore)";
    $start = "(ignore)";
    $fin   = "(ignore)";
}
if ("$data_type" eq "two_complment"){
    $mode = "\'1\' for signed division\n--              '0' for unsigned division";
}
elsif ("$data_type" eq "abs" || "$data_type" eq "unsigned"){
    $mode = "(ignore)";
}
{    
    print <<FHM_DL_DIV_TOP
-- Module     : $bit_width-bit $algorithm $data_type divider
--              using $add_algo for adder algorithm
-- References :
-- Author     : Designed by T.Morifuji (c)1996,1997,1999
--              Modified by T.Yoshimura (c)2004
-- Version    : 1.1  :
--              1.2  : Bug fixed

-- Functionality :
--  port
--   clock : $clock
--   async_reset : $a_reset
--   reset : $reset
--   clear : $clear
--   a     : dividend
--   b     : divisor
--   start : $start
--   mode  : $mode
--   q     : result of a / b
--   r     : reminder of a / b
--   flag  : '1' if b = 0
--   fin   : $fin

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity $instance_name is
  port (clock    : in std_logic;
	async_reset    : in std_logic;
	reset    : in std_logic;
        clear    : in std_logic;
        a, b     : in std_logic_vector($w_1 downto 0);
        start    : in std_logic;
        mode     : in std_logic;
        q        : out std_logic_vector($w_1 downto 0);
        r        : out std_logic_vector($w_1 downto 0);
        flag     : out std_logic;
        fin      : out std_logic );
end $instance_name;

architecture synthesis of $instance_name is
FHM_DL_DIV_TOP
}
if ("$algorithm" eq "seq") {
    print <<FHM_DL_COMP_SDIV
  component ${instance_name}_sdiv$bit_width
    port (clock : in std_logic;
	  async_reset : in std_logic;
	  reset : in std_logic;
          clear : in std_logic;
          a, b  : in std_logic_vector($w_1 downto 0);
          start : in std_logic;
          q, r  : out std_logic_vector($w_1 downto 0);
          flag  : out std_logic;
          fin   : out std_logic);
  end component;

FHM_DL_COMP_SDIV
}
elsif ("$algorithm" eq "array") {
    print <<FHM_DL_COMP_ADIV
  component ${instance_name}_adiv$bit_width
    port (a, b : in std_logic_vector($w_1 downto 0);
          q, r : out std_logic_vector($w_1 downto 0);
          flag : out std_logic);
  end component;

FHM_DL_COMP_ADIV
}

if ("$data_type" eq "unsigned") {
    print "begin\n";
    print "\n";

    if ("$algorithm" eq "seq") {
        print <<FHM_DL_UN_SEQ_COMP
  sdiv0 : ${instance_name}_sdiv$bit_width
    port map (
      clock => clock,
      async_reset => async_reset,
      reset => reset,
      clear => clear,
      a     => a,
      b     => b,
      start => start,
      q     => q,
      r     => r,
      flag  => flag,
      fin   => fin);
        
FHM_DL_UN_SEQ_COMP
    }
    elsif ("$algorithm" eq "array") {
        print <<FHM_DL_UN_ARRAY_COMP
  fin <= '1';

  adiv0 : ${instance_name}_adiv$bit_width
    port map (
      a    => a,
      b    => b,
      q    => q,
      r    => r,
      flag => flag);
  
FHM_DL_UN_ARRAY_COMP
    }
    print "end synthesis;\n";
}
elsif ("$data_type" eq "two_complement") {
    $mode = "mode";
    {
	print <<FHM_DL_TWOCOMP_TOP1
  component ${instance_name}_tconv$bit_width
    port (data_in  : in std_logic_vector($w_1 downto 0);
          conv     : in std_logic;
          data_out : out std_logic_vector($w_1 downto 0));
  end component;

FHM_DL_TWOCOMP_TOP1
    }
    if ("$algorithm" eq "seq"){
	$mode = "tmp_mode";
	print <<FHM_DL_SEQ_REG
  component ${instance_name}_reg1
    port (
      clock    : in  std_logic;
      async_reset    : in  std_logic;
      reset    : in  std_logic;
      enb      : in  std_logic;
      data_in  : in  std_logic;
      data_out : out std_logic);
  end component;

  signal tmp_mode : std_logic;

FHM_DL_SEQ_REG
    }
    {
	print <<FHM_DL_TWOCOMP_TOP2
  signal conved_a : std_logic_vector($w_1 downto 0);
  signal conved_b : std_logic_vector($w_1 downto 0);
  signal conved_q : std_logic_vector($w_1 downto 0);
  signal conved_r : std_logic_vector($w_1 downto 0);

  signal tmp_a    : std_logic_vector($w_1 downto 0);
  signal tmp_b    : std_logic_vector($w_1 downto 0);
  signal tmp_q    : std_logic_vector($w_1 downto 0);
  signal tmp_r    : std_logic_vector($w_1 downto 0);
  signal q_tconv_conv, r_tconv_conv : std_logic;

begin

  q_tconv_conv <= a($w_1) xor b($w_1);
  r_tconv_conv <= a($w_1);

  conv_a : ${instance_name}_tconv$bit_width
    port map (
      data_in  => a,
      conv     => a($w_1),
      data_out => conved_a);

  conv_b : ${instance_name}_tconv$bit_width
    port map (
      data_in  => b,
      conv     => b($w_1),
      data_out => conved_b);

  tmp_a <= a when mode = '0' else
           conved_a;

  tmp_b <= b when mode = '0' else
           conved_b;
FHM_DL_TWOCOMP_TOP2
    }
    if ("$algorithm" eq "seq") {
	print <<FHM_DL_TWOCOMP_SEQ
  divu : ${instance_name}_sdiv$bit_width
    port map (
      clock => clock,
      async_reset => async_reset,
      reset => reset,
      clear => clear,
      a     => tmp_a,
      b     => tmp_b,
      start => start,
      q     => tmp_q,
      r     => tmp_r,
      flag  => flag,
      fin   => fin);

  reg_mode : ${instance_name}_reg1
    port map (
      clock    => clock,
      async_reset    => async_reset,
      reset    => reset,
      enb      => start,
      data_in  => mode,
      data_out => tmp_mode);

FHM_DL_TWOCOMP_SEQ
    }
    elsif ("$algorithm" eq "array") {
	print <<FHM_DL_TWOCOMP_ARRAY
  fin <= '1';

  divu : ${instance_name}_adiv$bit_width
    port map (
      a    => tmp_a,
      b    => tmp_b,
      q    => tmp_q,
      r    => tmp_r,
      flag => flag);

FHM_DL_TWOCOMP_ARRAY
    }
    print <<FHM_DL_TWOCOMP_BOTTOM
  conv_q : ${instance_name}_tconv$bit_width
    port map (
      data_in  => tmp_q,
      conv     => q_tconv_conv,
      data_out => conved_q);

  conv_r : ${instance_name}_tconv$bit_width
    port map (
      data_in  => tmp_r,
      conv     => r_tconv_conv,
      data_out => conved_r);

  q <= tmp_q when $mode = '0' else
             conved_q;
  r <= tmp_r when $mode = '0' else
             conved_r;

end synthesis;
FHM_DL_TWOCOMP_BOTTOM
}
elsif ("$data_type" eq "abs") {
    {
	print <<FHM_DL_ABS_TOP
  component ${instance_name}_tconv$bit_width
    port (data_in  : in std_logic_vector($w_1 downto 0);
          conv     : in std_logic;
          data_out : out std_logic_vector($w_1 downto 0));
  end component;

  signal conved_a      : std_logic_vector($w_1 downto 0);
  signal conved_b      : std_logic_vector($w_1 downto 0);

begin

  conv_a : ${instance_name}_tconv$bit_width
    port map (
      data_in  => a,
      conv     => a($w_1),
      data_out => conved_a);

  conv_b : ${instance_name}_tconv$bit_width
    port map (
      data_in  => b,
      conv     => b($w_1),
      data_out => conved_b);

FHM_DL_ABS_TOP
    }
    if ("$algorithm" eq "seq") {
	print <<FHM_DL_ABS_SEQ
  divu : ${instance_name}_sdiv$bit_width
    port map (
      clock => clock,
      async_reset => async_reset,
      reset => reset,
      clear => clear,
      a     => conved_a,
      b     => conved_b,
      start => start,
      q     => q,
      r     => r,
      flag  => flag,
      fin   => fin);

FHM_DL_ABS_SEQ
    }
    elsif ("$algorithm" eq "array") {
	print <<FHM_DL_ABS_ARRAY
  fin <= '1';

  divu : ${instance_name}_adiv$bit_width
    port map (
      a    => conved_a,
      b    => conved_b,
      q    => q,
      r    => r,
      flag => flag);

FHM_DL_ABS_ARRAY
    }
    print "end synthesis;\n";
    exit (0);
}

          ]]>
        </script>
      </instance>

      <entity></entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>

      <synthesis>
        <parameter></parameter>
        <synthesis_script>
          <script>
            <![CDATA[
#!/usr/bin/perl
# this script generates synthesis script for divider in synthesis level
# parameter : instance_name priority bit_width algorithm adder_algorithm data_type

if ($#ARGV != 5){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name priority bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$priority      = $ARGV[1];
$bit_width     = $ARGV[2];
$algorithm     = $ARGV[3];
$add_algo      = $ARGV[4];
$data_type     = $ARGV[5];

if ($priority eq "area"){
  $priority_const = "set_max_area 0";
}
elsif ($priority eq "performance"){
  $priority_const = "set_max_delay -from all_inputs() -to all_outputs() 0";
}
elsif ($priority eq "power"){
  $priority_const = "";
}
elsif ($priority eq "none"){
  $priority_const = "";
}
else{
  print "priority $priority is not supported.\n";
  exit (100);
}

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$algorithm" eq "seq"){
    $create_clock = "create_clock -period 10 -waveform{0 5} clock";
}
elsif ("$algorithm" eq "array"){
    $create_clock = "";
}
else{
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$add_algo" ne "default"){
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

{
print <<FHM_DL_SCRIPT
hdlin_auto_save_templates = TRUE

analyze -f vhdl $instance_name.vhd

elaborate $instance_name
uniquify

$priority_const

$create_clock

compile 

write -hierarchy -output $instance_name.db

report_area
report_timing

quit
FHM_DL_SCRIPT
}
exit (0);

            ]]>
          </script>
        </synthesis_script>
      </synthesis>
    </design>

    <design>
      <design_lang> Verilog </design_lang>
                                                                                
      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates instance for divider in synthesis level
# parameter : instance_name bit_width algorithm adder_algorithm data_type

if ($#ARGV != 4){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$algorithm     = $ARGV[2];
$add_algo      = $ARGV[3];
$data_type     = $ARGV[4];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;
$w_2 = $bit_width - 2;
$w_3 = $bit_width - 3;

$zeros = 0 x $bit_width;
$zeros_1 = 0 x $w_1;

if ("$algorithm" ne "seq" && "$algorithm" ne "array"){
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$add_algo" ne "default"){
    print "add_algorithm $add_algo is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

# adder generation

$instance_name_add = $instance_name."_add$bit_width";
if ("$add_algo" eq "default"){
print <<FHM_DL_INSTANCE
// Module     : $bit_width-bit unsigned adder
// References :
// Author     : Designed by T.Morifuji (c)1996.
// Version    : 1.0
\n
// Functionality : behavior level
//  port
//   a, b   : add datas
//   cin    : carry in
//   result : result of a + b + c
//   cout   : '1' when result > 2^$bit_width-1
\n
module $instance_name_add (
  a      ,
  b      ,
  cin    ,
  result ,
  cout   );
\n
input  [$w_1:0] a, b   ;
input         cin    ;
output [$w_1:0] result ;
output        cout   ;
\n
wire  [$w_1:0] a, b   ;
wire         cin    ;
wire  [$w_1:0] result ;
wire         cout   ;
\n
assign {cout, result} = a + b + cin;
\n
endmodule
\n
FHM_DL_INSTANCE
}
else{
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}


# unsigned divider generation
if ("$algorithm" eq "seq") {
# sdiv generation

# register generation
# This script generates register instance in synthesis level

    $instance_name = $ARGV[0];
    $bit_width     = $ARGV[1];
    $b_len = &log2u($bit_width);
    $b_len2 = $b_len + 1;


    {
	print <<FHM_DL_SEQ_COMPS
// Module     : $bit_width-bit positive edge trigger register
// References :
// Author     : Designed by T.Morifuji (c)1997.
// Version    : 1.0  :
\n
// Functionality : synthesis level
//  port
//   clock    : clock
//   async_reset    : asynchronous reset
//   reset    : synchronous reset
//   enb      : '1' then register data
//   data_in  : data to register
//   data_out : registered data
\n
module ${instance_name}_reg$bit_width (
  clock       ,
  async_reset ,
  reset       ,
  enb         ,
  data_in     ,
  data_out    );
\n
input         clock       ;
input         async_reset ;
input         reset       ;
input         enb         ;
input  [$w_1:0] data_in     ;
output [$w_1:0] data_out    ;
\n
wire        clock       ;
wire        async_reset ;
wire        reset       ;
wire        enb         ;
wire [$w_1:0] data_in     ;
reg  [$w_1:0] data_out    ;
\n                                 
always@ (posedge clock or posedge async_reset)
begin
  if (async_reset == 1'b1)
    data_out <= \{$bit_width\{1'b0}} ;
  else
  begin
    if (reset == 1'b1)
      data_out <= \{$bit_width\{1'b0}} ;
    else if (enb == 1'b1)
      data_out <= data_in ;
  end
end
\n
endmodule
\n
// Module     : 1-bit positive edge trigger register
// References :
// Author     : Designed by T.Morifuji (c)1997.
// Version    : 1.0  :
\n
// Functionality : synthesis level
//  port
//   clock    : clock
//   async_reset    : asynchronous reset
//   reset    : synchronous reset
//   enb      : '1' then register data
//   data_in  : data to register
//   data_out : registered data
\n
module ${instance_name}_reg1 (
    clock       ,
    async_reset ,
    reset       ,
    enb         ,
    data_in     ,
    data_out    ) ;
\n
input  clock       ;
input  async_reset ;
input  reset       ;
input  enb         ;
input  data_in     ;
output data_out    ;
\n
wire clock       ;
wire async_reset ;
wire reset       ;
wire enb         ;
wire data_in     ;
reg  data_out    ;
\n
always@ (posedge clock or posedge async_reset)
begin
  if (async_reset == 1'b1)
    data_out <= 1'b0 ;
  else
  begin
    if (reset == 1'b1)
      data_out <= 1'b0 ;
    else if (enb == 1'b1)
      data_out <= data_in ;
  end
end
\n
endmodule
\n 
// Module     : $bit_width-bit shift register for divider
// References :
// Author     : Designed by T.Morifuji (c)1996,1997.
//              Modified by K.Ueda (c)2002.
// Version    : 1.0
//            : 2.0  : change algorithm

// Functionality :
//  port
//   clock  : clock
//   async_reset  : asynchronous reset
//   reset  : synchronous reset
//   ld     : load datas when '1'
//   mode   : mode of register
//            "00" : no operation (ignore ld)
//            "01" : initialize register
//            "11" : validate ld and shift data
//   ain    : represent quotient
//   pin    : represent reminder
//   cin    : represent 1-bit of reminder
//   aout   : output of ain
//   pout   : output of pin
//   cout   : output of cin
\n
module ${instance_name}_lsftreg$bit_width (
    clock       ,
    async_reset ,
    reset       ,
    ld          ,
    mode        ,
    ain         ,
    pin         ,
    cin         ,
    aout        ,
    pout        ,
    cout        ) ;
\n
input         clock       ;
input         async_reset ;
input         reset       ;
input         ld          ;
input  [ 1:0] mode        ;
input  [$w_1:0] ain         ;
input  [$w_1:0] pin         ;
input         cin         ;
output [$w_1:0] aout        ;
output [$w_1:0] pout        ;
output        cout        ;
\n
wire        clock       ;
wire        async_reset ;
wire        reset       ;
wire        ld          ;
wire [ 1:0] mode        ;
wire [$w_1:0] ain         ;
wire [$w_1:0] pin         ;
wire        cin         ;
wire [$w_1:0] aout        ;
wire [$w_1:0] pout        ;
wire        cout        ;
\n
wire [$w_1:0] pin_tmp     ;
wire [$w_1:0] ain_tmp     ;
wire        cout_in_tmp ;
\n                           
assign pin_tmp = (mode == 2'b01) ? \{{$w_1\{1'b0}}, ain[$w_1]} :
                 (mode == 2'b11 && ld == 1'b1) ? {pin[$w_2:0], aout[$w_1]} :
                 (mode == 2'b11 && ld == 1'b0) ? {pout[$w_2:0], aout[$w_1]} : pout ;
\n
assign ain_tmp = (mode == 2'b01) ? {ain[$w_2:0], 1'b0} :
                 (mode == 2'b11) ? {aout[$w_2:0], cin} : aout ;
\n
assign cout_in_tmp = (mode == 2'b01) ? 1'b0 :
                     (mode == 2'b11 && ld == 1'b1) ? pin[$w_1] :
                     (mode == 2'b11 && ld == 1'b0) ? pout[$w_1] : cout ;
\n
${instance_name}_reg$bit_width POUT_REG (
    .clock       (clock)       ,
    .async_reset (async_reset) ,
    .reset       (reset)       ,
    .enb         (1'b1)        ,
    .data_in     (pin_tmp)     ,
    .data_out    (pout)        ) ;
\n
${instance_name}_reg$bit_width AOUT_REG (
    .clock       (clock)       ,
    .async_reset (async_reset) ,
    .reset       (reset)       ,
    .enb         (1'b1)        ,
    .data_in     (ain_tmp)     ,
    .data_out    (aout)        ) ;
\n
${instance_name}_reg1 COUT_REG (
    .clock       (clock)       ,
    .async_reset (async_reset) ,
    .reset       (reset)       ,
    .enb         (1'b1)        ,
    .data_in     (cout_in_tmp) ,
    .data_out    (cout)        ) ;
\n                   
endmodule
\n
FHM_DL_SEQ_COMPS
    }
    {
	print <<FHM_DL_SDIV_TOP
// Module     : Basic ${bit_width}-bit sequential unsigned divider
// References :
// Author     : Designed by T.Morifuji (c)1996,1997,1999.
//              Modified by K.Ueda (c)2002
// Version    : 1.1
//              2.0 : change algorithm

// Functionality :
//  port
//   clock  : clock
//   async_reset  : asynchronous reset
//   reset  : synchronous reset
//   clear  : cancel division
//   a      : dividend
//   b      : divisor
//   start  : '1' then start division
//   q      : result of a / b
//   r      : reminder of a / b
//   flag   : '1' when b = 0
//   fin    : '1' when operation is over
\n
module ${instance_name}_sdiv$bit_width (
    clock       ,
    async_reset ,
    reset       ,
    clear       ,
    a           ,
    b           ,
    start       ,
    q           ,
    r           ,
    flag        ,
    fin         ) ;
\n
input         clock       ;
input         async_reset ;
input         reset       ;
input         clear       ;
input  [$w_1:0] a           ;
input  [$w_1:0] b           ;
input         start       ;
output [$w_1:0] q           ;
output [$w_1:0] r           ;
output        flag        ;
output        fin         ;
\n
wire          clock       ;
wire          async_reset ;
wire          reset       ;
wire          clear       ;
wire   [$w_1:0] a           ;
wire   [$w_1:0] b           ;
wire          start       ;
wire   [$w_1:0] q           ;
wire   [$w_1:0] r           ;
wire          flag        ;
reg           fin         ;
\n
// signals declaration
reg    [ 1:0] sft_mode       ;
wire   [$w_1:0] from_latch_out ;
wire   [$w_1:0] from_sft_aout  ;
wire   [$w_1:0] from_sft_pout  ;
wire          from_sft_cout  ;
wire   [$w_1:0] from_adder     ;
wire          add_cout       ;
wire   [$w_1:0] to_sft_ain     ;
wire   [$w_1:0] to_reg_in      ;
\n
reg    [ $b_len:0] current_state  ;
reg    [ $b_len:0] next_state     ;
\n  
FHM_DL_SDIV_TOP
    }
for ($i=0; $i<=$bit_width+2;$i++){
   $j = &to_comp($i, $b_len+1);
   if ($i == 0){
    print "parameter        st$i = ${b_len2}'b$j,\n";
   }
   elsif ($i == $bit_width+2){
    print "                 stend = ${b_len2}'b$j;\n";
   }
   else{
    print "                 st$i = ${b_len2}'b$j,\n";
   }
}
    {
	print <<FHM_DL_SDIV_CENTER
\n
assign q = from_sft_aout ;
assign r = {from_sft_cout , from_sft_pout[$w_1:1]} ;
\n
assign flag = (b == \{$bit_width\{1'b0}}) ? 1'b1 : 1'b0 ;
\n
assign to_reg_in = ~b ;
assign to_sft_ain = a ;
\n 
always @(current_state or start or clear)
begin
  case (current_state)
\n
    st0 :
      begin
        if (start == 1'b1 && clear == 1'b0)
          next_state = st1 ;
        else
          next_state = st0 ;
        sft_mode   = 2'b00 ;
        fin        = 1'b1 & ~start ;
      end
\n
    st1 :
      begin
        if (clear == 1'b1)
          next_state = st0 ;
        else
          next_state = st2 ;
        sft_mode   = 2'b01 ;
        fin        = 1'b0 ;
      end
\n
FHM_DL_SDIV_CENTER
    }
    $i=2;

    while ($i < $bit_width + 1) {
	print  "    st$i :\n";
	$i++;
	print <<FHM_DL_STATE
      begin
        if (clear == 1'b1)
          next_state = st0;
        else
          next_state = st$i;
        sft_mode = 2'b11;
        fin        = 1'b0;
      end
      \n
FHM_DL_STATE
    }

    print "    st$i :\n";
    {
	print <<FHM_DL_SDIV_BOTTOM
      begin
        if (clear == 1'b1)
          next_state = st0;
        else
          next_state = stend;
        sft_mode = 2'b11;
        fin        = 1'b0;
      end
      \n
    stend :
      begin
        next_state = st0;
        sft_mode = 2'b00;
        fin        = 1'b1;
      end
\n    
    default :
      begin
        next_state = st0;
        sft_mode = 2'b00;
        fin        = 1'b1;
      end
  endcase
end
\n
always @(posedge clock or posedge async_reset)
begin
  if (async_reset == 1'b1)
    current_state <= st0 ;
  else
  begin
    if (reset == 1'b1)
      current_state <= st0 ;
    else
      current_state <= next_state ;
  end
end
\n
${instance_name}_lsftreg$bit_width LSFTREG0 (
    .clock       (clock)         ,
    .async_reset (async_reset)   ,
    .reset       (reset)         ,
    .ld          (add_cout)      ,
    .mode        (sft_mode)      ,
    .ain         (to_sft_ain)    ,
    .pin         (from_adder)    ,
    .cin         (add_cout)      ,
    .aout        (from_sft_aout) ,
    .pout        (from_sft_pout) ,
    .cout        (from_sft_cout) );
\n
${instance_name}_add$bit_width ADD0 (
    .a      (from_sft_pout)  ,
    .b      (from_latch_out) ,
    .cin    (1'b1)           ,
    .result (from_adder)     ,
    .cout   (add_cout)       );
\n
${instance_name}_reg$bit_width REG0 (
    .clock       (clock)         ,
    .async_reset (async_reset)   ,
    .reset       (reset)         ,
    .enb         (start)         ,
    .data_in     (to_reg_in)     ,
    .data_out    (from_latch_out)) ;                                            \n
endmodule
\n                                                                              
FHM_DL_SDIV_BOTTOM
    }
}
elsif ("$algorithm" eq "array") {
{
    print <<FHM_DL_ADIV
// Module     : Basic $bit_width-bit array unsigned divider
// References :
// Author     : Designed by T.Morifuji (c)1996,1997.
// Version    : 1.0  :
\n
// Functionality :
//  port
//   a      : dividend
//   b      : divisor
//   q      : result of a / b
//   r      : reminder of a / b
//   flag   : '1' when b = 0
\n
module ${instance_name}_adiv$bit_width (
    a    ,
    b    ,
    q    ,
    r    ,
    flag ) ;
\n
input  [$w_1:0] a    ;
input  [$w_1:0] b    ;
output [$w_1:0] q    ;
output [$w_1:0] r    ;
output        flag ;
\n
wire  [$w_1:0] a    ;
wire  [$w_1:0] b    ;
wire  [$w_1:0] q    ;
wire  [$w_1:0] r    ;
wire        flag ;
\n
wire  [$w_1:0] conv_b      ;
wire  [$w_1:0] add_a[$w_1:0] ;
wire  [$w_1:0] s    [$w_1:0] ;
wire  [$w_2:0] subr [$w_2:0] ;
wire  [$w_1:0] c           ;
wire  [$w_1:0] s0          ;
\n

FHM_DL_ADIV
}
print " \n";

{
   print <<FHM_DL_ADIV
// function definition : ADD_A1
function [$w_1:0] ADD_A1 ;
input [$w_2:0] subrn ;
input        an    ;
input        n     ;
integer n ;
integer i ;
begin
  for (i = $w_1 ; i >= n + 1 ; i = i - 1)
    ADD_A1[i] = 1'b0 ;
  for (i = n ; i >= 1 ; i = i - 1)
    ADD_A1[i] = subrn[i-1] ;
  ADD_A1[0] = an ;
end
endfunction
\n
// function definition : ADD_A2
function [$w_1:0] ADD_A2 ;
input [$w_2:0] subrn ;
input        a0    ;
integer i ;
begin
for (i = $w_1 ; i >= 1 ; i = i - 1)
  ADD_A2[i] = subrn[i-1] ;
ADD_A2[0] = a0 ;
end
endfunction
\n
// function definition : SUBR
function [$w_2:0] SUBR ;
input [$w_1:0] sn    ;
input [$w_2:0] subrn ;
input        cn    ;
input        an    ;
input        n     ;
integer n ;
integer i ;
for (i = $w_2 ; i >= 0 ; i = i - 1)
  if (i > n)
    SUBR[i] = 1'b0 ;
  else if (i != 0)
    SUBR[i] = (sn[i] & cn) | ((~cn) & subrn[i-1]) ;
  else
    SUBR[0] = (sn[0] & cn) | ((~cn) & an) ;
endfunction
\n
// function definition : RR_N
function [$w_1:0] RR_N ;
input [$w_1:0] s$w_1    ;
input [$w_2:0] subr$w_2 ;
input        c$w_1    ;
input        a0     ;
integer i ;
for (i = $w_1 ; i >= 0 ; i = i - 1)
  if (i != 0)
    RR_N[i] = (s${w_1}[i] & c$w_1) | ((~c$w_1) & subr${w_2}[i-1]) ;
  else
    RR_N[i] = (s${w_1}[i] & c$w_1) | ((~c$w_1) & a0) ;
endfunction
\n
// function definition : QQ_N
function [$w_1:0] QQ_N ;
input [$w_1:0] cn ;
integer i ;
for (i = $w_1 ; i >= 0 ; i = i - 1)
  QQ_N[i] = cn[${w_1}-i] ;
endfunction
\n
assign flag = (b == {${bit_width}{1'b0}}) ? 1'b1 : 1'b0 ;
assign conv_b = ~b ;
\n
// a connect and add as
assign add_a[ 0] = {{${w_2}{1'b0}}, a[$w_1]} ;
FHM_DL_ADIV
}

for ($i=1;$i<=$w_2;$i++){
$i_tmp1 = $i - 1;
$i_tmp2 = $w_1 - $i;
print "assign add_a[ $i] = ADD_A1 (subr[ $i_tmp1], a[$i_tmp2],  $i) ;\n";
}
print "assign add_a[ $w_1] = ADD_A2 (subr[ $w_2], a[ 0]    ) ;\n";
print " \n";
print "// subr\n";
print "assign s0 = s[0] ;\n";
print "assign subr[ 0] = {{${w_3}{1'b0}}, (s0[0] & c[0]) | ((~c[0]) & a[$w_1])} ;\n";

for ($i=1;$i<=$w_2;$i++){
$i_tmp1 = $i - 1;
$i_tmp2 = $w_1 - $i;
print "assign subr[ $i] = SUBR (s[ $i], subr[ $i_tmp1], c[ $i], a[$i_tmp2],  $i) ;\n";
}

{
  print <<FHM_DL_ADIV
\n
// make result
assign r = RR_N (s[$w_1], subr[$w_2], c[$w_1], a[0]) ;
assign q = QQ_N (c) ;
\n
FHM_DL_ADIV
}

for ($i=0;$i<=$w_1;$i++){
  print<<FHM_DL_AMUL
${instance_name}_add${bit_width} ADD$i (.a(add_a[$i]), .b(conv_b),
                         .cin(1'b1), .result(s[$i]),
                         .cout(c[$i])) ;
\n
FHM_DL_AMUL
}

{
  print <<FHM_DL_ADIV
endmodule
FHM_DL_ADIV
}
}
if ("$data_type" eq "two_complement" || "$data_type" eq "abs") {
    print <<FHM_DL_TCONV
// Module     : $bit_width-bit 2's complement converter
// References :
// Author     : Designed by T.Morifuji (c)1996.
// Version    : 1.0  :
\n
// Functionality :
//  port
//   data_in  : data for convert
//   conv     : '1' then convert data
//   data_out : converted data
\n
module ${instance_name}_tconv$bit_width (
    data_in  ,
    conv     ,
    data_out ) ;
\n
input  [$w_1:0] data_in  ;
input         conv     ;
output [$w_1:0] data_out ;
\n
wire [$w_1:0] data_in  ;
wire        conv     ;
wire [$w_1:0] data_out ;
\n
wire [$w_1:0] not_data_in  ;
wire [$w_1:0] tmp_data_out ;
wire        tmp_cout     ;
\n
assign not_data_in = ~data_in ;
\n
${instance_name}_add$bit_width TWO_CONV (
    .a      (not_data_in)  ,
    .b      (\{$bit_width\{1'b0}})   ,
    .cin    (conv)         ,
    .result (tmp_data_out) ,
    .cout   (tmp_cout)     );
\n  
assign data_out = (conv == 1'b0) ? data_in : tmp_data_out ;
\n
endmodule
\n
FHM_DL_TCONV
}
if ("$algorithm" eq "seq"){
    $clock = "clock";
    $a_reset = "asynchronous reset";
    $reset = "synchronous reset";
    $clear = "cancel division";
    $start = "\'1\' then start division";
    $fin   = "\'1\' when operation is over";
}
elsif ("$algorithm" eq "array"){
    $clock = "(ignore)";
    $a_reset = "(ignore)";
    $reset = "(ignore)";
    $clear = "(ignore)";
    $start = "(ignore)";
    $fin   = "(ignore)";
}
if ("$data_type" eq "two_complment"){
    $mode = "\'1\' for signed division\n--              '0' for unsigned division";
}
elsif ("$data_type" eq "abs" || "$data_type" eq "unsigned"){
    $mode = "(ignore)";
}
{    
    print <<FHM_DL_DIV_TOP
// Module     : $bit_width-bit $algorithm $data_type divider
//              using $add_algo for adder algorithm
// References :
// Author     : Designed by T.Morifuji (c)1996,1997,1999
//              Modified by T.Yoshimura (c)2004
// Version    : 1.1  :
//              1.2  : Bug fixed
\n
// Functionality :
//  port
//   clock : $clock
//   async_reset : $a_reset
//   reset : $reset
//   clear : $clear
//   a     : dividend
//   b     : divisor
//   start : $start
//   mode  : $mode
//   q     : result of a / b
//   r     : reminder of a / b
//   flag  : '1' if b = 0
//   fin   : $fin
\n
module $instance_name (
    clock       ,
    async_reset ,
    reset       ,
    clear       ,
    a           ,
    b           ,
    start       ,
    mode        ,
    q           ,
    r           ,
    flag        ,
    fin         ) ;
\n
input         clock       ;
input         async_reset ;
input         reset       ;
input         clear       ;
input signed [$w_1:0] a           ;
input signed [$w_1:0] b           ;
input         start       ;
input         mode        ;
output signed [$w_1:0] q           ;
output signed [$w_1:0] r           ;
output        flag        ;
output        fin         ;
\n
wire        clock       ;
wire        async_reset ;
wire        reset       ;
wire        clear       ;
wire signed [$w_1:0] a           ;
wire signed [$w_1:0] b           ;
wire        start       ;
wire        mode        ;
wire signed [$w_1:0] q           ;
wire signed [$w_1:0] r           ;
wire        flag        ;
wire        fin         ;
\n
FHM_DL_DIV_TOP
}

if ("$data_type" eq "unsigned") {

    if ("$algorithm" eq "seq") {
        print <<FHM_DL_UN_SEQ_COMP
  ${instance_name}_sdiv$bit_width SDIV0 (
      .clock  (clock),
      .async_reset (async_reset),
      .reset  (reset),
      .clear  (clear),
      .a      (a),
      .b      (b),
      .start  (start),
      .q      (q),
      .r      (r),
      .flag   (flag),
      .fin    (fin));
        
FHM_DL_UN_SEQ_COMP
    }
    elsif ("$algorithm" eq "array") {
        print <<FHM_DL_UN_ARRAY_COMP
assign  fin = 1'b1;
\n
  ${instance_name}_adiv$bit_width ADIV0 (
      .a    (a),
      .b    (b),
      .q    (q),
      .r    (r),
      .flag (flag));
  
FHM_DL_UN_ARRAY_COMP
    }
    print "endmodule\n";
}
elsif ("$data_type" eq "two_complement") {
    $mode = "mode";
    if ("$algorithm" eq "seq"){
	$mode = "tmp_mode";
	print <<FHM_DL_SEQ_REG
wire        tmp_mode     ;
FHM_DL_SEQ_REG
    }
    {
	print <<FHM_DL_TWOCOMP_TOP2
wire signed [$w_1:0] conved_a     ;
wire signed [$w_1:0] conved_b     ;
wire signed [$w_1:0] conved_q     ;
wire signed [$w_1:0] conved_r     ;
wire signed [$w_1:0] tmp_a        ;
wire signed [$w_1:0] tmp_b        ;
wire signed [$w_1:0] tmp_q        ;
wire signed [$w_1:0] tmp_r        ;
wire        q_tconv_conv ;
wire        r_tconv_conv ;
\n
assign q_tconv_conv = a[$w_1] ^ b[$w_1] ;
assign r_tconv_conv = a[$w_1] ;
\n
${instance_name}_tconv$bit_width CONV_A (
    .data_in  (a)       ,
    .conv     (a[$w_1])   ,
    .data_out (conved_a)) ;
\n
${instance_name}_tconv$bit_width CONV_B (
    .data_in  (b)       ,
    .conv     (b[$w_1])   ,
    .data_out (conved_b)) ;
\n
assign tmp_a = (mode == 1'b0) ? a : conved_a ;
assign tmp_b = (mode == 1'b0) ? b : conved_b ;
\n
FHM_DL_TWOCOMP_TOP2
    }
    if ("$algorithm" eq "seq") {
	print <<FHM_DL_TWOCOMP_SEQ
${instance_name}_sdiv$bit_width DIVU (
    .clock       (clock)       ,
    .async_reset (async_reset) ,
    .reset       (reset)       ,
    .clear       (clear)       ,
    .a           (tmp_a)       ,
    .b           (tmp_b)       ,
    .start       (start)       ,
    .q           (tmp_q)       ,
    .r           (tmp_r)       ,
    .flag        (flag)        ,
    .fin         (fin)         ) ;
\n
${instance_name}_reg1 REG_MODE (
    .clock       (clock)       ,
    .async_reset (async_reset) ,
    .reset       (reset)       ,
    .enb         (start)       ,
    .data_in     (mode)        ,
    .data_out    (tmp_mode))   ;
\n
FHM_DL_TWOCOMP_SEQ
    }
    elsif ("$algorithm" eq "array") {
	print <<FHM_DL_TWOCOMP_ARRAY
assign  fin = 1'b1;
\n
  ${instance_name}_adiv$bit_width DIVU (
      .a    (tmp_a),
      .b    (tmp_b),
      .q    (tmp_q),
      .r    (tmp_r),
      .flag (flag));
\n
FHM_DL_TWOCOMP_ARRAY
    }
    print <<FHM_DL_TWOCOMP_BOTTOM
${instance_name}_tconv$bit_width CONV_Q (
    .data_in  (tmp_q)        ,
    .conv     (q_tconv_conv) ,
    .data_out (conved_q)     ) ;
\n
${instance_name}_tconv$bit_width CONV_R (
    .data_in  (tmp_r)        ,
    .conv     (r_tconv_conv) ,
    .data_out (conved_r)     ) ;
\n
assign q = ($mode == 1'b0) ? tmp_q : conved_q ;
assign r = ($mode == 1'b0) ? tmp_r : conved_r ;
\n
endmodule
FHM_DL_TWOCOMP_BOTTOM
}
elsif ("$data_type" eq "abs") {
    {
	print <<FHM_DL_ABS_TOP
wire  signed [$w_1:0] conved_a    ;
wire  signed [$w_1:0] conved_b    ;
\n
  ${instance_name}_tconv$bit_width CONV_A (
      .data_in  (a),
      .conv     (a[$w_1]),
      .data_out (conved_a));
\n
  ${instance_name}_tconv$bit_width CONV_B (
      .data_in  (b),
      .conv     (b[$w_1]),
      .data_out (conved_b));
\n
FHM_DL_ABS_TOP
    }
    if ("$algorithm" eq "seq") {
	print <<FHM_DL_ABS_SEQ
  ${instance_name}_sdiv$bit_width DIVU (
      .clock (clock),
      .async_reset (async_reset),
      .reset (reset),
      .clear (clear),
      .a     (conved_a),
      .b     (conved_b),
      .start (start),
      .q     (q),
      .r     (r),
      .flag  (flag),
      .fin   (fin));
\n
FHM_DL_ABS_SEQ
    }
    elsif ("$algorithm" eq "array") {
	print <<FHM_DL_ABS_ARRAY
assign  fin = 1'b1;
\n
  ${instance_name}_adiv$bit_width DIVU (
      .a    (conved_a),
      .b    (conved_b),
      .q    (q),
      .r    (r),
      .flag (flag));
\n
FHM_DL_ABS_ARRAY
    }
    print "endmodule\n";
    exit (0);
}
# ---------------------------------

sub log2u{
    $num = $_[0];

    for ($i=1, $N=2; $N<$num; $i++, $N*=2){};
    return($i);
}

# ---------------------------------

sub to_comp{
  @buf = ();
  $num = $_[0];
  $width = $_[1];

  for ($x=1; $x<$width; $x++){
    $buf[$x] = $num % 2;
    $num = ($num - $buf[$x]) / 2;
  }
  $buf[$x] = $num % 2;
  return (join("", reverse(@buf)));
}
          ]]>
        </script>
      </instance>
                                                                                
      <entity></entity>
                                                                                
      <testvector></testvector>
                                                                                
      <synthesis></synthesis>
    </design>

    <design>
      <design_lang> SystemC Header </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates divider instance in behavior level
# parameter : name_space instance_name bit_width data_type

if ($#ARGV != 5){
    print "number of parameters is wrong.\n";
    print "usage : this_script name_space instance_name bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];
$algorithm     = $ARGV[3];
$add_algo      = $ARGV[4];
$data_type     = $ARGV[5];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

if ( $bit_width <= 64 ) {
    $input_type = "sc_dt::sc_uint<$bit_width>";
} else {
    $input_type = "sc_dt::sc_biguint<$bit_width>";
}

$w = $bit_width - 1;

if ("$data_type" eq "two_complement"){
    $mode_comment = "\'1\' for signed multiplication\n//              '0' for unsigned multiplication";
}
else{
    $mode_comment = "(ignore)";
}

$macro = "__" . uc($name_space) . "_" . uc($instance_name) . "_H__";


if ($algorithm eq "array") {
    $sensitive_list = "sensitive << a << b << mode;";
    $proc_fin = "";
    $private_var = "";
} else {
    $sensitive_list = "sensitive << clock.pos() << async_reset;\n";
    $sensitive_list .= "      SC_METHOD(proc_fin);\n";
    $sensitive_list .= "      sensitive << start << div_fin;\n";
    $sensitive_list .= "      cycle_count = 0;";
    $proc_fin = "void proc_fin();";
    $private_var = "sc_core::sc_signal<bool> div_fin;\n";
    $private_var .= "    int cycle_count;";
}


{
print <<FHM_DL_INSTANCE;
#ifndef $macro
#define $macro 1

// Module     : $bit_width-bit Divider
// Feature    : 
// References : Start from scratch
// Author     : Designed by T.Morifuji (c)1996,1999
//              Modefied by K. Ueda (c)2002
// Version    : 2.0  :

// Functionality : behavioral level
//  port
//   clock   : (ignore)
//   async_reset   : (ignore)
//   reset   : (ignore)
//   clear   : (ignore)
//   a       : dividened
//   b       : divisor
//   start   : (ignore)
//   mode    : $mode_comment
//   q       : result of a / b
//   r       : reminder of a / b
//   flag    : '1' if b = 0
//   fin     : '1' when operation is over

// Comment :

#include <systemc>

namespace $name_space {
  SC_MODULE($instance_name) {
    sc_core::sc_in< bool > clock;
    sc_core::sc_in< bool > async_reset;
    sc_core::sc_in< bool > reset;
    sc_core::sc_in< bool > clear;
    sc_core::sc_in< $input_type > a, b;
    sc_core::sc_in< bool > start;
    sc_core::sc_in< bool > mode;
    sc_core::sc_out< $input_type > q, r;
    sc_core::sc_out< bool > flag;
    sc_core::sc_out< bool > fin;

    $private_var

    SC_CTOR($instance_name) :
      clock("clock"),
      async_reset("async_reset"),
      reset("reset"),
      clear("clear"),
      a("a"), b("b"),
      start("start"),
      mode("mode"),
      q("q"), r("r"),
      flag("flag"),
      fin("fin")
    {
      SC_METHOD(calc);
      $sensitive_list
    }

    void calc();
    $proc_fin
  };
};

#endif // $macro
FHM_DL_INSTANCE
}

exit (0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <design>
      <design_lang> SystemC Program </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates divider instance in behavior level
# parameter : name_space instance_name bit_width data_type

if ($#ARGV != 5){
    print "number of parameters is wrong.\n";
    print "usage : this_script name_space instance_name bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];
$algorithm     = $ARGV[3];
$add_algo      = $ARGV[4];
$data_type     = $ARGV[5];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

if ( $bit_width <= 64 ) {
    $input_type = "sc_dt::sc_uint<$bit_width>";
} else {
    $input_type = "sc_dt::sc_biguint<$bit_width>";
}

if ( $bit_width + 1 <= 64 ) {
    $tmp_input_type = "sc_dt::sc_int<" . ($bit_width + 1) . ">";
} else {
    $tmp_input_type = "sc_dt::sc_bigint<" . ($bit_width + 1) . ">";
}

$w = $bit_width - 1;

if ("$data_type" eq "two_complement"){
    $mode_comment = "\'1\' for signed multiplication\n//              '0' for unsigned multiplication";
}
else{
    $mode_comment = "(ignore)";
}


if ("$data_type" eq "two_complement") {
  $calc_read = "
  tmp_a = ((a.read()[$w] & mode.read()) , a.read());
  tmp_b = ((b.read()[$w] & mode.read()) , b.read());
  ";
} elsif("$data_type" eq "abs") {
  $calc_read = "
  if (a.read()[$w] == 1)
    tmp_a = - a.read();
  else
    tmp_a = a.read();
  if (b.read()[$w] == 1)
    tmp_b = - b.read();
  else
    tmp_b = b.read();
  ";
} elsif ("$data_type" eq "unsigned") {
  $calc_read = "
  tmp_a = a.read();
  tmp_b = b.read();
  ";
}


$calc_exec = "
  if ( tmp_b == 0 ) {
    flag.write( true );
    q.write( 0 );
    r.write( 0 );
  } else {
    flag.write( false );
    q.write( tmp_a / tmp_b );
    r.write( tmp_a % tmp_b );
  }
";


if ($algorithm eq "array") {
  $proc_fin = "";
  $calc_body = "
    $calc_read
    $calc_exec
    fin.write( true );
  ";
} else {
  $proc_fin = "
void ${name_space}::${instance_name}::proc_fin()
{
  if(start.read()){
    fin.write(0);
  }else{
    fin.write(div_fin.read());
  }
}
  ";
  $calc_body = "
  if(async_reset.read() || reset.read() || clear.read()){
    div_fin.write(1);
    q.write(0);
    r.write(0);
    flag.write(0);
    cycle_count = 0;
  }else if(start.read()){
    div_fin.write(0);
    cycle_count = 1;
  }else if(cycle_count > 0){
    cycle_count++;
    if(cycle_count == ${bit_width} + 2){
      $calc_read
      $calc_exec

      div_fin.write(1);
      cycle_count = 0;
    }
  }
  ";
}


print <<FHM_DL_INSTANCE;
#include "${instance_name}.h"

// Module     : $bit_width-bit Divider
// Feature    : 
// References : Start from scratch
// Author     : Designed by T.Morifuji (c)1996,1999
//              Modefied by K. Ueda (c)2002
// Version    : 2.0  :

// Functionality : behavioral level
//  port
//   clock   : (ignore)
//   async_reset   : (ignore)
//   reset   : (ignore)
//   clear   : (ignore)
//   a       : dividend
//   b       : divisor
//   start   : (ignore)
//   mode    : $mode_comment
//   q       : result of a / b
//   r       : reminder of a / b
//   flag    : '1' when if b = 0
//   fin     : '1' when operation is over

// Comment :

$proc_fin

void ${name_space}::${instance_name}::calc()
{
  $tmp_input_type tmp_a, tmp_b;

  $calc_body
}
FHM_DL_INSTANCE


exit (0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <estimation>
      <estimation_data>
        <library name="OSAKA">

          <est_type name="shape">
            <est_index name="area">
              <unit> mm2 </unit>
              <translate>
                <translate_value key="gate"> 4201.68 </translate_value>
                <translate_value key="mm2">  1 </translate_value>
              </translate>

              <parameters name="seq,default,unsigned">
                <max>
                  <data bit_width="4"> 0.12354418708707 </data>
                  <data bit_width="8"> 0.278784621865539 </data>
                  <data bit_width="16"> 0.499389274290284 </data>
                  <data bit_width="32"> 1.04944094719255 </data>
                  <data bit_width="60"> 1.41972217351155 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.0770761176481788 </data>
                  <data bit_width="8"> 0.143764370442299 </data>
                  <data bit_width="16"> 0.272370212867234 </data>
                  <data bit_width="32"> 0.558777779364445 </data>
                  <data bit_width="60"> 1.0497674999048 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.0770761176481788 </data>
                    <data bit_width="8"> 0.143764370442299 </data>
                    <data bit_width="16"> 0.272370212867234 </data>
                    <data bit_width="32"> 0.558777779364445 </data>
                    <data bit_width="60"> 1.0497674999048 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.12354418708707 </data>
                    <data bit_width="8"> 0.278784621865539 </data>
                    <data bit_width="16"> 0.499389274290284 </data>
                    <data bit_width="32"> 1.04944094719255 </data>
                    <data bit_width="60"> 1.41972217351155 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.090396675139468 </data>
                    <data bit_width="8"> 0.164920807391329 </data>
                    <data bit_width="16"> 0.307797819919651 </data>
                    <data bit_width="32"> 0.626411219321795 </data>
                    <data bit_width="60"> 1.22870273866644 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,default,abs">
                <max>
                  <data bit_width="4"> 0.123434934121589 </data>
                  <data bit_width="8"> 0.255840395508463 </data>
                  <data bit_width="16"> 0.596274464499914 </data>
                  <data bit_width="32"> 1.17385546709887 </data>
                  <data bit_width="60"> 1.77653606057577 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.0859267295462767 </data>
                  <data bit_width="8"> 0.168088224234116 </data>
                  <data bit_width="16"> 0.363414204556273 </data>
                  <data bit_width="32"> 0.71208112278898 </data>
                  <data bit_width="60"> 1.37680325941052 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.0859267295462767 </data>
                    <data bit_width="8"> 0.168088224234116 </data>
                    <data bit_width="16"> 0.363414204556273 </data>
                    <data bit_width="32"> 0.71208112278898 </data>
                    <data bit_width="60"> 1.37680325941052 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.123434934121589 </data>
                    <data bit_width="8"> 0.255840395508463 </data>
                    <data bit_width="16"> 0.596274464499914 </data>
                    <data bit_width="32"> 1.17385546709887 </data>
                    <data bit_width="60"> 1.77653606057577 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.0995698884731822 </data>
                    <data bit_width="8"> 0.198868308390929 </data>
                    <data bit_width="16"> 0.423785099055616 </data>
                    <data bit_width="32"> 0.896070724329316 </data>
                    <data bit_width="60"> 1.61490881694941 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,default,two_complement">
                <max>
                  <data bit_width="4"> 0.15917487290798 </data>
                  <data bit_width="8"> 0.313896541859447 </data>
                  <data bit_width="16"> 0.722555158174825 </data>
                  <data bit_width="32"> 1.31940120618419 </data>
                  <data bit_width="60"> 2.43449402239104 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.102003331524533 </data>
                  <data bit_width="8"> 0.196330696768911 </data>
                  <data bit_width="16"> 0.421487346965976 </data>
                  <data bit_width="32"> 0.824377338350374 </data>
                  <data bit_width="60"> 2.03349672964148 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.102003331524533 </data>
                    <data bit_width="8"> 0.196330696768911 </data>
                    <data bit_width="16"> 0.421487346965976 </data>
                    <data bit_width="32"> 0.824377338350374 </data>
                    <data bit_width="60"> 2.03349672964148 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.15917487290798 </data>
                    <data bit_width="8"> 0.313896541859447 </data>
                    <data bit_width="16"> 0.722555158174825 </data>
                    <data bit_width="32"> 1.31940120618419 </data>
                    <data bit_width="60"> 2.43449402239104 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.120194522429124 </data>
                    <data bit_width="8"> 0.230569698311152 </data>
                    <data bit_width="16"> 0.492591979160717 </data>
                    <data bit_width="32"> 1.0294337203214 </data>
                    <data bit_width="60"> 2.25992424839588 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,default,unsigned">
                <max>
                  <data bit_width="4"> 0.0873993402638944 </data>
                  <data bit_width="8"> 0.359039210744274 </data>
                  <data bit_width="16"> 1.43213117943299 </data>
                  <data bit_width="32"> 5.39100254612441 </data>
                  <data bit_width="60"> 15.2205514744102 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.0311440133470421 </data>
                  <data bit_width="8"> 0.128255306448849 </data>
                  <data bit_width="16"> 0.555747520515603 </data>
                  <data bit_width="32"> 2.43747320643171 </data>
                  <data bit_width="60"> 10.6958295550827 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.0311440133470421 </data>
                    <data bit_width="8"> 0.128255306448849 </data>
                    <data bit_width="16"> 0.555747520515603 </data>
                    <data bit_width="32"> 2.43747320643171 </data>
                    <data bit_width="60"> 10.6958295550827 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.0873993402638944 </data>
                    <data bit_width="8"> 0.359039210744274 </data>
                    <data bit_width="16"> 1.43213117943299 </data>
                    <data bit_width="32"> 5.39100254612441 </data>
                    <data bit_width="60"> 15.2205514744102 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.0393633817901411 </data>
                    <data bit_width="8"> 0.152767465632794 </data>
                    <data bit_width="16"> 0.625672698777632 </data>
                    <data bit_width="32"> 2.88151108604177 </data>
                    <data bit_width="60"> 11.8740524623484 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,default,abs">
                <max>
                  <data bit_width="4"> 0.0946508967841435 </data>
                  <data bit_width="8"> 0.323535485329678 </data>
                  <data bit_width="16"> 1.4980468472135 </data>
                  <data bit_width="32"> 5.14169332267093 </data>
                  <data bit_width="60"> 15.6668545379467 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.0348934361969498 </data>
                  <data bit_width="8"> 0.141092883798861 </data>
                  <data bit_width="16"> 0.600899486395918 </data>
                  <data bit_width="32"> 2.60327672312028 </data>
                  <data bit_width="60"> 11.1149141533863 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.0348934361969498 </data>
                    <data bit_width="8"> 0.141092883798861 </data>
                    <data bit_width="16"> 0.600899486395918 </data>
                    <data bit_width="32"> 2.60327672312028 </data>
                    <data bit_width="60"> 11.1149141533863 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.0946508967841435 </data>
                    <data bit_width="8"> 0.323535485329678 </data>
                    <data bit_width="16"> 1.4980468472135 </data>
                    <data bit_width="32"> 5.14169332267093 </data>
                    <data bit_width="60"> 15.6668545379467 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.0429343084194893 </data>
                    <data bit_width="8"> 0.17005218936235 </data>
                    <data bit_width="16"> 0.670243783915005 </data>
                    <data bit_width="32"> 2.84814970963995 </data>
                    <data bit_width="60"> 12.2677482207117 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,default,two_complement">
                <max>
                  <data bit_width="4"> 0.126574009919842 </data>
                  <data bit_width="8"> 0.494578896060623 </data>
                  <data bit_width="16"> 1.58022856238457 </data>
                  <data bit_width="32"> 6.09702501071 </data>
                  <data bit_width="60"> 28.9901431541669 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.0521860696197711 </data>
                  <data bit_width="8"> 0.176375401744064 </data>
                  <data bit_width="16"> 0.665436601549856 </data>
                  <data bit_width="32"> 2.77002619714019 </data>
                  <data bit_width="60"> 11.8513290369566 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.0521860696197711 </data>
                    <data bit_width="8"> 0.176375401744064 </data>
                    <data bit_width="16"> 0.665436601549856 </data>
                    <data bit_width="32"> 2.77002619714019 </data>
                    <data bit_width="60"> 11.8513290369566 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.126574009919842 </data>
                    <data bit_width="8"> 0.494578896060623 </data>
                    <data bit_width="16"> 1.58022856238457 </data>
                    <data bit_width="32"> 6.09702501071 </data>
                    <data bit_width="60"> 28.9901431541669 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.066032837579254 </data>
                    <data bit_width="8"> 0.203744476495116 </data>
                    <data bit_width="16"> 0.752441303954609 </data>
                    <data bit_width="32"> 3.12542928328669 </data>
                    <data bit_width="60"> 22.5372834497153 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>

            <est_index name="aspect_ratio">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="height">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="width">
              <!-- Dummy yet -->
            </est_index>
          </est_type>

          <est_type name="timing">
            <est_index name="delay">
              <unit> ns </unit>

              <parameters name="seq,default,unsigned">
                <max>
                  <data bit_width="4"> 1.70 </data>
                  <data bit_width="8"> 1.88 </data>
                  <data bit_width="16"> 2.65 </data>
                  <data bit_width="32"> 2.32 </data>
                  <data bit_width="60"> 2.66 </data>
                  <data bit_width="128"> 3.56 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.38 </data>
                  <data bit_width="8"> 0.50 </data>
                  <data bit_width="16"> 0.76 </data>
                  <data bit_width="32"> 0.86 </data>
                  <data bit_width="60"> 1.18 </data>
                  <data bit_width="128"> 1.23 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 1.57 </data>
                    <data bit_width="8"> 1.81 </data>
                    <data bit_width="16"> 2.40 </data>
                    <data bit_width="32"> 2.32 </data>
                    <data bit_width="60"> 2.66 </data>
                    <data bit_width="128"> 3.11 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.38 </data>
                    <data bit_width="8"> 0.50 </data>
                    <data bit_width="16"> 0.76 </data>
                    <data bit_width="32"> 0.86 </data>
                    <data bit_width="60"> 1.18 </data>
                    <data bit_width="128"> 1.23 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 1.70 </data>
                    <data bit_width="8"> 1.88 </data>
                    <data bit_width="16"> 2.65 </data>
                    <data bit_width="32"> 2.30 </data>
                    <data bit_width="60"> 2.56 </data>
                    <data bit_width="128"> 3.56 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,default,abs">
                <max>
                  <data bit_width="4"> 1.97 </data>
                  <data bit_width="8"> 3.46 </data>
                  <data bit_width="16"> 7.35 </data>
                  <data bit_width="32"> 13.44 </data>
                  <data bit_width="60"> 30.49 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.34 </data>
                  <data bit_width="8"> 1.80 </data>
                  <data bit_width="16"> 2.43 </data>
                  <data bit_width="32"> 7.67 </data>
                  <data bit_width="60"> 18.32 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 1.84 </data>
                    <data bit_width="8"> 2.93 </data>
                    <data bit_width="16"> 5.11 </data>
                    <data bit_width="32"> 8.96 </data>
                    <data bit_width="60"> 18.32 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 1.34 </data>
                    <data bit_width="8"> 1.80 </data>
                    <data bit_width="16"> 2.43 </data>
                    <data bit_width="32"> 7.67 </data>
                    <data bit_width="60"> 29.95 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 1.97 </data>
                    <data bit_width="8"> 3.46 </data>
                    <data bit_width="16"> 7.35 </data>
                    <data bit_width="32"> 13.44 </data>
                    <data bit_width="60"> 30.49 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,default,two_complement">
                <max>
                  <data bit_width="4"> 2.36 </data>
                  <data bit_width="8"> 3.20 </data>
                  <data bit_width="16"> 6.75 </data>
                  <data bit_width="32"> 12.81 </data>
                  <data bit_width="60"> 30.94 </data>
                </max>
                <min>
                  <data bit_width="4"> 2.26 </data>
                  <data bit_width="8"> 2.75 </data>
                  <data bit_width="16"> 3.15 </data>
                  <data bit_width="32"> 9.99 </data>
                  <data bit_width="60"> 17.62 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 2.26 </data>
                    <data bit_width="8"> 3.12 </data>
                    <data bit_width="16"> 5.43 </data>
                    <data bit_width="32"> 9.99 </data>
                    <data bit_width="60"> 18.76 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 2.36 </data>
                    <data bit_width="8"> 2.75 </data>
                    <data bit_width="16"> 3.15 </data>
                    <data bit_width="32"> 10.56 </data>
                    <data bit_width="60"> 17.62 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 2.27 </data>
                    <data bit_width="8"> 3.20 </data>
                    <data bit_width="16"> 6.75 </data>
                    <data bit_width="32"> 12.81 </data>
                    <data bit_width="60"> 30.94 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,default,unsigned">
                <max>
                  <data bit_width="4"> 8.76 </data>
                  <data bit_width="8"> 33.25 </data>
                  <data bit_width="16"> 120.48 </data>
                  <data bit_width="32"> 498.01 </data>
                  <data bit_width="60"> 1826.51 </data>
                </max>
                <min>
                  <data bit_width="4"> 3.25 </data>
                  <data bit_width="8"> 13.49 </data>
                  <data bit_width="16"> 46.67 </data>
                  <data bit_width="32"> 143.68 </data>
                  <data bit_width="60"> 1353.01 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 7.68 </data>
                    <data bit_width="8"> 30.03 </data>
                    <data bit_width="16"> 111.78 </data>
                    <data bit_width="32"> 421.96 </data>
                    <data bit_width="60"> 1353.01 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 3.25 </data>
                    <data bit_width="8"> 13.49 </data>
                    <data bit_width="16"> 46.67 </data>
                    <data bit_width="32"> 143.68 </data>
                    <data bit_width="60"> 1408.68 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 8.76 </data>
                    <data bit_width="8"> 33.25 </data>
                    <data bit_width="16"> 120.48 </data>
                    <data bit_width="32"> 498.01 </data>
                    <data bit_width="60"> 1826.51 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,default,abs">
                <max>
                  <data bit_width="4"> 9.63 </data>
                  <data bit_width="8"> 35.63 </data>
                  <data bit_width="16"> 127.33 </data>
                  <data bit_width="32"> 482.47 </data>
                  <data bit_width="60"> 1858.18 </data>
                </max>
                <min>
                  <data bit_width="4"> 3.72 </data>
                  <data bit_width="8"> 15.40 </data>
                  <data bit_width="16"> 41.07 </data>
                  <data bit_width="32"> 246.30 </data>
                  <data bit_width="60"> 1370.29 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 8.68 </data>
                    <data bit_width="8"> 31.95 </data>
                    <data bit_width="16"> 113.35 </data>
                    <data bit_width="32"> 438.47 </data>
                    <data bit_width="60"> 1370.29 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 3.72 </data>
                    <data bit_width="8"> 15.40 </data>
                    <data bit_width="16"> 41.07 </data>
                    <data bit_width="32"> 246.30 </data>
                    <data bit_width="60"> 1442.30 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 9.63 </data>
                    <data bit_width="8"> 35.63 </data>
                    <data bit_width="16"> 127.33 </data>
                    <data bit_width="32"> 482.47 </data>
                    <data bit_width="60"> 1858.18 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,default,two_complement">
                <max>
                  <data bit_width="4"> 11.55 </data>
                  <data bit_width="8"> 39.00 </data>
                  <data bit_width="16"> 134.22 </data>
                  <data bit_width="32"> 504.67 </data>
                  <data bit_width="60"> 2648.91 </data>
                </max>
                <min>
                  <data bit_width="4"> 4.94 </data>
                  <data bit_width="8"> 15.83 </data>
                  <data bit_width="16"> 43.52 </data>
                  <data bit_width="32"> 138.94 </data>
                  <data bit_width="60"> 1390.75 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 10.45 </data>
                    <data bit_width="8"> 33.85 </data>
                    <data bit_width="16"> 118.34 </data>
                    <data bit_width="32"> 442.30 </data>
                    <data bit_width="60"> 1390.75 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 4.94 </data>
                    <data bit_width="8"> 15.83 </data>
                    <data bit_width="16"> 43.52 </data>
                    <data bit_width="32"> 138.94 </data>
                    <data bit_width="60"> 1699.20 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 11.55 </data>
                    <data bit_width="8"> 39.00 </data>
                    <data bit_width="16"> 134.22 </data>
                    <data bit_width="32"> 504.67 </data>
                    <data bit_width="60"> 2648.91 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>

            <est_index name="delay_fullpath">
              <unit> ns </unit>

              <parameters name="seq,default,abs">
                <max>
                  <data bit_width="4">
                    inport	 a	 1.08
                    inport	 b	 1.11
                    outport	 divu	 0.47
                    outport	 divu	 0.85
                    internal	 4.15
                  </data>
                  <data bit_width="8">
                    inport	 a	 1.79
                    inport	 b	 1.89
                    outport	 divu	 0.47
                    outport	 divu	 0.86
                    internal	 4.61
                  </data>
                  <data bit_width="16">
                    inport	 a	 4.76
                    inport	 b	 3.37
                    outport	 divu	 0.47
                    outport	 divu	 0.86
                    internal	 6.72
                  </data>
                  <data bit_width="32">
                    inport	 a	 10.54
                    inport	 b	 6.14
                    outport	 divu	 0.47
                    outport	 divu	 0.87
                    internal	 11.62
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    inport	 a	 1.08
                    inport	 b	 1.11
                    outport	 divu	 0.47
                    outport	 divu	 0.85
                    internal	 4.15
                  </data>
                  <data bit_width="8">
                    inport	 a	 1.79
                    inport	 b	 1.89
                    outport	 divu	 0.47
                    outport	 divu	 0.86
                    internal	 4.61
                  </data>
                  <data bit_width="16">
                    inport	 a	 4.76
                    inport	 b	 3.37
                    outport	 divu	 0.47
                    outport	 divu	 0.86
                    internal	 6.72
                  </data>
                  <data bit_width="32">
                    inport	 a	 10.54
                    inport	 b	 6.14
                    outport	 divu	 0.47
                    outport	 divu	 0.87
                    internal	 11.62
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      inport	 a	 0.94
                      inport	 b	 1.08
                      outport	 divu	 0.52
                      outport	 divu	 0.85
                      internal	 3.91
                    </data>
                    <data bit_width="8">
                      inport	 a	 1.64
                      inport	 b	 1.96
                      outport	 divu	 0.52
                      outport	 divu	 0.89
                      internal	 4.56
                    </data>
                    <data bit_width="16">
                      inport	 a	 5.29
                      inport	 b	 3.52
                      outport	 divu	 0.52
                      outport	 divu	 0.89
                      internal	 7.45
                    </data>
                    <data bit_width="32">
                      inport	 a	 10.61
                      inport	 b	 6.18
                      outport	 divu	 0.52
                      outport	 divu	 0.85
                      internal	 13.22
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      inport	 a	 0.76
                      inport	 b	 0.87
                      outport	 divu	 0.48
                      outport	 divu	 0.66
                      internal	 1.38
                    </data>
                    <data bit_width="8">
                      inport	 a	 1.15
                      inport	 b	 1.57
                      outport	 divu	 0.48
                      outport	 divu	 0.79
                      internal	 1.71
                    </data>
                    <data bit_width="16">
                      inport	 a	 1.97
                      inport	 b	 2.15
                      outport	 divu	 0.47
                      outport	 divu	 1.01
                      internal	 2.18
                    </data>
                    <data bit_width="32">
                      inport	 a	 3.20
                      inport	 b	 3.20
                      outport	 divu	 0.47
                      outport	 divu	 0.85
                      internal	 3.23
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      inport	 a	 1.08
                      inport	 b	 1.11
                      outport	 divu	 0.47
                      outport	 divu	 0.85
                      internal	 4.15
                    </data>
                    <data bit_width="8">
                      inport	 a	 1.79
                      inport	 b	 1.89
                      outport	 divu	 0.47
                      outport	 divu	 0.86
                      internal	 4.61
                    </data>
                    <data bit_width="16">
                      inport	 a	 4.76
                      inport	 b	 3.37
                      outport	 divu	 0.47
                      outport	 divu	 0.86
                      internal	 6.72
                    </data>
                    <data bit_width="32">
                      inport	 a	 10.54
                      inport	 b	 6.14
                      outport	 divu	 0.47
                      outport	 divu	 0.87
                      internal	 11.62
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,default,unsigned">
                <max>
                  <data bit_width="4">
                    inport	 a	 0.42
                    inport	 b	 0.35
                    outport	 sdiv0	 0.51
                    outport	 sdiv0	 1.10
                    internal	 3.27
                  </data>
                  <data bit_width="8">
                    inport	 a	 0.37
                    inport	 b	 0.37
                    outport	 sdiv0	 0.47
                    outport	 sdiv0	 0.91
                    internal	 4.94
                  </data>
                  <data bit_width="16">
                    inport	 a	 0.37
                    inport	 b	 0.29
                    outport	 sdiv0	 0.51
                    outport	 sdiv0	 0.87
                    internal	 7.86
                  </data>
                  <data bit_width="32">
                    inport	 a	 0.37
                    inport	 b	 0.29
                    outport	 sdiv0	 0.47
                    outport	 sdiv0	 0.64
                    internal	 13.87
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    inport	 a	 0.42
                    inport	 b	 0.35
                    outport	 sdiv0	 0.51
                    outport	 sdiv0	 1.10
                    internal	 3.27
                  </data>
                  <data bit_width="8">
                    inport	 a	 0.37
                    inport	 b	 0.37
                    outport	 sdiv0	 0.47
                    outport	 sdiv0	 0.91
                    internal	 4.94
                  </data>
                  <data bit_width="16">
                    inport	 a	 0.37
                    inport	 b	 0.29
                    outport	 sdiv0	 0.51
                    outport	 sdiv0	 0.87
                    internal	 7.86
                  </data>
                  <data bit_width="32">
                    inport	 a	 0.37
                    inport	 b	 0.29
                    outport	 sdiv0	 0.47
                    outport	 sdiv0	 0.64
                    internal	 13.87
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      inport	 a	 0.37
                      inport	 b	 0.30
                      outport	 sdiv0	 0.52
                      outport	 sdiv0	 0.84
                      internal	 3.92
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.37
                      inport	 b	 0.37
                      outport	 sdiv0	 0.52
                      outport	 sdiv0	 0.85
                      internal	 4.85
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.37
                      inport	 b	 0.29
                      outport	 sdiv0	 0.52
                      outport	 sdiv0	 0.87
                      internal	 7.77
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.37
                      inport	 b	 0.29
                      outport	 sdiv0	 0.52
                      outport	 sdiv0	 0.87
                      internal	 13.62
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      inport	 a	 0.54
                      inport	 b	 0.34
                      outport	 sdiv0	 0.47
                      outport	 sdiv0	 0.67
                      internal	 1.46
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.43
                      inport	 b	 0.34
                      outport	 sdiv0	 0.47
                      outport	 sdiv0	 0.92
                      internal	 1.69
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.46
                      inport	 b	 0.34
                      outport	 sdiv0	 0.47
                      outport	 sdiv0	 0.96
                      internal	 2.31
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.50
                      inport	 b	 0.34
                      outport	 sdiv0	 0.47
                      outport	 sdiv0	 1.18
                      internal	 2.47
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      inport	 a	 0.42
                      inport	 b	 0.35
                      outport	 sdiv0	 0.51
                      outport	 sdiv0	 1.10
                      internal	 3.27
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.37
                      inport	 b	 0.37
                      outport	 sdiv0	 0.47
                      outport	 sdiv0	 0.91
                      internal	 4.94
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.37
                      inport	 b	 0.29
                      outport	 sdiv0	 0.51
                      outport	 sdiv0	 0.87
                      internal	 7.86
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.37
                      inport	 b	 0.29
                      outport	 sdiv0	 0.47
                      outport	 sdiv0	 0.64
                      internal	 13.87
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,default,two_complement">
                <max>
                  <data bit_width="4">
                    path	 a	 q	 0.90
                    path	 a	 r	 0.97
                    path	 b	 q	 0.91
                    inport	 a	 1.24
                    inport	 b	 1.09
                    outport	 reg_mode	 1.56
                    outport	 reg_mode	 1.84
                    internal	 3.90
                  </data>
                  <data bit_width="8">
                    path	 a	 q	 1.05
                    path	 a	 r	 1.27
                    path	 b	 q	 1.05
                    inport	 a	 2.41
                    inport	 b	 1.55
                    outport	 divu	 2.85
                    outport	 divu	 2.86
                    internal	 4.71
                  </data>
                  <data bit_width="16">
                    path	 a	 q	 1.49
                    path	 a	 r	 1.23
                    path	 b	 q	 1.48
                    inport	 a	 4.34
                    inport	 b	 2.98
                    outport	 divu	 5.74
                    outport	 divu	 5.98
                    internal	 6.43
                  </data>
                  <data bit_width="32">
                    path	 a	 q	 1.86
                    path	 a	 r	 1.57
                    path	 b	 q	 1.87
                    inport	 a	 8.32
                    inport	 b	 5.07
                    outport	 divu	 12.04
                    outport	 divu	 11.86
                    internal	 12.04
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 q	 0.90
                    path	 a	 r	 0.97
                    path	 b	 q	 0.91
                    inport	 a	 1.24
                    inport	 b	 1.09
                    outport	 reg_mode	 1.56
                    outport	 reg_mode	 1.84
                    internal	 3.90
                  </data>
                  <data bit_width="8">
                    path	 a	 q	 1.05
                    path	 a	 r	 1.27
                    path	 b	 q	 1.05
                    inport	 a	 2.41
                    inport	 b	 1.55
                    outport	 divu	 2.85
                    outport	 divu	 2.86
                    internal	 4.71
                  </data>
                  <data bit_width="16">
                    path	 a	 q	 1.49
                    path	 a	 r	 1.23
                    path	 b	 q	 1.48
                    inport	 a	 4.34
                    inport	 b	 2.98
                    outport	 divu	 5.74
                    outport	 divu	 5.98
                    internal	 6.43
                  </data>
                  <data bit_width="32">
                    path	 a	 q	 1.86
                    path	 a	 r	 1.57
                    path	 b	 q	 1.87
                    inport	 a	 8.32
                    inport	 b	 5.07
                    outport	 divu	 12.04
                    outport	 divu	 11.86
                    internal	 12.04
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 q	 0.84
                      path	 a	 r	 0.97
                      path	 b	 q	 0.85
                      inport	 a	 1.24
                      inport	 b	 1.01
                      outport	 reg_mode	 1.71
                      outport	 reg_mode	 2.09
                      internal	 3.91
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 1.23
                      path	 a	 r	 1.15
                      path	 b	 q	 1.24
                      inport	 a	 2.41
                      inport	 b	 1.91
                      outport	 divu	 2.76
                      outport	 divu	 2.76
                      internal	 5.41
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 1.71
                      path	 a	 r	 1.49
                      path	 b	 q	 1.72
                      inport	 a	 5.30
                      inport	 b	 3.14
                      outport	 divu	 5.83
                      outport	 divu	 5.82
                      internal	 10.44
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 1.44
                      path	 a	 r	 1.30
                      path	 b	 q	 1.47
                      inport	 a	 10.65
                      inport	 b	 5.88
                      outport	 divu	 11.94
                      outport	 divu	 11.94
                      internal	 19.01
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 q	 0.72
                      path	 a	 r	 0.65
                      path	 b	 q	 0.71
                      inport	 a	 0.95
                      inport	 b	 0.83
                      outport	 divu	 1.10
                      outport	 divu	 1.19
                      internal	 1.36
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 1.00
                      path	 a	 r	 0.83
                      path	 b	 q	 1.00
                      inport	 a	 1.13
                      inport	 b	 1.47
                      outport	 divu	 1.48
                      outport	 divu	 1.63
                      internal	 1.77
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 1.02
                      path	 a	 r	 1.11
                      path	 b	 q	 1.03
                      inport	 a	 2.10
                      inport	 b	 2.10
                      outport	 divu	 2.03
                      outport	 divu	 2.21
                      internal	 2.18
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 1.12
                      path	 a	 r	 1.14
                      path	 b	 q	 1.13
                      inport	 a	 3.12
                      inport	 b	 3.09
                      outport	 divu	 3.05
                      outport	 divu	 3.25
                      internal	 3.15
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 q	 0.90
                      path	 a	 r	 0.97
                      path	 b	 q	 0.91
                      inport	 a	 1.24
                      inport	 b	 1.09
                      outport	 reg_mode	 1.56
                      outport	 reg_mode	 1.84
                      internal	 3.90
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 1.05
                      path	 a	 r	 1.27
                      path	 b	 q	 1.05
                      inport	 a	 2.41
                      inport	 b	 1.55
                      outport	 divu	 2.85
                      outport	 divu	 2.86
                      internal	 4.71
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 1.49
                      path	 a	 r	 1.23
                      path	 b	 q	 1.48
                      inport	 a	 4.34
                      inport	 b	 2.98
                      outport	 divu	 5.74
                      outport	 divu	 5.98
                      internal	 6.43
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 1.86
                      path	 a	 r	 1.57
                      path	 b	 q	 1.87
                      inport	 a	 8.32
                      inport	 b	 5.07
                      outport	 divu	 12.04
                      outport	 divu	 11.86
                      internal	 12.04
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,default,abs">
                <max>
                  <data bit_width="4">
                    path	 a	 q	 4.38
                    path	 a	 r	 4.65
                    path	 b	 q	 5.47
                    path	 b	 r	 5.70
                  </data>
                  <data bit_width="8">
                    path	 a	 q	 20.62
                    path	 a	 r	 21.45
                    path	 b	 q	 22.63
                    path	 b	 r	 23.45
                  </data>
                  <data bit_width="16">
                    path	 a	 q	 73.85
                    path	 a	 r	 74.52
                    path	 b	 q	 79.67
                    path	 b	 r	 80.34
                  </data>
                  <data bit_width="32">
                    path	 a	 q	 279.04
                    path	 a	 r	 279.98
                    path	 b	 q	 290.81
                    path	 b	 r	 291.75
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 q	 4.38
                    path	 a	 r	 4.65
                    path	 b	 q	 5.47
                    path	 b	 r	 5.70
                  </data>
                  <data bit_width="8">
                    path	 a	 q	 20.62
                    path	 a	 r	 21.45
                    path	 b	 q	 22.63
                    path	 b	 r	 23.45
                  </data>
                  <data bit_width="16">
                    path	 a	 q	 73.85
                    path	 a	 r	 74.52
                    path	 b	 q	 79.67
                    path	 b	 r	 80.34
                  </data>
                  <data bit_width="32">
                    path	 a	 q	 100
                    path	 a	 r	 100
                    path	 b	 q	 100
                    path	 b	 r	 100
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 q	 4.15
                      path	 a	 r	 4.62
                      path	 b	 q	 5.23
                      path	 b	 r	 5.70
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 19.77
                      path	 a	 r	 20.74
                      path	 b	 q	 21.82
                      path	 b	 r	 22.79
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 74.34
                      path	 a	 r	 75.70
                      path	 b	 q	 80.07
                      path	 b	 r	 81.43
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 281.07
                      path	 a	 r	 282.07
                      path	 b	 q	 291.13
                      path	 b	 r	 292.13
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 q	 1.30
                      path	 a	 r	 1.51
                      path	 b	 q	 1.36
                      path	 b	 r	 1.51
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 6.35
                      path	 a	 r	 6.62
                      path	 b	 q	 6.36
                      path	 b	 r	 6.63
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 20.59
                      path	 a	 r	 20.74
                      path	 b	 q	 20.62
                      path	 b	 r	 20.78
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 98.55
                      path	 a	 r	 98.63
                      path	 b	 q	 98.57
                      path	 b	 r	 98.65
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 q	 4.38
                      path	 a	 r	 4.65
                      path	 b	 q	 5.47
                      path	 b	 r	 5.70
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 20.62
                      path	 a	 r	 21.45
                      path	 b	 q	 22.63
                      path	 b	 r	 23.45
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 73.85
                      path	 a	 r	 74.52
                      path	 b	 q	 79.67
                      path	 b	 r	 80.34
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 279.04
                      path	 a	 r	 279.98
                      path	 b	 q	 290.81
                      path	 b	 r	 291.75
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,default,unsigned">
                <max>
                  <data bit_width="4">
                    path	 a	 q	 4.57
                    path	 a	 r	 5.59
                    path	 b	 q	 5.32
                    path	 b	 r	 6.34
                  </data>
                  <data bit_width="8">
                    path	 a	 q	 17.25
                    path	 a	 r	 17.96
                    path	 b	 q	 19.55
                    path	 b	 r	 20.26
                  </data>
                  <data bit_width="16">
                    path	 a	 q	 65.87
                    path	 a	 r	 66.36
                    path	 b	 q	 70.36
                    path	 b	 r	 70.86
                  </data>
                  <data bit_width="32">
                    path	 a	 q	 285.77
                    path	 a	 r	 286.79
                    path	 b	 q	 296.86
                    path	 b	 r	 297.88
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 q	 4.57
                    path	 a	 r	 5.59
                    path	 b	 q	 5.32
                    path	 b	 r	 6.34
                  </data>
                  <data bit_width="8">
                    path	 a	 q	 17.25
                    path	 a	 r	 17.96
                    path	 b	 q	 19.55
                    path	 b	 r	 20.26
                  </data>
                  <data bit_width="16">
                    path	 a	 q	 65.87
                    path	 a	 r	 66.36
                    path	 b	 q	 70.36
                    path	 b	 r	 70.86
                  </data>
                  <data bit_width="32">
                    path	 a	 q	 100
                    path	 a	 r	 100
                    path	 b	 q	 100
                    path	 b	 r	 100
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 q	 4.54
                      path	 a	 r	 5.32
                      path	 b	 q	 4.73
                      path	 b	 r	 5.51
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 19.01
                      path	 a	 r	 19.95
                      path	 b	 q	 21.05
                      path	 b	 r	 21.99
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 73.83
                      path	 a	 r	 75.21
                      path	 b	 q	 78.42
                      path	 b	 r	 79.80
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 294.04
                      path	 a	 r	 295.04
                      path	 b	 q	 303.43
                      path	 b	 r	 304.42
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 q	 1.67
                      path	 a	 r	 1.81
                      path	 b	 q	 1.67
                      path	 b	 r	 1.81
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 6.86
                      path	 a	 r	 7.00
                      path	 b	 q	 6.87
                      path	 b	 r	 7.01
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 23.13
                      path	 a	 r	 23.31
                      path	 b	 q	 23.17
                      path	 b	 r	 23.34
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 108.51
                      path	 a	 r	 108.67
                      path	 b	 q	 108.81
                      path	 b	 r	 108.97
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 q	 4.57
                      path	 a	 r	 5.59
                      path	 b	 q	 5.32
                      path	 b	 r	 6.34
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 17.25
                      path	 a	 r	 17.96
                      path	 b	 q	 19.55
                      path	 b	 r	 20.26
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 65.87
                      path	 a	 r	 66.36
                      path	 b	 q	 70.36
                      path	 b	 r	 70.86
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 285.77
                      path	 a	 r	 286.79
                      path	 b	 q	 296.86
                      path	 b	 r	 297.88
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,default,two_complement">
                <max>
                  <data bit_width="4">
                    path	 a	 q	 6.70
                    path	 a	 r	 7.25
                    path	 b	 q	 7.00
                    path	 b	 r	 7.55
                  </data>
                  <data bit_width="8">
                    path	 a	 q	 21.53
                    path	 a	 r	 22.84
                    path	 b	 q	 23.30
                    path	 b	 r	 24.60
                  </data>
                  <data bit_width="16">
                    path	 a	 q	 76.24
                    path	 a	 r	 78.64
                    path	 b	 q	 79.58
                    path	 b	 r	 81.98
                  </data>
                  <data bit_width="32">
                    path	 a	 q	 288.57
                    path	 a	 r	 289.97
                    path	 b	 q	 300.30
                    path	 b	 r	 301.70
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 q	 6.70
                    path	 a	 r	 7.25
                    path	 b	 q	 7.00
                    path	 b	 r	 7.55
                  </data>
                  <data bit_width="8">
                    path	 a	 q	 21.53
                    path	 a	 r	 22.84
                    path	 b	 q	 23.30
                    path	 b	 r	 24.60
                  </data>
                  <data bit_width="16">
                    path	 a	 q	 76.24
                    path	 a	 r	 78.64
                    path	 b	 q	 79.58
                    path	 b	 r	 81.98
                  </data>
                  <data bit_width="32">
                    path	 a	 q	 100
                    path	 a	 r	 100
                    path	 b	 q	 100
                    path	 b	 r	 100
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 q	 6.22
                      path	 a	 r	 6.73
                      path	 b	 q	 7.09
                      path	 b	 r	 7.53
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 22.38
                      path	 a	 r	 23.36
                      path	 b	 q	 24.02
                      path	 b	 r	 25.00
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 79.64
                      path	 a	 r	 81.25
                      path	 b	 q	 82.35
                      path	 b	 r	 83.97
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 290.65
                      path	 a	 r	 293.33
                      path	 b	 q	 300.47
                      path	 b	 r	 303.15
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 q	 2.29
                      path	 a	 r	 2.36
                      path	 b	 q	 2.29
                      path	 b	 r	 2.36
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 7.41
                      path	 a	 r	 7.46
                      path	 b	 q	 7.41
                      path	 b	 r	 7.46
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 21.11
                      path	 a	 r	 21.11
                      path	 b	 q	 21.11
                      path	 b	 r	 21.12
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 84.86
                      path	 a	 r	 84.91
                      path	 b	 q	 84.87
                      path	 b	 r	 84.92
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 q	 6.70
                      path	 a	 r	 7.25
                      path	 b	 q	 7.00
                      path	 b	 r	 7.55
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 21.53
                      path	 a	 r	 22.84
                      path	 b	 q	 23.30
                      path	 b	 r	 24.60
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 76.24
                      path	 a	 r	 78.64
                      path	 b	 q	 79.58
                      path	 b	 r	 81.98
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 288.57
                      path	 a	 r	 289.97
                      path	 b	 q	 300.30
                      path	 b	 r	 301.70
                    </data>
                  </priority>
                </typ>
              </parameters>

            </est_index>
          </est_type>

          <est_type name="power">
            <est_index name="static_power">
              <unit> mW </unit>

              <parameters name="seq,default,unsigned">
                <max>
                  <data bit_width="4"> 12.6290 </data>
                  <data bit_width="8"> 23.8895 </data>
                  <data bit_width="16"> 47.6797 </data>
                  <data bit_width="32"> 92.0816 </data>
                  <data bit_width="60"> 145.3447 </data>
                </max>
                <min>
                  <data bit_width="4"> 6.9473 </data>
                  <data bit_width="8"> 12.4115 </data>
                  <data bit_width="16"> 23.1831 </data>
                  <data bit_width="32"> 47.7447 </data>
                  <data bit_width="60"> 90.3211 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 7.7456 </data>
                    <data bit_width="8"> 14.2725 </data>
                    <data bit_width="16"> 25.7776 </data>
                    <data bit_width="32"> 52.1036 </data>
                    <data bit_width="60"> 96.0286 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 12.6290 </data>
                    <data bit_width="8"> 23.8895 </data>
                    <data bit_width="16"> 47.6797 </data>
                    <data bit_width="32"> 92.0816 </data>
                    <data bit_width="60"> 145.3447 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 6.9473 </data>
                    <data bit_width="8"> 12.4115 </data>
                    <data bit_width="16"> 23.1831 </data>
                    <data bit_width="32"> 47.7447 </data>
                    <data bit_width="60"> 90.3211 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,default,abs">
                <max>
                  <data bit_width="4"> 15.7058 </data>
                  <data bit_width="8"> 32.6361 </data>
                  <data bit_width="16"> 70.2038 </data>
                  <data bit_width="32"> 115.2932 </data>
                  <data bit_width="60"> 265.6862 </data>
                </max>
                <min>
                  <data bit_width="4"> 10.1102 </data>
                  <data bit_width="8"> 20.0616 </data>
                  <data bit_width="16"> 38.6971 </data>
                  <data bit_width="32"> 79.2445 </data>
                  <data bit_width="60"> 172.9162 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 10.8047 </data>
                    <data bit_width="8"> 22.6285 </data>
                    <data bit_width="16"> 41.3741 </data>
                    <data bit_width="32"> 80.7945 </data>
                    <data bit_width="60"> 190.3938 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 15.7058 </data>
                    <data bit_width="8"> 32.6361 </data>
                    <data bit_width="16"> 70.2038 </data>
                    <data bit_width="32"> 115.2932 </data>
                    <data bit_width="60"> 265.6862 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 10.1102 </data>
                    <data bit_width="8"> 20.0616 </data>
                    <data bit_width="16"> 38.6971 </data>
                    <data bit_width="32"> 79.2445 </data>
                    <data bit_width="60"> 172.9162 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,default,two_complement">
                <max>
                  <data bit_width="4"> 17.5986 </data>
                  <data bit_width="8"> 30.0920 </data>
                  <data bit_width="16"> 57.8678 </data>
                  <data bit_width="32"> 91.9736 </data>
                  <data bit_width="60"> 352.3091 </data>
                </max>
                <min>
                  <data bit_width="4"> 10.4776 </data>
                  <data bit_width="8"> 18.0752 </data>
                  <data bit_width="16"> 35.6765 </data>
                  <data bit_width="32"> 70.3294 </data>
                  <data bit_width="60"> 261.1623 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 11.5716 </data>
                    <data bit_width="8"> 20.7821 </data>
                    <data bit_width="16"> 38.3112 </data>
                    <data bit_width="32"> 72.1246 </data>
                    <data bit_width="60"> 279.9951 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 17.5986 </data>
                    <data bit_width="8"> 30.0920 </data>
                    <data bit_width="16"> 57.8678 </data>
                    <data bit_width="32"> 91.9736 </data>
                    <data bit_width="60"> 352.3091 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 10.4776 </data>
                    <data bit_width="8"> 18.0752 </data>
                    <data bit_width="16"> 35.6765 </data>
                    <data bit_width="32"> 70.3294 </data>
                    <data bit_width="60"> 261.1623 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,default,unsigned">
                <max>
                  <data bit_width="4"> 41.4805 </data>
                  <data bit_width="8"> 143.2492 </data>
                  <data bit_width="16"> 519.4864 </data>
                  <data bit_width="32"> 1867 </data>
                  <data bit_width="60"> 4990 </data>
                </max>
                <min>
                  <data bit_width="4"> 11.4423 </data>
                  <data bit_width="8"> 41.2029 </data>
                  <data bit_width="16"> 169.4019 </data>
                  <data bit_width="32"> 742.1374 </data>
                  <data bit_width="60"> 3382.1 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 12.8868 </data>
                    <data bit_width="8"> 45.8401 </data>
                    <data bit_width="16"> 180.0477 </data>
                    <data bit_width="32"> 781.8513 </data>
                    <data bit_width="60"> 3483.7 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 41.4805 </data>
                    <data bit_width="8"> 143.2492 </data>
                    <data bit_width="16"> 519.4864 </data>
                    <data bit_width="32"> 1867 </data>
                    <data bit_width="60"> 4990 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 11.4423 </data>
                    <data bit_width="8"> 41.2029 </data>
                    <data bit_width="16"> 169.4019 </data>
                    <data bit_width="32"> 742.1374 </data>
                    <data bit_width="60"> 3382.1 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,default,abs">
                <max>
                  <data bit_width="4"> 45.6225 </data>
                  <data bit_width="8"> 156.9417 </data>
                  <data bit_width="16"> 659.7426 </data>
                  <data bit_width="32"> 2190.6 </data>
                  <data bit_width="60"> 6906.1 </data>
                </max>
                <min>
                  <data bit_width="4"> 12.6310 </data>
                  <data bit_width="8"> 53.0001 </data>
                  <data bit_width="16"> 227.5790 </data>
                  <data bit_width="32"> 1014.8 </data>
                  <data bit_width="60"> 4559.8 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 15.4923 </data>
                    <data bit_width="8"> 59.6666 </data>
                    <data bit_width="16"> 243.5652 </data>
                    <data bit_width="32"> 1077.4 </data>
                    <data bit_width="60"> 4700.4 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 45.6225 </data>
                    <data bit_width="8"> 156.9417 </data>
                    <data bit_width="16"> 659.7426 </data>
                    <data bit_width="32"> 2190.6 </data>
                    <data bit_width="60"> 6906.1 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 12.6310 </data>
                    <data bit_width="8"> 53.0001 </data>
                    <data bit_width="16"> 227.5790 </data>
                    <data bit_width="32"> 1014.8 </data>
                    <data bit_width="60"> 4559.8 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,default,two_complement">
                <max>
                  <data bit_width="4"> 60.6031 </data>
                  <data bit_width="8"> 215.9316 </data>
                  <data bit_width="16"> 649.8944 </data>
                  <data bit_width="32"> 2487 </data>
                  <data bit_width="60"> 8705.3 </data>
                </max>
                <min>
                  <data bit_width="4"> 19.8810 </data>
                  <data bit_width="8"> 63.6576 </data>
                  <data bit_width="16"> 239.7523 </data>
                  <data bit_width="32"> 1042.6 </data>
                  <data bit_width="60"> 4795.3 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 22.4202 </data>
                    <data bit_width="8"> 69.9064 </data>
                    <data bit_width="16"> 255.9269 </data>
                    <data bit_width="32"> 1083.9 </data>
                    <data bit_width="60"> 4795.3 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 60.6031 </data>
                    <data bit_width="8"> 215.9316 </data>
                    <data bit_width="16"> 649.8944 </data>
                    <data bit_width="32"> 2487 </data>
                    <data bit_width="60"> 8705.3 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 19.8810 </data>
                    <data bit_width="8"> 63.6576 </data>
                    <data bit_width="16"> 239.7523 </data>
                    <data bit_width="32"> 1042.6 </data>
                    <data bit_width="60"> 5834.2 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>
          </est_type>

          <est_type name="function_cycle">
            <unit> cycle </unit>

            <est_index name="cycle">

              <parameters name="seq,default,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,default,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,default,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,default,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,default,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,default,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>
            </est_index>

            <est_index name="latency">

              <parameters name="seq,default,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,default,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,default,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,default,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,default,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,default,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>
            </est_index>

            <est_index name="throughput">

              <parameters name="seq,default,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,default,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,default,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,default,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,default,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,default,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>
            </est_index>

          </est_type>

          <est_type name="function_power">
            <!-- Dummy yet -->
          </est_type>
        </library>
      </estimation_data>

      <estimation_method>
         
        <est_type name="shape">

          <est_index name="area">

            <parameters name="seq,default,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(seq,default,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(seq,default,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(seq,default,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,default,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(array,default,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,default,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(array,default,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,default,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(array,default,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

           <est_index name="aspect_ratio">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="height">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="width">

             <!-- Dummy yet -->

           </est_index>
		
        </est_type>

        <est_type name="timing">

          <est_index name="delay">

            <parameters name="seq,default,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(seq,default,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(seq,default,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(seq,default,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,default,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(array,default,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,default,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(array,default,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,default,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(array,default,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

          <est_index name="delay_fullpath">

          </est_index>

        </est_type>

        <est_type name="power">

          <est_index name="static_power">

            <parameters name="seq,default,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(seq,default,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(seq,default,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(seq,default,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,default,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(array,default,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,default,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(array,default,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,default,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(array,default,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

        </est_type>

        <est_type name="function_cycle">
          <est_index name="cycle">

            <parameters name="seq,default,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,default,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,default,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,default,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

          <est_index name="latency">

            <parameters name="seq,default,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,default,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,default,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,default,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

          <est_index name="throughput">

            <parameters name="seq,default,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,default,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,default,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,default,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

        </est_type>

        <est_type name="function_power">

        </est_type>

    
      </estimation_method>

    </estimation>


  </model>
</FHM>
