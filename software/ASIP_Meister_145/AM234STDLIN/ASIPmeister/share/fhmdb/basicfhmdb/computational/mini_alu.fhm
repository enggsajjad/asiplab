<?xml version="1.0" encoding="UTF-8" ?>
<!-- Modified by T.Hamabe on 2006/12/05 -->
<!-- Modified by T.Hamabe on 2006/11/30 -->
<FHM>
  <model_name> mini_alu </model_name>

  <model>
    <design_level> behavior </design_level>
    <version> 1.0 </version>
    <author> <![CDATA[ Kyoko Ueda ]]> </author>
    <affiliation> <![CDATA[ Osaka Univ. ]]> </affiliation>
    <model_info> <![CDATA[
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                %
%    Copyright 2008 ASIP Solutions, Inc. All rights reserved.    %
%              Copyright 2002-2005 PEAS Project                  %
%                                                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
]]> </model_info>

    <parameter>
      <parameter_value key="bit_width">
        <value> 4 </value>
        <value> 8 </value>
        <value> 12 </value>
        <value> 16 </value>
        <value> 20 </value>
        <value> 24 </value>
        <value> 28 </value>
        <value> 32 </value>
        <value> 64 </value>
        <value> 128 </value>
        <value> 256 </value>
      </parameter_value>
    </parameter>

    <function_description>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates alu function definition in behavior level
# parameter : bit_width

if ($#ARGV != 0){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width\n";
    exit (100);
}

$bit_width = $ARGV[0];
$bit_width_1 = $bit_width - 1;

{
print <<FHM_DL_FUNCTION
signed     add(twoscomp a, twoscomp b);
unsigned   addu(twoscomp a, twoscomp b);
signed     addi(twoscomp a, twoscomp b);
unsigned   addiu(twoscomp a, twoscomp b);
signed     sub(twoscomp a, twoscomp b);
unsigned   subu(twoscomp a, twoscomp b);
signed     subd(twoscomp a, twoscomp b);
unsigned   subdu(twoscomp a, twoscomp b);
signed     inc(twoscomp a);
unsigned   incu(twoscomp a);
signed     dec(twoscomp a);
unsigned   decu(twoscomp a);
unsigned   not(twoscomp a);
unsigned   and(twoscomp a, twoscomp b);
unsigned   or(twoscomp a, twoscomp b);
unsigned   xor(twoscomp a, twoscomp b);
unsigned   nor(twoscomp a, twoscomp b);
unsigned   nxor(twoscomp a, twoscomp b);
unsigned   nand(twoscomp a, twoscomp b);
bit_vector alu_flag(bit_vector mode, bit_vector a, bit_vector b, bit cin);

/** ${bit_width}-bits alu */
model alu_${bit_width}{
  port{
    in  a[${bit_width_1}:0], b[${bit_width_1}:0], cin, mode[3:0];
    out result[${bit_width_1}:0], flag[3:0];
  }

   /** C is '1' when (carry-occurred or not-borrowed) and unsigned-mode else '0'
       Z is '1' when result = 0 else '0'
       S is equal to MSB of result
       V is '1' when overflowed and signed-mode else '0' */
 
  /** add : signed add, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function add{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = add(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0101" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** addu : unsigned add, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function addu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = addu(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0001" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** addi : signed add and inc, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function addi{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = addi(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0101" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** addiu : unsigned add and inc, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function addiu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = addiu(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0001" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** sub : signed sub, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function sub{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = sub(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0110" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** subu : unsigned sub, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function subu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = subu(a, b, cin);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0010" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** subd : signed sub and dec, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function subd{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = subd(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0110" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** subdu : unsigned sub and dec, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function subdu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = subdu(a, b, cin);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0010" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** inc : signed inc, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function inc{
    input{
      unsigned a;
    }
    output{
      unsigned   result = inc(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0100" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** incu : unsigned inc, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function incu{
    input{
      unsigned a;
    }
    output{
      unsigned   result = incu(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0000" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** dec : signed dec, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function dec{
    input{
      unsigned a;
    }
    output{
      unsigned   result = dec(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0111" && cin = '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** decu : unsigned dec, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function decu{
    input{
      unsigned a;
    }
    output{
      unsigned   result = decu(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0011" && cin = '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** not : not, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function not{
    input{
      unsigned a;
    }
    output{
      unsigned   result = not(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "1011"]{
	valid result;
	valid flag;
      }
    }
  }

  /** and : and, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function and{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = and(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "1010"]{
	valid result;
	valid flag;
      }
    }
  }

  /** or : or, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function or{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = or(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "1000"]{
	valid result;
	valid flag;
      }
    }
  }

  /** xor : xor, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function xor{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = xor(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "1001"]{
	valid result;
	valid flag;
      }
    }
  }

  /** nor : nor, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function nor{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = nor(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "1100"]{
	valid result;
	valid flag;
      }
    }
  }

  /** nxor : nxor, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function nxor{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = nxor(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "1101"]{
	valid result;
	valid flag;
      }
    }
  }

  /** nand : nand, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function nand{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = nand(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "1110"]{
	valid result;
	valid flag;
      }
    }
  }

  /** cmp : signed comp, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function cmp{
    input{
      unsigned a, b;
    }
    output{
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0110" && cin = '1']{
	valid flag;
      }
    }
  }

  /** cmpu : unsigned comp, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function cmpu{
    input{
      unsigned a, b;
    }
    output{
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0010" && cin = '1']{
	valid flag;
      }
    }
  }

  /** cmpz : signed comp with zero, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function cmpz{
    input{
      unsigned a;
    }
    output{
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0100" && cin = '0']{
	valid flag;
      }
    }
  }

  /** cmpzu : unsigned comp with zero, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function cmpzu{
    input{
      unsigned a;
    }
    output{
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0000" && cin = '0']{
	valid flag;
      }
    }
  }
}
FHM_DL_FUNCTION
}
exit(0);
        ]]>
      </script>
    </function_description>

    <function_conv>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates alu function definition in behavior level
# parameter : bit_width

if ($#ARGV != 0){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width\n";
    exit (100);
}

$bit_width = $ARGV[0];
$bit_width_1 = $bit_width - 1;

{
print <<FHM_DL_FUNCCONV
/** signed add, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function add {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0101";
      cin = '0';
    }
  }
}

/** unsigned add, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function addu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0001";
      cin = '0';
    }
  }
}

/** signed add and inc, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function addi {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0101";
      cin = '1';
    }
  }
}

/** unsigned add and inc, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function addiu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0001";
      cin = '1';
    }
  }
}

/** signed sub, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function sub {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0110";
      cin = '1';
    }
  }
}

/** unsigned sub, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function subu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0010";
      cin = '1';
    }
  }
}

/** signed sub and dec, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function subd {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0110";
      cin = '0';
    }
  }
}

/** unsigned sub and dec, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function subdu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0010";
      cin = '0';
    }
  }
}

/** signed inc, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V */
function inc {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0100";
      cin = '1';
    }
  }
}

/** unsigned inc, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0 */
function incu {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0000";
      cin = '1';
    }
  }
}

/** signed dec, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function dec {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0111";
      cin = '0';
    }
  }
}

/** unsigned dec, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function decu {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0011";
      cin = '0';
    }
  }
}

/** not, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function not {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "1011";
    }
  }
}

/** and, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function and {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "1010";
    }
  }
}

/** or, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function or {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "1000";
    }
  }
}

/** xor, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function xor {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "1001";
    }
  }
}

/** nor, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function nor {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "1100";
    }
  }
}

/** nxor, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function nxor {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "1101";
    }
  }
}

/** nand, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function nand {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "1110";
    }
  }
}

/** signed cmp, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function cmp {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0110";
      cin = '1';
    }
  }
}

/** unsigned cmp, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cmpu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0010";
      cin = '1';
    }
  }
}

/** signed cmp zero, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cmpz {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0100";
      cin = '0';
    }
  }
}

/** unsigned cmp zero, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cmpzu {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0000";
      cin = '0';
    }
  }
}
FHM_DL_FUNCCONV
}
exit(0);
        ]]>
      </script>
    </function_conv>

    <function_port>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates alu port infomation in behavior level
# parameter : bit_width

if ($#ARGV != 0){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width\n";
    exit (100);
}


$bit_width = $ARGV[0];
$bit_width_1 = $bit_width - 1;

{
print <<FHM_DL_PORTINFO
a	in	bit_vector   $bit_width_1   0	data
b	in	bit_vector   $bit_width_1   0	data
cin	in	bit		mode
mode	in	bit_vector   3   0	mode
result	out	bit_vector   $bit_width_1   0	data
flag	out	bit_vector   3   0	data
FHM_DL_PORTINFO
}
exit (0);
        ]]>
      </script>
    </function_port>

    <design>
      <design_lang> vhdl </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates alu instance in behavior level
# parameter : instance_name bit_width

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];

$bit_width_1 = $bit_width - 1;

{
print <<FHM_DL_INSTANCE
-- Module     : Arithmetic Logic Unit
-- Feature    : 
-- References : alu.fhm

-- Version : 1.0 : Designed by K.Ueda (2005/07/17)
-- Version : 1.1 : Modefied by T.Shiro(2006/03/28)

-- Comment : function table is followings.
--  +---------+-------------+-------------+---------+
--  |  mode   |   cin = 0   |   cin = 1   |  flag   |
--  +---------+-------------+-------------+---------+
--  | 3 2 1 0 |   result    |   result    | c z s v |
--  +---------+-------------+-------------+---------+
--  | 0 0 0 0 | a           | a + 1       | * * * 0 | unsigned (c)
--  | 0 0 0 1 | a + b       | a + b + 1   | * * * 0 | unsigned (c)
--  | 0 0 1 0 | a - b - 1   | a - b       | * * * 0 | unsigned (c)
--  | 0 0 1 1 | a - 1       | a           | * * * 0 | unsigned (c)
--  | 0 1 0 0 | a           | a + 1       | * * * * | signed (v)
--  | 0 1 0 1 | a + b       | a + b + 1   | * * * * | signed (v)
--  | 0 1 1 0 | a - b - 1   | a - b       | * * * * | signed (v)
--  | 0 1 1 1 | a - 1       | a           | * * * * | signed (v)
--  | 1 0 0 0 |           a or b          | 0 * * 0 |
--  | 1 0 0 1 |          a xor b          | 0 * * 0 |
--  | 1 0 1 0 |          a and b          | 0 * * 0 |
--  | 1 0 1 1 |           not a           | 0 * * 0 |
--  | 1 1 0 0 |          a nor b          | 0 * * 0 |
--  | 1 1 0 1 |         a nxor b          | 0 * * 0 |
--  | 1 1 1 0 |         a nand b          | 0 * * 0 |
--  | 1 1 1 1 |             |             | 0 * * * |
--  +---------+-------------+-------------+---------+
-- C is '1' when (carry-occurred or not-borrowed) and unsigned-mode else
--      '0';
-- V is '1' when overflowed and signed-mode else
--      '0';
-- S is equal to MSB of result;
-- Z is '1' when result = 0 else
--      '0';

-- Functionality : behavior level
--  port
--   a, b   : datas
--   cin    : carry in
--   mode   : control (refer to the above table)
--   result : result of calculation
--   flag   : flag of result (refer to the above table)


library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_arith.all;
  use IEEE.std_logic_unsigned.all;

entity $instance_name is
  port (a, b 	: in std_logic_vector($bit_width_1 downto 0);
        cin     : in std_logic;
        mode 	: in std_logic_vector(3 downto 0);
        result 	: out std_logic_vector($bit_width_1 downto 0);
        flag 	: out std_logic_vector(3 downto 0) );
end $instance_name;


architecture behavior of $instance_name is

  -- purpose: adder
  procedure ${instance_name}_add (
    constant a, b   : in  std_logic_vector($bit_width_1 downto 0);
    constant cin    : in  std_logic;
    variable result : out std_logic_vector($bit_width_1 downto 0);
    variable cout   : out std_logic) is
    variable int_a, int_b : std_logic_vector($bit_width downto 0);
    variable int_result   : std_logic_vector($bit_width downto 0);
  begin  -- ${instance_name}_add
    int_a := '0' & a;
    int_b := '0' & b;
    int_result := int_a + int_b + cin;
    result := int_result($bit_width_1 downto 0);
    cout := int_result($bit_width);
  end ${instance_name}_add;

  constant vec${bit_width}_0 : std_logic_vector($bit_width_1 downto 0) := (others => '0');
  constant vec${bit_width}_1 : std_logic_vector($bit_width_1 downto 0) := (others => '1');
begin

  process(a, b, cin, mode)
    variable pre_result    : std_logic_vector($bit_width_1 downto 0);
    variable C, Z, S, V    : std_logic;

  begin

    case mode is
      when "0000" =>
        ${instance_name}_add(a, vec${bit_width}_0, cin, pre_result, C);
      when "0001" =>
        ${instance_name}_add(a, b, cin, pre_result, C);
      when "0010" =>
        ${instance_name}_add(a, not b, cin, pre_result, C);
      when "0011" =>
        ${instance_name}_add(a, vec${bit_width}_1, cin, pre_result, C);
      when "0100" =>
        ${instance_name}_add(a, vec${bit_width}_0, cin, pre_result, C);
      when "0101" =>
        ${instance_name}_add(a, b, cin, pre_result, C);
      when "0110" =>
        ${instance_name}_add(a, not b, cin, pre_result, C);
      when "0111" =>
        ${instance_name}_add(a, vec${bit_width}_1, cin, pre_result, C);
      when "1000" =>
        pre_result := a or b;
        C := '0';
      when "1001" =>
        pre_result := a xor b;
        C := '0';
      when "1010" =>
        pre_result := a and b;
        C := '0';
      when "1011" =>
        pre_result := not a;
        C := '0';
      when "1100" =>
        pre_result := not ( a or b );
        C := '0';
      when "1101" =>
        pre_result := not ( a xor b );
        C := '0';
      when "1110" =>
        pre_result := not ( a and b );
        C := '0';
      when others =>
        pre_result := (others => 'X');
        C := '0';
    end case;

    if (mode(3) = '1') then
      C := '0';
    end if;

    if (pre_result = vec${bit_width}_0) then
      Z := '1';
    else
      Z := '0';
    end if;

    S := pre_result($bit_width_1);

    V := '0';
    case mode is
      when "0100" =>
        if a($bit_width_1)='0' and pre_result($bit_width_1)='1' then
          V := '1';
        end if;
      when "0101" =>
        if     ( a($bit_width_1)='0' and b($bit_width_1)='0'
                 and pre_result($bit_width_1)='1' )
            or ( a($bit_width_1)='1' and b($bit_width_1)='1'
                 and pre_result($bit_width_1)='0' ) then
          V := '1';
        end if;
      when "0110" =>
        if     ( a($bit_width_1)='0' and b($bit_width_1)='1'
                 and pre_result($bit_width_1)='1' )
            or ( a($bit_width_1)='1' and b($bit_width_1)='0'
                 and pre_result($bit_width_1)='0' ) then
          V := '1';
        end if;
      when "0111" =>
        if a($bit_width_1)='1' and pre_result($bit_width_1)='0' then
          V := '1';
        end if;
      when others =>
        V := '0';
    end case;

    result <= pre_result;
    flag <= C & Z & S & V;

  end process;
end behavior;
FHM_DL_INSTANCE
}
exit(0);
          ]]>
        </script>
      </instance>

      <entity></entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>

      <synthesis></synthesis>
    </design>

    <design>
      <design_lang> Verilog </design_lang>
                                                                                
      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates alu instance in behavior level
# parameter : instance_name bit_width

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];

$bit_width_1 = $bit_width - 1;

{
print <<FHM_DL_INSTANCE
// Module     : Arithmetic Logic Unit
// Feature    : 
// References : alu.fhm
\n
// Version : 1.0 : Designed by K.Ueda (2005/07/17)
\n
// Comment : function table is followings.
//  +---------+-------------+-------------+---------+
//  |  mode   |   cin = 0   |   cin = 1   |  flag   |
//  +---------+-------------+-------------+---------+
//  | 3 2 1 0 |   result    |   result    | c z s v |
//  +---------+-------------+-------------+---------+
//  | 0 0 0 0 | a           | a + 1       | * * * 0 | unsigned (c)
//  | 0 0 0 1 | a + b       | a + b + 1   | * * * 0 | unsigned (c)
//  | 0 0 1 0 | a - b - 1   | a - b       | * * * 0 | unsigned (c)
//  | 0 0 1 1 | a - 1       | a           | * * * 0 | unsigned (c)
//  | 0 1 0 0 | a           | a + 1       | * * * * | signed (v)
//  | 0 1 0 1 | a + b       | a + b + 1   | * * * * | signed (v)
//  | 0 1 1 0 | a - b - 1   | a - b       | * * * * | signed (v)
//  | 0 1 1 1 | a - 1       | a           | * * * * | signed (v)
//  | 1 0 0 0 |           a or b          | 0 * * 0 |
//  | 1 0 0 1 |          a xor b          | 0 * * 0 |
//  | 1 0 1 0 |          a and b          | 0 * * 0 |
//  | 1 0 1 1 |           not a           | 0 * * 0 |
//  | 1 1 0 0 |          a nor b          | 0 * * 0 |
//  | 1 1 0 1 |         a nxor b          | 0 * * 0 |
//  | 1 1 1 0 |         a nand b          | 0 * * 0 |
//  | 1 1 1 1 |             |             | 0 * * * |
//  +---------+-------------+-------------+---------+
// C is '1' when (carry-occurred or not-borrowed) and unsigned-mode else
//      '0';
// V is '1' when overflowed and signed-mode else
//      '0';
// S is equal to MSB of result;
// Z is '1' when result = 0 else
//      '0';
\n
// Functionality : behavior level
//  port
//   a, b   : datas
//   cin    : carry in
//   mode   : control (refer to the above table)
//   result : result of calculation
//   flag   : flag of result (refer to the above table)
\n
module $instance_name (
  a      ,
  b      ,
  cin    ,
  mode   ,
  result ,
  flag   );
\n
input  [$bit_width_1:0] a      ;
input  [$bit_width_1:0] b      ;
input         cin    ;
input  [ 3:0] mode   ;
output [$bit_width_1:0] result ;
output [ 3:0] flag   ;
\n
wire  [$bit_width_1:0] a      ;
wire  [$bit_width_1:0] b      ;
wire         cin    ;
wire  [ 3:0] mode   ;
reg   [$bit_width_1:0] result ;
reg   [ 3:0] flag   ;
\n
task ${instance_name}_add ; 
input  [$bit_width_1:0] a      ;
input  [$bit_width_1:0] b      ;
input         cin    ;
output [$bit_width_1:0] result ;
output        cout   ;
  begin  // ${instance_name}_add
    {cout, result} = a + b + cin;
  end
endtask
\n
reg [$bit_width_1:0] pre_result ;
reg        C          ;
reg        Z          ; 
reg        S          ; 
reg        V          ;
\n
always@ (a or b or cin or mode)
begin
    case (mode)
      4'b0000 :
        ${instance_name}_add(a, \{$bit_width\{1'b0}}, cin, pre_result, C);
      4'b0001 :
        ${instance_name}_add(a, b, cin, pre_result, C);
      4'b0010 :
        ${instance_name}_add(a, ~b, cin, pre_result, C);
      4'b0011 :
        ${instance_name}_add(a, \{$bit_width\{1'b1}}, cin, pre_result, C);
      4'b0100 :
        ${instance_name}_add(a, \{$bit_width\{1'b0}}, cin, pre_result, C);
      4'b0101 :
        ${instance_name}_add(a, b, cin, pre_result, C);
      4'b0110 :
        ${instance_name}_add(a, ~b, cin, pre_result, C);
      4'b0111 :
        ${instance_name}_add(a, \{$bit_width\{1'b1}}, cin, pre_result, C);
      4'b1000 :
        begin
          pre_result = a | b;
          C = 1'b0;
        end
      4'b1001 :
        begin
          pre_result = a ^ b;
          C = 1'b0; 
        end
      4'b1010 :
        begin
          pre_result = a & b;
          C = 1'b0;
        end
      4'b1011 :
        begin
          pre_result = ~a;
          C = 1'b0;
        end
      4'b1100 :
        begin
          pre_result = ~( a | b );
          C = 1'b0;
        end
      4'b1101 :
        begin
          pre_result = ~( a ^ b );
          C = 1'b0;
        end
      4'b1110 :
        begin
          pre_result = ~( a & b );
          C = 1'b0;
        end
      default :
        begin
          pre_result = \{$bit_width\{1'bX}};
          C = 1'bX;
        end
    endcase
\n
    if (pre_result == \{$bit_width\{1'b0}})
      Z = 1'b1;
    else
      Z = 1'b0;
\n
    S = pre_result[$bit_width_1];
\n
    V = 1'b0;
\n
    case (mode)
      4'b0100 :
      begin
        if (a[$bit_width_1]==1'b0 && pre_result[$bit_width_1]==1'b1)
          V = 1'b1;
      end
      4'b0101 :
      begin
        if    ( ( a[$bit_width_1]==1'b0 && b[$bit_width_1]==1'b0
                 && pre_result[$bit_width_1]==1'b1 )
            || ( a[$bit_width_1]==1'b1 && b[$bit_width_1]==1'b1
                 && pre_result[$bit_width_1]==1'b0 ) )
          V = 1'b1;
      end
      4'b0110 :
      begin
        if    ( ( a[$bit_width_1]==1'b0 && b[$bit_width_1]==1'b1
                 && pre_result[$bit_width_1]==1'b1 )
            || ( a[$bit_width_1]==1'b1 && b[$bit_width_1]==1'b0
                 && pre_result[$bit_width_1]==1'b0 ) )
          V = 1'b1;
      end
      4'b0111 :
      begin
        if (a[$bit_width_1]==1'b1 && pre_result[$bit_width_1]==1'b0)
          V = 1'b1;
      end
      default :
        V = 1'b0;
    endcase
\n
    result = pre_result;
    flag = {C , Z , S , V};
\n
end
\n
endmodule
FHM_DL_INSTANCE
}
exit(0);
          ]]>
        </script>
      </instance>
                                                                                
      <entity></entity>
                                                                                
      <testvector></testvector>
                                                                                
      <synthesis></synthesis>
    </design>

    <design>
      <design_lang> SystemC Header </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates alu instance in behavior level
# parameter : name_space instance_name bit_width

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script name_space instance_name bit_width\n";
    exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];

$bit_width_1 = $bit_width - 1;

if($bit_width > 64) {
    $data_type = "sc_dt::sc_biguint<" . $bit_width . ">";
} else {
    $data_type = "sc_dt::sc_uint<" . $bit_width . ">";
}

$macro = "__" . uc($name_space) . "_" . uc($instance_name) . "_H__";

{
print <<FHM_DL_INSTANCE
#ifndef $macro
#define $macro 1

// Module     : Arithmetic Logic Unit
// Feature    : 
// References : alu.fhm

// Version : 1.0 : Designed by K.Ueda (2005/07/17)
// Version : 1.1 : Modefied by T.Shiro(2006/03/28)

// Comment : function table is followings.
//  +---------+-------------+-------------+---------+
//  |  mode   |   cin = 0   |   cin = 1   |  flag   |
//  +---------+-------------+-------------+---------+
//  | 3 2 1 0 |   result    |   result    | c z s v |
//  +---------+-------------+-------------+---------+
//  | 0 0 0 0 | a           | a + 1       | * * * 0 | unsigned (c)
//  | 0 0 0 1 | a + b       | a + b + 1   | * * * 0 | unsigned (c)
//  | 0 0 1 0 | a - b - 1   | a - b       | * * * 0 | unsigned (c)
//  | 0 0 1 1 | a - 1       | a           | * * * 0 | unsigned (c)
//  | 0 1 0 0 | a           | a + 1       | * * * * | signed (v)
//  | 0 1 0 1 | a + b       | a + b + 1   | * * * * | signed (v)
//  | 0 1 1 0 | a - b - 1   | a - b       | * * * * | signed (v)
//  | 0 1 1 1 | a - 1       | a           | * * * * | signed (v)
//  | 1 0 0 0 |           a or b          | 0 * * 0 |
//  | 1 0 0 1 |          a xor b          | 0 * * 0 |
//  | 1 0 1 0 |          a and b          | 0 * * 0 |
//  | 1 0 1 1 |           not a           | 0 * * 0 |
//  | 1 1 0 0 |          a nor b          | 0 * * 0 |
//  | 1 1 0 1 |         a nxor b          | 0 * * 0 |
//  | 1 1 1 0 |         a nand b          | 0 * * 0 |
//  | 1 1 1 1 |             |             | 0 * * * |
//  +---------+-------------+-------------+---------+
// C is '1' when (carry-occurred or not-borrowed) and unsigned-mode else
//      '0';
// V is '1' when overflowed and signed-mode else
//      '0';
// S is equal to MSB of result;
// Z is '1' when result = 0 else
//      '0';

// Functionality : behavior level
//  port
//   a, b   : datas
//   cin    : carry in
//   mode   : control (refer to the above table)
//   result : result of calculation
//   flag   : flag of result (refer to the above table)

#include <systemc>

namespace ${name_space} {
  SC_MODULE($instance_name) {
    sc_core::sc_in< $data_type > a, b;
    sc_core::sc_in< bool > cin;
    sc_core::sc_in< sc_dt::sc_uint<4> > mode;
    sc_core::sc_out< $data_type > result;
    sc_core::sc_out< sc_dt::sc_uint<4> > flag;
  
    SC_CTOR($instance_name) :
      a("a"), b("b"), cin("cin"),
      mode("mode"), result("result"), flag("flag")
    {
      SC_METHOD(process);
      sensitive << a << b << cin << mode;
    }
  
    void process();
  };
};

#endif // $macro
FHM_DL_INSTANCE
}
exit(0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <design>
      <design_lang> SystemC Program </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates alu instance in behavior level
# parameter : name_space instance_name bit_width

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script name_space instance_name bit_width\n";
    exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];

$bit_width_1 = $bit_width - 1;

if($bit_width > 64) {
    $data_type = "sc_dt::sc_biguint<" . $bit_width . ">";
} else {
    $data_type = "sc_dt::sc_uint<" . $bit_width . ">";
}

if($bit_width + 1 > 64) {
    $tmp_type = "sc_dt::sc_biguint<" . ($bit_width + 1) . ">";
} else {
    $tmp_type = "sc_dt::sc_uint<" . ($bit_width + 1) . ">";
}

$one  = "~ ${data_type}(0)";

{
print <<FHM_DL_INSTANCE
#include "$instance_name.h"

// Module     : Arithmetic Logic Unit
// Feature    : 
// References : alu.fhm

// Version : 1.0 : Designed by K.Ueda (2005/07/17)
// Version : 1.1 : Modefied by T.Shiro(2006/03/28)

// Comment : function table is followings.
//  +---------+-------------+-------------+---------+
//  |  mode   |   cin = 0   |   cin = 1   |  flag   |
//  +---------+-------------+-------------+---------+
//  | 3 2 1 0 |   result    |   result    | c z s v |
//  +---------+-------------+-------------+---------+
//  | 0 0 0 0 | a           | a + 1       | * * * 0 | unsigned (c)
//  | 0 0 0 1 | a + b       | a + b + 1   | * * * 0 | unsigned (c)
//  | 0 0 1 0 | a - b - 1   | a - b       | * * * 0 | unsigned (c)
//  | 0 0 1 1 | a - 1       | a           | * * * 0 | unsigned (c)
//  | 0 1 0 0 | a           | a + 1       | * * * * | signed (v)
//  | 0 1 0 1 | a + b       | a + b + 1   | * * * * | signed (v)
//  | 0 1 1 0 | a - b - 1   | a - b       | * * * * | signed (v)
//  | 0 1 1 1 | a - 1       | a           | * * * * | signed (v)
//  | 1 0 0 0 |           a or b          | 0 * * 0 |
//  | 1 0 0 1 |          a xor b          | 0 * * 0 |
//  | 1 0 1 0 |          a and b          | 0 * * 0 |
//  | 1 0 1 1 |           not a           | 0 * * 0 |
//  | 1 1 0 0 |          a nor b          | 0 * * 0 |
//  | 1 1 0 1 |         a nxor b          | 0 * * 0 |
//  | 1 1 1 0 |         a nand b          | 0 * * 0 |
//  | 1 1 1 1 |             |             | 0 * * * |
//  +---------+-------------+-------------+---------+
// C is '1' when (carry-occurred or not-borrowed) and unsigned-mode else
//      '0';
// V is '1' when overflowed and signed-mode else
//      '0';
// S is equal to MSB of result;
// Z is '1' when result = 0 else
//      '0';

// Functionality : behavior level
//  port
//   a, b   : datas
//   cin    : carry in
//   mode   : control (refer to the above table)
//   result : result of calculation
//   flag   : flag of result (refer to the above table)


static void ${instance_name}_add( 
  const $data_type &a,
  const $data_type &b,
  const bool &cin, 
  $data_type &result,
  sc_dt::sc_uint<1> &cout )
{
  $tmp_type a_tmp(a);
  a_tmp += b;
  a_tmp += cin;
  result = a_tmp($bit_width - 1, 0);
  cout = a_tmp[$bit_width];
}

void ${name_space}::${instance_name}::process()
{
  $data_type pre_result;
  sc_dt::sc_uint<1> C, Z, S, V;

  $data_type tmp_a = a.read(), tmp_b = b.read();
  bool tmp_cin = cin.read();
  sc_dt::sc_uint<4> tmp_mode = mode.read();

  if( tmp_mode == 0 ) {
    ${instance_name}_add( tmp_a, 0, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 1 ) {
    ${instance_name}_add( tmp_a, tmp_b, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 2 ) {
    ${instance_name}_add( tmp_a, ~tmp_b, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 3 ) {
    ${instance_name}_add( tmp_a, $one, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 4 ) {
    ${instance_name}_add( tmp_a, 0, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 5 ) {
    ${instance_name}_add( tmp_a, tmp_b, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 6 ) {
    ${instance_name}_add( tmp_a, ~tmp_b, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 7 ) {
    ${instance_name}_add( tmp_a, $one, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 8 ) {
    pre_result = tmp_a | tmp_b;
    C = 0;
  } else if ( tmp_mode == 9 ) {
    pre_result = tmp_a ^ tmp_b;
    C = 0;
  } else if ( tmp_mode == 10 ) {
    pre_result = tmp_a & tmp_b;
    C = 0;
  } else if ( tmp_mode == 11 ) {
    pre_result = ~tmp_a;
    C = 0;
  } else if ( tmp_mode == 12 ) {
    pre_result = ~( tmp_a | tmp_b );
    C = 0;
  } else if ( tmp_mode == 13 ) {
    pre_result = ~ ( tmp_a ^ tmp_b );
    C = 0;
  } else if ( tmp_mode == 14 ) {
    pre_result = ~ ( tmp_a & tmp_b );
    C = 0;
  } else {
    pre_result = 0;
    C = 0;
  }

  if ( tmp_mode[3] == 1 )
    C = 0;

  if ( pre_result == 0 )
    Z = 1;
  else
    Z = 0;

  S = pre_result[$bit_width_1];

  V = 0;
  if ( tmp_mode == 4 ) {
    if ( tmp_a[$bit_width_1] == 0 && pre_result[$bit_width_1] == 1 )
      V = 1;
  } else if ( tmp_mode == 5 ) {
    if (( tmp_a[$bit_width_1] == 0 && tmp_b[$bit_width_1] == 0
              && pre_result[$bit_width_1] == 1 )
     || ( tmp_a[$bit_width_1] == 1 && tmp_b[$bit_width_1] == 1
              && pre_result[$bit_width_1] == 0 )) {
      V = 1;
    }
  } else if ( tmp_mode == 6 ) {
    if (( tmp_a[$bit_width_1] == 0 && tmp_b[$bit_width_1] == 1
              && pre_result[$bit_width_1] == 1 )
     || ( tmp_a[$bit_width_1] == 1 && tmp_b[$bit_width_1] == 0
              && pre_result[$bit_width_1] == 0 )) {
      V = 1;
    }
  } else if ( tmp_mode == 7 ) {
    if ( tmp_a[$bit_width_1] == 1 && pre_result[$bit_width_1] == 0 )
      V = 1;
  } else {
    V = 0;
  }

  result.write( pre_result );
  flag.write( (C , Z , S , V ) );
}
FHM_DL_INSTANCE
}

exit(0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <estimation>
      <estimation_data>
        <library name="OSAKA">

          <est_type name="shape">
            <est_index name="area">
              <unit> mm2 </unit>
              <translate>
                <translate_value key="gate"> 4201.68 </translate_value>
                <translate_value key="mm2">  1 </translate_value>
              </translate>

              <parameters name="">
                <max>
                  <data bit_width="4"> 0.164985391557663 </data>
                  <data bit_width="8"> 0.257213515070162 </data>
                  <data bit_width="16"> 0.533158260505322 </data>
                  <data bit_width="32"> 1.04701481098037 </data>
                  <data bit_width="128"> 4.66936830172693 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.113589963300394 </data>
                  <data bit_width="8"> 0.197268678956989 </data>
                  <data bit_width="16"> 0.397879236400678 </data>
                  <data bit_width="32"> 0.755690911016546 </data>
                  <data bit_width="128"> 3.51382605434017 </data>
                </min>
                <typ>
                </typ>
              </parameters>
            </est_index>

            <est_index name="aspect_ratio">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="height">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="width">
              <!-- Dummy yet -->
            </est_index>
          </est_type>

          <est_type name="timing">
            <est_index name="delay">
              <unit> ns </unit>

              <parameters name="">
                <max>
                  <data bit_width="4"> 9.15 </data>
                  <data bit_width="8"> 12.25 </data>
                  <data bit_width="16"> 18.08 </data>
                  <data bit_width="32"> 31.02 </data>
                  <data bit_width="128"> 100.10 </data>
                </max>
                <min>
                  <data bit_width="4"> 4.65 </data>
                  <data bit_width="8"> 5.40 </data>
                  <data bit_width="16"> 7.12 </data>
                  <data bit_width="32"> 8.79 </data>
                  <data bit_width="128"> 33.00 </data>
                </min>
                <typ>
                </typ>
              </parameters>
            </est_index>

            <est_index name="delay_fullpath">
            <!-- Dummy yet -->
            </est_index>
          </est_type>

          <est_type name="power">
            <est_index name="static_power">
              <unit> mW </unit>
              <parameters name="">
                <max>
                  <data bit_width="4"> 70.0840 </data>
                  <data bit_width="8"> 108.6488 </data>
                  <data bit_width="16"> 214.1503 </data>
                  <data bit_width="32"> 392.6953 </data>
                  <data bit_width="128"> 1565.9 </data>
                </max>
                <min>
                  <data bit_width="4"> 40.3143 </data>
                  <data bit_width="8"> 64.8514 </data>
                  <data bit_width="16"> 139.7683 </data>
                  <data bit_width="32"> 266.0890 </data>
                  <data bit_width="128"> 1190.2 </data>
                </min>
                <typ>
                </typ>
              </parameters>
            </est_index>
          </est_type>

          <est_type name="function_cycle">
            <!-- Dummy yet -->
          </est_type>

          <est_type name="function_power">
            <!-- Dummy yet -->
          </est_type>
        </library>
      </estimation_data>

      <estimation_method>
         
        <est_type name="shape">

          <est_index name="area">

            <parameters name="">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for alu.
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$n = $i;

# numerator 1
$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;

# numerator 2
$nume_2 = &sum(@bit) * &sum(@data);
    
# denominator 1
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;

# denominator 2
$deno_2 = &sum(@bit) * &sum(@bit);
	

# divide by zero
if ($deno_1 == $deno_2) {
    exit(100);
}
if ($n == 0) {
    exit(100);
}


$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;

$ret_data = $a * $ARGV[1] + $b;


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$ret_data += $data[$i];
    }

    return($ret_data);
}

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

           <est_index name="aspect_ratio">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="height">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="width">

             <!-- Dummy yet -->

           </est_index>
		
        </est_type>

        <est_type name="timing">

          <est_index name="delay">

            <parameters name="">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for alu.
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$n = $i;

# numerator 1
$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;

# numerator 2
$nume_2 = &sum(@bit) * &sum(@data);
    
# denominator 1
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;

# denominator 2
$deno_2 = &sum(@bit) * &sum(@bit);
	

# divide by zero
if ($deno_1 == $deno_2) {
    exit(100);
}
if ($n == 0) {
    exit(100);
}


$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;

$ret_data = $a * $ARGV[1] + $b;


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$ret_data += $data[$i];
    }

    return($ret_data);
}

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

          <est_index name="delay_fullpath">

            <parameters name="">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay_fullpath for alu.
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

$Round = 1;

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression for delay_fullpath
#--------------------------------------------------------------------------#
$n = 0;

while (<TMP>) {

    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>/ ) {

	$bit_width = $1;
	$bit[$n] = $bit_width;
	$n++;
	$_ = <TMP>;
	
	$i = 0;
	while (! /\<\s*\/data\s*\>/ ) {

	    # path 
	    if ( /path\s+(\w+)\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "path\t $1\t $2\t ";
		$delay{$bit_width}[$i] = $3; 
		$i++;
	    }

	    # inport
	    if ( /inport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "inport\t $1\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }

	    # outport
	     if ( /outport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "outport\t $1\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }

	    # internal
	    if ( /internal\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "internal\t ";
		$delay{$bit_width}[$i] = $1;
		$i++;
	    }

	    $_ = <TMP>;
	}
    }
}
close(TMP);

$line_num = $i;



for ($j = 0; $j < $line_num; $j++) {

    # numerator 1
    $nume_1 = 0.00;
    foreach $bit_width (@bit) {
	$nume_1 += $bit_width * $delay{$bit_width}[$j];
    }
    $nume_1 *= $n;

    # numerator 2
    $nume_2 = &sum(@bit);

    $tmp = 0.00;
    foreach $bit_width (@bit) {
	$tmp += $delay{$bit_width}[$j];
    }
    $nume_2 *= $tmp;
    
    # denominator 1
    $deno_1 = 0.00;
    for ($i = 0; $i < $n; $i++) {
	$deno_1 += $bit[$i] * $bit[$i];
    }
    $deno_1 *= $n;

    # denominator 2
    $deno_2 = &sum(@bit) * &sum(@bit);
    

    # divide by zero
    if ($deno_1 == $deno_2) {
	exit(100);
    }
    if ($n == 0) {
	exit(100);
    }


    # a
    $a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);

    # b
    $tmp = 0.00;
    foreach $bit_width (@bit) {
	$tmp += $delay{$bit_width}[$j];
    }
    $b = ($tmp - $a * &sum(@bit)) / $n;
    
    $ret_data = $a * $ARGV[1] + $b;
    $ret_data = &data_round($ret_data, $Round);
    
    print "$line{$bit[0]}[$j] $ret_data\n";
}

exit(0);


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $return_data );

    $return_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$return_data += $data[$i];
    }

    return($return_data);
}


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}
                ]]>
              </script>
            </parameters>
          </est_index>

        </est_type>

        <est_type name="power">

          <est_index name="static_power">

            <parameters name="">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for alu.
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

        </est_type>

        <est_type name="function_cycle">

        </est_type>

        <est_type name="function_power">

        </est_type>

    
      </estimation_method>

    </estimation>


  </model>

  <model>
    <design_level> synthesis </design_level>
    <version> 1.0 </version>
    <author> <![CDATA[ Yamane Yukinori ]]> </author>
    <affiliation> <![CDATA[ Osaka Univ. ]]> </affiliation>
    <model_info> <![CDATA[
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                %
%    Copyright 2008 ASIP Solutions, Inc. All rights reserved.    %
%              Copyright 2002-2005 PEAS Project                  %
%                                                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
]]> </model_info>

    <parameter>
      <parameter_value key="bit_width">
        <value> 4 </value>
        <value> 8 </value>
        <value> 12 </value>
        <value> 16 </value>
        <value> 20 </value>
        <value> 24 </value>
        <value> 28 </value>
        <value> 32 </value>
        <value> 64 </value>
        <value> 128 </value>
        <value> 256 </value>
      </parameter_value>
      <parameter_value key="algorithm">
        <value> default </value>
      </parameter_value>
    </parameter>

    <function_description>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates alu function definition in synthesis level
# parameter : bit_width algorithm

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm\n";
    exit (100);
}

$bit_width = $ARGV[0];
$algorithm = $ARGV[1];

$bit_width_1 = $bit_width - 1;

{
print <<FHM_DL_FUNCTION
signed     add(twoscomp a, twoscomp b);
unsigned   addu(twoscomp a, twoscomp b);
signed     addi(twoscomp a, twoscomp b);
unsigned   addiu(twoscomp a, twoscomp b);
signed     sub(twoscomp a, twoscomp b);
unsigned   subu(twoscomp a, twoscomp b);
signed     subd(twoscomp a, twoscomp b);
unsigned   subdu(twoscomp a, twoscomp b);
signed     inc(twoscomp a);
unsigned   incu(twoscomp a);
signed     dec(twoscomp a);
unsigned   decu(twoscomp a);
unsigned   not(twoscomp a);
unsigned   and(twoscomp a, twoscomp b);
unsigned   or(twoscomp a, twoscomp b);
unsigned   xor(twoscomp a, twoscomp b);
unsigned   nor(twoscomp a, twoscomp b);
unsigned   nxor(twoscomp a, twoscomp b);
unsigned   nand(twoscomp a, twoscomp b);
bit_vector alu_flag(bit_vector mode, bit_vector a, bit_vector b, bit cin);

/** ${bit_width}-bits alu */
model alu_${bit_width}{
  port{
    in  a[${bit_width_1}:0], b[${bit_width_1}:0], cin, mode[3:0];
    out result[${bit_width_1}:0], flag[3:0];
  }

   /** C is '1' when (carry-occurred or not-borrowed) and unsigned-mode else '0'
       Z is '1' when result = 0 else '0'
       S is equal to MSB of result
       V is '1' when overflowed and signed-mode else '0' */
 
  /** add : signed add, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function add{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = add(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0101" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** addu : unsigned add, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function addu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = addu(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0001" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** addi : signed add and inc, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function addi{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = addi(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0101" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** addiu : unsigned add and inc, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function addiu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = addiu(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0001" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** sub : signed sub, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function sub{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = sub(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0110" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** subu : unsigned sub, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function subu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = subu(a, b, cin);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0010" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** subd : signed sub and dec, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function subd{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = subd(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0110" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** subdu : unsigned sub and dec, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function subdu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = subdu(a, b, cin);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0010" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** inc : signed inc, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function inc{
    input{
      unsigned a;
    }
    output{
      unsigned   result = inc(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0100" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** incu : unsigned inc, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function incu{
    input{
      unsigned a;
    }
    output{
      unsigned   result = incu(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0000" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** dec : signed dec, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function dec{
    input{
      unsigned a;
    }
    output{
      unsigned   result = dec(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0111" && cin = '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** decu : unsigned dec, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function decu{
    input{
      unsigned a;
    }
    output{
      unsigned   result = decu(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0011" && cin = '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** not : not, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function not{
    input{
      unsigned a;
    }
    output{
      unsigned   result = not(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "1011"]{
	valid result;
	valid flag;
      }
    }
  }

  /** and : and, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function and{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = and(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "1010"]{
	valid result;
	valid flag;
      }
    }
  }

  /** or : or, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function or{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = or(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "1000"]{
	valid result;
	valid flag;
      }
    }
  }

  /** xor : xor, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function xor{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = xor(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "1001"]{
	valid result;
	valid flag;
      }
    }
  }

  /** nor : nor, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function nor{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = nor(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "1100"]{
	valid result;
	valid flag;
      }
    }
  }

  /** nxor : nxor, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function nxor{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = nxor(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "1101"]{
	valid result;
	valid flag;
      }
    }
  }

  /** nand : nand, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function nand{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = nand(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "1110"]{
	valid result;
	valid flag;
      }
    }
  }

  /** cmp : signed comp, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function cmp{
    input{
      unsigned a, b;
    }
    output{
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0110" && cin = '1']{
	valid flag;
      }
    }
  }

  /** cmpu : unsigned comp, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function cmpu{
    input{
      unsigned a, b;
    }
    output{
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0010" && cin = '1']{
	valid flag;
      }
    }
  }

  /** cmpz : signed comp with zero, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function cmpz{
    input{
      unsigned a;
    }
    output{
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0100" && cin = '0']{
	valid flag;
      }
    }
  }

  /** cmpzu : unsigned comp with zero, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function cmpzu{
    input{
      unsigned a;
    }
    output{
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "0000" && cin = '0']{
	valid flag;
      }
    }
  }
}
FHM_DL_FUNCTION
}
exit(0);
        ]]>
      </script>
    </function_description>

    <function_conv>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates alu function definition in synthesis level
# parameter : bit_width algorithm

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm\n";
    exit (100);
}

$bit_width = $ARGV[0];
$bit_width_1 = $bit_width - 1;

{
print <<FHM_DL_FUNCCONV
/** signed add, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function add {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0101";
      cin = '0';
    }
  }
}

/** unsigned add, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function addu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0001";
      cin = '0';
    }
  }
}

/** signed add and inc, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function addi {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0101";
      cin = '1';
    }
  }
}

/** unsigned add and inc, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function addiu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0001";
      cin = '1';
    }
  }
}

/** signed sub, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function sub {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0110";
      cin = '1';
    }
  }
}

/** unsigned sub, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function subu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0010";
      cin = '1';
    }
  }
}

/** signed sub and dec, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function subd {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0110";
      cin = '0';
    }
  }
}

/** unsigned sub and dec, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function subdu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0010";
      cin = '0';
    }
  }
}

/** signed inc, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V */
function inc {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0100";
      cin = '1';
    }
  }
}

/** unsigned inc, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0 */
function incu {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0000";
      cin = '1';
    }
  }
}

/** signed dec, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function dec {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0111";
      cin = '0';
    }
  }
}

/** unsigned dec, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function decu {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0011";
      cin = '0';
    }
  }
}

/** not, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function not {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "1011";
    }
  }
}

/** and, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function and {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "1010";
    }
  }
}

/** or, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function or {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "1000";
    }
  }
}

/** xor, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function xor {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "1001";
    }
  }
}

/** nor, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function nor {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "1100";
    }
  }
}

/** nxor, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function nxor {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "1101";
    }
  }
}

/** nand, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function nand {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "1110";
    }
  }
}

/** signed cmp, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function cmp {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0110";
      cin = '1';
    }
  }
}

/** unsigned cmp, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cmpu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0010";
      cin = '1';
    }
  }
}

/** signed cmp zero, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cmpz {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0100";
      cin = '0';
    }
  }
}

/** unsigned cmp zero, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cmpzu {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [3:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "0000";
      cin = '0';
    }
  }
}
FHM_DL_FUNCCONV
}
exit(0);
        ]]>
      </script>
    </function_conv>

    <function_port>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates alu port infomation in synthesis level
# parameter : bit_width algorithm

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm\n";
    exit (100);
}


$bit_width = $ARGV[0];
$algorithm = $ARGV[1];

$bit_width_1 = $bit_width - 1;

{
print <<FHM_DL_PORTINFO
a	in	bit_vector   $bit_width_1   0	data
b	in	bit_vector   $bit_width_1   0	data
cin	in	bit		mode
mode	in	bit_vector   3   0	mode
result	out	bit_vector   $bit_width_1   0	data
flag	out	bit_vector   3   0	data
FHM_DL_PORTINFO
}
exit(0);
        ]]>
      </script>
    </function_port>

    <design>
      <design_lang> vhdl </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates alu instance in synthesis level
# parameter : instance_name bit_width algorithm

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width algorithm\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$algorithm     = $ARGV[2];

$bit_width_1 = $bit_width - 1;
$bit_width_2 = $bit_width - 2;

$zero = "0" x $bit_width;
$zero = "\"" . $zero . "\"";
$one  = "1" x $bit_width;
$one  = "\"" . $one . "\"";

$ones = "\"" . "1" x $bit_width . "\"";

$x_str = "X" x $bit_width;
$x_str = "\"" . $x_str . "\"";

if ("$algorithm" eq "default"){
    print <<FHM_DL_INSTANCE_default
-- Module     : $bit_width-bit unsigned adder
-- References :
-- Author     : Designed by T.Morifuji (c)1996.
-- Version    : 1.0
\n
-- Functionality : synthesis level
--  port
--   a, b   : add datas
--   cin    : carry in
--   result : result of a + b + c
--   cout   : '1' when result > 2^$bit_width-1
\n
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_unsigned.all;

entity ${instance_name}_add is
  port (a, b   : in  std_logic_vector($bit_width_1 downto 0);
        cin    : in  std_logic;
        result : out std_logic_vector($bit_width_1 downto 0);
        cout   : out std_logic);
end ${instance_name}_add;

architecture synthesis of ${instance_name}_add is
begin

  process (a, b, cin)
    variable int_a, int_b : std_logic_vector($bit_width downto 0);
    variable int_result   : std_logic_vector($bit_width downto 0);
  begin
    int_a      := '0' & a;
    int_b      := '0' & b;

    int_result := int_a + int_b + cin;

    result     <= int_result($bit_width_1 downto 0);
    cout       <= int_result($bit_width);

  end process;

end synthesis;
FHM_DL_INSTANCE_default
}#default
else{
  print "false\n";
  exit (100);
}
# --- End of Adder

{
print <<FHM_DL_INSTANCE

--%
-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-- Comment    : function table is followings.
-- Module     : Arithmetic Logic Unit
-- Feature    :
-- References : mini_alu.fhm

-- Version : 1.0    : Desgined by K.Ueda (2005/07/17)
-- Version : 1.1    : Modified by T.Shiro (2006/03/15)

-- Comment    : function table is followings.
--  +---------+-------------+-------------+---------+
--  |  mode   |   cin = 0   |   cin = 1   |  flag   |
--  +---------+-------------+-------------+---------+
--  | 3 2 1 0 |   result    |   result    | c z s v |
--  +---------+-------------+-------------+---------+
--  | 0 0 0 0 | a           | a + 1       | * * * 0 | unsigned (c)
--  | 0 0 0 1 | a + b       | a + b + 1   | * * * 0 | unsigned (c)
--  | 0 0 1 0 | a - b - 1   | a - b       | * * * 0 | unsigned (c)
--  | 0 0 1 1 | a - 1       | a           | * * * 0 | unsigned (c)
--  | 0 1 0 0 | a           | a + 1       | * * * * | signed (v)
--  | 0 1 0 1 | a + b       | a + b + 1   | * * * * | signed (v)
--  | 0 1 1 0 | a - b - 1   | a - b       | * * * * | signed (v)
--  | 0 1 1 1 | a - 1       | a           | * * * * | signed (v)
--  | 1 0 0 0 |           a or b          | 0 * * 0 |
--  | 1 0 0 1 |          a xor b          | 0 * * 0 |
--  | 1 0 1 0 |          a and b          | 0 * * 0 |
--  | 1 0 1 1 |           not a           | 0 * * 0 |
--  | 1 1 0 0 |          a nor b          | 0 * * 0 |
--  | 1 1 0 1 |         a nxor b          | 0 * * 0 |
--  | 1 1 1 0 |         a nand b          | 0 * * 0 |
--  | 1 1 1 1 |             |             | 0 * * * |
--  +---------+-------------+-------------+---------+
-- C is '1' when (carry-occurred or not-bollowed) and unsigned-mode else
--      '0';
-- V is '1' when overflowed and signed-mode else
--      '0';
-- S is equal to MSB of result;
-- Z is '1' when result = 0 else
--      '0';



library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;
  use IEEE.std_logic_arith.all;

entity $instance_name is
  port (a, b 	: in std_logic_vector($bit_width_1 downto 0);
        cin     : in std_logic;
        mode 	: in std_logic_vector(3 downto 0);
        result 	: out std_logic_vector($bit_width_1 downto 0);
        flag 	: out std_logic_vector(3 downto 0) );
end $instance_name;

architecture synthesis of $instance_name is

  component ${instance_name}_add
    port (a, b 	 : in std_logic_vector($bit_width_1 downto 0);
          cin    : in std_logic;
          result : out std_logic_vector($bit_width_1 downto 0);
          cout 	 : out std_logic);
  end component;

  signal ain, bin             : std_logic_vector($bit_width_1 downto 0);
  signal tmp_cout             : std_logic;
  signal tmp_out              : std_logic_vector($bit_width_1 downto 0);
  signal pre_result           : std_logic_vector($bit_width_1 downto 0);
  signal V, C                 : std_logic;
  signal S, Z                 : std_logic;
 

begin

  --  input value of adder
  ain <= a;
  bin <= $zero when mode(1 downto 0) = "00"
                    and mode(3) = '0'          else -- a
         b     when mode(1 downto 0) = "01"
                    and mode(3) = '0'          else -- a + b
         not b when mode(1 downto 0) = "10"    else -- a - b
         $one  when mode(1 downto 0) = "11"
                    and mode(3) = '0'          else -- a - 1
         $x_str;


  -- flag output
  S <= pre_result($bit_width_1);

  C <=  tmp_cout when mode(3) = '0' else
        '0';

  Z <= '1' when pre_result = conv_std_logic_vector(0, $bit_width) else
       '0';


  V <= '1'  when mode = "0100" and
                  (a($bit_width_1)='0' and pre_result($bit_width_1)='1') else
       '1'  when mode = "0101" and
                     (( a($bit_width_1)='0' and b($bit_width_1)='0' and pre_result($bit_width_1)='1' )
                   or ( a($bit_width_1)='1' and b($bit_width_1)='1' and pre_result($bit_width_1)='0' )) else
       '1'  when mode = "0110" and
                     (( a($bit_width_1)='0' and b($bit_width_1)='1' and pre_result($bit_width_1)='1' )
                   or ( a($bit_width_1)='1' and b($bit_width_1)='0' and pre_result($bit_width_1)='0' )) else
       '1'  when mode = "0111" and 
                  ( a($bit_width_1)='1' and pre_result($bit_width_1)='0') else
       '0';

  flag <= C & Z & S & V;

  -- output 
  pre_result <= tmp_out       when mode(3) = '0'             else 
                a or b        when mode(3 downto 0) = "1000" else
                a xor b       when mode(3 downto 0) = "1001" else
                a and b       when mode(3 downto 0) = "1010" else
                not a         when mode(3 downto 0) = "1011" else
                not (a or b)  when mode(3 downto 0) = "1100" else
                not (a xor b) when mode(3 downto 0) = "1101" else
                not (a and b) when mode(3 downto 0) = "1110" else
                $x_str;

  result <= pre_result;

  -- port mapping add
  a0 : ${instance_name}_add
    port map (ain, bin, cin,
              tmp_out, tmp_cout);

end synthesis;
FHM_DL_INSTANCE
}

exit (0);
          ]]>
        </script>
      </instance>

      <entity></entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>

      <synthesis>
        <parameter></parameter>
        <synthesis_script>
          <script>
            <![CDATA[
#!/usr/bin/perl
# this script generates alu synthesis script in synthesis level
# parameter : instance_name priority bit_width

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name priority bit_width algorithm\n";
    exit (100);
}


$instance_name = $ARGV[0];
$priority      = $ARGV[1];
$bit_width     = $ARGV[2];
$algorithm     = $ARGV[3];


if ($priority eq "area"){
  $priority_const = "set_max_area 0";
}
elsif ($priority eq "performance"){
  $priority_const = "set_max_delay -from all_inputs() -to all_outputs() 0";
}
elsif ($priority eq "power"){
  $priority_const = "";
}
elsif ($priority eq "none"){
  $priority_const = "";
}
else{
  print "Not supported priority\n";
  exit (100);
}

{
print <<FHM_DL_SCRIPT
hdlin_auto_save_templates = TRUE

analyze -f vhdl $instance_name.vhd

elaborate $instance_name
uniquify

$priority_const

compile 

write -hierarchy -output $instance_name.db

report_area
report_timing

quit
FHM_DL_SCRIPT
}
exit (0);
            ]]>
          </script>
        </synthesis_script>
      </synthesis>
    </design>

    <design>
      <design_lang> Verilog </design_lang>
                                                                               
      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates alu instance in synthesis level
# parameter : instance_name bit_width algorithm

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width algorithm\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$algorithm     = $ARGV[2];

$bit_width_1 = $bit_width - 1;

if ("$algorithm" eq "default"){
print <<FHM_DL_INSTANCE
// Module     : $bit_width-bit unsigned adder
// References :
// Author     : Designed by T.Morifuji (c)1996.
// Version    : 1.0
\n
// Functionality : synthesis level
//  port
//   a, b   : add datas
//   cin    : carry in
//   result : result of a + b + c
//   cout   : '1' when result > 2^$bit_width-1
\n
module ${instance_name}_add (
  a      ,
  b      ,
  cin    ,
  result ,
  cout   ) ; 
\n
input   [$bit_width_1:0] a      ;
input   [$bit_width_1:0] b      ;
input         cin    ;
output  [$bit_width_1:0] result ;
output        cout   ;
\n

assign {cout, result} = a + b + cin;
\n
endmodule
\n
FHM_DL_INSTANCE
}
else{
    print "algorithm $algorithm is not supported.\n";
exit (100);
}

{
    print <<FHM_DL_INSTANCE;
// Module     : Arithmetic Logic Unit
// Feature    : 
// References : alu.fhm
\n
// Version : 1.0 : Designed by K.Ueda (2005/07/17)
// Version : 1.1 : Modified by T.Shiro (2006/03/15)
\n
// Comment : function table is followings.
//  +---------+-------------+-------------+---------+
//  |  mode   |   cin = 0   |   cin = 1   |  flag   |
//  +---------+-------------+-------------+---------+
//  | 3 2 1 0 |   result    |   result    | c z s v |
//  +---------+-------------+-------------+---------+
//  | 0 0 0 0 | a           | a + 1       | * * * 0 | unsigned (c)
//  | 0 0 0 1 | a + b       | a + b + 1   | * * * 0 | unsigned (c)
//  | 0 0 1 0 | a - b - 1   | a - b       | * * * 0 | unsigned (c)
//  | 0 0 1 1 | a - 1       | a           | * * * 0 | unsigned (c)
//  | 0 1 0 0 | a           | a + 1       | * * * * | signed (v)
//  | 0 1 0 1 | a + b       | a + b + 1   | * * * * | signed (v)
//  | 0 1 1 0 | a - b - 1   | a - b       | * * * * | signed (v)
//  | 0 1 1 1 | a - 1       | a           | * * * * | signed (v)
//  | 1 0 0 0 |           a or b          | 0 * * 0 |
//  | 1 0 0 1 |          a xor b          | 0 * * 0 |
//  | 1 0 1 0 |          a and b          | 0 * * 0 |
//  | 1 0 1 1 |           not a           | 0 * * 0 |
//  | 1 1 0 0 |          a nor b          | 0 * * 0 |
//  | 1 1 0 1 |         a nxor b          | 0 * * 0 |
//  | 1 1 1 0 |         a nand b          | 0 * * 0 |
//  | 1 1 1 1 |             |             | 0 * * * |
//  +---------+-------------+-------------+---------+
// C is '1' when (carry-occurred or not-borrowed) and unsigned-mode else
//      '0';
// V is '1' when overflowed and signed-mode else
//      '0';
// S is equal to MSB of result;
// Z is '1' when result = 0 else
//      '0';
\n
module $instance_name (
  a      ,
  b      ,
  cin    ,
  mode   ,
  result ,
  flag   ) ;
\n
input  [$bit_width_1:0] a      ;
input  [$bit_width_1:0] b      ;
input         cin    ;
input  [ 3:0] mode   ;
output [$bit_width_1:0] result ;
output [ 3:0] flag   ;
\n
wire [$bit_width_1:0] a      ;
wire [$bit_width_1:0] b      ;
wire        cin    ;
wire [ 3:0] mode   ;
wire [$bit_width_1:0] result ;
wire [ 3:0] flag   ;
\n
wire [$bit_width_1:0] ain        ;
wire [$bit_width_1:0] bin        ;
wire        tmp_cout   ;
wire [$bit_width_1:0] tmp_out    ;
wire [$bit_width_1:0] pre_result ;
wire        V          ;
wire        C          ;
wire        S          ;
wire        Z          ;
\n
//  input value of adder
assign ain = a ;
assign bin = (mode[1:0] == 2'b00 && mode[3] == 1'b0) ? \{$bit_width\{1'b0}} : // a
             (mode[1:0] == 2'b01 && mode[3] == 1'b0) ? b : // a + b
             (mode[1:0] == 2'b10) ? ~b : // a - b
             (mode[1:0] == 2'b11 && mode[3] == 1'b0) ? \{$bit_width\{1'b1}} : // a - 1
                                                       \{$bit_width\{1'bX}} ;
\n
// flag output
assign S = pre_result[$bit_width_1] ;
assign C = (mode[3] == 1'b0) ? tmp_cout : 1'b0 ;
assign Z = (pre_result == \{$bit_width\{1'b0}}) ? 1'b1 : 1'b0 ;
assign V = (mode == 4'b0100 && (a[$bit_width_1] == 1'b0 && pre_result[$bit_width_1] == 1'b1)) ? 1'b1 :
           (mode == 4'b0101 && ((a[$bit_width_1] == 1'b0 && b[$bit_width_1] == 1'b0 && pre_result[$bit_width_1] == 1'b1) ||
                                (a[$bit_width_1] == 1'b1 && b[$bit_width_1] == 1'b1 && pre_result[$bit_width_1] == 1'b0))) ? 1'b1 :
           (mode == 4'b0110 && ((a[$bit_width_1] == 1'b0 && b[$bit_width_1] == 1'b1 && pre_result[$bit_width_1] == 1'b1) ||
                                (a[$bit_width_1] == 1'b1 && b[$bit_width_1] == 1'b0 && pre_result[$bit_width_1] == 1'b0))) ? 1'b1 :
           (mode == 4'b0111 && (a[$bit_width_1] == 1'b1 && pre_result[$bit_width_1] == 1'b0)) ? 1'b1 : 1'b0 ;
assign flag = {C, Z, S, V} ;
\n
// output
assign pre_result = (mode[3] == 1'b0) ? tmp_out : 
                    (mode[3:0] == 4'b1000) ? a | b :
                    (mode[3:0] == 4'b1001) ? a ^ b :
                    (mode[3:0] == 4'b1010) ? a & b :
                    (mode[3:0] == 4'b1011) ? ~a :
                    (mode[3:0] == 4'b1100) ? ~(a | b) :
                    (mode[3:0] == 4'b1101) ? ~(a ^ b) :
                    (mode[3:0] == 4'b1110) ? ~(a & b) : \{$bit_width\{1'bX}} ;
assign result = pre_result ;
\n
// port mapping add
${instance_name}_add A0 (
    .a      (ain)     ,
    .b      (bin)     ,
    .cin    (cin)     ,
    .result (tmp_out) ,
    .cout   (tmp_cout)) ;
\n
endmodule
FHM_DL_INSTANCE
}

exit (0);
          ]]>
        </script>
      </instance>
                                                                                
      <entity></entity>
                                                                                
      <testvector></testvector>
                                                                                
      <synthesis></synthesis>
    </design>

    <design>
      <design_lang> SystemC Header </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates alu instance in behavior level
# parameter : name_space instance_name bit_width

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script name_space instance_name bit_width\n";
    exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];
$algorithm     = $ARGV[3];

$bit_width_1 = $bit_width - 1;

if($bit_width > 64) {
    $data_type = "sc_dt::sc_biguint<" . $bit_width . ">";
} else {
    $data_type = "sc_dt::sc_uint<" . $bit_width . ">";
}

$macro = "__" . uc($name_space) . "_" . uc($instance_name) . "_H__";

{
print <<FHM_DL_INSTANCE
#ifndef $macro
#define $macro 1

// Module     : Arithmetic Logic Unit
// Feature    : 
// References : alu.fhm

// Version : 1.0 : Designed by K.Ueda (2005/07/17)
// Version : 1.1 : Modefied by T.Shiro(2006/03/28)

// Comment : function table is followings.
//  +---------+-------------+-------------+---------+
//  |  mode   |   cin = 0   |   cin = 1   |  flag   |
//  +---------+-------------+-------------+---------+
//  | 3 2 1 0 |   result    |   result    | c z s v |
//  +---------+-------------+-------------+---------+
//  | 0 0 0 0 | a           | a + 1       | * * * 0 | unsigned (c)
//  | 0 0 0 1 | a + b       | a + b + 1   | * * * 0 | unsigned (c)
//  | 0 0 1 0 | a - b - 1   | a - b       | * * * 0 | unsigned (c)
//  | 0 0 1 1 | a - 1       | a           | * * * 0 | unsigned (c)
//  | 0 1 0 0 | a           | a + 1       | * * * * | signed (v)
//  | 0 1 0 1 | a + b       | a + b + 1   | * * * * | signed (v)
//  | 0 1 1 0 | a - b - 1   | a - b       | * * * * | signed (v)
//  | 0 1 1 1 | a - 1       | a           | * * * * | signed (v)
//  | 1 0 0 0 |           a or b          | 0 * * 0 |
//  | 1 0 0 1 |          a xor b          | 0 * * 0 |
//  | 1 0 1 0 |          a and b          | 0 * * 0 |
//  | 1 0 1 1 |           not a           | 0 * * 0 |
//  | 1 1 0 0 |          a nor b          | 0 * * 0 |
//  | 1 1 0 1 |         a nxor b          | 0 * * 0 |
//  | 1 1 1 0 |         a nand b          | 0 * * 0 |
//  | 1 1 1 1 |             |             | 0 * * * |
//  +---------+-------------+-------------+---------+
// C is '1' when (carry-occurred or not-borrowed) and unsigned-mode else
//      '0';
// V is '1' when overflowed and signed-mode else
//      '0';
// S is equal to MSB of result;
// Z is '1' when result = 0 else
//      '0';

// Functionality : behavior level
//  port
//   a, b   : datas
//   cin    : carry in
//   mode   : control (refer to the above table)
//   result : result of calculation
//   flag   : flag of result (refer to the above table)

#include <systemc>

namespace ${name_space} {
  SC_MODULE($instance_name) {
    sc_core::sc_in< $data_type > a, b;
    sc_core::sc_in< bool > cin;
    sc_core::sc_in< sc_dt::sc_uint<4> > mode;
    sc_core::sc_out< $data_type > result;
    sc_core::sc_out< sc_dt::sc_uint<4> > flag;
  
    SC_CTOR($instance_name) :
      a("a"), b("b"), cin("cin"),
      mode("mode"), result("result"), flag("flag")
    {
      SC_METHOD(process);
      sensitive << a << b << cin << mode;
    }
  
    void process();
  };
};

#endif // $macro
FHM_DL_INSTANCE
}
exit(0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <design>
      <design_lang> SystemC Program </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates alu instance in behavior level
# parameter : name_space instance_name bit_width

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script name_space instance_name bit_width\n";
    exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];
$algorithm     = $ARGV[3];

$bit_width_1 = $bit_width - 1;

if($bit_width > 64) {
    $data_type = "sc_dt::sc_biguint<" . $bit_width . ">";
} else {
    $data_type = "sc_dt::sc_uint<" . $bit_width . ">";
}

if($bit_width + 1 > 64) {
    $tmp_type = "sc_dt::sc_biguint<" . ($bit_width + 1) . ">";
} else {
    $tmp_type = "sc_dt::sc_uint<" . ($bit_width + 1) . ">";
}

$one  = "~ ${data_type}(0)";

{
print <<FHM_DL_INSTANCE
#include "$instance_name.h"

// Module     : Arithmetic Logic Unit
// Feature    : 
// References : alu.fhm

// Version : 1.0 : Designed by K.Ueda (2005/07/17)
// Version : 1.1 : Modefied by T.Shiro(2006/03/28)

// Comment : function table is followings.
//  +---------+-------------+-------------+---------+
//  |  mode   |   cin = 0   |   cin = 1   |  flag   |
//  +---------+-------------+-------------+---------+
//  | 3 2 1 0 |   result    |   result    | c z s v |
//  +---------+-------------+-------------+---------+
//  | 0 0 0 0 | a           | a + 1       | * * * 0 | unsigned (c)
//  | 0 0 0 1 | a + b       | a + b + 1   | * * * 0 | unsigned (c)
//  | 0 0 1 0 | a - b - 1   | a - b       | * * * 0 | unsigned (c)
//  | 0 0 1 1 | a - 1       | a           | * * * 0 | unsigned (c)
//  | 0 1 0 0 | a           | a + 1       | * * * * | signed (v)
//  | 0 1 0 1 | a + b       | a + b + 1   | * * * * | signed (v)
//  | 0 1 1 0 | a - b - 1   | a - b       | * * * * | signed (v)
//  | 0 1 1 1 | a - 1       | a           | * * * * | signed (v)
//  | 1 0 0 0 |           a or b          | 0 * * 0 |
//  | 1 0 0 1 |          a xor b          | 0 * * 0 |
//  | 1 0 1 0 |          a and b          | 0 * * 0 |
//  | 1 0 1 1 |           not a           | 0 * * 0 |
//  | 1 1 0 0 |          a nor b          | 0 * * 0 |
//  | 1 1 0 1 |         a nxor b          | 0 * * 0 |
//  | 1 1 1 0 |         a nand b          | 0 * * 0 |
//  | 1 1 1 1 |             |             | 0 * * * |
//  +---------+-------------+-------------+---------+
// C is '1' when (carry-occurred or not-borrowed) and unsigned-mode else
//      '0';
// V is '1' when overflowed and signed-mode else
//      '0';
// S is equal to MSB of result;
// Z is '1' when result = 0 else
//      '0';

// Functionality : behavior level
//  port
//   a, b   : datas
//   cin    : carry in
//   mode   : control (refer to the above table)
//   result : result of calculation
//   flag   : flag of result (refer to the above table)


static void ${instance_name}_add( 
  const $data_type &a,
  const $data_type &b,
  const bool &cin, 
  $data_type &result,
  sc_dt::sc_uint<1> &cout )
{
  $tmp_type a_tmp(a);
  a_tmp += b;
  a_tmp += cin;
  result = a_tmp($bit_width - 1, 0);
  cout = a_tmp[$bit_width];
}

void ${name_space}::${instance_name}::process()
{
  $data_type pre_result;
  sc_dt::sc_uint<1> C, Z, S, V;

  $data_type tmp_a = a.read(), tmp_b = b.read();
  bool tmp_cin = cin.read();
  sc_dt::sc_uint<4> tmp_mode = mode.read();

  if( tmp_mode == 0 ) {
    ${instance_name}_add( tmp_a, 0, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 1 ) {
    ${instance_name}_add( tmp_a, tmp_b, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 2 ) {
    ${instance_name}_add( tmp_a, ~tmp_b, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 3 ) {
    ${instance_name}_add( tmp_a, $one, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 4 ) {
    ${instance_name}_add( tmp_a, 0, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 5 ) {
    ${instance_name}_add( tmp_a, tmp_b, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 6 ) {
    ${instance_name}_add( tmp_a, ~tmp_b, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 7 ) {
    ${instance_name}_add( tmp_a, $one, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 8 ) {
    pre_result = tmp_a | tmp_b;
    C = 0;
  } else if ( tmp_mode == 9 ) {
    pre_result = tmp_a ^ tmp_b;
    C = 0;
  } else if ( tmp_mode == 10 ) {
    pre_result = tmp_a & tmp_b;
    C = 0;
  } else if ( tmp_mode == 11 ) {
    pre_result = ~tmp_a;
    C = 0;
  } else if ( tmp_mode == 12 ) {
    pre_result = ~( tmp_a | tmp_b );
    C = 0;
  } else if ( tmp_mode == 13 ) {
    pre_result = ~ ( tmp_a ^ tmp_b );
    C = 0;
  } else if ( tmp_mode == 14 ) {
    pre_result = ~ ( tmp_a & tmp_b );
    C = 0;
  } else {
    pre_result = 0;
    C = 0;
  }

  if ( tmp_mode[3] == 1 )
    C = 0;

  if ( pre_result == 0 )
    Z = 1;
  else
    Z = 0;

  S = pre_result[$bit_width_1];

  V = 0;
  if ( tmp_mode == 4 ) {
    if ( tmp_a[$bit_width_1] == 0 && pre_result[$bit_width_1] == 1 )
      V = 1;
  } else if ( tmp_mode == 5 ) {
    if (( tmp_a[$bit_width_1] == 0 && tmp_b[$bit_width_1] == 0
              && pre_result[$bit_width_1] == 1 )
     || ( tmp_a[$bit_width_1] == 1 && tmp_b[$bit_width_1] == 1
              && pre_result[$bit_width_1] == 0 )) {
      V = 1;
    }
  } else if ( tmp_mode == 6 ) {
    if (( tmp_a[$bit_width_1] == 0 && tmp_b[$bit_width_1] == 1
              && pre_result[$bit_width_1] == 1 )
     || ( tmp_a[$bit_width_1] == 1 && tmp_b[$bit_width_1] == 0
              && pre_result[$bit_width_1] == 0 )) {
      V = 1;
    }
  } else if ( tmp_mode == 7 ) {
    if ( tmp_a[$bit_width_1] == 1 && pre_result[$bit_width_1] == 0 )
      V = 1;
  } else {
    V = 0;
  }

  result.write( pre_result );
  flag.write( (C , Z , S , V ) );
}
FHM_DL_INSTANCE
}

exit(0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <estimation>
      <estimation_data>
        <library name="OSAKA">

          <est_type name="shape">
            <est_index name="area">
              <unit> mm2 </unit>
              <translate>
                <translate_value key="gate"> 4201.68 </translate_value>
                <translate_value key="mm2">  1 </translate_value>
              </translate>

              <parameters name="default">
                <max>
                  <data bit_width="4"> 0.13935300260848 </data>
                  <data bit_width="8"> 0.237479093362655 </data>
                  <data bit_width="16"> 0.499193691094991 </data>
                  <data bit_width="32"> 0.987219277051084 </data>
                  <data bit_width="128"> 4.62417990399078 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.113589963300394 </data>
                  <data bit_width="8"> 0.197268678956989 </data>
                  <data bit_width="16"> 0.397879236400678 </data>
                  <data bit_width="32"> 0.755690911016546 </data>
                  <data bit_width="128"> 3.6908162701586 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.113589963300394 </data>
                    <data bit_width="8"> 0.197268678956989 </data>
                    <data bit_width="16"> 0.41874581429333 </data>
                    <data bit_width="32"> 0.782818615410978 </data>
                    <data bit_width="128"> 3.6908162701586 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.136427290036366 </data>
                    <data bit_width="8"> 0.209247283229565 </data>
                    <data bit_width="16"> 0.397879236400678 </data>
                    <data bit_width="32"> 0.755690911016546 </data>
                    <data bit_width="128"> 4.62417990399078 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.13935300260848 </data>
                    <data bit_width="8"> 0.237479093362655 </data>
                    <data bit_width="16"> 0.499193691094991 </data>
                    <data bit_width="32"> 0.987219277051084 </data>
                    <data bit_width="128"> 4.51300041745207 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>

            <est_index name="aspect_ratio">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="height">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="width">
              <!-- Dummy yet -->
            </est_index>
          </est_type>

          <est_type name="timing">
            <est_index name="delay">
              <unit> ns </unit>

              <parameters name="default">
                <max>
                  <data bit_width="4"> 9.15 </data>
                  <data bit_width="8"> 12.25 </data>
                  <data bit_width="16"> 18.08 </data>
                  <data bit_width="32"> 31.02 </data>
                  <data bit_width="128"> 100.10 </data>
                </max>
                <min>
                  <data bit_width="4"> 4.84 </data>
                  <data bit_width="8"> 7.60 </data>
                  <data bit_width="16"> 11.66 </data>
                  <data bit_width="32"> 19.65 </data>
                  <data bit_width="128"> 70.00 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 8.13 </data>
                    <data bit_width="8"> 10.29 </data>
                    <data bit_width="16"> 14.77 </data>
                    <data bit_width="32"> 23.42 </data>
                    <data bit_width="128"> 76.03 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 4.84 </data>
                    <data bit_width="8"> 7.60 </data>
                    <data bit_width="16"> 11.66 </data>
                    <data bit_width="32"> 19.65 </data>
                    <data bit_width="128"> 70.00 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 9.15 </data>
                    <data bit_width="8"> 12.25 </data>
                    <data bit_width="16"> 18.08 </data>
                    <data bit_width="32"> 31.02 </data>
                    <data bit_width="128"> 100.10 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>

            <est_index name="delay_fullpath">
              <unit> ns </unit>

              <parameters name="default">
                <max>
                  <data bit_width="4">
                    path	 a	 result	 4.60
                    path	 b	 result	 4.84
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 7.52
                    path	 b	 result	 8.12
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 10.95
                    path	 b	 result	 11.74
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 18.41
                    path	 b	 result	 19.17
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 result	 4.60
                    path	 b	 result	 4.84
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 7.52
                    path	 b	 result	 8.12
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 10.95
                    path	 b	 result	 11.74
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 18.41
                    path	 b	 result	 19.17
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 result	 4.48
                      path	 b	 result	 5.27
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 7.02
                      path	 b	 result	 8.05
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 11.16
                      path	 b	 result	 11.99
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 18.55
                      path	 b	 result	 19.54
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 result	 2.34
                      path	 b	 result	 2.34
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 2.19
                      path	 b	 result	 2.31
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 2.67
                      path	 b	 result	 2.76
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 2.96
                      path	 b	 result	 3.01
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 result	 4.60
                      path	 b	 result	 4.84
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 7.52
                      path	 b	 result	 8.12
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 10.95
                      path	 b	 result	 11.74
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 18.41
                      path	 b	 result	 19.17
                    </data>
                  </priority>
                </typ>
              </parameters>

            </est_index>
          </est_type>

          <est_type name="power">
            <est_index name="static_power">
              <unit> mW </unit>
              <parameters name="default">
                <max>
                  <data bit_width="4"> 54.3717 </data>
                  <data bit_width="8"> 87.0715 </data>
                  <data bit_width="16"> 164.5019 </data>
                  <data bit_width="32"> 302.4174 </data>
                  <data bit_width="128"> 1565.9 </data>
                </max>
                <min>
                  <data bit_width="4"> 40.3143 </data>
                  <data bit_width="8"> 64.8514 </data>
                  <data bit_width="16"> 139.7683 </data>
                  <data bit_width="32"> 266.0890 </data>
                  <data bit_width="128"> 1190.2 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 45.2199 </data>
                    <data bit_width="8"> 79.9842 </data>
                    <data bit_width="16"> 164.5019 </data>
                    <data bit_width="32"> 302.4174 </data>
                    <data bit_width="128"> 1311.8 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 54.3717 </data>
                    <data bit_width="8"> 87.0715 </data>
                    <data bit_width="16"> 154.2068 </data>
                    <data bit_width="32"> 266.0890 </data>
                    <data bit_width="128"> 1565.9 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 40.3143 </data>
                    <data bit_width="8"> 64.8514 </data>
                    <data bit_width="16"> 139.7683 </data>
                    <data bit_width="32"> 267.5416 </data>
                    <data bit_width="128"> 1190.2 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>
          </est_type>

          <est_type name="function_cycle">
            <unit> cycle </unit>

            <est_index name="cycle">
              <parameters name="default">
                <function name="add">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="addu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="addi">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="addiu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cadd">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="caddu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="caddi">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="caddiu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="sub">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="subu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="subd">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="subdu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csub">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csubu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csubd">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csubdu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="inc">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="incu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cinc">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cincu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="dec">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="decu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cdec">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cdecu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="not">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="and">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="or">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="xor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="nor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="nxor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="nand">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmp">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpz">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpzu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="max">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="maxu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="min">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="minu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
              </parameters>
            </est_index>

            <est_index name="latency">

              <parameters name="default">
                <function name="add">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="addu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="addi">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="addiu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cadd">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="caddu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="caddi">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="caddiu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="sub">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="subu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="subd">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="subdu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csub">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csubu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csubd">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csubdu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="inc">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="incu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cinc">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cincu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="dec">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="decu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cdec">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cdecu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="not">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="and">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="or">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="xor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="nor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="nxor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="nand">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmp">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpz">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpzu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="max">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="maxu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="min">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="minu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
              </parameters>
            </est_index>

            <est_index name="throughput">
              <parameters name="default">
                <function name="add">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="addu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="addi">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="addiu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cadd">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="caddu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="caddi">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="caddiu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="sub">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="subu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="subd">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="subdu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csub">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csubu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csubd">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csubdu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="inc">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="incu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cinc">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cincu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="dec">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="decu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cdec">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cdecu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="not">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="and">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="or">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="xor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="nor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="nxor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="nand">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmp">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpz">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpzu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="max">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="maxu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="min">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="minu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
              </parameters>
            </est_index>

          </est_type>

          <est_type name="function_power">
            <!-- Dummy yet -->
          </est_type>
        </library>
      </estimation_data>

      <estimation_method>
         
        <est_type name="shape">

          <est_index name="area">

            <parameters name="default">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for alu(default) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$n = $i;

# numerator 1
$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;

# numerator 2
$nume_2 = &sum(@bit) * &sum(@data);
    
# denominator 1
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;

# denominator 2
$deno_2 = &sum(@bit) * &sum(@bit);
	

# divide by zero
if ($deno_1 == $deno_2) {
    exit(100);
}
if ($n == 0) {
    exit(100);
}


$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;

$ret_data = $a * $ARGV[1] + $b;


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$ret_data += $data[$i];
    }

    return($ret_data);
}

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

           <est_index name="aspect_ratio">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="height">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="width">

             <!-- Dummy yet -->

           </est_index>
		
        </est_type>

        <est_type name="timing">

          <est_index name="delay">

            <parameters name="default">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for alu(default) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$n = $i;

# numerator 1
$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;

# numerator 2
$nume_2 = &sum(@bit) * &sum(@data);
    
# denominator 1
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;

# denominator 2
$deno_2 = &sum(@bit) * &sum(@bit);
	

# divide by zero
if ($deno_1 == $deno_2) {
    exit(100);
}
if ($n == 0) {
    exit(100);
}


$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;

$ret_data = $a * $ARGV[1] + $b;


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$ret_data += $data[$i];
    }

    return($ret_data);
}

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

          <est_index name="delay_fullpath">

            <parameters name="default">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay_fullpath for alu(default) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

$Round = 1;

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression for delay_fullpath
#--------------------------------------------------------------------------#
$n = 0;

while (<TMP>) {

    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>/ ) {

	$bit_width = $1;
	$bit[$n] = $bit_width;
	$n++;
	$_ = <TMP>;
	
	$i = 0;
	while (! /\<\s*\/data\s*\>/ ) {

	    # path 
	    if ( /path\s+(\w+)\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "path\t $1\t $2\t ";
		$delay{$bit_width}[$i] = $3; 
		$i++;
	    }

	    # inport
	    if ( /inport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "inport\t $1\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }

	    # outport
	     if ( /outport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "outport\t $1\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }

	    # internal
	    if ( /internal\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "internal\t ";
		$delay{$bit_width}[$i] = $1;
		$i++;
	    }

	    $_ = <TMP>;
	}
    }
}
close(TMP);

$line_num = $i;



for ($j = 0; $j < $line_num; $j++) {

    # numerator 1
    $nume_1 = 0.00;
    foreach $bit_width (@bit) {
	$nume_1 += $bit_width * $delay{$bit_width}[$j];
    }
    $nume_1 *= $n;

    # numerator 2
    $nume_2 = &sum(@bit);

    $tmp = 0.00;
    foreach $bit_width (@bit) {
	$tmp += $delay{$bit_width}[$j];
    }
    $nume_2 *= $tmp;
    
    # denominator 1
    $deno_1 = 0.00;
    for ($i = 0; $i < $n; $i++) {
	$deno_1 += $bit[$i] * $bit[$i];
    }
    $deno_1 *= $n;

    # denominator 2
    $deno_2 = &sum(@bit) * &sum(@bit);
    

    # divide by zero
    if ($deno_1 == $deno_2) {
	exit(100);
    }
    if ($n == 0) {
	exit(100);
    }


    # a
    $a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);

    # b
    $tmp = 0.00;
    foreach $bit_width (@bit) {
	$tmp += $delay{$bit_width}[$j];
    }
    $b = ($tmp - $a * &sum(@bit)) / $n;
    
    $ret_data = $a * $ARGV[1] + $b;
    $ret_data = &data_round($ret_data, $Round);
    
    print "$line{$bit[0]}[$j] $ret_data\n";
}

exit(0);


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $return_data );

    $return_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$return_data += $data[$i];
    }

    return($return_data);
}


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

        </est_type>

        <est_type name="power">

          <est_index name="static_power">

            <parameters name="default">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for alu(default) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

        </est_type>

        <est_type name="function_cycle">
          <est_index name="cycle">
            <parameters name="default">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
                ]]>
              </script>
            </parameters>
          </est_index>

          <est_index name="latency">
            <parameters name="default">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
                ]]>
              </script>
            </parameters>
          </est_index>

          <est_index name="throughput">
            <parameters name="default">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
                ]]>
              </script>
            </parameters>
          </est_index>
        </est_type>

        <est_type name="function_power">

        </est_type>

    
      </estimation_method>

    </estimation>

  </model>
</FHM>
