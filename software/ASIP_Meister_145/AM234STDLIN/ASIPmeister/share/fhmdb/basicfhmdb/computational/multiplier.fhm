<?xml version="1.0" encoding="UTF-8" ?>
<!-- Modified by A.Higuchi on 2007/11/30 -->
<!-- Modified by T.Hamabe on 2006/12/05 -->
<!-- Modified by T.Hamabe on 2006/11/30 -->
<FHM>
  <model_name> multiplier </model_name>

  <model>
    <design_level> behavior </design_level>
    <version> 1.0 </version>
    <author> <![CDATA[ Tak. Tokihisa ]]> </author>
    <affiliation> <![CDATA[ Osaka Univ. ]]> </affiliation>
    <model_info> <![CDATA[
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                %
%    Copyright 2008 ASIP Solutions, Inc. All rights reserved.    %
%              Copyright 2002-2005 PEAS Project                  %
%                                                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
]]> </model_info>

    <parameter>
      <parameter_value key="bit_width">
        <value> 4 </value>
        <value> 8 </value>
        <value> 12 </value>
        <value> 16 </value>
        <value> 20 </value>
        <value> 24 </value>
        <value> 28 </value>
        <value> 32 </value>
        <value> 36 </value>
        <value> 40 </value>
        <value> 44 </value>
        <value> 48 </value>
        <value> 52 </value>
        <value> 56 </value>
        <value> 60 </value>
        <value> 64 </value>
        <value> 128 </value>
      </parameter_value>
      <parameter_value key="algorithm">
        <value> default </value>
        <value> seq </value>
        <value> array </value>
      </parameter_value>
      <parameter_value key="data_type">
        <value> unsigned </value>
        <value> abs </value>
        <value> two_complement </value>
      </parameter_value>
    </parameter>

    <function_description>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates multiplier function definition in behavior level
# parameter : bit_width algorithm data_type

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$algorithm = $ARGV[1];
$data_type = $ARGV[2];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ( $algorithm eq "seq" ) {
    $cycle = "multi";
} elsif ( $algorithm eq "default" || $algorithm eq "array" ) {
    $cycle = "single";
} else {
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w = $bit_width - 1;
$w2 = 2*$bit_width -1;


if ("$data_type" eq "two_complement"){
    print <<FHM_DL_TWOCOMP_BASIC_FUNC
twoscomp mul(twoscomp a, towscomp b);
unsigned mul(unsigned a, unsigned b);
FHM_DL_TWOCOMP_BASIC_FUNC
}
elsif ("$data_type" eq "abs"){
    print <<FHM_DL_ABS_BASIC_FUNC
signmagn mul(signmagn a, signmagn b);
FHM_DL_ABS_BASIC_FUNC
}
elsif ("$data_type" eq "unsigned"){
    print <<FHM_DL_UN_BASIC_FUNC
unsigned mul(unsigned a, unsigned b);
FHM_DL_UN_BASIC_FUNC
}
{
    print <<FHM_DL_FUNC

/** $bit_width-bit $data_type multiplier */
model ${data_type}_mul${bit_width}{
  port{
    clock clock;
    in  async_reset, reset, start;
    in  a[$w:0], b[$w:0];
    in  mode;
    out result[$w:0];
    out fin;
  }
  default_control{
    reset = 0;
    start = 0;
  }

  /** no operation */
  function nop : idle{
    control{
      in start, reset;
    }
    protocol{
      [start == 0 && reset == 0]{
      }
    }
  }

  /** reset */
  function reset : reset{
    control{
      in reset;
    }
    protocol{
      [reset == 1]{
      }
    }
  }

FHM_DL_FUNC
}

if ("$data_type" eq "two_complement"){
    &print_func("signed multiplication", "mul", "twoscomp", 1, 1);
    &print_func("unsigned multiplication", "mulu", "unsigned", 1, 0);
}
elsif ("$data_type" eq "abs"){
    &print_func("abs multiplication", "mula", "signmagn", 0);
}
elsif ("$data_type" eq "unsigned"){
    &print_func("unsigned multiplication", "mulu", "unsigned", 0);
}
print "}\n";
exit (0);

# ---------------------------------

sub print_func{
    $comment   = $_[0];
    $func_name = $_[1];
    $d_type    = $_[2];
    $mode      = $_[3];
    $mode_val  = $_[4];

    {
	print <<FHM_DL_SUB_FUNC1
  /** $comment */
  function ${func_name}{
    input{
      $d_type a, b;
    }
    output{
      $d_type result = mul(a, b);
    }
FHM_DL_SUB_FUNC1
    }
    if ($mode == 1){
	print <<FHM_DL_SUB_SIGNED
    control{
      in mode;
      out fin;
    }
    protocol{
      [mode == $mode_val]{
	valid result;
	fin = 1;
      }
    }
  }

FHM_DL_SUB_SIGNED
    }
    else{
	print <<FHM_DL_SUB_NOSIGNED
    control{
      out fin;
    }
    protocol{
      [true]{
	valid result;
	fin = 1;
      }
    }
  }

FHM_DL_SUB_NOSIGNED
    }
}
exit (0);
        ]]>
      </script>
    </function_description>

    <function_conv>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates multiplier function definition in behavior level
# parameter : bit_width algorithm data_type

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$algorithm = $ARGV[1];
$data_type = $ARGV[2];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

{
print <<FHM_DL_NOP_RESET
/** no operation */
function nop{
  input{
  }

  output{
  }

  control{
    in bit start;
    in bit reset;
  }

  protocol{
    single_cycle_protocol{
      start = '0';
      reset = '0';
    }
  }
}

/** reset */
function reset{
  input{
  }

  output{
  }

  control{
    in bit reset;
  }

  protocol{
    single_cycle_protocol{
      reset = '1';
    }
  }
}

FHM_DL_NOP_RESET
}

if ("$algorithm" eq "seq"){
    $multi = 1;
}
else{
    $multi = 0;
}

$w = $bit_width - 1;
$w2 = $bit_width * 2 - 1;

if ("$data_type" eq "two_complement"){
    &print_func("signed multiplication", "mul", 1, 1);
    &print_func("unsigned multiplication", "mulu", 1, 0);
}
elsif ("$data_type" eq "abs"){
    &print_func("abs multiplication", "mula", 0);
}
elsif ("$data_type" eq "unsigned"){
    &print_func("unsigned multiplication", "mulu", 0);
}
exit (0);

# ---------------------------------

sub print_func{
  $comment   = $_[0];
  $func_name = $_[1];
  $mode      = $_[2];
  $mode_val  = $_[3];

  {
    print <<FHM_DL_FUNC1
/** $comment */
function ${func_name}{
  input{
    bit [$w:0] a;
    bit [$w:0] b;
  }

  output{
    bit [$w2:0] result;
  }

  control{
FHM_DL_FUNC1
  }

  if ($mode == 1){
    print "    in  bit mode;\n";
  }

  if ($multi == 1){
  print <<FHM_DL_MULTI1
    in  bit start;
    in  bit clear;
    out bit fin;
FHM_DL_MULTI1
}

{
  print <<FHM_DL_FUNC2
  }

  protocol{
FHM_DL_FUNC2
  }

  if ($multi == 1){
    {
      print <<FHM_DL_MULTI2
    multi_cycle_protocol{
      start_signal  start = '1';
      fin_signal    fin = '1';
      cancel_signal clear = '1';
FHM_DL_MULTI2
    }
    if ($mode == 1){
      print "\n";
    }
  }
  elsif ($mode == 1){
    print "    single_cycle_protocol{\n";
  }

  if ($mode == 1){
    print "      mode = '$mode_val';\n";
  }

  if ($mode == 1 || $multi == 1){
      print "    }\n";
  }
  print <<FHM_DL_FUNC3
  }
}

FHM_DL_FUNC3
}
        ]]>
      </script>
    </function_conv>

    <function_port>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates adder pultiplier infomation in behavior level
# parameter : bit_width algorithm data_type

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$algorithm = $ARGV[1];
$data_type = $ARGV[2];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$algorithm" ne "default" && "$algorithm" ne "seq" && "$algorithm" ne "array"){
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w = $bit_width-1;
$w2 = $bit_width * 2 - 1;

print <<FHM_DL_PORT;
clock	in	bit		clock
async_reset	in	bit		reset
reset	in	bit		ctrl
a	in	bit_vector   $w   0	data
b	in	bit_vector   $w   0	data
mode	in	bit	       	mode
start	in	bit		ctrl
clear	in	bit		ctrl
result	out	bit_vector   $w2   0	data
fin	out	bit	       	ctrl
FHM_DL_PORT
exit (0);
        ]]>
      </script>
    </function_port>

    <design>
      <design_lang> vhdl </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates multiplier instance in behavior level
# parameter : instance_name bit_width algorithm data_type

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width algorithm data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$algorithm     = $ARGV[2];
$data_type     = $ARGV[3];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$b2 = 2 * $bit_width;
$w = $bit_width - 1;
$w2 = $b2 -1;
$w3 = ($bit_width + 1) * 2 - 1;

if ("$data_type" eq "two_complement"){
    $mode_comment = "\'1\' for signed multiplication\n--              '0' for unsigned multiplication";
}
else{
    $mode_comment = "(ignore)";
}

print <<FHM_DL_INSTANCE;
-- Module     : $bit_width-bit Multiplier
-- Feature    : 
-- References : Start from scratch
-- Author     : Designed by T.Morifuji (c)1996,1999
--              Modefied by Tak. Tokihisa (c)2002
-- Version    : 1.1  :

-- Functionality : behavioral level
--  port
--   clock   : (ignore)
--   async_reset   : (ignore)
--   reset   : (ignore)
--   a       : multiplicand
--   b       : multiplier
--   mode    : $mode_comment
--   start   : (ignore)
--   clear   : (ignore)
--   result  : multiplied result
--   fin     : '1' when operation is over

-- Comment :

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_signed.all;

entity $instance_name is
  port (clock  : in std_logic;
        async_reset  : in std_logic;
        reset  : in std_logic;
        a, b   : in std_logic_vector($w downto 0);
        mode   : in std_logic;
        start  : in std_logic;
	clear  : in std_logic;
        result : out std_logic_vector($w2 downto 0);
        fin    : out std_logic);
end $instance_name;

architecture behavior of $instance_name is
begin
  process (a, b, mode)
    variable tmp_a, tmp_b : std_logic_vector($bit_width downto 0);
    variable tmp_result   : std_logic_vector($w3 downto 0);
  begin
FHM_DL_INSTANCE

if ("$data_type" eq "two_complement"){
    print <<FHM_DL_INSTANCE2;
    tmp_a := (a($w) and mode) & a;
    tmp_b := (b($w) and mode) & b;
FHM_DL_INSTANCE2
}
elsif("$data_type" eq "abs"){
    print <<FHM_DL_INSTANCE3;
    if (a($w) = '1') then
      tmp_a := '0' & not a + 1;
    else
      tmp_a := '0' & a;
    end if;
    if (b($w) = '1') then
      tmp_b := '0' & not b + 1;
    else
      tmp_b := '0' & b;
    end if;
FHM_DL_INSTANCE3
}
elsif ("$data_type" eq"unsigned"){
    print <<FHM_DL_INSTANCE4;
    tmp_a := '0' & a;
    tmp_b := '0' & b;
FHM_DL_INSTANCE4
}
{
	print <<FHM_DL_INSTANCE5

    tmp_result := tmp_a * tmp_b;
    result <= tmp_result($w2 downto 0);
  end process;

  fin <= '1' and not start;
end behavior;
FHM_DL_INSTANCE5
}
exit (0);
          ]]>
        </script>
      </instance>

      <entity></entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>

      <synthesis></synthesis>
    </design>

    <design>
      <design_lang> Verilog </design_lang>
                                                                                
      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates multiplier instance in behavior level
# parameter : instance_name bit_width algorithm data_type

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width algorithm data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$algorithm     = $ARGV[2];
$data_type     = $ARGV[3];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$b2 = 2 * $bit_width;
$w = $bit_width - 1;
$w2 = $b2 -1;
$w3 = ($bit_width + 1) * 2 - 1;

if ("$data_type" eq "two_complement"){
    $mode_comment = "\'1\' for signed multiplication\n//              '0' for unsigned multiplication";
}
else{
    $mode_comment = "(ignore)";
}

print <<FHM_DL_INSTANCE;
// Module     : $bit_width-bit Multiplier
// Feature    : 
// References : Start from scratch
// Author     : Designed by T.Morifuji (c)1996,1999
//              Modefied by Tak. Tokihisa (c)2002
// Version    : 1.1  :
\n
// Functionality : behavioral level
//  port
//   clock   : (ignore)
//   async_reset   : (ignore)
//   reset   : (ignore)
//   a       : multiplicand
//   b       : multiplier
//   mode    : $mode_comment
//   start   : (ignore)
//   clear   : (ignore)
//   result  : multiplied result
//   fin     : '1' when operation is over
\n
// Comment :
\n
module $instance_name (
  clock       ,
  async_reset ,
  reset       ,
  a           ,
  b           ,
  mode        ,
  start       ,
  clear       ,
  result      ,
  fin         ) ;
\n
input         clock       ;
input         async_reset ;
input         reset       ;
input signed [$w:0] a, b        ;
input         mode        ;
input         start       ;
input	      clear       ;
output signed [$w2:0] result      ;
output        fin         ;
\n
wire         clock       ;
wire         async_reset ;
wire         reset       ;
wire signed [$w:0] a, b        ;
wire         mode        ;
wire         start       ;
wire	     clear       ;
reg signed  [$w2:0] result      ;
\n
reg signed [$bit_width:0] tmp_a, tmp_b ;
reg signed [$w3:0] tmp_result   ;
\n
always@ (a or b or mode)
begin
FHM_DL_INSTANCE

if ("$data_type" eq "two_complement"){
    print <<FHM_DL_INSTANCE2;
    tmp_a = {(a[$w] & mode) , a};
    tmp_b = {(b[$w] & mode) , b};
FHM_DL_INSTANCE2
}
elsif("$data_type" eq "abs"){
    print <<FHM_DL_INSTANCE3;
    if (a[$w] == 1'b1)
      tmp_a = {1'b0 , ~a} + 1'b1;
    else
      tmp_a = {1'b0 , a};
\n
    if (b[$w] == 1'b1)
      tmp_b = {1'b0 , ~b} + 1'b1;
    else
      tmp_b = {1'b0 , b};
\n
FHM_DL_INSTANCE3
}
elsif ("$data_type" eq"unsigned"){
    print <<FHM_DL_INSTANCE4;
    tmp_a = {1'b0 , a};
    tmp_b = {1'b0 , b};
FHM_DL_INSTANCE4
}
{
	print <<FHM_DL_INSTANCE5

    tmp_result = tmp_a * tmp_b;
    result = tmp_result[$w2:0];
end

assign fin = 1'b1 & ~ start;
\n
endmodule
FHM_DL_INSTANCE5
}
exit (0);
          ]]>
        </script>
      </instance>
                                                                                
      <entity></entity>
                                                                                
      <testvector></testvector>
                                                                                
      <synthesis></synthesis>
    </design>

    <design>
      <design_lang> SystemC Header </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates multiplier instance in behavior level
# parameter : name_space instance_name bit_width algorithm data_type

if ($#ARGV != 4){
    print "number of parameters is wrong.\n";
    print "usage : this_script name_space instance_name bit_width algorithm data_type\n";
    exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];
$algorithm     = $ARGV[3];
$data_type     = $ARGV[4];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$b2 = 2 * $bit_width;

if ( $bit_width <= 64 ) {
    $input_type = "sc_dt::sc_uint<$bit_width>";
} else {
    $input_type = "sc_dt::sc_biguint<$bit_width>";
}

if ( $b2 <= 64 ) {
    $output_type = "sc_dt::sc_uint<$b2>";
} else {
    $output_type = "sc_dt::sc_biguint<$b2>";
}

$w = $bit_width - 1;
$w2 = $b2 -1;
$delay = $bit_width + 2;

if ("$data_type" eq "two_complement"){
    $mode_comment = "\'1\' for signed multiplication\n//              '0' for unsigned multiplication";
}
else{
    $mode_comment = "(ignore)";
}

$macro = "__" . uc($name_space) . "_" . uc($instance_name) . "_H__";

{
print <<FHM_DL_INSTANCE;
#ifndef $macro
#define $macro 1

// Module     : $bit_width-bit Multiplier
// Feature    : 
// References : Start from scratch
// Author     : Designed by T.Morifuji (c)1996,1999
//              Modefied by Tak. Tokihisa (c)2002
// Version    : 1.1  :

// Functionality : behavioral level
//  port
//   clock   : (ignore)
//   async_reset   : (ignore)
//   reset   : (ignore)
//   a       : multiplicand
//   b       : multiplier
//   mode    : $mode_comment
//   start   : (ignore)
//   clear   : (ignore)
//   result  : multiplied result
//   fin     : '1' when operation is over

// Comment :

#include <systemc>

namespace $name_space {
  SC_MODULE($instance_name) {
    sc_core::sc_in< bool > clock;
    sc_core::sc_in< bool > async_reset;
    sc_core::sc_in< bool > reset;
    sc_core::sc_in< $input_type > a, b;
    sc_core::sc_in< bool > mode;
    sc_core::sc_in< bool > start;
    sc_core::sc_in< bool > clear;
    sc_core::sc_out< $output_type > result;
    sc_core::sc_out< bool > fin;
FHM_DL_INSTANCE
}

if ( $algorithm eq "seq" ) {
print <<FHM_DL_INSTANCE

    sc_core::sc_signal< bool > tmp_fin;
    int count;
FHM_DL_INSTANCE
}

{
print <<FHM_DL_INSTANCE

    SC_CTOR($instance_name) :
      clock("clock"),
      async_reset("async_reset"),
      reset("reset"),
      a("a"), b("b"),
      mode("mode"),
      start("start"),
      clear("clear"),
      result("result"),
      fin("fin")
    {
FHM_DL_INSTANCE
}

if ( $algorithm eq "seq" ) {
print <<FHM_DL_INSTANCE
      SC_METHOD(calc);
      sensitive << clock.pos() << async_reset.pos();

      SC_METHOD(proc_fin);
      sensitive << start << tmp_fin;
FHM_DL_INSTANCE
} else {
print <<FHM_DL_INSTANCE
      SC_METHOD(init);

      SC_METHOD(calc);
      sensitive << a << b << mode;
FHM_DL_INSTANCE
}

{
print <<FHM_DL_INSTANCE
    }

    void init();
    void calc();
FHM_DL_INSTANCE
}

if ( $algorithm eq "seq" ) {
print <<FHM_DL_INSTANCE
    void proc_fin();
FHM_DL_INSTANCE
}

{
print <<FHM_DL_INSTANCE
  };
};

#endif // $macro
FHM_DL_INSTANCE
}

exit (0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <design>
      <design_lang> SystemC Program </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates multiplier instance in behavior level
# parameter : name_space instance_name bit_width algorithm data_type

if ($#ARGV != 4){
    print "number of parameters is wrong.\n";
    print "usage : this_script name_space instance_name bit_width algorithm data_type\n";
    exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];
$algorithm     = $ARGV[3];
$data_type     = $ARGV[4];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$b2 = 2 * $bit_width;
$b3 = 2 * ($bit_width + 1);

if ( $bit_width <= 64 ) {
    $input_type = "sc_dt::sc_uint<$bit_width>";
} else {
    $input_type = "sc_dt::sc_biguint<$bit_width>";
}

if ( $b2 <= 64 ) {
    $output_type = "sc_dt::sc_uint<$b2>";
} else {
    $output_type = "sc_dt::sc_biguint<$b2>";
}

if ( $bit_width + 1 <= 64 ) {
    $tmp_input_type = "sc_dt::sc_int<" . ($bit_width + 1) . ">";
} else {
    $tmp_input_type = "sc_dt::sc_bigint<" . ($bit_width + 1) . ">";
}

if ( $b3 <= 64 ) {
    $tmp_result_type = "sc_dt::sc_int<$b3>";
} else {
    $tmp_result_type = "sc_dt::sc_bigint<$b3>";
}

$w = $bit_width - 1;
$w2 = $b2 -1;
$w3 = $b3 - 1;
$delay = $bit_width + 2;

if ("$data_type" eq "two_complement"){
    $mode_comment = "\'1\' for signed multiplication\n//              '0' for unsigned multiplication";
}
else{
    $mode_comment = "(ignore)";
}

{
print <<FHM_DL_INSTANCE
#include "${instance_name}.h"

// Module     : $bit_width-bit Multiplier
// Feature    : 
// References : Start from scratch
// Author     : Designed by T.Morifuji (c)1996,1999
//              Modefied by Tak. Tokihisa (c)2002
// Version    : 1.1  :

// Functionality : behavioral level
//  port
//   clock   : 
//   async_reset   : 
//   reset   : 
//   a       : multiplicand
//   b       : multiplier
//   mode    : $mode_comment
//   start   : 
//   clear   : 
//   result  : multiplied result
//   fin     : '1' when operation is over

// Comment :

void ${name_space}::${instance_name}::init()
{
FHM_DL_INSTANCE
}

if ( $algorithm eq "seq" ) {
    print <<FHM_DL_INSTANCE
  result.write( 0 );
  tmp_fin.write( false );
  count = 0;
FHM_DL_INSTANCE
} else {
    print <<FHM_DL_INSTANCE
  fin.write( true );
FHM_DL_INSTANCE
}

{
    print <<FHM_DL_INSTANCE
}

FHM_DL_INSTANCE
}

if ( $algorithm eq "seq" ) {
    {
    print <<FHM_DL_INSTANCE
void ${name_space}::${instance_name}::proc_fin()
{
  if( start.read() ){
    fin.write( false );
  }else{
    fin.write( tmp_fin.read() );
  }
}

void ${name_space}::${instance_name}::calc()
{
  if ( async_reset.read() ) {
    init();
  } else {
    if ( reset.read() || clear.read() ) {
      init();
    } else if( start.read() ) {
      tmp_fin.write( false );
      count = 1;
    } else if ( count > 0 ) {
      count++;

      if ( count == $delay ) {
        $tmp_input_type tmp_a, tmp_b;
        $tmp_result_type tmp_result;

FHM_DL_INSTANCE
    }

    if ("$data_type" eq "two_complement"){
    print <<FHM_DL_INSTANCE2;
        tmp_a = ((a.read()[$w] & mode.read()) , a.read());
        tmp_b = ((b.read()[$w] & mode.read()) , b.read());
FHM_DL_INSTANCE2
    } elsif("$data_type" eq "abs") {
    print <<FHM_DL_INSTANCE3;
        if ( a.read()[$w] == 1 )
          tmp_a = - a.read();
        else
          tmp_a = a.read();

        if ( b.read()[$w] = 1 )
          tmp_b = - b.read();
        else
          tmp_b = b.read();
FHM_DL_INSTANCE3
    } elsif ("$data_type" eq"unsigned") {
    print <<FHM_DL_INSTANCE4;
        tmp_a = a.read();
        tmp_b = b.read();
FHM_DL_INSTANCE4
    }

    {
    print <<FHM_DL_INSTANCE5
        tmp_result = tmp_a * tmp_b;

        tmp_fin.write( true );
        result.write( ${input_type}(tmp_result($w2, 0)) );
        count = 0;
      }
    }
  }
}

FHM_DL_INSTANCE5
    }
} else {
    {
    print <<FHM_DL_INSTANCE
void ${name_space}::${instance_name}::calc()
{
  $tmp_input_type tmp_a, tmp_b;

FHM_DL_INSTANCE
    }

    if ("$data_type" eq "two_complement"){
        print <<FHM_DL_INSTANCE2;
  tmp_a = ((a.read()[$w] & mode.read()) , a.read());
  tmp_b = ((b.read()[$w] & mode.read()) , b.read());
FHM_DL_INSTANCE2
    } elsif("$data_type" eq "abs") {
        print <<FHM_DL_INSTANCE3;
  if (a.read()[$w] == 1)
    tmp_a = - a.read();
  else
    tmp_a = a.read();

  if (b.read()[$w] = 1)
    tmp_b = - b.read();
  else
    tmp_b = b.read();
FHM_DL_INSTANCE3
    } elsif ("$data_type" eq"unsigned") {
        print <<FHM_DL_INSTANCE4;
  tmp_a = a.read();
  tmp_b = b.read();
FHM_DL_INSTANCE4
    }

    {
    print <<FHM_DL_INSTANCE

  result.write( ${input_type}(tmp_a * tmp_b)($w, 0) );
}
FHM_DL_INSTANCE
    }
}
exit (0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <estimation>
      <estimation_data>
        <library name="OSAKA">

          <est_type name="shape">
            <est_index name="area">
              <unit> mm2 </unit>
              <translate>
                <translate_value key="gate"> 4201.68 </translate_value>
                <translate_value key="mm2">  1 </translate_value>
              </translate>

              <parameters name="unsigned">
                <max>
                  <data bit_width="4"> 0.299954045286647 </data>
                  <data bit_width="8"> 0.73309700262752 </data>
                  <data bit_width="16"> 2.59570511462082 </data>
                  <data bit_width="32"> 9.61999965632794 </data>
                  <data bit_width="128"> 182.99043477847 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.0446700243712039 </data>
                  <data bit_width="8"> 0.190987825584052 </data>
                  <data bit_width="16"> 0.384135431541669 </data>
                  <data bit_width="32"> 0.746129886854782 </data>
                  <data bit_width="128"> 3.21349417828107 </data>
                </min>
                <typ>
                </typ>
              </parameters>

              <parameters name="abs">
                <max>
                  <data bit_width="4"> 0.299954045286647 </data>
                  <data bit_width="8"> 0.73309700262752 </data>
                  <data bit_width="16"> 2.59570511462082 </data>
                  <data bit_width="32"> 9.61999965632794 </data>
                  <data bit_width="128"> 182.99043477847 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.0446700243712039 </data>
                  <data bit_width="8"> 0.190987825584052 </data>
                  <data bit_width="16"> 0.384135431541669 </data>
                  <data bit_width="32"> 0.746129886854782 </data>
                  <data bit_width="128"> 3.21349417828107 </data>
                </min>
                <typ>
                </typ>
              </parameters>

              <parameters name="two_complement">
                <max>
                  <data bit_width="4"> 0.299954045286647 </data>
                  <data bit_width="8"> 0.73309700262752 </data>
                  <data bit_width="16"> 2.59570511462082 </data>
                  <data bit_width="32"> 9.61999965632794 </data>
                  <data bit_width="128"> 182.99043477847 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.0446700243712039 </data>
                  <data bit_width="8"> 0.190987825584052 </data>
                  <data bit_width="16"> 0.384135431541669 </data>
                  <data bit_width="32"> 0.746129886854782 </data>
                  <data bit_width="128"> 3.21349417828107 </data>
                </min>
                <typ>
                </typ>
              </parameters>
            </est_index>

            <est_index name="aspect_ratio">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="height">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="width">
              <!-- Dummy yet -->
            </est_index>
          </est_type>

          <est_type name="timing">
            <est_index name="delay">
              <unit> ns </unit>

              <parameters name="unsigned">
                <max>
                  <data bit_width="4"> 13.34 </data>
                  <data bit_width="8"> 25.20 </data>
                  <data bit_width="16"> 48.97 </data>
                  <data bit_width="32"> 103.68 </data>
                  <data bit_width="128"> 428.70 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.76 </data>
                  <data bit_width="8"> 1.91 </data>
                  <data bit_width="16"> 1.98 </data>
                  <data bit_width="32"> 2.07 </data>
                  <data bit_width="128"> 2.93 </data>
                </min>
                <typ>
                </typ>
              </parameters>

              <parameters name="abs">
                <max>
                  <data bit_width="4"> 13.34 </data>
                  <data bit_width="8"> 25.20 </data>
                  <data bit_width="16"> 48.97 </data>
                  <data bit_width="32"> 103.68 </data>
                  <data bit_width="128"> 428.70 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.76 </data>
                  <data bit_width="8"> 1.91 </data>
                  <data bit_width="16"> 1.98 </data>
                  <data bit_width="32"> 2.07 </data>
                  <data bit_width="128"> 2.93 </data>
                </min>
                <typ>
                </typ>
              </parameters>

              <parameters name="two_complement">
                <max>
                  <data bit_width="4"> 13.34 </data>
                  <data bit_width="8"> 25.20 </data>
                  <data bit_width="16"> 48.97 </data>
                  <data bit_width="32"> 103.68 </data>
                  <data bit_width="128"> 428.70 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.76 </data>
                  <data bit_width="8"> 1.91 </data>
                  <data bit_width="16"> 1.98 </data>
                  <data bit_width="32"> 2.07 </data>
                  <data bit_width="128"> 2.93 </data>
                </min>
                <typ>
                </typ>
              </parameters>
            </est_index>

            <est_index name="delay_fullpath">
            <!-- Dummy yet -->
            </est_index>
          </est_type>

          <est_type name="power">
            <est_index name="static_power">
              <unit> mW </unit>
              <parameters name="unsigned">
                <max>
                  <data bit_width="4"> 81.8238 </data>
                  <data bit_width="8"> 266.7147 </data>
                  <data bit_width="16"> 1098.4 </data>
                  <data bit_width="32"> 4375 </data>
                  <data bit_width="128"> 88990 </data>
                </max>
                <min>
                  <data bit_width="4"> 4.5194 </data>
                  <data bit_width="8"> 6.7509 </data>
                  <data bit_width="16"> 12.5875 </data>
                  <data bit_width="32"> 23.0052 </data>
                  <data bit_width="128"> 96.6946 </data>
                </min>
                <typ>
                </typ>
              </parameters>

              <parameters name="abs">
                <max>
                  <data bit_width="4"> 81.8238 </data>
                  <data bit_width="8"> 266.7147 </data>
                  <data bit_width="16"> 1098.4 </data>
                  <data bit_width="32"> 4375 </data>
                  <data bit_width="128"> 88990 </data>
                </max>
                <min>
                  <data bit_width="4"> 4.5194 </data>
                  <data bit_width="8"> 6.7509 </data>
                  <data bit_width="16"> 12.5875 </data>
                  <data bit_width="32"> 23.0052 </data>
                  <data bit_width="128"> 96.6946 </data>
                </min>
                <typ>
                </typ>
              </parameters>

              <parameters name="two_complement">
                <max>
                  <data bit_width="4"> 81.8238 </data>
                  <data bit_width="8"> 266.7147 </data>
                  <data bit_width="16"> 1098.4 </data>
                  <data bit_width="32"> 4375 </data>
                  <data bit_width="128"> 88990 </data>
                </max>
                <min>
                  <data bit_width="4"> 4.5194 </data>
                  <data bit_width="8"> 6.7509 </data>
                  <data bit_width="16"> 12.5875 </data>
                  <data bit_width="32"> 23.0052 </data>
                  <data bit_width="128"> 96.6946 </data>
                </min>
                <typ>
                </typ>
              </parameters>
            </est_index>
          </est_type>

          <est_type name="function_cycle">
            <!-- Dummy yet -->
          </est_type>

          <est_type name="function_power">
            <!-- Dummy yet -->
          </est_type>
        </library>
      </estimation_data>

      <estimation_method>
         
        <est_type name="shape">

          <est_index name="area">

            <parameters name="abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

           <est_index name="aspect_ratio">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="height">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="width">

             <!-- Dummy yet -->

           </est_index>
		
        </est_type>

        <est_type name="timing">

          <est_index name="delay">

            <parameters name="abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

          <est_index name="delay_fullpath">

          </est_index>

        </est_type>

        <est_type name="power">

          <est_index name="static_power">

            <parameters name="abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

        </est_type>

        <est_type name="function_cycle">

        </est_type>

        <est_type name="function_power">

        </est_type>

    
      </estimation_method>

    </estimation>
  </model>

  <model>
    <design_level> synthesis </design_level>
    <version> 1.0 </version>
    <author> <![CDATA[ Tak. Tokihisa ]]> </author>
    <affiliation> <![CDATA[ Osaka Univ. ]]> </affiliation>
    <model_info> <![CDATA[
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                %
%    Copyright 2008 ASIP Solutions, Inc. All rights reserved.    %
%              Copyright 2002-2005 PEAS Project                  %
%                                                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
]]> </model_info>

    <parameter>
      <parameter_value key="bit_width">
        <value> 4 </value>
        <value> 8 </value>
        <value> 12 </value>
        <value> 16 </value>
        <value> 20 </value>
        <value> 24 </value>
        <value> 28 </value>
        <value> 32 </value>
        <value> 36 </value>
        <value> 40 </value>
        <value> 44 </value>
        <value> 48 </value>
        <value> 52 </value>
        <value> 56 </value>
        <value> 60 </value>
        <value> 64 </value>
        <value> 128 </value>
      </parameter_value>
      <parameter_value key="algorithm">
        <value> default </value>
        <value> seq </value>
        <value> array </value>
      </parameter_value>
      <parameter_value key="adder_algorithm">
        <value> default </value>
      </parameter_value>
      <parameter_value key="data_type">
        <value> unsigned </value>
        <value> abs </value>
        <value> two_complement </value>
      </parameter_value>
    </parameter>

    <function_description>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates AUTOGEN description for multiplier in synthesis level
# parameter : bit_width algorithm adder_algorithm data_type

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$algorithm = $ARGV[1];
$add_algo  = $ARGV[2];
$data_type = $ARGV[3];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$algorithm" eq "default"){
    $cycle = "single";
    $add_str = "";
}
elsif ("$algorithm" eq "seq"){
    $cycle = "multi";
    $add_str = ": use $add_algo adder algorithm";
}
elsif ("$algorithm" eq "array"){
    $cycle = "single";
    $add_str = ": use $add_algo adder algorithm";
}
else{
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$add_algo" ne "default"){
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

if ("$algorithm" eq "default"){
    print <<FHM_DL_WARNING;
/* "adder_algorithm" value is ignored when "default" is selected as "algorithm". */

FHM_DL_WARNING
}

$w = $bit_width - 1;

if ("$data_type" eq "two_complement"){
    print <<FHM_DL_TWOCOMP_BASIC_FUNC
twoscomp mul(twoscomp a, towscomp b);
unsigned mul(unsigned a, unsigned b);
FHM_DL_TWOCOMP_BASIC_FUNC
}
elsif ("$data_type" eq "abs"){
    print <<FHM_DL_ABS_BASIC_FUNC
signmagn mul(signmagn a, signmagn b);
FHM_DL_ABS_BASIC_FUNC
}
elsif ("$data_type" eq "unsigned"){
    print <<FHM_DL_UN_BASIC_FUNC
unsigned mul(unsigned a, unsigned b);
FHM_DL_UN_BASIC_FUNC
}
{
    print <<FHM_DL_FUNC;
/** $bit_width-bit $data_type $cycle cycle $algorithm multiplier $add_str */
model ${data_type}_mul${bit_width}{
  port{
    clock clock;
    in  async_reset, reset, start;
    in  a[$w:0], b[$w:0];
    in  mode;
    out result[$w:0];
    out fin;
  }
FHM_DL_FUNC
}

if ($cycle eq "multi"){
    print <<FHM_DL_FUNC;
  default_control{
    reset = 0;
    start = 0;
  }

  /** no operation */
  function nop : idle{
    control{
      in start, reset;
    }
    protocol{
      [start == 0 && reset == 0]{
      }
    }
  }

  /** reset */
  function reset : reset{
    control{
      in reset;
    }
    protocol{
      [reset == 1]{
      }
    }
  }

FHM_DL_FUNC
}
else{
    print <<FHM_DL_FUNC;
  /** reset : no action for single cycle model */
  function reset : reset{
  }

FHM_DL_FUNC
}

if ("$algorithm" eq "seq"){
    $multi = 1;
}
else{
    $multi = 0;
}

if ("$data_type" eq "two_complement"){
    &print_func("signed multiplication", "mul", "twoscomp", 1, 1);
    &print_func("unsigned multiplication", "mulu", "unsigned", 1, 0);
}
elsif ("$data_type" eq "abs"){
    &print_func("abs multiplication", "mula", "signmagn", 0);
}
elsif ("$data_type" eq "unsigned"){
    &print_func("unsigned multiplication", "mulu", "unsigned", 0);
}
print "}\n";
exit (0);

# ---------------------------------

sub print_func{
    $comment   = $_[0];
    $func_name = $_[1];
    $d_type    = $_[2];
    $mode      = $_[3];
    $mode_val  = $_[4];

    {
	print <<FHM_DL_SUB_FUNC1
  /** $comment */
  function ${func_name}{
    input{
      $d_type a, b;
    }
    output{
      $d_type result = mul(a, b);
    }
FHM_DL_SUB_FUNC1
    }
    if ($mode == 1){
        {
	print <<FHM_DL_SUB_SIGNED_1
    control{
      in mode;
      out fin;
    }
    protocol{
FHM_DL_SUB_SIGNED_1
        }
	if ($multi == 1){
	print <<FHM_DL_SUB_SIGNED_2
      repeat [start == 1 && mode == $mode_val] until (fin == 1 || reset == 1);
      if (fin == 1){
        valid result;
      }
    }
  }

FHM_DL_SUB_SIGNED_2
        }
	else{
	print <<FHM_DL_SUB_SIGNED_3
      [mode == $mode_val]{
	valid result;
      }
    }
  }

FHM_DL_SUB_SIGNED_3
        }
    }
    else{
    {
	print <<FHM_DL_SUB_NOSIGNED_1
    control{
      out fin;
    }
    protocol{
FHM_DL_SUB_NOSIGNED_1
    }
	if ($multi == 0){
	print <<FHM_DL_SUB_NOSIGNED_2
      [true]{
	valid result;
      }
    }
  }

FHM_DL_SUB_NOSIGNED_2
        }
        else{
	print <<FHM_DL_SUB_NOSIGNED_3
      repeat [start == 1] until (fin == 1 || reset == 1);
      if (fin == 1){
        valid result;
      }
    }
  }

FHM_DL_SUB_NOSIGNED_3
        }
    }
}
exit (0);
        ]]>
      </script>
    </function_description>

    <function_conv>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates AUTOGEN description for multiplier in synthesis level
# parameter : bit_width algorithm adder_algorithm data_type

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$algorithm = $ARGV[1];
$add_algo  = $ARGV[2];
$data_type = $ARGV[3];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$algorithm" ne "default" && "$algorithm" ne "seq" && "$algorithm" ne "array"){
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$add_algo" ne "default"){
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

{
print <<FHM_DL_NOP_RESET
/** no operation */
function nop{
  input{
  }

  output{
  }

  control{
    in bit start;
    in bit reset;
  }

  protocol{
    single_cycle_protocol{
      start = '0';
      reset = '0';
    }
  }
}

/** reset */
function reset{
  input{
  }

  output{
  }

  control{
    in bit reset;
  }

  protocol{
    single_cycle_protocol{
      reset = '1';
    }
  }
}

FHM_DL_NOP_RESET
}

if ("$algorithm" eq "seq"){
    $multi = 1;
}
else{
    $multi = 0;
}

$w = $bit_width - 1;
$w2 = $bit_width * 2 - 1;

if ("$data_type" eq "two_complement"){
    &print_func("signed multiplication", "mul", 1, 1);
    &print_func("unsigned multiplication", "mulu", 1, 0);
}
elsif ("$data_type" eq "abs"){
    &print_func("abs multiplication", "mula", 0);
}
elsif ("$data_type" eq "unsigned"){
    &print_func("unsigned multiplication", "mulu", 0);
}
exit (0);

# ---------------------------------

sub print_func{
  $comment   = $_[0];
  $func_name = $_[1];
  $mode      = $_[2];
  $mode_val  = $_[3];

  {
    print <<FHM_DL_FUNC1
/** $comment */
function ${func_name}{
  input{
    bit [$w:0] a;
    bit [$w:0] b;
  }

  output{
    bit [$w2:0] result;
  }

  control{
FHM_DL_FUNC1
  }

  if ($mode == 1){
    print "    in  bit mode;\n";
  }

  if ($multi == 1){
  print <<FHM_DL_MULTI1
    in  bit start;
    in  bit clear;
    out bit fin;
FHM_DL_MULTI1
}

{
  print <<FHM_DL_FUNC2
  }

  protocol{
FHM_DL_FUNC2
  }

  if ($multi == 1){
    {
      print <<FHM_DL_MULTI2
    multi_cycle_protocol{
      start_signal  start = '1';
      fin_signal    fin = '1';
      cancel_signal clear = '1';
FHM_DL_MULTI2
    }
    if ($mode == 1){
      print "\n";
    }
  }
  elsif ($mode == 1){
    print "    single_cycle_protocol{\n";
  }

  if ($mode == 1){
    print "      mode = '$mode_val';\n";
  }

  if ($mode == 1 || $multi == 1){
      print "    }\n";
  }
  print <<FHM_DL_FUNC3
  }
}

FHM_DL_FUNC3
}
        ]]>
      </script>
    </function_conv>

    <function_port>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates adder pultiplier infomation in rt level
# parameter : bit_width algorithm adder_algorithm data_type

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$algorithm = $ARGV[1];
$add_algo  = $ARGV[2];
$data_type = $ARGV[3];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$algorithm" ne "default" && "$algorithm" ne "seq" && "$algorithm" ne "array"){
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$add_algo" ne "default"){
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w = $bit_width-1;
$w2 = $bit_width * 2 - 1;

print <<FHM_DL_PORT;
clock	in	bit		clock
async_reset	in	bit		reset
reset	in	bit		ctrl
a	in	bit_vector   $w   0	data
b	in	bit_vector   $w   0	data
mode	in	bit	       	mode
start	in	bit		ctrl
clear	in	bit		ctrl
result	out	bit_vector   $w2   0	data
fin	out	bit	       	ctrl
FHM_DL_PORT
exit (0);
        ]]>
      </script>
    </function_port>

    <design>
      <design_lang> vhdl </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates instance for multiplier in synthesis level
# parameter : instance_name bit_width algorithm adder_algorithm data_type

if ($#ARGV != 4){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width algorithm adder_algorithm data_type\n";     
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$algorithm     = $ARGV[2];
$add_algo      = $ARGV[3];
$data_type     = $ARGV[4];
if ("$algorithm" eq "default"){
@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$b2 = 2 * $bit_width;
$w = $bit_width - 1;
$w2 = $b2 -1;
$w3 = ($bit_width + 1) * 2 - 1;

if ("$data_type" eq "two_complement"){
    $mode_comment = "\'1\' for signed multiplication\n--              '0' for unsigned multiplication";
}
else{
    $mode_comment = "(ignore)";
}

print <<FHM_DL_INSTANCE;
-- Module     : $bit_width-bit Multiplier
-- Feature    : 
-- References : Start from scratch
-- Author     : Designed by T.Morifuji (c)1996,1999
--              Modefied by Tak. Tokihisa (c)2002
-- Version    : 1.1  :

-- Functionality : synthesis level
--  port
--   clock   : (ignore)
--   async_reset   : (ignore)
--   reset   : (ignore)
--   a       : multiplicand
--   b       : multiplier
--   mode    : $mode_comment
--   start   : (ignore)
--   clear   : (ignore)
--   result  : multiplied result
--   fin     : '1' when operation is over

-- Comment :

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_signed.all;

entity $instance_name is
  port (clock  : in std_logic;
        async_reset  : in std_logic;
        reset  : in std_logic;
        a, b   : in std_logic_vector($w downto 0);
        mode   : in std_logic;
        start  : in std_logic;
	clear  : in std_logic;
        result : out std_logic_vector($w2 downto 0);
        fin    : out std_logic);
end $instance_name;

architecture synthesis of $instance_name is
begin
  process (a, b, mode)
    variable tmp_a, tmp_b : std_logic_vector($bit_width downto 0);
    variable tmp_result   : std_logic_vector($w3 downto 0);
  begin
FHM_DL_INSTANCE

if ("$data_type" eq "two_complement"){
    print <<FHM_DL_INSTANCE2;
    tmp_a := (a($w) and mode) & a;
    tmp_b := (b($w) and mode) & b;
FHM_DL_INSTANCE2
}
elsif("$data_type" eq "abs"){
    print <<FHM_DL_INSTANCE3;
    if (a($w) = '1') then
      tmp_a := '0' & not a + 1;
    else
      tmp_a := '0' & a;
    end if;
    if (b($w) = '1') then
      tmp_b := '0' & not b + 1;
    else
      tmp_b := '0' & b;
    end if;
FHM_DL_INSTANCE3
}
elsif ("$data_type" eq"unsigned"){
    print <<FHM_DL_INSTANCE4;
    tmp_a := '0' & a;
    tmp_b := '0' & b;
FHM_DL_INSTANCE4
}
{
	print <<FHM_DL_INSTANCE5

    tmp_result := tmp_a * tmp_b;
    result <= tmp_result($w2 downto 0);
    fin <= '1';
  end process;
end synthesis;
FHM_DL_INSTANCE5
}
 exit (0);
}#$algorithm == "default"

if ("$algorithm" ne "default"){
@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}


$w = $bit_width - 1;
$w2 = $bit_width * 2 - 1;
$w3 = $bit_width - 2;
$w4 = $bit_width * 2 - 2;
$double_width = $bit_width * 2;
$instance_name_add = $instance_name."_add$bit_width";
$instance_name_add2 = $instance_name."_add$double_width";

if ($bit_width == 1){
    $data1 = "";
    $data2 = "(0)";

    $double_data1 = "_vector($w2 downto 0)";
    $double_data2 = "($w2 downto 0)";
}
elsif (($bit_width >= 2 && $bit_width <= 72) || $bit_width == 128 || $bit_width
== 256){
    $data1 = "_vector($w downto 0)";
    $data2 = "($w downto 0)";

    $double_data1 = "_vector($w2 downto 0)";
    $double_data2 = "($w2 downto 0)";
}
else{
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$algorithm" ne "seq" && "$algorithm" ne "array"){
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$add_algo" ne "default"){
    print "add_algorithm $add_algo is not supported.\n";
    exit (100);
}


if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$zeros = 0 x $bit_width;
$zeros = "\"" . $zeros . "\"";

$zeros1 = 0 x $w;
$zeros1 = "\"" . $zeros1 . "\"";

$zeros2 = 0 x $double_width;
$zeros2 = "\"" . $zeros2 . "\"";

# 1 bit register generation for tconv_result
if ("$algorithm" eq "seq" && "$data_type" eq "two_complement"){
    print <<FHM_DL_INSTANCE_REG;
-- Module     : 1-bit Edge Trigger Register
-- Feature    : positive
-- References : Started from scratch
-- Author     : Designed by T.Morifuji (c)1997.
-- Version    : 1.0  :

-- Functionality : synthesis level
--  port
--   clock    : clock
--   async_reset    : asynchronous reset
--   reset    : synchronous reset
--   enb      : '1' then register data
--   data_in  : data to register
--   data_out : registered data

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;


entity ${instance_name}_reg1 is
  port (clock    : in std_logic;
        async_reset    : in std_logic;
        reset    : in std_logic;
        enb      : in std_logic;
        data_in  : in std_logic;
        data_out : out std_logic);
end ${instance_name}_reg1;

architecture synthesis of ${instance_name}_reg1 is
begin

  process (clock, async_reset)
  begin
    if (async_reset = '1') then
      data_out <= '0';
    elsif (clock'event and clock = '1') then
      if (reset = '1') then
        data_out <= '0';
      elsif (enb = '1') then
        data_out <= data_in;
      end if;
    end if;
  end process;

end synthesis;

--%%

FHM_DL_INSTANCE_REG
}

# adder generation
if ("$add_algo" eq "default"){
    if ("$algorithm" eq "array" || "$data_type" ne "unsigned"){
print <<FHM_DL_INSTANCE
-- Module     : $bit_width-bit unsigned adder
-- References :
-- Author     : Designed by T.Morifuji (c)1996.
-- Version    : 1.0

-- Functionality : synthesis level
--  port
--   a, b   : add datas
--   cin    : carry in
--   result : result of a + b + c
--   cout   : '1' when result > 2^$bit_width-1

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity $instance_name_add is
  port (a, b   : in std_logic$data1;
        cin    : in std_logic;
        result : out std_logic$data1;
        cout   : out std_logic);
end $instance_name_add;

architecture synthesis of $instance_name_add is

begin  -- synthesis

  addition: process (a, b, cin)
    variable int_a, int_b : std_logic_vector($bit_width downto 0);
    variable int_result   : std_logic_vector($bit_width downto 0);
  begin
    int_a      := '0' & a;
    int_b      := '0' & b;

    int_result := int_a + int_b + cin;

    result     <= int_result$data2;
    cout       <= int_result($bit_width);

  end process addition;

end synthesis;

FHM_DL_INSTANCE
    }
    if ("$algorithm" eq "seq" || "$data_type" eq "two_complement"){
print <<FHM_DL_INSTANCE
-- Module     : ${double_width}-bit unsigned adder
-- References :
-- Author     : Designed by T.Morifuji (c)1996.
-- Version    : 1.0

-- Functionality : synthesis level
--  port
--   a, b   : add datas
--   cin    : carry in
--   result : result of a + b + c
--   cout   : '1' when result > 2^$bit_width-1

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity $instance_name_add2 is
  port (a, b   : in std_logic$double_data1;
        cin    : in std_logic;
        result : out std_logic$double_data1;
        cout   : out std_logic);
end $instance_name_add2;

architecture synthesis of $instance_name_add2 is

begin  -- synthesis

  addition: process (a, b, cin)
    variable int_a, int_b : std_logic_vector($double_width downto 0);
    variable int_result   : std_logic_vector($double_width downto 0);
  begin
    int_a      := '0' & a;
    int_b      := '0' & b;

    int_result := int_a + int_b + cin;

    result     <= int_result$double_data2;
    cout       <= int_result($double_width);

  end process addition;

end synthesis;

FHM_DL_INSTANCE
    }
}

# unsigned multiplier generation
if ("$algorithm" eq "seq") {
    {
    print <<FHM_DL_SMUL0;
-- Module     : ${bit_width}-bit Edge Trigger Register
-- Feature    : positive
-- References : Started from scratch
-- Author     : Designed by T.Morifuji (c)1997.
-- Version    : 1.0  :

-- Functionality : synthesis level
--  port
--   clock    : clock
--   async_reset    : asynchronous reset
--   reset    : synchronous reset
--   enb      : '1' then register data
--   data_in  : data to register
--   data_out : registered data


library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_reg$bit_width is
  port (clock    : in std_logic;
        async_reset      : in std_logic;
        reset      : in std_logic;
        enb      : in std_logic;
        data_in  : in std_logic_vector($w downto 0);
        data_out : out std_logic_vector($w downto 0) );
end ${instance_name}_reg$bit_width;

architecture synthesis of ${instance_name}_reg$bit_width is
begin

  process (clock, async_reset)
  begin
    if (async_reset = '1') then
      data_out <= (others => '0');
    elsif (clock'event and clock = '1') then
      if (reset = '1') then
        data_out <= (others => '0');
      elsif (enb = '1') then
        data_out <= data_in;
      end if;
    end if;
  end process;

end synthesis;

--%%

-- Module     : ${double_width}-bit Edge Trigger Register
-- Feature    : positive
-- References : Started from scratch
-- Author     : Designed by T.Morifuji (c)1997.
-- Version    : 1.0  :

-- Functionality : synthesis level
--  port
--   clock    : clock
--   async_reset    : asynchronous reset
--   reset    : synchronous reset
--   enb      : '1' then register data
--   data_in  : data to register
--   data_out : registered data


library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_reg$double_width is
  port (clock    : in std_logic;
        async_reset      : in std_logic;
        reset      : in std_logic;
        enb      : in std_logic;
        data_in  : in std_logic_vector($w2 downto 0);
        data_out : out std_logic_vector($w2 downto 0) );
end ${instance_name}_reg$double_width;

architecture synthesis of ${instance_name}_reg$double_width is
begin

  process (clock, async_reset)
  begin
    if (async_reset = '1') then
      data_out <= (others => '0');
    elsif (clock'event and clock = '1') then
      if (reset = '1') then
        data_out <= (others => '0');
      elsif (enb = '1') then
        data_out <= data_in;
      end if;
    end if;
  end process;

end synthesis;

--%%

-- Module     : ${bit_width}-bit Unsigned Multiplier
-- Feature    : type : shift
-- References : Start from scratch
-- Author     : Designed by T.Morifuji (c)1996,1997,1999.
--              Modified by T.Yoshimura (c)2004.
-- Version    : 1.2  :

-- Functionality :
--  port
--   clock  : clock
--   a, b   : can represent from 0 to 2^$bit_width-1 in integer
--   mode   : start multiplication when '0' after 1-clock '1'
--   result : multiplied result
--   fin    : '1' when operation is over

-- Comment :

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_smul is
  port (clock  : in std_logic;
        async_reset  : in std_logic;
        reset  : in std_logic;
        clear  : in std_logic;
        start  : in std_logic;
        a, b   : in std_logic_vector($w downto 0);
        result : out std_logic_vector($w2 downto 0);
        fin    : out std_logic );
end ${instance_name}_smul;

architecture synthesis of ${instance_name}_smul is

  -- adder
  component ${instance_name_add2}
    port (a, b   : in std_logic_vector($w2 downto 0);
          cin    : in std_logic;
          result : out std_logic_vector($w2 downto 0);
          cout   : out std_logic );
  end component;

  -- register: positive edge trigger
  component ${instance_name}_reg$bit_width
    port (clock    : in std_logic;
          async_reset      : in std_logic;
          reset      : in std_logic;
          enb      : in std_logic;
          data_in  : in std_logic_vector($w downto 0);
          data_out : out std_logic_vector($w downto 0) );
  end component;

  component ${instance_name}_reg$double_width
    port (clock    : in std_logic;
          async_reset      : in std_logic;
          reset      : in std_logic;
          enb      : in std_logic;
          data_in  : in std_logic_vector($w2 downto 0);
          data_out : out std_logic_vector($w2 downto 0) );
  end component;

  --
  -- signals declaration
  --

  signal add_sel, ld_ab, sft_b : std_logic;
  signal reg${double_width}_enb, reg${double_width}_reset : std_logic;
  signal reg${double_width}_reset2 : std_logic;
  signal from_reg_${bit_width}_a : std_logic_vector($w downto 0);
  signal to_reg_${bit_width}_b, from_reg_${bit_width}_b : std_logic_vector($w downto 0);
  signal to_add_a, to_add_b, from_add, result_tmp : std_logic_vector($w2 downto 0);
  signal zero, one : std_logic;
FHM_DL_SMUL0
    }
    print "  type s_t is (st0, st1, ";
    $i = 2;

    while ($i <= $bit_width+1) {
        print "st$i, ";
        $j = $i % 7;
        if ($j == 0) {
            print  "\n";
            print  "                 ";
        }
        $i= $i + 1;
    }
    print"st$i);\n";
    {
    print <<FHM_DL_SMUL1
  signal current_state, next_state : s_t;
begin  --  synthesis
  zero <= '0';
  one <= '1';

  add_sel <= from_reg_${bit_width}_b($w);
  to_add_a($w2 downto $bit_width) <= $zeros;
  to_add_a($w downto 0) <= from_reg_${bit_width}_a when add_sel='1' else
                           $zeros;
  to_add_b <= result_tmp($w2-1 downto 0) & '0';
  result <= result_tmp;

  reg_${bit_width}_a: ${instance_name}_reg$bit_width
    port map (
      clock    => clock,
      async_reset    => async_reset,
      reset    => reset,
      enb      => ld_ab,
      data_in  => a,
      data_out => from_reg_${bit_width}_a);

  to_reg_${bit_width}_b <= b when ld_ab='1' else
                           from_reg_${bit_width}_b($w-1 downto 0) & '0' when sft_b='1' else
                           from_reg_${bit_width}_b($w downto 0);
  
  reg_${bit_width}_b: ${instance_name}_reg$bit_width
    port map (
      clock    => clock,
      async_reset    => async_reset,
      reset    => reset,
      enb      => one,
      data_in  => to_reg_${bit_width}_b,
      data_out => from_reg_${bit_width}_b);
  
  add0 : ${instance_name_add2}
    port map (
      a      => to_add_a,
      b      => to_add_b,
      cin    => zero,
      result => from_add,
      cout   => open);

  reg${double_width}_reset2 <= reg${double_width}_reset or reset;
  reg_$double_width: ${instance_name}_reg$double_width
    port map (
      clock    => clock,
      async_reset => async_reset,
      reset    => reg${double_width}_reset2,
      enb      => reg${double_width}_enb,
      data_in  => from_add,
      data_out => result_tmp);
  
  process (current_state, start, clear)
  begin
    case current_state is
      when st0 =>
        ld_ab <= '0';
        sft_b <= '0';
        reg${double_width}_enb <= '0';
        reg${double_width}_reset <= '0';
        fin <= '1' and not start;
        if (start = '1' and clear = '0') then
          next_state <= st1;
        else
          next_state <= st0;
        end if;
      when st1 =>
        if clear = '1' then
          next_state <= st0;
        else
          next_state <= st2;
        end if;
        ld_ab <= '1';
        sft_b <= '0';
        reg${double_width}_enb <= '0';
        reg${double_width}_reset <= '1';
        fin <= '0';
FHM_DL_SMUL1
    }
    $i = 2;

    while ($i <= $bit_width+1) {
        $n_i = $i + 1;
        {
        print <<FHM_DL_SMUL_STATE
      when st$i =>
        if clear = '1' then
          next_state <= st0;
        else
          next_state <= st$n_i;
        end if;
        ld_ab <= '0';
        sft_b <= '1';
        reg${double_width}_enb <= '1';
        reg${double_width}_reset <= '0';
        fin <= '0';
FHM_DL_SMUL_STATE
        }
        $i = $n_i;
    }
    {
    print <<FHM_DL_SMUL2
      when st$i =>
        next_state <= st0;
        ld_ab <= '0';
        sft_b <= '0';
        reg${double_width}_enb <= '0';
        reg${double_width}_reset <= '0';
        fin <= '1';
    end case;
  end process;

  process (clock, async_reset)
  begin
    if (async_reset = '1') then
      current_state <= st0;
    elsif (clock'event and clock = '1') then
      if (reset = '1') then
        current_state <= st0;
      else
        current_state <= next_state;
      end if;
    end if;
  end process;  
end synthesis;

--%%

FHM_DL_SMUL2
    }
}
elsif ("$algorithm" eq "array") {
    print <<FHM_DL_AMUL;
-- Module     : ${bit_width}-bit Unsigned Multiplier
-- Feature    : type : array
-- References : Start from scratch
-- Author     : Designed by T.Morifuji (c)1996,1997.
-- Version    : 1.0  :

-- Functionality :
--  port
--   W      : bit width. boundary of input
--   a, b   : can represent from 0 to 2^$bit_width-1 in integer
--   result : multiplied result

-- Comment :

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_amul is
  port (a, b   : in std_logic_vector($w downto 0);
        result : out std_logic_vector($w2 downto 0));
end ${instance_name}_amul;

architecture synthesis of ${instance_name}_amul is

  -- component declaration
  -- adder
  component ${instance_name_add}
    port (a, b   : in std_logic_vector($w downto 0);
          cin    : in std_logic;
          result : out std_logic_vector($w downto 0);
          cout   : out std_logic);
  end component;

  --  type definition
  type vectors is array (Natural range <>) of std_logic_vector($w downto 0);

  --  signal declaration
  signal qout   : std_logic_vector($w downto 0);
  signal add_a	: vectors($w downto 0);
  signal add_b	: vectors($w downto 0);
  signal add_s	: vectors($w downto 0);
  signal s	: vectors($w downto 0);
  signal c	: std_logic_vector($w downto 0);
 
  signal zero	: std_logic;

begin

  zero <= '0';

  a_connect : for i in 0 to $w generate
    add_a0 : if (i = 0) generate
      input_0 : for j in $w downto 0 generate
        s(i)(j) <= a(j) and b(0);
      end generate input_0;
    c(0) <= zero;

    end generate add_a0;
    
    add_as : if (0 < i and i <= $w) generate
      input_0 : for j in $w downto 0 generate
        add_a(i)(j) <= a(j) and b(i);
        b_carry : if (j = $w) generate
	  add_b(i)(j) <= c(i-1);
	end generate b_carry;

  b_other : if (j /= $w) generate
	  add_b(i)(j) <= s(i-1)(j+1);
	end generate b_other;

      end generate input_0;

    end generate add_as;

  end generate a_connect;

  -- make result
  s_conv : for i in 1 to $w3 generate
    result(i) <= s(i)(0);
  end generate s_conv;

  s_conv2 : for i in $w to $w4 generate
    result(i) <= s($w)(i-$w);
  end generate s_conv2;

  result(0) <= a(0) and b(0);
  result($w2) <= c($w);

  -- port mapping : adder
  add_connect : for i in 1 to $w generate
   adds : ${instance_name_add}
      port map (add_a(i), add_b(i),
                zero, s(i), c(i) );
  end generate add_connect;

end synthesis;

--%%

FHM_DL_AMUL
}

if ("$data_type" eq "two_complement" || "$data_type" eq "abs") {
    print <<FHM_DL_TWO;
-- Module     : ${bit_width}-bit 2's complement converter
-- Feature    : ${bit_width}-bit
-- References : Start from scratch
-- Author     : Designed by T.Morifuji (c)1996.
-- Version : 1.0  :

-- Functionality :
--  port
--   data_in  : data for convert
--   conv     : '1' then convert data
--   data_out : converted data

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_tconv$bit_width is
    port (data_in  : in  std_logic_vector($w downto 0);
          conv     : in std_logic;
          data_out : out std_logic_vector($w downto 0));
end ${instance_name}_tconv$bit_width;

architecture synthesis of ${instance_name}_tconv$bit_width is

  component ${instance_name_add}
    port (a, b   : in std_logic_vector($w downto 0);
          cin    : in std_logic;
          result : out std_logic_vector($w downto 0);
          cout   : out std_logic);
  end component;

  signal not_data_in  : std_logic_vector($w downto 0);
  signal zero         : std_logic_vector($w downto 0);
  signal tmp_data_out : std_logic_vector($w downto 0);
  signal tmp_cout     : std_logic;

begin

  not_data_in <= not data_in;
  zero <= $zeros;

  two_conv : ${instance_name_add}
    port map (not_data_in, zero, conv,
              tmp_data_out, tmp_cout);

  data_out <= data_in when conv = '0' else
              tmp_data_out;

end synthesis;

--%%

FHM_DL_TWO
}
if ("$data_type" eq "two_complement") {
    print <<FHM_DL_TWO;
-- Module     : ${double_width}-bit 2's complement converter
-- Feature    : ${double_width}-bit
-- References : Start from scratch
-- Author     : Designed by T.Morifuji (c)1996.

-- Version : 1.0  :
-- Functionality :
--  port
--   data_in  : data for convert
--   conv     : '1' then convert data
--   data_out : converted data


library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_tconv$double_width is
    port (data_in  : in  std_logic_vector($w2 downto 0);
          conv     : in std_logic;
          data_out : out std_logic_vector($w2 downto 0));
end ${instance_name}_tconv$double_width;

architecture synthesis of ${instance_name}_tconv$double_width is

  component ${instance_name_add2}
    port (a, b   : in std_logic_vector($w2 downto 0);
          cin    : in std_logic;
          result : out std_logic_vector($w2 downto 0);
          cout   : out std_logic);
  end component;

  signal not_data_in  : std_logic_vector($w2 downto 0);
  signal zero         : std_logic_vector($w2 downto 0);
  signal tmp_data_out : std_logic_vector($w2 downto 0);
  signal tmp_cout     : std_logic;

begin

  not_data_in <= not data_in;
  zero <= $zeros2;

  two_conv : ${instance_name_add2}
    port map (not_data_in, zero, conv,
              tmp_data_out, tmp_cout);

  data_out <= data_in when conv = '0' else
              tmp_data_out;

end synthesis;

--%%

FHM_DL_TWO
}

print <<FHM_DL_INSTANCE2;
-- Module     : ${bit_width}-bit Multiplier
-- Feature    : $algorithm $add_algo $data_type
-- References : Start from scratch
-- Author     : Designed by T.Morifuji (c)1996,1997,1999.
--              Modified by T.Yoshimura (c)2004.
-- Version    : 1.2  :
-- Functionality :
--  port
--   W       : bit width. boundary of input
--   clock   : clock
--   a, b    : can represent from 0 to 2^$bit_width-1 in integer
FHM_DL_INSTANCE2
if ($data_type eq "two_complement") {
    print "--   mode    : '0' when data type is unsigned\n";
    print "--             '1' when data type is two_complement\n";
}
else {
    print "--   mode    : (ignore)\n";
}
if ($algorithm eq "seq") {
  print "--   start   : '1' when operation starts\n";
}
else {
  print "--   start   : (ignore)\n";
}
print <<FHM_DL_INSTANCE3;
--   result  : multiplied result
--   fin     : '1' when operation is over

-- Comment :

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity $instance_name is
  port (clock  : in std_logic;
        async_reset  : in std_logic;
        reset  : in std_logic;
        a, b   : in std_logic_vector($w downto 0);
        mode   : in std_logic;
        start  : in std_logic;
        clear  : in std_logic;
        result : out std_logic_vector($w2 downto 0);
        fin    : out std_logic);
end $instance_name;

architecture synthesis of $instance_name is

FHM_DL_INSTANCE3
if ("$algorithm" eq "seq") {
  print <<FHM_DL_SEQ;
  component ${instance_name}_smul
    port (clock  : in std_logic;
          async_reset  : in std_logic;
          reset  : in std_logic;
          clear  : in std_logic;
          start  : in std_logic;
          a, b   : in std_logic_vector($w downto 0);
          result : out std_logic_vector($w2 downto 0);
          fin    : out std_logic );
  end component;
FHM_DL_SEQ
}
elsif ("$algorithm" eq "array") {
    print <<FHM_DL_SEQ2;
  component ${instance_name}_amul
    port (a, b   : in std_logic_vector($w downto 0);
          result : out std_logic_vector($w2 downto 0));
  end component;

FHM_DL_SEQ2
}


if ("$data_type" eq "unsigned") {
    if ("$algorithm" eq "seq") {
	print <<FHM_DL_SEQ3;
signal smul_fin              : std_logic;

begin

  smul0 : ${instance_name}_smul
    port map (
      clock       => clock,
      async_reset => async_reset,
      reset       => reset,
      clear       => clear,
      start       => start,
      a           => a,
      b           => b,
      result      => result,
      fin         => smul_fin);

  fin <= smul_fin and (not start);
FHM_DL_SEQ3
    }
    elsif ("$algorithm" eq "array") {
	print <<FHM_DL_ARRAY;
begin

  fin <= '1';

  amul0 : ${instance_name}_amul
    port map (a, b, result);
FHM_DL_ARRAY
    }
    print "end synthesis;\n";
}

if ("$data_type" eq "two_complement") {
    print <<FHM_DL_TWO2;
  component ${instance_name}_tconv$bit_width
    port (data_in  : in std_logic_vector($w downto 0);
          conv     : in std_logic;
          data_out : out std_logic_vector($w downto 0));
  end component;

  component ${instance_name}_tconv${double_width}
    port (data_in  : in std_logic_vector($w2 downto 0);
          conv     : in std_logic;
          data_out : out std_logic_vector($w2 downto 0));
  end component;

FHM_DL_TWO2
    if ("$algorithm" eq "seq") {
        print <<FHM_DL_SEQ4;
  component ${instance_name}_reg1
    port (clock    : in std_logic;
          async_reset      : in std_logic;
          reset      : in std_logic;
          enb      : in std_logic;
          data_in  : in std_logic;
          data_out : out std_logic );
  end component;
FHM_DL_SEQ4
    }
    print <<FHM_DL_TWO3;
  signal conved_a          : std_logic_vector($w downto 0);
  signal conved_b          : std_logic_vector($w downto 0);
  signal conved_result     : std_logic_vector($w2 downto 0);

  signal tmp_a             : std_logic_vector($w downto 0);
  signal tmp_b             : std_logic_vector($w downto 0);
  signal tmp_result        : std_logic_vector($w2 downto 0);

FHM_DL_TWO3
    if ("$algorithm" eq "seq") {
        print <<FHM_DL_SEQ5;
  signal in_result_tconv_conv  : std_logic;
  signal out_result_tconv_conv : std_logic;
  signal mode_tmp : std_logic;

  signal smul_fin              : std_logic;

FHM_DL_SEQ5
    }
    print <<FHM_DL_TWO4;
  signal result_tconv_conv     : std_logic;

begin

  result_tconv_conv <= a($w) xor b($w);
FHM_DL_TWO4
    if ("$algorithm" eq "seq") {
	print <<FHM_DL_SEQ6;
  in_result_tconv_conv <= result_tconv_conv;

  tconv_reg : ${instance_name}_reg1
    port map (
      clock    => clock,
      async_reset      => async_reset,
      reset      => reset,
      enb      => start,
      data_in  => in_result_tconv_conv,
      data_out => out_result_tconv_conv);

  mode_reg : ${instance_name}_reg1
    port map (
      clock    => clock,
      async_reset => async_reset,
      reset    => reset,
      enb      => start,
      data_in  => mode,
      data_out => mode_tmp);
FHM_DL_SEQ6
    }
    print <<FHM_DL_TWO5;

  conv_a : ${instance_name}_tconv${bit_width}
    port map (a, a($w), conved_a);

  conv_b : ${instance_name}_tconv${bit_width}
    port map (b, b($w), conved_b);
FHM_DL_TWO5

    if ("$algorithm" eq "seq") {
	print <<FHM_DL_SEQ6;

  tmp_a <= a when mode_tmp = '0' else
           conved_a;

  tmp_b <= b when mode_tmp = '0' else
           conved_b;

  mulu : ${instance_name}_smul
    port map (
      clock  => clock,
      async_reset  => async_reset,
      reset  => reset,
      clear  => clear,
      start  => start,
      a      => tmp_a,
      b      => tmp_b,
      result => tmp_result,
      fin    => smul_fin);

FHM_DL_SEQ6
    }
    elsif ("$algorithm" eq "array") {
	print <<FHM_DL_ARRAY2;
  fin <= '1';

  tmp_a <= a when mode = '0' else
           conved_a;

  tmp_b <= b when mode = '0' else
           conved_b;

  mulu : ${instance_name}_amul
    port map (tmp_a, tmp_b, tmp_result);
FHM_DL_ARRAY2
    }
    print "  conv_result : ${instance_name}_tconv${double_width}\n";

    if ("$algorithm" eq "seq") {
	print "    port map (tmp_result, out_result_tconv_conv, conved_result);\n\n";
	print "  result <= tmp_result when mode_tmp = '0' else\n";
	print "            conved_result;\n\n";
    }
    else {
        print "    port map (tmp_result, result_tconv_conv, conved_result);\n\n";
	print "  result <= tmp_result when mode = '0' else\n";
	print "            conved_result;\n\n";
    }

    if ("$algorithm" eq "seq") {
	print "    fin <= smul_fin and (not start);\n\n";
    }

    print "end synthesis;\n";
}

if ("$data_type" eq "abs") {
    print <<FHM_DL_ABS;

  component ${instance_name}_tconv$bit_width
    port (data_in  : in std_logic_vector($w downto 0);
          conv     : in std_logic;
          data_out : out std_logic_vector($w downto 0));
  end component;

FHM_DL_ABS

    if ("$algorithm" eq "seq") {
	print <<FHM_DL_SEQ7;
  signal smul_fin  : std_logic;
  signal vss       : std_logic := '0';

FHM_DL_SEQ7
    }
    print <<FHM_DL_ABS;
  signal conved_a          : std_logic_vector($w downto 0);
  signal conved_b          : std_logic_vector($w downto 0);
  signal to_result : std_logic_vector($w2 downto 0);

begin

  conv_a : ${instance_name}_tconv${bit_width}
    port map (a, a($w), conved_a);

  conv_b : ${instance_name}_tconv${bit_width}
    port map (b, b($w), conved_b);

  result($w2 downto 0) <= to_result($w2 downto 0);

FHM_DL_ABS
  
    if ("$algorithm" eq "seq") {
	print <<FHM_DL_SEQ9;

  mulu : ${instance_name}_smul
    port map (
      clock       => clock,
      async_reset => async_reset,
      reset       => reset,
      clear       => clear,
      start       => start,
      a           => conved_a,
      b           => conved_b,
      result      => to_result,
      fin         => smul_fin);

  fin <= smul_fin and (not start);
FHM_DL_SEQ9
    } 
    elsif ("$algorithm" eq "array") {
	print <<FHM_DL_ARRAY3;
  fin <= '1';

  mulu : ${instance_name}_amul
    port map (conved_a, conved_b, to_result);

FHM_DL_ARRAY3
    }
    print "end synthesis;\n";
}
}#$algorithm == default 
exit (0);
          ]]>        </script>
      </instance>

      <entity></entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>

      <synthesis>
        <parameter></parameter>
        <synthesis_script>
          <script>
            <![CDATA[
#!/usr/bin/perl
# this script generates synthesis script for multiplier in synthesis level
# parameter : instance_name priority bit_width algorithm adder_algorithm data_type

if ($#ARGV != 5){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name priority bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$priority      = $ARGV[1];
$bit_width     = $ARGV[2];
$algorithm     = $ARGV[3];
$add_algo      = $ARGV[4];
$data_type     = $ARGV[5];

if ($priority eq "area"){
  $priority_const = "set_max_area 0";
}
elsif ($priority eq "performance"){
  $priority_const = "set_max_delay -from all_inputs() -to all_outputs() 0";
}
elsif ($priority eq "power"){
  $priority_const = "";
}
elsif ($priority eq "none"){
  $priority_const = "";
}
else{
  print "priority $priority is not supported.\n";
  exit (100);
}

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$algorithm" eq "seq"){
    $create_clock = "create_clock -period 10 -waveform{0 5} clock";
}
elsif ("$algorithm" eq "default" || "$algorithm" eq "array"){
    $create_clock = "";
}
else{
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$add_algo" ne "default"){
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

{
print <<FHM_DL_SCRIPT
hdlin_auto_save_templates = TRUE

analyze -f vhdl $instance_name.vhd

elaborate $instance_name
uniquify

$priority_const

$create_clock

compile 

write -hierarchy -output $instance_name.db

report_area
report_timing

quit
FHM_DL_SCRIPT
}
exit (0);
            ]]>
          </script>
        </synthesis_script>
      </synthesis>
    </design>

    <design>
      <design_lang> Verilog </design_lang>
                                                                                
      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates instance for multiplier in synthesis level
# parameter : instance_name bit_width algorithm adder_algorithm data_type

if ($#ARGV != 4){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width algorithm adder_algorithm data_type\n";     
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$algorithm     = $ARGV[2];
$add_algo      = $ARGV[3];
$data_type     = $ARGV[4];
if ("$algorithm" eq "default"){
@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$b2 = 2 * $bit_width;
$w = $bit_width - 1;
$w2 = $b2 -1;
$w3 = ($bit_width + 1) * 2 - 1;

if ("$data_type" eq "two_complement"){
    $mode_comment = "\'1\' for signed multiplication\n//              '0' for unsigned multiplication";
}
else{
    $mode_comment = "(ignore)";
}

print <<FHM_DL_INSTANCE;
// Module     : $bit_width-bit Multiplier
// Feature    : 
// References : Start from scratch
// Author     : Designed by T.Morifuji (c)1996,1999
//              Modefied by Tak. Tokihisa (c)2002
// Version    : 1.1  :

// Functionality : synthesis level
//  port
//   clock   : (ignore)
//   async_reset   : (ignore)
//   reset   : (ignore)
//   a       : multiplicand
//   b       : multiplier
//   mode    : $mode_comment
//   start   : (ignore)
//   clear   : (ignore)
//   result  : multiplied result
//   fin     : '1' when operation is over
\n
// Comment :
\n
module $instance_name (
  clock       ,
  async_reset ,
  reset       ,
  a           ,
  b           ,
  mode        ,
  start       ,
  clear       ,
  result      ,
  fin         );
\n 
input         clock       ;
input         async_reset ;
input         reset       ;
input signed [$w:0] a           ;
input signed [$w:0] b           ;
input         mode        ;
input         start       ;
input         clear       ;
output signed [$w2:0] result      ;
output        fin         ;
\n
wire         clock       ;
wire         async_reset ;
wire         reset       ;
wire signed [$w:0] a           ;
wire signed [$w:0] b           ;
wire         mode        ;
wire         start       ;
wire         clear       ;
wire signed [$w2:0] result      ;
wire         fin         ;
\n
wire signed [$bit_width:0] tmp_a       ;
wire signed [$bit_width:0] tmp_b       ;
wire signed [$w3:0] tmp_result  ;
\n
FHM_DL_INSTANCE

if ("$data_type" eq "two_complement"){
    print <<FHM_DL_INSTANCE2;
assign tmp_a = {a[$w] & mode, a};
assign tmp_b = {b[$w] & mode, b};
FHM_DL_INSTANCE2
}
elsif("$data_type" eq "abs"){
    print <<FHM_DL_INSTANCE3;
assign tmp_a = (a[$w] == 1'b1) ? {1'b0 , ~a} + 1'b1 : {1'b0 , a} ;
assign tmp_b = (b[$w] == 1'b1) ? {1'b0 , ~b} + 1'b1 : {1'b0 , b} ;
FHM_DL_INSTANCE3
}
elsif ("$data_type" eq"unsigned"){
    print <<FHM_DL_INSTANCE4;
assign tmp_a = {1'b0 , a};
assign tmp_b = {1'b0 , b};
FHM_DL_INSTANCE4
}
{
	print <<FHM_DL_INSTANCE5
\n
assign tmp_result = tmp_a * tmp_b;
assign result     = tmp_result[$w2:0];
assign fin        = 1'b1;
\n
endmodule
FHM_DL_INSTANCE5
}
 exit (0);
}#$algorithm == "default"

if ("$algorithm" ne "default"){
@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}


$w = $bit_width - 1;
$w2 = $bit_width * 2 - 1;
$w3 = $bit_width - 2;
$w4 = $bit_width * 2 - 2;
$double_width = $bit_width * 2;
$instance_name_add = $instance_name."_add$bit_width";
$instance_name_add2 = $instance_name."_add$double_width";
$b_len = &log2u($bit_width);
$b_len2 = $b_len + 1;

if ($bit_width == 1){
    $data1 = "";
    $data2 = "[0]";

    $double_data = "[$w2:0]";
}
elsif (($bit_width >= 2 && $bit_width <= 72) || $bit_width == 128 || $bit_width
== 256){
    $data1 = "[$w:0]";
    $data2 = "[$w:0]";

    $double_data = "[$w2:0]";
}
else{
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$algorithm" ne "seq" && "$algorithm" ne "array"){
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$add_algo" ne "default"){
    print "add_algorithm $add_algo is not supported.\n";
    exit (100);
}


if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$zeros = 0 x $bit_width;
$zeros = "\"" . $zeros . "\"";

$zeros1 = 0 x $w;
$zeros1 = "\"" . $zeros1 . "\"";

$zeros2 = 0 x $double_width;
$zeros2 = "\"" . $zeros2 . "\"";

# 1 bit register generation for tconv_result
if ("$algorithm" eq "seq" && "$data_type" eq "two_complement"){
    print <<FHM_DL_INSTANCE_REG;
// Module     : 1-bit Edge Trigger Register
// Feature    : positive
// References : Started from scratch
// Author     : Designed by T.Morifuji (c)1997.
// Version    : 1.0  :
\n
// Functionality : synthesis level
//  port
//   clock    : clock
//   async_reset    : asynchronous reset
//   reset    : synchronous reset
//   enb      : '1' then register data
//   data_in  : data to register
//   data_out : registered data
\n
module ${instance_name}_reg1 (
  clock       , 
  async_reset ,
  reset       ,
  enb         ,
  data_in     ,
  data_out    );
\n
input  clock       ;
input  async_reset ;
input  reset       ;
input  enb         ;
input  data_in     ;
output data_out    ;
\n
wire  clock       ;
wire  async_reset ;
wire  reset       ;
wire  enb         ;
wire  data_in     ;
reg   data_out    ;
\n
always@ (posedge clock or posedge async_reset)
begin
    if (async_reset == 1'b1)
      data_out  <= 1'b0;
    else
    begin
      if (reset == 1'b1)
        data_out <= 1'b0;
      else if (enb == 1'b1)
        data_out <= data_in;
    end
end

endmodule
\n
//%%
\n
FHM_DL_INSTANCE_REG
}

# adder generation
if ("$add_algo" eq "default"){
    if ("$algorithm" eq "array" || "$data_type" ne "unsigned"){
print <<FHM_DL_INSTANCE
// Module     : $bit_width-bit unsigned adder
// References :
// Author     : Designed by T.Morifuji (c)1996.
// Version    : 1.0
\n
// Functionality : synthesis level
//  port
//   a, b   : add datas
//   cin    : carry in
//   result : result of a + b + c
//   cout   : '1' when result > 2^$bit_width-1
\n
module $instance_name_add (
  a      ,
  b      ,
  cin    ,
  result ,
  cout   );
\n
input  $data1 a      ;
input  $data1 b      ;
input         cin    ;
output $data1 result ;
output        cout   ;
\n
wire  $data1 a      ;
wire  $data1 b      ;
wire         cin    ;
wire  $data1 result ;
wire         cout   ;
\n
assign {cout, result} = a + b + cin;
\n
endmodule
\n
FHM_DL_INSTANCE
    }
    if ("$algorithm" eq "seq" || "$data_type" eq "two_complement"){
print <<FHM_DL_INSTANCE
// Module     : ${double_width}-bit unsigned adder
// References :
// Author     : Designed by T.Morifuji (c)1996.
// Version    : 1.0
\n
// Functionality : synthesis level
//  port
//   a, b   : add datas
//   cin    : carry in
//   result : result of a + b + c
//   cout   : '1' when result > 2^$bit_width-1
\n
module $instance_name_add2 (
  a      ,
  b      ,
  cin    ,
  result ,
  cout   );
\n
input  $double_data a      ; 
input  $double_data b      ;
input         cin   ;
output $double_data result ;
output        cout   ;
\n
wire  $double_data a      ; 
wire  $double_data b      ;
wire         cin    ;
wire  $double_data result ;
wire         cout   ;
\n
assign {cout, result} = a + b + cin;
\n
endmodule
\n
FHM_DL_INSTANCE
    }
}

# unsigned multiplier generation
if ("$algorithm" eq "seq") {
    {
    print <<FHM_DL_SMUL0;
// Module     : ${bit_width}-bit Edge Trigger Register
// Feature    : positive
// References : Started from scratch
// Author     : Designed by T.Morifuji (c)1997.
// Version    : 1.0  :
\n
// Functionality : synthesis level
//  port
//   clock    : clock
//   async_reset    : asynchronous reset
//   reset    : synchronous reset
//   enb      : '1' then register data
//   data_in  : data to register
//   data_out : registered data
\n
module ${instance_name}_reg$bit_width (
  clock       ,
  async_reset ,
  reset       ,
  enb         ,
  data_in     ,
  data_out    ) ;
\n
input         clock       ;
input         async_reset ;
input         reset       ;
input         enb         ;
input  [$w:0] data_in     ;
output [$w:0] data_out    ;
\n
wire         clock       ;
wire         async_reset ;
wire         reset       ;
wire         enb         ;
wire  [$w:0] data_in     ;
reg   [$w:0] data_out    ;
\n
always@ (posedge clock or posedge async_reset)
begin
    if (async_reset == 1'b1)
      data_out <= \{$bit_width\{1'b0\}\};
    else
    begin
      if (reset == 1'b1)
        data_out <= \{$bit_width\{1'b0\}\};
      else if (enb == 1'b1)
        data_out <= data_in;
    end
end
\n
endmodule
\n
//%%
\n
// Module     : ${double_width}-bit Edge Trigger Register
// Feature    : positive
// References : Started from scratch
// Author     : Designed by T.Morifuji (c)1997.
// Version    : 1.0  :
\n
// Functionality : synthesis level
//  port
//   clock    : clock
//   async_reset    : asynchronous reset
//   reset    : synchronous reset
//   enb      : '1' then register data
//   data_in  : data to register
//   data_out : registered data
\n
module ${instance_name}_reg$double_width (
  clock       ,
  async_reset ,
  reset       ,
  enb         ,
  data_in     ,
  data_out    ) ;
\n
input         clock       ;
input         async_reset ;
input         reset       ;
input         enb         ;
input  [$w2:0] data_in     ;
output [$w2:0] data_out    ;
\n
wire         clock       ;
wire         async_reset ;
wire         reset       ;
wire         enb         ;
wire  [$w2:0] data_in     ;
reg   [$w2:0] data_out    ;
\n
always@ (posedge clock or posedge async_reset)
begin
    if (async_reset == 1'b1)
      data_out <= \{$double_width\{1'b0\}\};
    else
    begin
      if (reset == 1'b1)
        data_out <= \{$double_width\{1'b0\}\};
      else if (enb == 1'b1)
        data_out <= data_in;
    end
end
\n
endmodule
\n
//%%
\n
// Module     : ${bit_width}-bit Unsigned Multiplier
// Feature    : type : shift
// References : Start from scratch
// Author     : Designed by T.Morifuji (c)1996,1997,1999.
//              Modified by T.Yoshimura (c)2004.
// Version    : 1.2  :
\n
// Functionality :
//  port
//   clock  : clock
//   a, b   : can represent from 0 to 2^$bit_width-1 in integer
//   mode   : start multiplication when '0' after 1-clock '1'
//   result : multiplied result
//   fin    : '1' when operation is over
\n
// Comment :
\n
module ${instance_name}_smul (
  clock       ,
  async_reset ,
  reset       ,
  clear       ,
  start       ,
  a           ,
  b           ,
  result      ,
  fin         ) ;
\n
input         clock       ;
input         async_reset ;
input         reset       ;
input         clear       ;
input         start       ;
input  [$w:0] a           ;
input  [$w:0] b           ;
output [$w2:0] result      ;
output        fin         ;
\n
wire         clock       ;
wire         async_reset ;
wire         reset       ;
wire         clear       ;
wire         start       ;
wire  [$w:0] a           ;
wire  [$w:0] b           ;
wire  [$w2:0] result      ;
reg          fin         ;
\n
wire         add_sel       ; 
reg          ld_ab         ;
reg          sft_b         ;
reg          reg${double_width}_enb     ;
reg          reg${double_width}_reset   ;
wire         reg${double_width}_reset2  ;
wire [$w:0]  from_reg_${bit_width}_a ;
wire [$w:0]  to_reg_${bit_width}_b   ;
wire [$w:0]  from_reg_${bit_width}_b ;
wire [$w2:0]  to_add_a      ; 
wire [$w2:0]  to_add_b      ; 
wire [$w2:0]  from_add      ; 
wire [$w2:0]  result_tmp    ;
wire         cout_tmp      ;
\n
reg  [ $b_len:0] current_state  ;
reg  [ $b_len:0] next_state     ;
\n
FHM_DL_SMUL0
    }
for ($i=0; $i<=$bit_width+2;$i++){
   $j = &to_comp($i, $b_len+1);
   if ($i == 0){
    print "parameter        st$i = ${b_len2}'b$j,\n";
   }
   elsif ($i == $bit_width+2){
    print "                 st$i = ${b_len2}'b$j;\n";
   }
   else{
    print "                 st$i = ${b_len2}'b$j,\n";
   }
}
    {
    print <<FHM_DL_SMUL1
\n
assign  add_sel = from_reg_${bit_width}_b[$w];
assign  to_add_a[$w2:$bit_width] = \{$bit_width\{1'b0\}\};
assign  to_add_a[$w:0] = (add_sel == 1'b1) ? from_reg_${bit_width}_a : \{$bit_width\{1'b0\}\};
assign  to_add_b = {result_tmp[$w2-1:0] , 1'b0};
assign  result = result_tmp;
\n
  ${instance_name}_reg$bit_width  reg_${bit_width}_a (
      .clock    (clock),
      .async_reset    (async_reset),
      .reset    (reset),
      .enb      (ld_ab),
      .data_in  (a),
      .data_out (from_reg_${bit_width}_a));
\n
assign  to_reg_${bit_width}_b = (ld_ab == 1'b1) ? b : 
                      (sft_b == 1'b1) ? {from_reg_${bit_width}_b[$w-1:0] , 1'b0} : from_reg_${bit_width}_b[$w:0];
\n  
  ${instance_name}_reg$bit_width  reg_${bit_width}_b (
      .clock    (clock),
      .async_reset    (async_reset),
      .reset    (reset),
      .enb      (1'b1),
      .data_in  (to_reg_${bit_width}_b),
      .data_out (from_reg_${bit_width}_b));
\n  
  ${instance_name_add2}  add0 (
      .a      (to_add_a),
      .b      (to_add_b),
      .cin    (1'b0),
      .result (from_add),
      .cout   (cout_tmp));
\n
assign  reg${double_width}_reset2 = reg${double_width}_reset | reset;
\n
  ${instance_name}_reg$double_width  reg_$double_width (
      .clock    (clock),
      .async_reset (async_reset),
      .reset    (reg${double_width}_reset2),
      .enb      (reg${double_width}_enb),
      .data_in  (from_add),
      .data_out (result_tmp));
\n  
always@ (current_state or start or clear)
begin
  case (current_state)
\n
    st0 :
      begin
        ld_ab = 1'b0;
        sft_b = 1'b0;
        reg${double_width}_enb = 1'b0;
        reg${double_width}_reset = 1'b0;
        fin = 1'b1 & ~start;
        if (start == 1'b1 && clear == 1'b0)
          next_state = st1;
        else
          next_state = st0;
      end
\n
    st1 :
      begin
        if (clear == 1'b1)
          next_state = st0;
        else
          next_state = st2;
        ld_ab = 1'b1;
        sft_b = 1'b0;
        reg${double_width}_enb = 1'b0;
        reg${double_width}_reset = 1'b1;
        fin = 1'b0;
      end
\n
FHM_DL_SMUL1
    }
    $i = 2;

    while ($i <= $bit_width+1) {
        $n_i = $i + 1;
        {
        print <<FHM_DL_SMUL_STATE
    st$i :
      begin
        if (clear == 1'b1)
          next_state = st0;
        else
          next_state = st$n_i;
        ld_ab = 1'b0;
        sft_b = 1'b1;
        reg${double_width}_enb = 1'b1;
        reg${double_width}_reset = 1'b0;
        fin = 1'b0;
      end
\n
FHM_DL_SMUL_STATE
        }
        $i = $n_i;
    }
    {
    print <<FHM_DL_SMUL2
    st$i :
      begin
        next_state = st0;
        ld_ab = 1'b0;
        sft_b = 1'b0;
        reg${double_width}_enb = 1'b0;
        reg${double_width}_reset = 1'b0;
        fin = 1'b1;
      end
\n
    default :
      begin
        next_state = st0;
        ld_ab = 1'b0;
        sft_b = 1'b0;
        reg${double_width}_enb = 1'b0;
        reg${double_width}_reset = 1'b0;
        fin = 1'b1;
      end
\n
 endcase
end
\n
always@ (posedge clock or posedge async_reset)
begin
    if (async_reset == 1'b1)
      current_state <= st0;
    else
    begin
      if (reset == 1'b1)
        current_state <= st0;
      else
        current_state <= next_state;
    end
end
\n  
endmodule
\n
//%%
\n
FHM_DL_SMUL2
    }
}
elsif ("$algorithm" eq "array") {
{
    print <<FHM_DL_AMUL;
// Module     : ${bit_width}-bit Unsigned Multiplier
// Feature    : type : array
// References : Start from scratch
// Author     : Designed by T.Morifuji (c)1996,1997.
// Version    : 1.0  :
\n
// Functionality :
//  port
//   W      : bit width. boundary of input
//   a, b   : can represent from 0 to 2^$bit_width-1 in integer
//   result : multiplied result
\n
// Comment :
\n
module ${instance_name}_amul (
  a      ,
  b      ,
  result ) ;
\n
input  [$w:0] a      ; 
input  [$w:0] b      ;
output [$w2:0] result ;
\n
wire  [$w:0] a      ; 
wire  [$w:0] b      ;
wire  [$w2:0] result ;
\n
wire  [$w:0] add_a [$w:1] ;
wire  [$w:0] add_b [$w:1] ;
wire  [$w:0] s	 [$w:0] ;
wire  [$w:0] c ; 
\n
FHM_DL_AMUL
}

{
   print<<FHM_DL_AMUL
// function definition : ADD_AN
function [$w:0] ADD_AN ;
input [$w:0] a  ;
input        bn ;
integer i ;
for (i = $w ; i >= 0 ; i = i - 1)
  ADD_AN[i] = a[i] & bn ;
endfunction
\n
// function definition : ADD_BN
function [$w:0] ADD_BN ;
input [$w:0] sn ;
input        cn ;
integer i ;
for (i = $w ; i >= 0 ; i = i - 1) 
  if (i == $w)
    ADD_BN[$w] = cn ;
  else
    ADD_BN[i] = sn[i+1] ;
endfunction
\n
// function definition : RES
function RES ;
input [$w:0] sn ;
  RES = sn[0] ;
endfunction
\n
// function definition : S0
function [$w:0] S0 ;
input [$w:0] a  ;
input        b0 ;
integer i ;
for (i = $w ; i >= 0 ; i = i - 1)
  S0[i] = a[i] & b0 ;
endfunction
\n
// add a
FHM_DL_AMUL
}

for ($i=1;$i<=$w;$i++){
print "assign add_a[ $i] = ADD_AN (a, b[ $i]) ;\n";
}
print " \n";
print "// b carry\n";
for ($i=1;$i<=$w;$i++){
$i_tmp = $i - 1;
print "assign add_b[ $i] = ADD_BN (s[ $i_tmp], c[ $i_tmp]) ;\n";
}
print " \n";
print "assign result[ 0] = a[0] & b[0] ;\n";
$w_2 = $bit_width - 2;
$w2_2 = 2*$bit_width - 2;
for ($i=1;$i<=$w_2;$i++){
print "assign result[ $i] = RES (s[ $i]) ;\n";
}
print "assign result[$w2_2:$w] = s[$w] ;\n";
print "assign result[$w2] = c[$w] ;\n";
{
  print<<FHM_DL_AMUL
\n
assign s[0] = S0 (a, b[0]) ; 
assign c[0] = 1'b0 ;
\n
// port mapping : adder
FHM_DL_AMUL
}

for ($i=1;$i<=$w;$i++){
  print<<FHM_DL_AMUL
${instance_name}_add${bit_width} add$i (.a(add_a[$i]), .b(add_b[$i]),
                         .cin(1'b0), .result(s[$i]),
                         .cout(c[$i])) ;
\n
FHM_DL_AMUL
}

{
   print<<FHM_DL_AMUL
endmodule
\n
//%%
\n
FHM_DL_AMUL
}
}

if ("$data_type" eq "two_complement" || "$data_type" eq "abs") {
    print <<FHM_DL_TWO;
// Module     : ${bit_width}-bit 2's complement converter
// Feature    : ${bit_width}-bit
// References : Start from scratch
// Author     : Designed by T.Morifuji (c)1996.
// Version : 1.0  :
\n
// Functionality :
//  port
//   data_in  : data for convert
//   conv     : '1' then convert data
//   data_out : converted data
\n
module ${instance_name}_tconv$bit_width (
  data_in  ,
  conv     ,
  data_out );
\n
input  [$w:0] data_in  ;
input         conv     ;
output [$w:0] data_out ;
\n
wire  [$w:0] data_in  ;
wire         conv     ;
wire  [$w:0] data_out ;
\n
wire  [$w:0] not_data_in ;
wire  [$w:0] tmp_data_out;
wire         tmp_cout    ;
\n
assign not_data_in = ~data_in;
\n
  ${instance_name_add}  two_conv (
    .a      (not_data_in),
    .b      (\{$bit_width\{1'b0\}\}), 
    .cin    (conv),
    .result (tmp_data_out),
    .cout   (tmp_cout));
\n
assign  data_out = (conv == 1'b0) ? data_in : tmp_data_out;
\n
endmodule
\n
//%%
\n
FHM_DL_TWO
}
if ("$data_type" eq "two_complement") {
    print <<FHM_DL_TWO;
// Module     : ${double_width}-bit 2's complement converter
// Feature    : ${double_width}-bit
// References : Start from scratch
// Author     : Designed by T.Morifuji (c)1996.
\n
// Version : 1.0  :
// Functionality :
//  port
//   data_in  : data for convert
//   conv     : '1' then convert data
//   data_out : converted data
\n
module ${instance_name}_tconv$double_width (
  data_in  ,
  conv     ,
  data_out );
\n
input  [$w2:0] data_in  ;
input         conv     ;
output [$w2:0] data_out ;
\n
wire [$w2:0] data_in  ;
wire        conv     ;
wire [$w2:0] data_out ;
\n
wire [$w2:0] not_data_in ;
wire [$w2:0] tmp_data_out;
wire        tmp_cout ;
\n
assign not_data_in = ~data_in;
\n
  ${instance_name_add2}  two_conv (
     .a       (not_data_in),
     .b       (\{$double_width\{1'b0\}\}),
     .cin     (conv),
     .result  (tmp_data_out),
     .cout    (tmp_cout));
\n
assign  data_out = (conv == 1'b0) ? data_in : tmp_data_out;
\n
endmodule
\n
//%%
\n
FHM_DL_TWO
}

print <<FHM_DL_INSTANCE2;
// Module     : ${bit_width}-bit Multiplier
// Feature    : $algorithm $add_algo $data_type
// References : Start from scratch
// Author     : Designed by T.Morifuji (c)1996,1997,1999.
//              Modified by T.Yoshimura (c)2004.
// Version    : 1.2  :
// Functionality :
//  port
//   W       : bit width. boundary of input
//   clock   : clock
//   a, b    : can represent from 0 to 2^$bit_width-1 in integer
FHM_DL_INSTANCE2
if ($data_type eq "two_complement") {
    print "//   mode    : '0' when data type is unsigned\n";
    print "//             '1' when data type is two_complement\n";
}
else {
    print "//   mode    : (ignore)\n";
}
if ($algorithm eq "seq") {
  print "//   start   : '1' when operation starts\n";
}
else {
  print "//   start   : (ignore)\n";
}
print <<FHM_DL_INSTANCE3;
//   result  : multiplied result
//   fin     : '1' when operation is over
\n
// Comment :
\n
module $instance_name (
  clock       ,
  async_reset ,
  reset       ,
  a           ,
  b           ,
  mode        ,
  start       ,
  clear       ,
  result      ,
  fin         ) ;
\n
input         clock       ;
input         async_reset ;
input         reset       ;
input signed [$w:0] a           ; 
input signed [$w:0] b           ;
input         mode        ;
input         start       ;
input         clear       ;
output signed [$w2:0] result      ;
output        fin         ;
\n
wire         clock       ;
wire         async_reset ;
wire         reset       ;
wire signed [$w:0] a           ; 
wire signed [$w:0] b           ;
wire         mode        ;
wire         start       ;
wire         clear       ;
wire signed [$w2:0] result      ;
wire         fin         ;
\n
FHM_DL_INSTANCE3



if ("$data_type" eq "unsigned") {
    if ("$algorithm" eq "seq") {
	print <<FHM_DL_SEQ3;
wire         smul_fin ;
\n
  ${instance_name}_smul  smul0 (
      .clock       (clock),
      .async_reset (async_reset),
      .reset       (reset),
      .clear       (clear),
      .start       (start),
      .a           (a),
      .b           (b),
      .result      (result),
      .fin         (smul_fin));
\n
assign  fin = smul_fin & ~start;
\n
FHM_DL_SEQ3
    }
    elsif ("$algorithm" eq "array") {
	print <<FHM_DL_ARRAY;
\n
assign  fin = 1'b1;
\n
  ${instance_name}_amul  amul0 ( 
    .a        (a), 
    .b        (b),
    .result   (result));
\n
FHM_DL_ARRAY
    }
    print "endmodule\n";
}

if ("$data_type" eq "two_complement") {


    print <<FHM_DL_TWO3;
wire signed [$w:0] conved_a ;
wire signed [$w:0] conved_b ;
wire signed [$w2:0] conved_result ;
wire signed [$w:0] tmp_a ;
wire signed [$w:0] tmp_b ;
wire signed [$w2:0] tmp_result ;
FHM_DL_TWO3
    if ("$algorithm" eq "seq") {
        print <<FHM_DL_SEQ5;
wire         in_result_tconv_conv ;
wire         out_result_tconv_conv ;
wire         mode_tmp ;
wire         smul_fin ;
FHM_DL_SEQ5
    }
    print <<FHM_DL_TWO4;
wire         result_tconv_conv ;
\n
assign  result_tconv_conv = a[$w] ^ b[$w];
FHM_DL_TWO4
    if ("$algorithm" eq "seq") {
	print <<FHM_DL_SEQ6;
assign  in_result_tconv_conv = result_tconv_conv;
\n
  ${instance_name}_reg1  tconv_reg (
      .clock    (clock),
      .async_reset      (async_reset),
      .reset    (reset),
      .enb      (start),
      .data_in  (in_result_tconv_conv),
      .data_out (out_result_tconv_conv));
\n
  ${instance_name}_reg1  mode_reg (
      .clock    (clock),
      .async_reset (async_reset),
      .reset    (reset),
      .enb      (start),
      .data_in  (mode),
      .data_out (mode_tmp));
FHM_DL_SEQ6
    }
    print <<FHM_DL_TWO5;
\n
  ${instance_name}_tconv${bit_width}  conv_a (
      .data_in   (a),
      .conv      (a[$w]),
      .data_out  (conved_a));      
\n
  ${instance_name}_tconv${bit_width}  conv_b (
      .data_in   (b),
      .conv      (b[$w]),
      .data_out  (conved_b));
\n
FHM_DL_TWO5

    if ("$algorithm" eq "seq") {
	print <<FHM_DL_SEQ6;
assign  tmp_a = (mode_tmp == 1'b0) ? a : conved_a;
\n
assign  tmp_b = (mode_tmp == 1'b0) ? b : conved_b;
\n
  ${instance_name}_smul  mulu (
      .clock  (clock),
      .async_reset  (async_reset),
      .reset  (reset),
      .clear  (clear),
      .start  (start),
      .a      (tmp_a),
      .b      (tmp_b),
      .result (tmp_result),
      .fin    (smul_fin));
\n
FHM_DL_SEQ6
    }
    elsif ("$algorithm" eq "array") {
	print <<FHM_DL_ARRAY2;
assign  fin = 1'b1;
\n
assign  tmp_a = (mode == 1'b0) ? a : conved_a;
\n
assign  tmp_b = (mode == 1'b0) ? b : conved_b;
\n
  ${instance_name}_amul  mulu (
      .a         (tmp_a),
      .b         (tmp_b),
      .result    (tmp_result));
\n
FHM_DL_ARRAY2
    }
    print "  ${instance_name}_tconv${double_width}  conv_result (\n";

    if ("$algorithm" eq "seq") {
        print "    .data_in   (tmp_result),\n";
        print "    .conv      (out_result_tconv_conv),\n";
        print "    .data_out  (conved_result));\n";
        print " \n";
	print "assign  result = (mode_tmp == 1'b0) ? tmp_result : conved_result;\n";
    }
    else {
        print "    .data_in   (tmp_result),\n";
        print "    .conv      (result_tconv_conv),\n";
        print "    .data_out  (conved_result));\n";
        print " \n";
	print "assign  result = (mode == 1'b0) ? tmp_result : conved_result;\n";
        print " \n";
    }

    if ("$algorithm" eq "seq") {
	print "assign  fin = smul_fin & ~start;\n";
        print " \n";
    }

    print "endmodule\n";
}

if ("$data_type" eq "abs") {

    if ("$algorithm" eq "seq") {
	print <<FHM_DL_SEQ7;
wire        smul_fin ;
wire        vss = 1'b0 ;
FHM_DL_SEQ7
    }
    print <<FHM_DL_ABS;
wire signed [$w:0] conved_a ;
wire signed [$w:0] conved_b ;
wire signed [$w2:0] to_result ;
\n
  ${instance_name}_tconv${bit_width}  conv_a (
     .data_in     (a),
     .conv        (a[$w]),
     .data_out    (conved_a));
\n
  ${instance_name}_tconv${bit_width}  conv_b (
     .data_in     (b),
     .conv        (b[$w]),
     .data_out    (conved_b));
\n
assign  result[$w2:0] = to_result[$w2:0];
\n
FHM_DL_ABS
  
    if ("$algorithm" eq "seq") {
	print <<FHM_DL_SEQ9;

  ${instance_name}_smul  mulu (
      .clock       (clock),
      .async_reset (async_reset),
      .reset       (reset),
      .clear       (clear),
      .start       (start),
      .a           (conved_a),
      .b           (conved_b),
      .result      (to_result),
      .fin         (smul_fin));
\n
assign  fin = smul_fin & ~start;
\n
FHM_DL_SEQ9
    } 
    elsif ("$algorithm" eq "array") {
	print <<FHM_DL_ARRAY3;
assign  fin = 1'b1;
\n
  ${instance_name}_amul  mulu (
      .a         (conved_a),
      .b         (conved_b),
      .result    (to_result));
\n
FHM_DL_ARRAY3
    }
    print "endmodule\n";
}
}#$algorithm == default 
exit (0);
# ---------------------------------

sub log2u{
    $num = $_[0];

    for ($i=1, $N=2; $N<$num; $i++, $N*=2){};
    return($i);
}

# ---------------------------------

sub to_comp{
  @buf = ();
  $num = $_[0];
  $width = $_[1];

  for ($x=1; $x<$width; $x++){
    $buf[$x] = $num % 2;
    $num = ($num - $buf[$x]) / 2;
  }
  $buf[$x] = $num % 2;
  return (join("", reverse(@buf)));
}
          ]]>
        </script>
      </instance>
                                                                                
      <entity></entity>
                                                                                
      <testvector></testvector>
                                                                                
      <synthesis></synthesis>
    </design>

    <design>
      <design_lang> SystemC Header </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates multiplier instance in behavior level
# parameter : name_space instance_name bit_width algorithm data_type

if ($#ARGV != 5){
    print "number of parameters is wrong.\n";
    print "usage : this_script name_space instance_name bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];
$algorithm     = $ARGV[3];
$add_algo      = $ARGV[4];
$data_type     = $ARGV[5];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$b2 = 2 * $bit_width;

if ( $bit_width <= 64 ) {
    $input_type = "sc_dt::sc_uint<$bit_width>";
} else {
    $input_type = "sc_dt::sc_biguint<$bit_width>";
}

if ( $b2 <= 64 ) {
    $output_type = "sc_dt::sc_uint<$b2>";
} else {
    $output_type = "sc_dt::sc_biguint<$b2>";
}

$w = $bit_width - 1;
$w2 = $b2 -1;
$delay = $bit_width + 2;

if ("$data_type" eq "two_complement"){
    $mode_comment = "\'1\' for signed multiplication\n//              '0' for unsigned multiplication";
}
else{
    $mode_comment = "(ignore)";
}

$macro = "__" . uc($name_space) . "_" . uc($instance_name) . "_H__";

{
print <<FHM_DL_INSTANCE;
#ifndef $macro
#define $macro 1

// Module     : $bit_width-bit Multiplier
// Feature    : 
// References : Start from scratch
// Author     : Designed by T.Morifuji (c)1996,1999
//              Modefied by Tak. Tokihisa (c)2002
// Version    : 1.1  :

// Functionality : behavioral level
//  port
//   clock   : (ignore)
//   async_reset   : (ignore)
//   reset   : (ignore)
//   a       : multiplicand
//   b       : multiplier
//   mode    : $mode_comment
//   start   : (ignore)
//   clear   : (ignore)
//   result  : multiplied result
//   fin     : '1' when operation is over

// Comment :

#include <systemc>

namespace $name_space {
  SC_MODULE($instance_name) {
    sc_core::sc_in< bool > clock;
    sc_core::sc_in< bool > async_reset;
    sc_core::sc_in< bool > reset;
    sc_core::sc_in< $input_type > a, b;
    sc_core::sc_in< bool > mode;
    sc_core::sc_in< bool > start;
    sc_core::sc_in< bool > clear;
    sc_core::sc_out< $output_type > result;
    sc_core::sc_out< bool > fin;
FHM_DL_INSTANCE
}

if ( $algorithm eq "seq" ) {
print <<FHM_DL_INSTANCE

    sc_core::sc_signal< bool > tmp_fin;
    int count;
FHM_DL_INSTANCE
}

{
print <<FHM_DL_INSTANCE

    SC_CTOR($instance_name) :
      clock("clock"),
      async_reset("async_reset"),
      reset("reset"),
      a("a"), b("b"),
      mode("mode"),
      start("start"),
      clear("clear"),
      result("result"),
      fin("fin")
    {
FHM_DL_INSTANCE
}

if ( $algorithm eq "seq" ) {
print <<FHM_DL_INSTANCE
      SC_METHOD(calc);
      sensitive << clock.pos() << async_reset.pos();

      SC_METHOD(proc_fin);
      sensitive << start << tmp_fin;
FHM_DL_INSTANCE
} else {
print <<FHM_DL_INSTANCE
      SC_METHOD(init);

      SC_METHOD(calc);
      sensitive << a << b << mode;
FHM_DL_INSTANCE
}

{
print <<FHM_DL_INSTANCE
    }

    void init();
    void calc();
FHM_DL_INSTANCE
}

if ( $algorithm eq "seq" ) {
print <<FHM_DL_INSTANCE
    void proc_fin();
FHM_DL_INSTANCE
}

{
print <<FHM_DL_INSTANCE
  };
};

#endif // $macro
FHM_DL_INSTANCE
}

exit (0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <design>
      <design_lang> SystemC Program </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates multiplier instance in behavior level
# parameter : name_space instance_name bit_width algorithm data_type

if ($#ARGV != 5){
    print "number of parameters is wrong.\n";
    print "usage : this_script name_space instance_name bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];
$algorithm     = $ARGV[3];
$add_algo      = $ARGV[4];
$data_type     = $ARGV[5];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$b2 = 2 * $bit_width;
$b3 = 2 * ($bit_width + 1);

if ( $bit_width <= 64 ) {
    $input_type = "sc_dt::sc_uint<$bit_width>";
} else {
    $input_type = "sc_dt::sc_biguint<$bit_width>";
}

if ( $b2 <= 64 ) {
    $output_type = "sc_dt::sc_uint<$b2>";
} else {
    $output_type = "sc_dt::sc_biguint<$b2>";
}

if ( $bit_width + 1 <= 64 ) {
    $tmp_input_type = "sc_dt::sc_int<" . ($bit_width + 1) . ">";
} else {
    $tmp_input_type = "sc_dt::sc_bigint<" . ($bit_width + 1) . ">";
}

if ( $b3 <= 64 ) {
    $tmp_result_type = "sc_dt::sc_int<$b3>";
} else {
    $tmp_result_type = "sc_dt::sc_bigint<$b3>";
}

$w = $bit_width - 1;
$w2 = $b2 -1;
$w3 = $b3 - 1;
$delay = $bit_width + 2;

if ("$data_type" eq "two_complement"){
    $mode_comment = "\'1\' for signed multiplication\n//              '0' for unsigned multiplication";
}
else{
    $mode_comment = "(ignore)";
}

{
print <<FHM_DL_INSTANCE
#include "${instance_name}.h"

// Module     : $bit_width-bit Multiplier
// Feature    : 
// References : Start from scratch
// Author     : Designed by T.Morifuji (c)1996,1999
//              Modefied by Tak. Tokihisa (c)2002
// Version    : 1.1  :

// Functionality : behavioral level
//  port
//   clock   : 
//   async_reset   : 
//   reset   : 
//   a       : multiplicand
//   b       : multiplier
//   mode    : $mode_comment
//   start   : 
//   clear   : 
//   result  : multiplied result
//   fin     : '1' when operation is over

// Comment :

void ${name_space}::${instance_name}::init()
{
FHM_DL_INSTANCE
}

if ( $algorithm eq "seq" ) {
    print <<FHM_DL_INSTANCE
  result.write( 0 );
  tmp_fin.write( false );
  count = 0;
FHM_DL_INSTANCE
} else {
    print <<FHM_DL_INSTANCE
  fin.write( true );
FHM_DL_INSTANCE
}

{
    print <<FHM_DL_INSTANCE
}

FHM_DL_INSTANCE
}

if ( $algorithm eq "seq" ) {
    {
    print <<FHM_DL_INSTANCE
void ${name_space}::${instance_name}::proc_fin()
{
  if( start.read() ){
    fin.write( false );
  }else{
    fin.write( tmp_fin.read() );
  }
}

void ${name_space}::${instance_name}::calc()
{
  if ( async_reset.read() ) {
    init();
  } else {
    if ( reset.read() || clear.read() ) {
      init();
    } else if( start.read() ) {
      tmp_fin.write( false );
      count = 1;
    } else if ( count > 0 ) {
      count++;

      if ( count == $delay ) {
        $tmp_input_type tmp_a, tmp_b;
        $tmp_result_type tmp_result;

FHM_DL_INSTANCE
    }

    if ("$data_type" eq "two_complement"){
    print <<FHM_DL_INSTANCE2;
        tmp_a = ((a.read()[$w] & mode.read()) , a.read());
        tmp_b = ((b.read()[$w] & mode.read()) , b.read());
FHM_DL_INSTANCE2
    } elsif("$data_type" eq "abs") {
    print <<FHM_DL_INSTANCE3;
        if ( a.read()[$w] == 1 )
          tmp_a = - a.read();
        else
          tmp_a = a.read();

        if ( b.read()[$w] == 1 )
          tmp_b = - b.read();
        else
          tmp_b = b.read();
FHM_DL_INSTANCE3
    } elsif ("$data_type" eq"unsigned") {
    print <<FHM_DL_INSTANCE4;
        tmp_a = a.read();
        tmp_b = b.read();
FHM_DL_INSTANCE4
    }

    {
    print <<FHM_DL_INSTANCE5
        tmp_result = tmp_a * tmp_b;

        tmp_fin.write( true );
        result.write( ${output_type}(tmp_result($w2, 0)) );
        count = 0;
      }
    }
  }
}

FHM_DL_INSTANCE5
    }
} else {
    {
    print <<FHM_DL_INSTANCE
void ${name_space}::${instance_name}::calc()
{
  $tmp_input_type tmp_a, tmp_b;

FHM_DL_INSTANCE
    }

    if ("$data_type" eq "two_complement"){
        print <<FHM_DL_INSTANCE2;
  tmp_a = ((a.read()[$w] & mode.read()) , a.read());
  tmp_b = ((b.read()[$w] & mode.read()) , b.read());
FHM_DL_INSTANCE2
    } elsif("$data_type" eq "abs") {
        print <<FHM_DL_INSTANCE3;
  if (a.read()[$w] == 1)
    tmp_a = - a.read();
  else
    tmp_a = a.read();

  if (b.read()[$w] == 1)
    tmp_b = - b.read();
  else
    tmp_b = b.read();
FHM_DL_INSTANCE3
    } elsif ("$data_type" eq"unsigned") {
        print <<FHM_DL_INSTANCE4;
  tmp_a = a.read();
  tmp_b = b.read();
FHM_DL_INSTANCE4
    }

    {
    print <<FHM_DL_INSTANCE

  result.write( ${output_type}(tmp_a * tmp_b)($w2, 0) );
}
FHM_DL_INSTANCE
    }
}
exit (0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <estimation>
      <estimation_data>
        <library name="OSAKA">

          <est_type name="shape">
            <est_index name="area">
              <unit> mm2 </unit>
              <translate>
                <translate_value key="gate"> 4201.68 </translate_value>
                <translate_value key="mm2">  1 </translate_value>
              </translate>

              <parameters name="default,default,unsigned">
                <max>
                  <data bit_width="4"> 0.123712925306068 </data>
                  <data bit_width="8"> 0.236757234487157 </data>
                  <data bit_width="16"> 0.476205827668932 </data>
                  <data bit_width="32"> 0.945771826031492 </data>
                  <data bit_width="128"> 4.06975509653281 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.099111087707774 </data>
                  <data bit_width="8"> 0.190987825584052 </data>
                  <data bit_width="16"> 0.384135431541669 </data>
                  <data bit_width="32"> 0.746129886854782 </data>
                  <data bit_width="128"> 3.21349417828107 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.099111087707774 </data>
                    <data bit_width="8"> 0.190987825584052 </data>
                    <data bit_width="16"> 0.384135431541669 </data>
                    <data bit_width="32"> 0.746129886854782 </data>
                    <data bit_width="128"> 3.21349417828107 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.123712925306068 </data>
                    <data bit_width="8"> 0.236757234487157 </data>
                    <data bit_width="16"> 0.476205827668932 </data>
                    <data bit_width="32"> 0.945771826031492 </data>
                    <data bit_width="128"> 4.06975509653281 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.106531854401097 </data>
                    <data bit_width="8"> 0.207308027265284 </data>
                    <data bit_width="16"> 0.415832754279241 </data>
                    <data bit_width="32"> 0.797478569524571 </data>
                    <data bit_width="128"> 3.28899411211706 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="default,default,abs">
                <max>
                  <data bit_width="4"> 0.172741339892614 </data>
                  <data bit_width="8"> 0.330637049703928 </data>
                  <data bit_width="16"> 0.676175714238114 </data>
                  <data bit_width="32"> 1.35792908931665 </data>
                  <data bit_width="128"> 5.72224514218122 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.132268346946936 </data>
                  <data bit_width="8"> 0.257472462205594 </data>
                  <data bit_width="16"> 0.519861693417871 </data>
                  <data bit_width="32"> 1.03546483668437 </data>
                  <data bit_width="128"> 4.45995383465661 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.132268346946936 </data>
                    <data bit_width="8"> 0.257472462205594 </data>
                    <data bit_width="16"> 0.519861693417871 </data>
                    <data bit_width="32"> 1.03546483668437 </data>
                    <data bit_width="128"> 4.45995383465661 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.172741339892614 </data>
                    <data bit_width="8"> 0.330637049703928 </data>
                    <data bit_width="16"> 0.676175714238114 </data>
                    <data bit_width="32"> 1.35792908931665 </data>
                    <data bit_width="128"> 5.72224514218122 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.14387131361741 </data>
                    <data bit_width="8"> 0.285395630557301 </data>
                    <data bit_width="16"> 0.57750256016641 </data>
                    <data bit_width="32"> 1.14115974705356 </data>
                    <data bit_width="128"> 4.81419550846328 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="default,default,two_complement">
                <max>
                  <data bit_width="4"> 0.242819713067154 </data>
                  <data bit_width="8"> 0.48033099712496 </data>
                  <data bit_width="16"> 0.966254007206641 </data>
                  <data bit_width="32"> 1.98143770777403 </data>
                  <data bit_width="128"> 7.84562105205537 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.188362837960054 </data>
                  <data bit_width="8"> 0.37107012433122 </data>
                  <data bit_width="16"> 0.730794514813122 </data>
                  <data bit_width="32"> 1.46525153414825 </data>
                  <data bit_width="128"> 6.46204222929876 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.188362837960054 </data>
                    <data bit_width="8"> 0.37107012433122 </data>
                    <data bit_width="16"> 0.730794514813122 </data>
                    <data bit_width="32"> 1.46525153414825 </data>
                    <data bit_width="128"> 6.46204222929876 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.242819713067154 </data>
                    <data bit_width="8"> 0.48033099712496 </data>
                    <data bit_width="16"> 0.966254007206641 </data>
                    <data bit_width="32"> 1.98143770777403 </data>
                    <data bit_width="128"> 7.84562105205537 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.210378756592601 </data>
                    <data bit_width="8"> 0.410242048656728 </data>
                    <data bit_width="16"> 0.827526306620209 </data>
                    <data bit_width="32"> 1.61653507311361 </data>
                    <data bit_width="128"> 7.00918246915519 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,default,unsigned">
                <max>
                  <data bit_width="4"> 0.123712925306068 </data>
                  <data bit_width="8"> 0.236757234487157 </data>
                  <data bit_width="16"> 0.476205827668932 </data>
                  <data bit_width="32"> 0.945771826031492 </data>
                  <data bit_width="128"> 4.06975509653281 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.099111087707774 </data>
                  <data bit_width="8"> 0.190987825584052 </data>
                  <data bit_width="16"> 0.384135431541669 </data>
                  <data bit_width="32"> 0.746129886854782 </data>
                  <data bit_width="128"> 3.21349417828107 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.099111087707774 </data>
                    <data bit_width="8"> 0.190987825584052 </data>
                    <data bit_width="16"> 0.384135431541669 </data>
                    <data bit_width="32"> 0.746129886854782 </data>
                    <data bit_width="128"> 3.21349417828107 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.123712925306068 </data>
                    <data bit_width="8"> 0.236757234487157 </data>
                    <data bit_width="16"> 0.476205827668932 </data>
                    <data bit_width="32"> 0.945771826031492 </data>
                    <data bit_width="128"> 4.06975509653281 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.106531854401097 </data>
                    <data bit_width="8"> 0.207308027265284 </data>
                    <data bit_width="16"> 0.415832754279241 </data>
                    <data bit_width="32"> 0.797478569524571 </data>
                    <data bit_width="128"> 3.28899411211706 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,default,abs">
                <max>
                  <data bit_width="4"> 0.172741339892614 </data>
                  <data bit_width="8"> 0.330637049703928 </data>
                  <data bit_width="16"> 0.676175714238114 </data>
                  <data bit_width="32"> 1.35792908931665 </data>
                  <data bit_width="128"> 5.72224514218122 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.132268346946936 </data>
                  <data bit_width="8"> 0.257472462205594 </data>
                  <data bit_width="16"> 0.519861693417871 </data>
                  <data bit_width="32"> 1.03546483668437 </data>
                  <data bit_width="128"> 4.45995383465661 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.132268346946936 </data>
                    <data bit_width="8"> 0.257472462205594 </data>
                    <data bit_width="16"> 0.519861693417871 </data>
                    <data bit_width="32"> 1.03546483668437 </data>
                    <data bit_width="128"> 4.45995383465661 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.172741339892614 </data>
                    <data bit_width="8"> 0.330637049703928 </data>
                    <data bit_width="16"> 0.676175714238114 </data>
                    <data bit_width="32"> 1.35792908931665 </data>
                    <data bit_width="128"> 5.72224514218122 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.14387131361741 </data>
                    <data bit_width="8"> 0.285395630557301 </data>
                    <data bit_width="16"> 0.57750256016641 </data>
                    <data bit_width="32"> 1.14115974705356 </data>
                    <data bit_width="128"> 4.81419550846328 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,default,two_complement">
                <max>
                  <data bit_width="4"> 0.242819713067154 </data>
                  <data bit_width="8"> 0.48033099712496 </data>
                  <data bit_width="16"> 0.966254007206641 </data>
                  <data bit_width="32"> 1.98143770777403 </data>
                  <data bit_width="128"> 7.84562105205537 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.188362837960054 </data>
                  <data bit_width="8"> 0.37107012433122 </data>
                  <data bit_width="16"> 0.730794514813122 </data>
                  <data bit_width="32"> 1.46525153414825 </data>
                  <data bit_width="128"> 6.46204222929876 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.188362837960054 </data>
                    <data bit_width="8"> 0.37107012433122 </data>
                    <data bit_width="16"> 0.730794514813122 </data>
                    <data bit_width="32"> 1.46525153414825 </data>
                    <data bit_width="128"> 6.46204222929876 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.242819713067154 </data>
                    <data bit_width="8"> 0.48033099712496 </data>
                    <data bit_width="16"> 0.966254007206641 </data>
                    <data bit_width="32"> 1.98143770777403 </data>
                    <data bit_width="128"> 7.84562105205537 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.210378756592601 </data>
                    <data bit_width="8"> 0.410242048656728 </data>
                    <data bit_width="16"> 0.827526306620209 </data>
                    <data bit_width="32"> 1.61653507311361 </data>
                    <data bit_width="128"> 7.00918246915519 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,default,unsigned">
                <max>
                  <data bit_width="4"> 0.0665344038575046 </data>
                  <data bit_width="8"> 0.303126110508178 </data>
                  <data bit_width="16"> 1.3788018554483 </data>
                  <data bit_width="32"> 5.65741802231488 </data>
                  <data bit_width="128"> 153.581082447973 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.0446700243712039 </data>
                  <data bit_width="8"> 0.198250458150073 </data>
                  <data bit_width="16"> 0.875305453532872 </data>
                  <data bit_width="32"> 4.13702357604577 </data>
                  <data bit_width="128"> 111.925475345576 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.0446700243712039 </data>
                    <data bit_width="8"> 0.198250458150073 </data>
                    <data bit_width="16"> 0.875305453532872 </data>
                    <data bit_width="32"> 4.13702357604577 </data>
                    <data bit_width="128"> 111.925475345576 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.0665344038575046 </data>
                    <data bit_width="8"> 0.303126110508178 </data>
                    <data bit_width="16"> 1.3788018554483 </data>
                    <data bit_width="32"> 5.65741802231488 </data>
                    <data bit_width="128"> 153.581082447973 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.0587543273166924 </data>
                    <data bit_width="8"> 0.251823273309724 </data>
                    <data bit_width="16"> 1.1325912808686 </data>
                    <data bit_width="32"> 4.65291887340302 </data>
                    <data bit_width="128"> 111.926665345766 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,default,abs">
                <max>
                  <data bit_width="4"> 0.11535037770606 </data>
                  <data bit_width="8"> 0.397692805020849 </data>
                  <data bit_width="16"> 1.57627704132633 </data>
                  <data bit_width="32"> 6.37088542559167 </data>
                  <data bit_width="128"> 153.54899706784 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.0778272836103654 </data>
                  <data bit_width="8"> 0.26473512380762 </data>
                  <data bit_width="16"> 1.01439637121342 </data>
                  <data bit_width="32"> 4.40444869290379 </data>
                  <data bit_width="128"> 110.399471163915 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.0778272836103654 </data>
                    <data bit_width="8"> 0.26473512380762 </data>
                    <data bit_width="16"> 1.01439637121342 </data>
                    <data bit_width="32"> 4.40444869290379 </data>
                    <data bit_width="128"> 110.399471163915 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.11535037770606 </data>
                    <data bit_width="8"> 0.397692805020849 </data>
                    <data bit_width="16"> 1.57627704132633 </data>
                    <data bit_width="32"> 6.37088542559167 </data>
                    <data bit_width="128"> 153.54899706784 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.100387076835932 </data>
                    <data bit_width="8"> 0.348701519868243 </data>
                    <data bit_width="16"> 1.30899323675292 </data>
                    <data bit_width="32"> 5.0183618888159 </data>
                    <data bit_width="128"> 114.526272824204 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,default,two_complement">
                <max>
                  <data bit_width="4"> 0.179825995554159 </data>
                  <data bit_width="8"> 0.536206415767026 </data>
                  <data bit_width="16"> 1.85495463267074 </data>
                  <data bit_width="32"> 6.99433117372099 </data>
                  <data bit_width="128"> 154.131174910988 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.127579903038784 </data>
                  <data bit_width="8"> 0.369388638830182 </data>
                  <data bit_width="16"> 1.22627183769349 </data>
                  <data bit_width="32"> 4.86245512961482 </data>
                  <data bit_width="128"> 113.117111786238 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.127579903038784 </data>
                    <data bit_width="8"> 0.369388638830182 </data>
                    <data bit_width="16"> 1.22627183769349 </data>
                    <data bit_width="32"> 4.86245512961482 </data>
                    <data bit_width="128"> 113.117111786238 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.179825995554159 </data>
                    <data bit_width="8"> 0.536206415767026 </data>
                    <data bit_width="16"> 1.85495463267074 </data>
                    <data bit_width="32"> 6.99433117372099 </data>
                    <data bit_width="128"> 154.131174910988 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.158894572171132 </data>
                    <data bit_width="8"> 0.462797639991622 </data>
                    <data bit_width="16"> 1.56375856466937 </data>
                    <data bit_width="32"> 5.5008400285124 </data>
                    <data bit_width="128"> 113.456916340607 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>

            <est_index name="aspect_ratio">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="height">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="width">
              <!-- Dummy yet -->
            </est_index>
          </est_type>

          <est_type name="timing">
            <est_index name="delay">
              <unit> ns </unit>

              <parameters name="default,default,unsigned">
                <max>
                  <data bit_width="4"> 2.57 </data>
                  <data bit_width="8"> 2.43 </data>
                  <data bit_width="16"> 3.03 </data>
                  <data bit_width="32"> 2.63 </data>
                  <data bit_width="128"> 4.26 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.76 </data>
                  <data bit_width="8"> 1.91 </data>
                  <data bit_width="16"> 2.63 </data>
                  <data bit_width="32"> 2.07 </data>
                  <data bit_width="128"> 2.93 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 2.47 </data>
                    <data bit_width="8"> 2.05 </data>
                    <data bit_width="16"> 2.72 </data>
                    <data bit_width="32"> 2.63 </data>
                    <data bit_width="128"> 2.93 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 1.76 </data>
                    <data bit_width="8"> 1.91 </data>
                    <data bit_width="16"> 3.03 </data>
                    <data bit_width="32"> 2.07 </data>
                    <data bit_width="128"> 4.26 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 2.57 </data>
                    <data bit_width="8"> 2.43 </data>
                    <data bit_width="16"> 2.63 </data>
                    <data bit_width="32"> 2.55 </data>
                    <data bit_width="128"> 3.05 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="default,default,abs">
                <max>
                  <data bit_width="4"> 4.21 </data>
                  <data bit_width="8"> 2.41 </data>
                  <data bit_width="16"> 10.14 </data>
                  <data bit_width="32"> 19.27 </data>
                  <data bit_width="128"> 70.94 </data>
                </max>
                <min>
                  <data bit_width="4"> 2.47 </data>
                  <data bit_width="8"> 2.02 </data>
                  <data bit_width="16"> 2.68 </data>
                  <data bit_width="32"> 2.50 </data>
                  <data bit_width="128"> 2.93 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 2.47 </data>
                    <data bit_width="8"> 2.05 </data>
                    <data bit_width="16"> 2.72 </data>
                    <data bit_width="32"> 2.64 </data>
                    <data bit_width="128"> 2.93 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 4.21 </data>
                    <data bit_width="8"> 2.02 </data>
                    <data bit_width="16"> 10.14 </data>
                    <data bit_width="32"> 19.27 </data>
                    <data bit_width="128"> 70.94 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 2.57 </data>
                    <data bit_width="8"> 2.41 </data>
                    <data bit_width="16"> 2.68 </data>
                    <data bit_width="32"> 2.50 </data>
                    <data bit_width="128"> 3.00 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="default,default,two_complement">
                <max>
                  <data bit_width="4"> 6.70 </data>
                  <data bit_width="8"> 10.99 </data>
                  <data bit_width="16"> 19.75 </data>
                  <data bit_width="32"> 36.52 </data>
                  <data bit_width="128"> 142.70 </data>
                </max>
                <min>
                  <data bit_width="4"> 5.75 </data>
                  <data bit_width="8"> 10.01 </data>
                  <data bit_width="16"> 17.52 </data>
                  <data bit_width="32"> 32.78 </data>
                  <data bit_width="128"> 122.71 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 5.97 </data>
                    <data bit_width="8"> 10.07 </data>
                    <data bit_width="16"> 17.76 </data>
                    <data bit_width="32"> 32.78 </data>
                    <data bit_width="128"> 128.54 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 5.75 </data>
                    <data bit_width="8"> 10.01 </data>
                    <data bit_width="16"> 17.52 </data>
                    <data bit_width="32"> 33.19 </data>
                    <data bit_width="128"> 122.71 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 6.70 </data>
                    <data bit_width="8"> 10.99 </data>
                    <data bit_width="16"> 19.75 </data>
                    <data bit_width="32"> 36.52 </data>
                    <data bit_width="128"> 142.70 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,default,unsigned">
                <max>
                  <data bit_width="4"> 2.57 </data>
                  <data bit_width="8"> 2.43 </data>
                  <data bit_width="16"> 3.03 </data>
                  <data bit_width="32"> 2.63 </data>
                  <data bit_width="128"> 4.26 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.76 </data>
                  <data bit_width="8"> 1.91 </data>
                  <data bit_width="16"> 2.63 </data>
                  <data bit_width="32"> 2.07 </data>
                  <data bit_width="128"> 2.93 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 2.47 </data>
                    <data bit_width="8"> 2.05 </data>
                    <data bit_width="16"> 2.72 </data>
                    <data bit_width="32"> 2.63 </data>
                    <data bit_width="128"> 2.93 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 1.76 </data>
                    <data bit_width="8"> 1.91 </data>
                    <data bit_width="16"> 3.03 </data>
                    <data bit_width="32"> 2.07 </data>
                    <data bit_width="128"> 4.26 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 2.57 </data>
                    <data bit_width="8"> 2.43 </data>
                    <data bit_width="16"> 2.63 </data>
                    <data bit_width="32"> 2.55 </data>
                    <data bit_width="128"> 3.05 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,default,abs">
                <max>
                  <data bit_width="4"> 4.21 </data>
                  <data bit_width="8"> 2.41 </data>
                  <data bit_width="16"> 10.14 </data>
                  <data bit_width="32"> 19.27 </data>
                  <data bit_width="128"> 70.94 </data>
                </max>
                <min>
                  <data bit_width="4"> 2.47 </data>
                  <data bit_width="8"> 2.02 </data>
                  <data bit_width="16"> 2.68 </data>
                  <data bit_width="32"> 2.50 </data>
                  <data bit_width="128"> 2.93 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 2.47 </data>
                    <data bit_width="8"> 2.05 </data>
                    <data bit_width="16"> 2.72 </data>
                    <data bit_width="32"> 2.64 </data>
                    <data bit_width="128"> 2.93 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 4.21 </data>
                    <data bit_width="8"> 2.02 </data>
                    <data bit_width="16"> 10.14 </data>
                    <data bit_width="32"> 19.27 </data>
                    <data bit_width="128"> 70.94 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 2.57 </data>
                    <data bit_width="8"> 2.41 </data>
                    <data bit_width="16"> 2.68 </data>
                    <data bit_width="32"> 2.50 </data>
                    <data bit_width="128"> 3.00 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,default,two_complement">
                <max>
                  <data bit_width="4"> 6.70 </data>
                  <data bit_width="8"> 10.99 </data>
                  <data bit_width="16"> 19.75 </data>
                  <data bit_width="32"> 36.52 </data>
                  <data bit_width="128"> 142.70 </data>
                </max>
                <min>
                  <data bit_width="4"> 5.75 </data>
                  <data bit_width="8"> 10.01 </data>
                  <data bit_width="16"> 17.52 </data>
                  <data bit_width="32"> 32.78 </data>
                  <data bit_width="128"> 122.71 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 5.97 </data>
                    <data bit_width="8"> 10.07 </data>
                    <data bit_width="16"> 17.76 </data>
                    <data bit_width="32"> 32.78 </data>
                    <data bit_width="128"> 128.54 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 5.75 </data>
                    <data bit_width="8"> 10.01 </data>
                    <data bit_width="16"> 17.52 </data>
                    <data bit_width="32"> 33.19 </data>
                    <data bit_width="128"> 122.71 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 6.70 </data>
                    <data bit_width="8"> 10.99 </data>
                    <data bit_width="16"> 19.75 </data>
                    <data bit_width="32"> 36.52 </data>
                    <data bit_width="128"> 142.70 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,default,unsigned">
                <max>
                  <data bit_width="4"> 8.00 </data>
                  <data bit_width="8"> 18.59 </data>
                  <data bit_width="16"> 39.85 </data>
                  <data bit_width="32"> 81.34 </data>
                  <data bit_width="128"> 309.22 </data>
                </max>
                <min>
                  <data bit_width="4"> 5.76 </data>
                  <data bit_width="8"> 13.69 </data>
                  <data bit_width="16"> 29.60 </data>
                  <data bit_width="32"> 65.26 </data>
                  <data bit_width="128"> 283.68 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 5.76 </data>
                    <data bit_width="8"> 13.69 </data>
                    <data bit_width="16"> 29.60 </data>
                    <data bit_width="32"> 70.94 </data>
                    <data bit_width="128"> 309.20 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 6.02 </data>
                    <data bit_width="8"> 13.99 </data>
                    <data bit_width="16"> 29.74 </data>
                    <data bit_width="32"> 65.26 </data>
                    <data bit_width="128"> 283.68 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 8.00 </data>
                    <data bit_width="8"> 18.59 </data>
                    <data bit_width="16"> 39.85 </data>
                    <data bit_width="32"> 81.34 </data>
                    <data bit_width="128"> 309.22 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,default,abs">
                <max>
                  <data bit_width="4"> 11.34 </data>
                  <data bit_width="8"> 21.41 </data>
                  <data bit_width="16"> 43.19 </data>
                  <data bit_width="32"> 86.38 </data>
                  <data bit_width="128"> 290.49 </data>
                </max>
                <min>
                  <data bit_width="4"> 7.70 </data>
                  <data bit_width="8"> 15.61 </data>
                  <data bit_width="16"> 31.61 </data>
                  <data bit_width="32"> 64.21 </data>
                  <data bit_width="128"> 272.75 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 7.70 </data>
                    <data bit_width="8"> 15.61 </data>
                    <data bit_width="16"> 31.61 </data>
                    <data bit_width="32"> 64.21 </data>
                    <data bit_width="128"> 272.75 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 7.76 </data>
                    <data bit_width="8"> 15.97 </data>
                    <data bit_width="16"> 32.32 </data>
                    <data bit_width="32"> 67.35 </data>
                    <data bit_width="128"> 282.62 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 11.34 </data>
                    <data bit_width="8"> 21.41 </data>
                    <data bit_width="16"> 43.19 </data>
                    <data bit_width="32"> 86.38 </data>
                    <data bit_width="128"> 290.49 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,default,two_complement">
                <max>
                  <data bit_width="4"> 13.34 </data>
                  <data bit_width="8"> 24.35 </data>
                  <data bit_width="16"> 47.05 </data>
                  <data bit_width="32"> 90.33 </data>
                  <data bit_width="128"> 307.41 </data>
                </max>
                <min>
                  <data bit_width="4"> 10.17 </data>
                  <data bit_width="8"> 18.24 </data>
                  <data bit_width="16"> 34.41 </data>
                  <data bit_width="32"> 67.04 </data>
                  <data bit_width="128"> 275.83 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 10.47 </data>
                    <data bit_width="8"> 18.41 </data>
                    <data bit_width="16"> 34.41 </data>
                    <data bit_width="32"> 67.04 </data>
                    <data bit_width="128"> 275.83 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 10.17 </data>
                    <data bit_width="8"> 18.24 </data>
                    <data bit_width="16"> 35.45 </data>
                    <data bit_width="32"> 70.26 </data>
                    <data bit_width="128"> 281.64 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 13.34 </data>
                    <data bit_width="8"> 24.35 </data>
                    <data bit_width="16"> 47.05 </data>
                    <data bit_width="32"> 90.33 </data>
                    <data bit_width="128"> 307.41 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>

            <est_index name="delay_fullpath">
              <unit> ns </unit>

              <parameters name="default,default,abs">
                <max>
                  <data bit_width="4">
                    inport	 a	 0.48
                    inport	 b	 0.47
                    outport	 mulu	 1.22
                    internal	 2.75
                  </data>
                  <data bit_width="8">
                    inport	 a	 0.48
                    inport	 b	 0.47
                    outport	 mulu	 1.25
                    internal	 4.01
                  </data>
                  <data bit_width="16">
                    inport	 a	 0.48
                    inport	 b	 0.47
                    outport	 mulu	 1.41
                    internal	 7.66
                  </data>
                  <data bit_width="32">
                    inport	 a	 0.47
                    inport	 b	 0.46
                    outport	 mulu	 1.40
                    internal	 12.92
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    inport	 a	 0.48
                    inport	 b	 0.47
                    outport	 mulu	 1.22
                    internal	 2.75
                  </data>
                  <data bit_width="8">
                    inport	 a	 0.48
                    inport	 b	 0.47
                    outport	 mulu	 1.25
                    internal	 4.01
                  </data>
                  <data bit_width="16">
                    inport	 a	 0.48
                    inport	 b	 0.47
                    outport	 mulu	 1.41
                    internal	 7.66
                  </data>
                  <data bit_width="32">
                    inport	 a	 0.47
                    inport	 b	 0.46
                    outport	 mulu	 1.40
                    internal	 12.92
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.47
                      internal	 2.81
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.12
                      internal	 4.21
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.48
                      internal	 7.99
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.49
                      internal	 14.95
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      inport	 a	 0.46
                      inport	 b	 0.47
                      outport	 mulu	 0.68
                      internal	 1.19
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.46
                      inport	 b	 0.47
                      outport	 mulu	 0.75
                      internal	 1.38
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.46
                      inport	 b	 0.47
                      outport	 mulu	 1.14
                      internal	 2.17
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.46
                      inport	 b	 0.47
                      outport	 mulu	 0.84
                      internal	 2.90
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.22
                      internal	 2.75
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.25
                      internal	 4.01
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.41
                      internal	 7.66
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.47
                      inport	 b	 0.46
                      outport	 mulu	 1.40
                      internal	 12.92
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="default,default,unsigned">
                <max>
                  <data bit_width="4">
                    inport	 a	 0.23
                    inport	 b	 0
                    outport	 smul0	 1.45
                    internal	 2.68
                  </data>
                  <data bit_width="8">
                    inport	 a	 0.23
                    inport	 b	 0
                    outport	 smul0	 1.24
                    internal	 3.95
                  </data>
                  <data bit_width="16">
                    inport	 a	 0.23
                    inport	 b	 0
                    outport	 smul0	 1.41
                    internal	 7.79
                  </data>
                  <data bit_width="32">
                    inport	 a	 0.23
                    inport	 b	 0
                    outport	 smul0	 1.81
                    internal	 12.96
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    inport	 a	 0.23
                    inport	 b	 0.00
                    outport	 smul0	 1.45
                    internal	 2.68
                  </data>
                  <data bit_width="8">
                    inport	 a	 0.23
                    inport	 b	 0.00
                    outport	 smul0	 1.24
                    internal	 3.95
                  </data>
                  <data bit_width="16">
                    inport	 a	 0.23
                    inport	 b	 0.00
                    outport	 smul0	 1.41
                    internal	 7.79
                  </data>
                  <data bit_width="32">
                    inport	 a	 0.23
                    inport	 b	 0.00
                    outport	 smul0	 1.81
                    internal	 12.96
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      inport	 a	 0.23
                      inport	 b	 0.23
                      outport	 smul0	 1.47
                      internal	 2.95
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.23
                      inport	 b	 0.23
                      outport	 smul0	 1.12
                      internal	 4.23
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.23
                      inport	 b	 0.23
                      outport	 smul0	 1.48
                      internal	 8.01
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.23
                      inport	 b	 0.23
                      outport	 smul0	 1.49
                      internal	 14.96
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      inport	 a	 0.34
                      inport	 b	 0.41
                      outport	 smul0	 0.79
                      internal	 1.18
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.34
                      inport	 b	 0.41
                      outport	 smul0	 1.03
                      internal	 1.53
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.34
                      inport	 b	 0.41
                      outport	 smul0	 1.22
                      internal	 1.97
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.34
                      inport	 b	 0.41
                      outport	 smul0	 0.86
                      internal	 3.33
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      inport	 a	 0.23
                      inport	 b	 0.00
                      outport	 smul0	 1.45
                      internal	 2.68
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.23
                      inport	 b	 0.00
                      outport	 smul0	 1.24
                      internal	 3.95
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.23
                      inport	 b	 0.00
                      outport	 smul0	 1.41
                      internal	 7.79
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.23
                      inport	 b	 0.00
                      outport	 smul0	 1.81
                      internal	 12.96
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="default,default,two_complement">
                <max>
                  <data bit_width="4">
                    inport	 a	 0.96
                    inport	 b	 0.93
                    outport	 mulu	 2.30
                    internal	 2.78
                  </data>
                  <data bit_width="8">
                    inport	 a	 2.39
                    inport	 b	 2.14
                    outport	 mulu	 5.79
                    internal	 5.79
                  </data>
                  <data bit_width="16">
                    inport	 a	 4.60
                    inport	 b	 4.62
                    outport	 mulu	 12.90
                    internal	 12.90
                  </data>
                  <data bit_width="32">
                    inport	 a	 10.48
                    inport	 b	 10.40
                    outport	 mulu	 24.61
                    internal	 24.61
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    inport	 a	 0.96
                    inport	 b	 0.93
                    outport	 mulu	 2.30
                    internal	 2.78
                  </data>
                  <data bit_width="8">
                    inport	 a	 2.39
                    inport	 b	 2.14
                    outport	 mulu	 5.79
                    internal	 5.79
                  </data>
                  <data bit_width="16">
                    inport	 a	 4.60
                    inport	 b	 4.62
                    outport	 mulu	 12.90
                    internal	 12.90
                  </data>
                  <data bit_width="32">
                    inport	 a	 10.48
                    inport	 b	 10.40
                    outport	 mulu	 24.61
                    internal	 24.61
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      inport	 a	 0.82
                      inport	 b	 0.93
                      outport	 mulu	 2.08
                      internal	 2.54
                    </data>
                    <data bit_width="8">
                      inport	 a	 2.35
                      inport	 b	 2.15
                      outport	 mulu	 5.82
                      internal	 5.82
                    </data>
                    <data bit_width="16">
                      inport	 a	 5.07
                      inport	 b	 5.36
                      outport	 mulu	 12.07
                      internal	 12.07
                    </data>
                    <data bit_width="32">
                      inport	 a	 10.94
                      inport	 b	 11.24
                      outport	 mulu	 24.51
                      internal	 24.51
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      inport	 a	 0.72
                      inport	 b	 0.73
                      outport	 mulu	 1.37
                      internal	 1.25
                    </data>
                    <data bit_width="8">
                      inport	 a	 1.12
                      inport	 b	 1.13
                      outport	 mulu	 1.67
                      internal	 1.59
                    </data>
                    <data bit_width="16">
                      inport	 a	 2.11
                      inport	 b	 2.20
                      outport	 mulu	 2.32
                      internal	 2.40
                    </data>
                    <data bit_width="32">
                      inport	 a	 3.23
                      inport	 b	 3.30
                      outport	 mulu	 3.00
                      internal	 3.70
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      inport	 a	 0.96
                      inport	 b	 0.93
                      outport	 mulu	 2.30
                      internal	 2.78
                    </data>
                    <data bit_width="8">
                      inport	 a	 2.39
                      inport	 b	 2.14
                      outport	 mulu	 5.79
                      internal	 5.79
                    </data>
                    <data bit_width="16">
                      inport	 a	 4.60
                      inport	 b	 4.62
                      outport	 mulu	 12.90
                      internal	 12.90
                    </data>
                    <data bit_width="32">
                      inport	 a	 10.48
                      inport	 b	 10.40
                      outport	 mulu	 24.61
                      internal	 24.61
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,default,abs">
                <max>
                  <data bit_width="4">
                    inport	 a	 0.48
                    inport	 b	 0.47
                    outport	 mulu	 1.22
                    internal	 2.75
                  </data>
                  <data bit_width="8">
                    inport	 a	 0.48
                    inport	 b	 0.47
                    outport	 mulu	 1.25
                    internal	 4.01
                  </data>
                  <data bit_width="16">
                    inport	 a	 0.48
                    inport	 b	 0.47
                    outport	 mulu	 1.41
                    internal	 7.66
                  </data>
                  <data bit_width="32">
                    inport	 a	 0.47
                    inport	 b	 0.46
                    outport	 mulu	 1.40
                    internal	 12.92
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    inport	 a	 0.48
                    inport	 b	 0.47
                    outport	 mulu	 1.22
                    internal	 2.75
                  </data>
                  <data bit_width="8">
                    inport	 a	 0.48
                    inport	 b	 0.47
                    outport	 mulu	 1.25
                    internal	 4.01
                  </data>
                  <data bit_width="16">
                    inport	 a	 0.48
                    inport	 b	 0.47
                    outport	 mulu	 1.41
                    internal	 7.66
                  </data>
                  <data bit_width="32">
                    inport	 a	 0.47
                    inport	 b	 0.46
                    outport	 mulu	 1.40
                    internal	 12.92
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.47
                      internal	 2.81
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.12
                      internal	 4.21
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.48
                      internal	 7.99
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.49
                      internal	 14.95
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      inport	 a	 0.46
                      inport	 b	 0.47
                      outport	 mulu	 0.68
                      internal	 1.19
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.46
                      inport	 b	 0.47
                      outport	 mulu	 0.75
                      internal	 1.38
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.46
                      inport	 b	 0.47
                      outport	 mulu	 1.14
                      internal	 2.17
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.46
                      inport	 b	 0.47
                      outport	 mulu	 0.84
                      internal	 2.90
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.22
                      internal	 2.75
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.25
                      internal	 4.01
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.41
                      internal	 7.66
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.47
                      inport	 b	 0.46
                      outport	 mulu	 1.40
                      internal	 12.92
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,default,unsigned">
                <max>
                  <data bit_width="4">
                    inport	 a	 0.23
                    inport	 b	 0
                    outport	 smul0	 1.45
                    internal	 2.68
                  </data>
                  <data bit_width="8">
                    inport	 a	 0.23
                    inport	 b	 0
                    outport	 smul0	 1.24
                    internal	 3.95
                  </data>
                  <data bit_width="16">
                    inport	 a	 0.23
                    inport	 b	 0
                    outport	 smul0	 1.41
                    internal	 7.79
                  </data>
                  <data bit_width="32">
                    inport	 a	 0.23
                    inport	 b	 0
                    outport	 smul0	 1.81
                    internal	 12.96
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    inport	 a	 0.23
                    inport	 b	 0.00
                    outport	 smul0	 1.45
                    internal	 2.68
                  </data>
                  <data bit_width="8">
                    inport	 a	 0.23
                    inport	 b	 0.00
                    outport	 smul0	 1.24
                    internal	 3.95
                  </data>
                  <data bit_width="16">
                    inport	 a	 0.23
                    inport	 b	 0.00
                    outport	 smul0	 1.41
                    internal	 7.79
                  </data>
                  <data bit_width="32">
                    inport	 a	 0.23
                    inport	 b	 0.00
                    outport	 smul0	 1.81
                    internal	 12.96
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      inport	 a	 0.23
                      inport	 b	 0.23
                      outport	 smul0	 1.47
                      internal	 2.95
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.23
                      inport	 b	 0.23
                      outport	 smul0	 1.12
                      internal	 4.23
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.23
                      inport	 b	 0.23
                      outport	 smul0	 1.48
                      internal	 8.01
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.23
                      inport	 b	 0.23
                      outport	 smul0	 1.49
                      internal	 14.96
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      inport	 a	 0.34
                      inport	 b	 0.41
                      outport	 smul0	 0.79
                      internal	 1.18
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.34
                      inport	 b	 0.41
                      outport	 smul0	 1.03
                      internal	 1.53
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.34
                      inport	 b	 0.41
                      outport	 smul0	 1.22
                      internal	 1.97
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.34
                      inport	 b	 0.41
                      outport	 smul0	 0.86
                      internal	 3.33
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      inport	 a	 0.23
                      inport	 b	 0.00
                      outport	 smul0	 1.45
                      internal	 2.68
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.23
                      inport	 b	 0.00
                      outport	 smul0	 1.24
                      internal	 3.95
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.23
                      inport	 b	 0.00
                      outport	 smul0	 1.41
                      internal	 7.79
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.23
                      inport	 b	 0.00
                      outport	 smul0	 1.81
                      internal	 12.96
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,default,two_complement">
                <max>
                  <data bit_width="4">
                    inport	 a	 0.96
                    inport	 b	 0.93
                    outport	 mulu	 2.30
                    internal	 2.78
                  </data>
                  <data bit_width="8">
                    inport	 a	 2.39
                    inport	 b	 2.14
                    outport	 mulu	 5.79
                    internal	 5.79
                  </data>
                  <data bit_width="16">
                    inport	 a	 4.60
                    inport	 b	 4.62
                    outport	 mulu	 12.90
                    internal	 12.90
                  </data>
                  <data bit_width="32">
                    inport	 a	 10.48
                    inport	 b	 10.40
                    outport	 mulu	 24.61
                    internal	 24.61
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    inport	 a	 0.96
                    inport	 b	 0.93
                    outport	 mulu	 2.30
                    internal	 2.78
                  </data>
                  <data bit_width="8">
                    inport	 a	 2.39
                    inport	 b	 2.14
                    outport	 mulu	 5.79
                    internal	 5.79
                  </data>
                  <data bit_width="16">
                    inport	 a	 4.60
                    inport	 b	 4.62
                    outport	 mulu	 12.90
                    internal	 12.90
                  </data>
                  <data bit_width="32">
                    inport	 a	 10.48
                    inport	 b	 10.40
                    outport	 mulu	 24.61
                    internal	 24.61
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      inport	 a	 0.82
                      inport	 b	 0.93
                      outport	 mulu	 2.08
                      internal	 2.54
                    </data>
                    <data bit_width="8">
                      inport	 a	 2.35
                      inport	 b	 2.15
                      outport	 mulu	 5.82
                      internal	 5.82
                    </data>
                    <data bit_width="16">
                      inport	 a	 5.07
                      inport	 b	 5.36
                      outport	 mulu	 12.07
                      internal	 12.07
                    </data>
                    <data bit_width="32">
                      inport	 a	 10.94
                      inport	 b	 11.24
                      outport	 mulu	 24.51
                      internal	 24.51
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      inport	 a	 0.72
                      inport	 b	 0.73
                      outport	 mulu	 1.37
                      internal	 1.25
                    </data>
                    <data bit_width="8">
                      inport	 a	 1.12
                      inport	 b	 1.13
                      outport	 mulu	 1.67
                      internal	 1.59
                    </data>
                    <data bit_width="16">
                      inport	 a	 2.11
                      inport	 b	 2.20
                      outport	 mulu	 2.32
                      internal	 2.40
                    </data>
                    <data bit_width="32">
                      inport	 a	 3.23
                      inport	 b	 3.30
                      outport	 mulu	 3.00
                      internal	 3.70
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      inport	 a	 0.96
                      inport	 b	 0.93
                      outport	 mulu	 2.30
                      internal	 2.78
                    </data>
                    <data bit_width="8">
                      inport	 a	 2.39
                      inport	 b	 2.14
                      outport	 mulu	 5.79
                      internal	 5.79
                    </data>
                    <data bit_width="16">
                      inport	 a	 4.60
                      inport	 b	 4.62
                      outport	 mulu	 12.90
                      internal	 12.90
                    </data>
                    <data bit_width="32">
                      inport	 a	 10.48
                      inport	 b	 10.40
                      outport	 mulu	 24.61
                      internal	 24.61
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,default,abs">
                <max>
                  <data bit_width="4">
                    path	 a	 result	 1.99
                    path	 b	 result	 1.95
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 8.72
                    path	 b	 result	 8.73
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 19.90
                    path	 b	 result	 19.92
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 46.48
                    path	 b	 result	 46.51
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 result	 1.99
                    path	 b	 result	 1.95
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 8.72
                    path	 b	 result	 8.73
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 19.90
                    path	 b	 result	 19.92
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 46.48
                    path	 b	 result	 46.51
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 result	 1.86
                      path	 b	 result	 1.90
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 8.68
                      path	 b	 result	 8.70
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 22.08
                      path	 b	 result	 22.04
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 48.99
                      path	 b	 result	 49.02
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 result	 0.99
                      path	 b	 result	 0.99
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 4.54
                      path	 b	 result	 4.52
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 12.64
                      path	 b	 result	 12.65
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 29.16
                      path	 b	 result	 29.18
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 result	 1.99
                      path	 b	 result	 1.95
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 8.72
                      path	 b	 result	 8.73
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 19.90
                      path	 b	 result	 19.92
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 46.48
                      path	 b	 result	 46.51
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,default,unsigned">
                <max>
                  <data bit_width="4">
                    path	 a	 result	 3.61
                    path	 b	 result	 3.64
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 10.68
                    path	 b	 result	 10.65
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 22.05
                    path	 b	 result	 22.08
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 49.15
                    path	 b	 result	 49.18
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 result	 3.61
                    path	 b	 result	 3.64
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 10.68
                    path	 b	 result	 10.65
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 22.05
                    path	 b	 result	 22.08
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 49.15
                    path	 b	 result	 49.18
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 result	 3.23
                      path	 b	 result	 3.26
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 10.52
                      path	 b	 result	 10.50
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 24.24
                      path	 b	 result	 24.00
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 50.38
                      path	 b	 result	 50.41
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 result	 2.02
                      path	 b	 result	 2.03
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 5.52
                      path	 b	 result	 5.52
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 13.26
                      path	 b	 result	 13.26
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 30.23
                      path	 b	 result	 30.23
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 result	 3.61
                      path	 b	 result	 3.64
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 10.68
                      path	 b	 result	 10.65
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 22.05
                      path	 b	 result	 22.08
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 49.15
                      path	 b	 result	 49.18
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,default,two_complement">
                <max>
                  <data bit_width="4">
                    path	 a	 result	 4.66
                    path	 b	 result	 5.17
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 11.60
                    path	 b	 result	 11.76
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 23.69
                    path	 b	 result	 23.38
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 51.62
                    path	 b	 result	 51.87
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 result	 4.66
                    path	 b	 result	 5.17
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 11.60
                    path	 b	 result	 11.76
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 23.69
                    path	 b	 result	 23.38
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 51.62
                    path	 b	 result	 51.87
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 result	 4.51
                      path	 b	 result	 4.77
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 12.37
                      path	 b	 result	 12.25
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 26.03
                      path	 b	 result	 26.37
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 52.82
                      path	 b	 result	 52.05
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 result	 2.61
                      path	 b	 result	 2.61
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 6.35
                      path	 b	 result	 6.34
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 14.32
                      path	 b	 result	 14.33
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 32.95
                      path	 b	 result	 32.93
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 result	 4.66
                      path	 b	 result	 5.17
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 11.60
                      path	 b	 result	 11.76
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 23.69
                      path	 b	 result	 23.38
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 51.62
                      path	 b	 result	 51.87
                    </data>
                  </priority>
                </typ>
              </parameters>

            </est_index>
          </est_type>

          <est_type name="power">
            <est_index name="static_power">
              <unit> mW </unit>

              <parameters name="default,default,unsigned">
                <max>
                  <data bit_width="4"> 8.0705 </data>
                  <data bit_width="8"> 10.3144 </data>
                  <data bit_width="16"> 18.7985 </data>
                  <data bit_width="32"> 32.7649 </data>
                  <data bit_width="128"> 188.8178 </data>
                </max>
                <min>
                  <data bit_width="4"> 4.5194 </data>
                  <data bit_width="8"> 6.7509 </data>
                  <data bit_width="16"> 12.5875 </data>
                  <data bit_width="32"> 23.0052 </data>
                  <data bit_width="128"> 96.6946 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 4.7631 </data>
                    <data bit_width="8"> 7.5798 </data>
                    <data bit_width="16"> 13.7755 </data>
                    <data bit_width="32"> 25.2039 </data>
                    <data bit_width="128"> 102.7054 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 8.0705 </data>
                    <data bit_width="8"> 10.3144 </data>
                    <data bit_width="16"> 18.7985 </data>
                    <data bit_width="32"> 32.7649 </data>
                    <data bit_width="128"> 188.8178 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 4.5194 </data>
                    <data bit_width="8"> 6.7509 </data>
                    <data bit_width="16"> 12.5875 </data>
                    <data bit_width="32"> 23.0052 </data>
                    <data bit_width="128"> 96.6946 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="default,default,abs">
                <max>
                  <data bit_width="4"> 22.7343 </data>
                  <data bit_width="8"> 32.0887 </data>
                  <data bit_width="16"> 73.4014 </data>
                  <data bit_width="32"> 139.4252 </data>
                  <data bit_width="128"> 535.2403 </data>
                </max>
                <min>
                  <data bit_width="4"> 11.9280 </data>
                  <data bit_width="8"> 20.3985 </data>
                  <data bit_width="16"> 38.5779 </data>
                  <data bit_width="32"> 76.2374 </data>
                  <data bit_width="128"> 319.8841 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 13.1256 </data>
                    <data bit_width="8"> 23.0790 </data>
                    <data bit_width="16"> 43.4583 </data>
                    <data bit_width="32"> 85.9239 </data>
                    <data bit_width="128"> 355.2412 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 22.7343 </data>
                    <data bit_width="8"> 32.0887 </data>
                    <data bit_width="16"> 73.4014 </data>
                    <data bit_width="32"> 139.4252 </data>
                    <data bit_width="128"> 535.2403 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 11.9280 </data>
                    <data bit_width="8"> 20.3985 </data>
                    <data bit_width="16"> 38.5779 </data>
                    <data bit_width="32"> 76.2374 </data>
                    <data bit_width="128"> 319.8841 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="default,default,two_complement">
                <max>
                  <data bit_width="4"> 25.4564 </data>
                  <data bit_width="8"> 46.2918 </data>
                  <data bit_width="16"> 86.6277 </data>
                  <data bit_width="32"> 168.1598 </data>
                  <data bit_width="128"> 624.7239 </data>
                </max>
                <min>
                  <data bit_width="4"> 15.1376 </data>
                  <data bit_width="8"> 26.5703 </data>
                  <data bit_width="16"> 50.4497 </data>
                  <data bit_width="32"> 95.7792 </data>
                  <data bit_width="128"> 415.6704 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 16.5180 </data>
                    <data bit_width="8"> 29.5078 </data>
                    <data bit_width="16"> 53.8735 </data>
                    <data bit_width="32"> 106.3317 </data>
                    <data bit_width="128"> 453.4141 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 25.4564 </data>
                    <data bit_width="8"> 46.2918 </data>
                    <data bit_width="16"> 86.6277 </data>
                    <data bit_width="32"> 168.1598 </data>
                    <data bit_width="128"> 624.7239 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 15.1376 </data>
                    <data bit_width="8"> 26.5703 </data>
                    <data bit_width="16"> 50.4497 </data>
                    <data bit_width="32"> 95.7792 </data>
                    <data bit_width="128"> 415.6704 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,default,unsigned">
                <max>
                  <data bit_width="4"> 8.0705 </data>
                  <data bit_width="8"> 10.3144 </data>
                  <data bit_width="16"> 18.7985 </data>
                  <data bit_width="32"> 32.7649 </data>
                  <data bit_width="128"> 188.8178 </data>
                </max>
                <min>
                  <data bit_width="4"> 4.5194 </data>
                  <data bit_width="8"> 6.7509 </data>
                  <data bit_width="16"> 12.5875 </data>
                  <data bit_width="32"> 23.0052 </data>
                  <data bit_width="128"> 96.6946 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 4.7631 </data>
                    <data bit_width="8"> 7.5798 </data>
                    <data bit_width="16"> 13.7755 </data>
                    <data bit_width="32"> 25.2039 </data>
                    <data bit_width="128"> 102.7054 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 8.0705 </data>
                    <data bit_width="8"> 10.3144 </data>
                    <data bit_width="16"> 18.7985 </data>
                    <data bit_width="32"> 32.7649 </data>
                    <data bit_width="128"> 188.8178 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 4.5194 </data>
                    <data bit_width="8"> 6.7509 </data>
                    <data bit_width="16"> 12.5875 </data>
                    <data bit_width="32"> 23.0052 </data>
                    <data bit_width="128"> 96.6946 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,default,abs">
                <max>
                  <data bit_width="4"> 22.7343 </data>
                  <data bit_width="8"> 32.0887 </data>
                  <data bit_width="16"> 73.4014 </data>
                  <data bit_width="32"> 139.4252 </data>
                  <data bit_width="128"> 535.2403 </data>
                </max>
                <min>
                  <data bit_width="4"> 11.9280 </data>
                  <data bit_width="8"> 20.3985 </data>
                  <data bit_width="16"> 38.5779 </data>
                  <data bit_width="32"> 76.2374 </data>
                  <data bit_width="128"> 319.8841 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 13.1256 </data>
                    <data bit_width="8"> 23.0790 </data>
                    <data bit_width="16"> 43.4583 </data>
                    <data bit_width="32"> 85.9239 </data>
                    <data bit_width="128"> 355.2412 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 22.7343 </data>
                    <data bit_width="8"> 32.0887 </data>
                    <data bit_width="16"> 73.4014 </data>
                    <data bit_width="32"> 139.4252 </data>
                    <data bit_width="128"> 535.2403 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 11.9280 </data>
                    <data bit_width="8"> 20.3985 </data>
                    <data bit_width="16"> 38.5779 </data>
                    <data bit_width="32"> 76.2374 </data>
                    <data bit_width="128"> 319.8841 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,default,two_complement">
                <max>
                  <data bit_width="4"> 25.4564 </data>
                  <data bit_width="8"> 46.2918 </data>
                  <data bit_width="16"> 86.6277 </data>
                  <data bit_width="32"> 168.1598 </data>
                  <data bit_width="128"> 624.7239 </data>
                </max>
                <min>
                  <data bit_width="4"> 15.1376 </data>
                  <data bit_width="8"> 26.5703 </data>
                  <data bit_width="16"> 50.4497 </data>
                  <data bit_width="32"> 95.7792 </data>
                  <data bit_width="128"> 415.6704 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 16.5180 </data>
                    <data bit_width="8"> 29.5078 </data>
                    <data bit_width="16"> 53.8735 </data>
                    <data bit_width="32"> 106.3317 </data>
                    <data bit_width="128"> 453.4141 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 25.4564 </data>
                    <data bit_width="8"> 46.2918 </data>
                    <data bit_width="16"> 86.6277 </data>
                    <data bit_width="32"> 168.1598 </data>
                    <data bit_width="128"> 624.7239 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 15.1376 </data>
                    <data bit_width="8"> 26.5703 </data>
                    <data bit_width="16"> 50.4497 </data>
                    <data bit_width="32"> 95.7792 </data>
                    <data bit_width="128"> 415.6704 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,default,unsigned">
                <max>
                  <data bit_width="4"> 18.0704 </data>
                  <data bit_width="8"> 100.6959 </data>
                  <data bit_width="16"> 509.6430 </data>
                  <data bit_width="32"> 2245.9 </data>
                  <data bit_width="128"> 57757 </data>
                </max>
                <min>
                  <data bit_width="4"> 12.5921 </data>
                  <data bit_width="8"> 67.4968 </data>
                  <data bit_width="16"> 338.9810 </data>
                  <data bit_width="32"> 1603.8 </data>
                  <data bit_width="128"> 39490 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 13.6735 </data>
                    <data bit_width="8"> 73.2088 </data>
                    <data bit_width="16"> 355.9634 </data>
                    <data bit_width="32"> 1690 </data>
                    <data bit_width="128"> 39490 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 18.0704 </data>
                    <data bit_width="8"> 100.6959 </data>
                    <data bit_width="16"> 509.6430 </data>
                    <data bit_width="32"> 2245.9 </data>
                    <data bit_width="128"> 57757 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 12.5921 </data>
                    <data bit_width="8"> 67.4968 </data>
                    <data bit_width="16"> 338.9810 </data>
                    <data bit_width="32"> 1603.8 </data>
                    <data bit_width="128"> 39490 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,default,abs">
                <max>
                  <data bit_width="4"> 28.5812 </data>
                  <data bit_width="8"> 123.8895 </data>
                  <data bit_width="16"> 591.9648 </data>
                  <data bit_width="32"> 2768.9 </data>
                  <data bit_width="128"> 64978.2 </data>
                </max>
                <min>
                  <data bit_width="4"> 17.7778 </data>
                  <data bit_width="8"> 81.3289 </data>
                  <data bit_width="16"> 395.1296 </data>
                  <data bit_width="32"> 1882 </data>
                  <data bit_width="128"> 48591.9 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 19.7933 </data>
                    <data bit_width="8"> 88.3894 </data>
                    <data bit_width="16"> 417.8260 </data>
                    <data bit_width="32"> 1987.5 </data>
                    <data bit_width="128"> 48643.2 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 28.5812 </data>
                    <data bit_width="8"> 123.8895 </data>
                    <data bit_width="16"> 591.9648 </data>
                    <data bit_width="32"> 2768.9 </data>
                    <data bit_width="128"> 64978.2 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 17.7778 </data>
                    <data bit_width="8"> 81.3289 </data>
                    <data bit_width="16"> 395.1296 </data>
                    <data bit_width="32"> 1882 </data>
                    <data bit_width="128"> 48591.9 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,default,two_complement">
                <max>
                  <data bit_width="4"> 50.8553 </data>
                  <data bit_width="8"> 172.8401 </data>
                  <data bit_width="16"> 695.8508 </data>
                  <data bit_width="32"> 2979 </data>
                  <data bit_width="128"> 63187.8 </data>
                </max>
                <min>
                  <data bit_width="4"> 34.7857 </data>
                  <data bit_width="8"> 119.6344 </data>
                  <data bit_width="16"> 474.5724 </data>
                  <data bit_width="32"> 2040.1 </data>
                  <data bit_width="128"> 48761.7 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 38.2230 </data>
                    <data bit_width="8"> 130.3315 </data>
                    <data bit_width="16"> 504.0006 </data>
                    <data bit_width="32"> 2151.5 </data>
                    <data bit_width="128"> 48761.7 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 50.8553 </data>
                    <data bit_width="8"> 172.8401 </data>
                    <data bit_width="16"> 695.8508 </data>
                    <data bit_width="32"> 2979 </data>
                    <data bit_width="128"> 63187.8 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 34.7857 </data>
                    <data bit_width="8"> 119.6344 </data>
                    <data bit_width="16"> 474.5724 </data>
                    <data bit_width="32"> 2040.1 </data>
                    <data bit_width="128"> 48800.9 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>
          </est_type>

          <est_type name="function_cycle">
            <unit> cycle </unit>

            <est_index name="cycle">

              <parameters name="default,default,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="default,default,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="default,default,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,default,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,default,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,default,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,default,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,default,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,default,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>
            </est_index>

            <est_index name="latency">

              <parameters name="default,default,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="default,default,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="default,default,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,default,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,default,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,default,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,default,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,default,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,default,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>
            </est_index>

            <est_index name="throughput">

              <parameters name="default,default,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="default,default,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="default,default,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,default,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,default,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,default,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,default,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,default,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,default,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>
            </est_index>

          </est_type>

          <est_type name="function_power">
            <!-- Dummy yet -->
          </est_type>
        </library>
      </estimation_data>

      <estimation_method>
         
        <est_type name="shape">

          <est_index name="area">

            <parameters name="default,default,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(default,default,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="default,default,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(default,default,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="default,default,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(default,default,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(seq,default,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(seq,default,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(seq,default,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,default,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(array,default,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,default,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(array,default,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,default,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(array,default,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

           <est_index name="aspect_ratio">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="height">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="width">

             <!-- Dummy yet -->

           </est_index>
		
        </est_type>

        <est_type name="timing">

          <est_index name="delay">

            <parameters name="default,default,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(default,default,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="default,default,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(default,default,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="default,default,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(default,default,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(seq,default,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(seq,default,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(seq,default,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,default,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(array,default,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,default,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(array,default,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,default,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(array,default,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

          <est_index name="delay_fullpath">

          </est_index>

        </est_type>

        <est_type name="power">

          <est_index name="static_power">

            <parameters name="default,default,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(default,default,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="default,default,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(default,default,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="default,default,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(default,default,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(seq,default,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(seq,default,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(seq,default,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,default,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(array,default,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,default,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(array,default,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,default,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(array,default,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

        </est_type>

        <est_type name="function_cycle">
          <est_index name="cycle">

            <parameters name="default,default,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="default,default,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="default,default,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,default,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,default,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,default,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

          <est_index name="latency">

            <parameters name="default,default,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="default,default,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="default,default,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,default,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,default,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,default,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

          <est_index name="throughput">

            <parameters name="default,default,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="default,default,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="default,default,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,default,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,default,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,default,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,default,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

        </est_type>

        <est_type name="function_power">

        </est_type>

    
      </estimation_method>

    </estimation>


  </model>
</FHM>
