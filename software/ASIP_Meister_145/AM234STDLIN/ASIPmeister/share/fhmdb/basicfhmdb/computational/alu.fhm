<?xml version="1.0" encoding="UTF-8" ?>
<!-- Modified by T.Hamabe on 2006/12/05 -->
<!-- Modified by T.Hamabe on 2006/11/30 -->
<FHM>
  <model_name> alu </model_name>

  <model>
    <design_level> behavior </design_level>
    <version> 1.0 </version>
    <author> <![CDATA[ Yamane Yukinori ]]> </author>
    <affiliation> <![CDATA[ Osaka Univ. ]]> </affiliation>
    <model_info> <![CDATA[
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                %
%    Copyright 2008 ASIP Solutions, Inc. All rights reserved.    %
%              Copyright 2002-2005 PEAS Project                  %
%                                                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
]]> </model_info>

    <parameter>
      <parameter_value key="bit_width">
        <value> 4 </value>
        <value> 8 </value>
        <value> 12 </value>
        <value> 16 </value>
        <value> 20 </value>
        <value> 24 </value>
        <value> 28 </value>
        <value> 32 </value>
        <value> 64 </value>
        <value> 128 </value>
        <value> 256 </value>
      </parameter_value>
    </parameter>

    <function_description>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates alu function definition in behavior level
# parameter : bit_width

if ($#ARGV != 0){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width\n";
    exit (100);
}

$bit_width = $ARGV[0];
$bit_width_1 = $bit_width - 1;

{
print <<FHM_DL_FUNCTION
signed     add(twoscomp a, twoscomp b);
unsigned   addu(twoscomp a, twoscomp b);
signed     addi(twoscomp a, twoscomp b);
unsigned   addiu(twoscomp a, twoscomp b);
signed     cadd(twoscomp a, twoscomp b);
unsigned   caddu(twoscomp a, twoscomp b);
signed     caddi(twoscomp a, twoscomp b);
unsigned   caddiu(twoscomp a, twoscomp b);
signed     sub(twoscomp a, twoscomp b);
unsigned   subu(twoscomp a, twoscomp b);
signed     subd(twoscomp a, twoscomp b);
unsigned   subdu(twoscomp a, twoscomp b);
signed     csub(twoscomp a, twoscomp b);
unsigned   csubu(twoscomp a, twoscomp b);
signed     csubd(twoscomp a, twoscomp b);
unsigned   csubdu(twoscomp a, twoscomp b);
signed     inc(twoscomp a);
unsigned   incu(twoscomp a);
signed     cinc(twoscomp a);
unsigned   cincu(twoscomp a);
signed     dec(twoscomp a);
unsigned   decu(twoscomp a);
signed     cdec(twoscomp a);
unsigned   cdecu(twoscomp a);
unsigned   not(twoscomp a);
unsigned   and(twoscomp a, twoscomp b);
unsigned   or(twoscomp a, twoscomp b);
unsigned   xor(twoscomp a, twoscomp b);
unsigned   nor(twoscomp a, twoscomp b);
unsigned   nxor(twoscomp a, twoscomp b);
unsigned   nand(twoscomp a, twoscomp b);
signed     max(twoscomp a, twoscomp b);
unsigned   maxu(twoscomp a, twoscomp b);
signed     min(twoscomp a, twoscomp b);
unsigned   minu(twoscomp a, twoscomp b);
bit_vector alu_flag(bit_vector mode, bit_vector a, bit_vector b, bit cin);

/** ${bit_width}-bits alu */
model alu_${bit_width}{
  port{
    in  a[${bit_width_1}:0], b[${bit_width_1}:0], cin, mode[4:0];
    out result[${bit_width_1}:0], flag[3:0];
  }

   /** C is '1' when (carry-occurred or not-borrowed) and unsigned-mode else '0'
       Z is '1' when result = 0 else '0'
       S is equal to MSB of result
       V is '1' when overflowed and signed-mode else '0' */
 
  /** add : signed add, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function add{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = add(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01001" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** addu : unsigned add, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function addu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = addu(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00001" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** addi : signed add and inc, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function addi{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = addi(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01001" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** addiu : unsigned add and inc, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function addiu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = addiu(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00001" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** cadd : signed add with saturation, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function cadd{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = cadd(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01101" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** caddu : unsigned add with saturation, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function caddu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = caddu(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00101" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** caddi : signed add and inc with saturation, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function caddi{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = caddi(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01101" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }
  
  /** caddiu : unsigned add and inc with saturation, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function caddiu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = caddiu(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00101" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** sub : signed sub, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function sub{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = sub(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01010" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** subu : unsigned sub, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function subu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = subu(a, b, cin);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00010" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** subd : signed sub and dec, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function subd{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = subd(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01010" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** subdu : unsigned sub and dec, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function subdu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = subdu(a, b, cin);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00010" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** csub : signed sub with saturation, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function csub{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = csub(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01110" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** csubu : unsigned sub with saturation, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function csubu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = csubu(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00110" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** csubd : signed sub and dec with saturation, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function csubd{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = csubd(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01110" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** csubdu : unsigned sub and dec with saturation, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function csubdu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = csubdu(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00110" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** inc : signed inc, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function inc{
    input{
      unsigned a;
    }
    output{
      unsigned   result = inc(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01000" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** incu : unsigned inc, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function incu{
    input{
      unsigned a;
    }
    output{
      unsigned   result = incu(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00000" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** cinc : signed inc with saturation, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function cinc{
    input{
      unsigned a;
    }
    output{
      unsigned   result = cinc(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01100" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** cincu : unsigned inc with saturation, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function cincu{
    input{
      unsigned a;
    }
    output{
      unsigned   result = cincu(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00100" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** dec : signed dec, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function dec{
    input{
      unsigned a;
    }
    output{
      unsigned   result = dec(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01011" && cin = '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** decu : unsigned dec, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function decu{
    input{
      unsigned a;
    }
    output{
      unsigned   result = decu(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00011" && cin = '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** cdec : signed dec with saturation, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function cdec{
    input{
      unsigned a;
    }
    output{
      unsigned   result = cdec(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01111" && cin = '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** cdecu : unsigned dec with saturation, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function cdecu{
    input{
      unsigned a;
    }
    output{
      unsigned   result = cdecu(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00111" && cin = '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** not : not, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function not{
    input{
      unsigned a;
    }
    output{
      unsigned   result = not(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "10011"]{
	valid result;
	valid flag;
      }
    }
  }

  /** and : and, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function and{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = and(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "10010"]{
	valid result;
	valid flag;
      }
    }
  }

  /** or : or, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function or{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = or(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "10000"]{
	valid result;
	valid flag;
      }
    }
  }

  /** xor : xor, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function xor{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = xor(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "10001"]{
	valid result;
	valid flag;
      }
    }
  }

  /** nor : nor, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function nor{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = nor(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "11000"]{
	valid result;
	valid flag;
      }
    }
  }

  /** nxor : nxor, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function nxor{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = nxor(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "11001"]{
	valid result;
	valid flag;
      }
    }
  }

  /** nand : nand, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function nand{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = nand(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "11010"]{
	valid result;
	valid flag;
      }
    }
  }

  /** cmp : signed comp, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function cmp{
    input{
      unsigned a, b;
    }
    output{
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01010" && cin = '1']{
	valid flag;
      }
    }
  }

  /** cmpu : unsigned comp, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function cmpu{
    input{
      unsigned a, b;
    }
    output{
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00010" && cin = '1']{
	valid flag;
      }
    }
  }

  /** cmpz : signed comp with zero, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function cmpz{
    input{
      unsigned a;
    }
    output{
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01000" && cin = '0']{
	valid flag;
      }
    }
  }

  /** cmpzu : unsigned comp with zero, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function cmpzu{
    input{
      unsigned a;
    }
    output{
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00000" && cin = '0']{
	valid flag;
      }
    }
  }

  /** max : signed max, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function max{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = max(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "10110" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** maxu : unsigned max, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function maxu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = maxu(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "10100" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** min : signed min, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function min{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = min(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "10111" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** minu : unsigned min, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function minu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = minu(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "10101" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }
}
FHM_DL_FUNCTION
}
exit(0);
        ]]>
      </script>
    </function_description>

    <function_conv>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates alu function definition in behavior level
# parameter : bit_width

if ($#ARGV != 0){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width\n";
    exit (100);
}

$bit_width = $ARGV[0];
$bit_width_1 = $bit_width - 1;

{
print <<FHM_DL_FUNCCONV
/** signed add, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function add {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01001";
      cin = '0';
    }
  }
}

/** unsigned add, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function addu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00001";
      cin = '0';
    }
  }
}

/** signed add and inc, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function addi {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01001";
      cin = '1';
    }
  }
}

/** unsigned add and inc, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function addiu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00001";
      cin = '1';
    }
  }
}

/** signed add with saturation, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function cadd {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01101";
      cin = '0';
    }
  }
}

/** unsigned add with saturation, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function caddu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00101";
      cin = '0';
    }
  }
}

/** signed add and inc with saturation, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function caddi {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01101";
      cin = '1';
    }
  }
}

/** unsigned add and inc with saturation, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function caddiu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00101";
      cin = '1';
    }
  }
}

/** signed sub, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function sub {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01010";
      cin = '1';
    }
  }
}

/** unsigned sub, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function subu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00010";
      cin = '1';
    }
  }
}

/** signed sub and dec, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function subd {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01010";
      cin = '0';
    }
  }
}

/** unsigned sub and dec, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function subdu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00010";
      cin = '0';
    }
  }
}

/** signed sub with saturation, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function csub {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01110";
      cin = '1';
    }
  }
}

/** unsigned sub with saturation, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function csubu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00110";
      cin = '1';
    }
  }
}

/** signed sub and dec with saturation, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function csubd {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01110";
      cin = '0';
    }
  }
}

/** unsigned sub and dec with saturation, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function csubdu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00110";
      cin = '0';
    }
  }
}

/** signed inc, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V */
function inc {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01000";
      cin = '1';
    }
  }
}

/** unsigned inc, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0 */
function incu {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00000";
      cin = '1';
    }
  }
}

/** signed inc with saturation, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V */
function cinc {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01100";
      cin = '1';
    }
  }
}

/** unsigned inc with saturation, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0 */
function cincu {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00100";
      cin = '1';
    }
  }
}

/** signed dec, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function dec {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01011";
      cin = '0';
    }
  }
}

/** unsigned dec, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function decu {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00011";
      cin = '0';
    }
  }
}

/** signed dec with saturation, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V */
function cdec {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01111";
      cin = '0';
    }
  }
}

/** unsigned dec with saturation, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cdecu {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00111";
      cin = '0';
    }
  }
}

/** not, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function not {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "10011";
    }
  }
}

/** and, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function and {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "10010";
    }
  }
}

/** or, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function or {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "10000";
    }
  }
}

/** xor, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function xor {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "10001";
    }
  }
}

/** nor, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function nor {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "11000";
    }
  }
}

/** nxor, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function nxor {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "11001";
    }
  }
}

/** nand, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function nand {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "11010";
    }
  }
}

/** signed cmp, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function cmp {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01010";
      cin = '1';
    }
  }
}

/** unsigned cmp, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cmpu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00010";
      cin = '1';
    }
  }
}

/** signed cmp zero, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cmpz {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01000";
      cin = '0';
    }
  }
}

/** unsigned cmp zero, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cmpzu {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00000";
      cin = '0';
    }
  }
}

/** signed max, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function max {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "10110";
      cin = '1';
    }
  }
}

/** unsigned max, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function maxu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "10100";
      cin = '1';
    }
  }
}

/** signed min, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function min {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "10111";
      cin = '1';
    }
  }
}

/** unsigned min, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function minu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "10101";
      cin = '1';
    }
  }
}
FHM_DL_FUNCCONV
}
exit(0);
        ]]>
      </script>
    </function_conv>

    <function_port>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates alu port infomation in behavior level
# parameter : bit_width

if ($#ARGV != 0){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width\n";
    exit (100);
}


$bit_width = $ARGV[0];
$bit_width_1 = $bit_width - 1;

{
print <<FHM_DL_PORTINFO
a	in	bit_vector   $bit_width_1   0	data
b	in	bit_vector   $bit_width_1   0	data
cin	in	bit		mode
mode	in	bit_vector   4   0	mode
result	out	bit_vector   $bit_width_1   0	data
flag	out	bit_vector   3   0	data
FHM_DL_PORTINFO
}
exit (0);
        ]]>
      </script>
    </function_port>

    <design>
      <design_lang> vhdl </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates alu instance in behavior level
# parameter : instance_name bit_width

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];

$bit_width_1 = $bit_width - 1;

$zero = "0" x $bit_width;
$zero = "\"" . $zero . "\"";
$one  = "1" x $bit_width;
$one  = "\"" . $one . "\"";
$maxint = "\"0" . "1"x($bit_width-1) . "\"";
$minint = "\"1" . "0"x($bit_width-1) . "\"";

$x_str = "X" x $bit_width;
$x_str = "\"" . $x_str . "\"";

{
print <<FHM_DL_INSTANCE
-- Module     : Arithmetic Logic Unit
-- Feature    : 
-- References : 
-- Author     : Designed by T.Morifuji (c)1997,1998.

-- Version : 1.3  : Modified by Y.Yamane 2002/01/15 Tue

-- Comment : function table is followings.
--  +-----------+-------------+-------------+---------+
--  |   mode    |   cin = 0   |   cin = 1   |  flag   |
--  +-----------+-------------+-------------+---------+
--  | 4 3 2 1 0 |   result    |   result    | c z s v |
--  +-----------+-------------+-------------+---------+
--  | 0 0 0 0 0 | a           | a + 1       | * * * 0 | unsigned (c)
--  | 0 0 0 0 1 | a + b       | a + b + 1   | * * * 0 | unsigned (c)
--  | 0 0 0 1 0 | a - b - 1   | a - b       | * * * 0 | unsigned (c)
--  | 0 0 0 1 1 | a - 1       | a           | * * * 0 | unsigned (c)
--  | 0 0 1 0 0 | a           | a +] 1      | * * * 0 | unsigned clip
--  | 0 0 1 0 1 | a +] b      | a +] b +] 1 | * * * 0 | unsigned clip
--  | 0 0 1 1 0 | a -] b -] 1 | a -] b      | * * * 0 | unsigned clip
--  | 0 0 1 1 1 | a -] 1      | a           | * * * 0 | unsigned clip
--  | 0 1 0 0 0 | a           | a + 1       | * * * * | signed (v)
--  | 0 1 0 0 1 | a + b       | a + b + 1   | * * * * | signed (v)
--  | 0 1 0 1 0 | a - b - 1   | a - b       | * * * * | signed (v)
--  | 0 1 0 1 1 | a - 1       | a           | * * * * | signed (v)
--  | 0 1 1 0 0 | a           | a +] 1      | * * * * | signed clip
--  | 0 1 1 0 1 | a +] b      | a +] b +] 1 | * * * * | signed clip
--  | 0 1 1 1 0 | a -] b -] 1 | a -] b      | * * * * | signed clip
--  | 0 1 1 1 1 | a -] 1      | a           | * * * * | signed clip
--  | 1 0 0 0 0 |           a or b          | 0 * * 0 |
--  | 1 0 0 0 1 |          a xor b          | 0 * * 0 |
--  | 1 0 0 1 0 |          a and b          | 0 * * 0 |
--  | 1 0 0 1 1 |           not a           | 0 * * 0 |
--  | 1 0 1 0 0 |             | max(a, b)   | * * * 0 | unsigned
--  | 1 0 1 0 1 |             | min(a, b)   | * * * 0 | unsigned
--  | 1 0 1 1 0 |             | max(a, b)   | * * * * | signed
--  | 1 0 1 1 1 |             | min(a, b)   | * * * * | signed
--  | 1 1 0 0 0 |          a nor b          | 0 * * 0 |
--  | 1 1 0 0 1 |         a nxor b          | 0 * * 0 |
--  | 1 1 0 1 0 |         a nand b          | 0 * * 0 |
--  | 1 1 0 1 1 |             |             | 0 * * * |
--  | 1 1 1 0 0 |             |             | 0 * * * |
--  | 1 1 1 0 1 |             |             | 0 * * * |
--  | 1 1 1 1 0 |             |             | 0 * * * |
--  | 1 1 1 1 1 |             |             | 0 * * * |
--  +-----------+-------------+-------------+---------+
-- C is '1' when (carry-occurred or not-bollowed) and unsigned-mode else
--      '0';
-- V is '1' when overflowed and signed-mode else
--      '0';
-- S is equal to MSB of result;
-- Z is '1' when result = 0 else
--      '0';

-- Functionality : behavior level
--  port
--   a, b   : datas
--   cin    : carry in
--   mode   : control (refer to the above table)
--   result : result of calculation
--   flag   : flag of result (refer to the above table)


library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_arith.all;
  use IEEE.std_logic_unsigned.all;

entity $instance_name is
  port (a, b 	: in std_logic_vector($bit_width_1 downto 0);
        cin     : in std_logic;
        mode 	: in std_logic_vector(4 downto 0);
        result 	: out std_logic_vector($bit_width_1 downto 0);
        flag 	: out std_logic_vector(3 downto 0) );
end $instance_name;


architecture behavior of $instance_name is

  -- purpose: adder
  procedure ${instance_name}_add (
    constant a, b   : in  std_logic_vector($bit_width_1 downto 0);
    constant cin    : in  std_logic;
    variable result : out std_logic_vector($bit_width_1 downto 0);
    variable cout   : out std_logic) is
    variable int_a, int_b : std_logic_vector($bit_width downto 0);
    variable int_result   : std_logic_vector($bit_width downto 0);
  begin  -- ${instance_name}_add
    int_a := '0' & a;
    int_b := '0' & b;
    int_result := int_a + int_b + cin;
    result := int_result($bit_width_1 downto 0);
    cout := int_result($bit_width);
  end ${instance_name}_add;

begin

  process(a, b, cin, mode)
    variable pre_result    : std_logic_vector($bit_width_1 downto 0);
    variable s_max, s_min  : std_logic_vector($bit_width_1 downto 0);
    variable C, Z, S, V    : std_logic;

  begin

    case mode is
      when "00000" =>
        ${instance_name}_add(a,$zero,cin,pre_result,C);
      when "00001" =>
        ${instance_name}_add(a,b,cin,pre_result,C);
      when "00010" =>
        ${instance_name}_add(a,not b,cin,pre_result,C);
      when "00011" =>
        ${instance_name}_add(a,$one,cin,pre_result,C);
      when "00100" =>
        ${instance_name}_add(a,$zero,cin,pre_result,C);
      when "00101" =>
        ${instance_name}_add(a,b,cin,pre_result,C);
      when "00110" =>
        ${instance_name}_add(a,not b,cin,pre_result,C);
      when "00111" =>
        ${instance_name}_add(a,$one,cin,pre_result,C);
      when "01000" =>
        ${instance_name}_add(a,$zero,cin,pre_result,C);
      when "01001" =>
        ${instance_name}_add(a,b,cin,pre_result,C);
      when "01010" =>
        ${instance_name}_add(a,not b,cin,pre_result,C);
      when "01011" =>
        ${instance_name}_add(a,$one,cin,pre_result,C);
      when "01100" =>
        ${instance_name}_add(a,$zero,cin,pre_result,C);
      when "01101" =>
        ${instance_name}_add(a,b,cin,pre_result,C);
      when "01110" =>
        ${instance_name}_add(a,not b,cin,pre_result,C);
      when "01111" =>
        ${instance_name}_add(a,$one,cin,pre_result,C);
      when "10000" =>
        pre_result := a or b;
      when "10001" =>
        pre_result := a xor b;
      when "10010" =>
        pre_result := a and b;
      when "10011" =>
        pre_result := not a;
      when "10100" =>
        ${instance_name}_add(a,not b,'1',pre_result,C);
      when "10101" =>
        ${instance_name}_add(a,not b,'1',pre_result,C);
      when "10110" =>
        ${instance_name}_add(a,not b,'1',pre_result,C);
      when "10111" =>
        ${instance_name}_add(a,not b,'1',pre_result,C);
      when "11000" =>
        pre_result := not ( a or b );
      when "11001" =>
        pre_result := not ( a xor b );
      when "11010" =>
        pre_result := not ( a and b );
      when others =>
        pre_result := $x_str;
    end case;

    if mode(4 downto 2) = "100" or mode(4 downto 3) = "11" then
      C := '0';
    end if;

    V := '0';
    case mode is
      when "01000" | "01100" =>
        if a($bit_width_1)='0' and pre_result($bit_width_1)='1' then
          V := '1';
        end if;
      when "01001" | "01101" =>
        if     ( a($bit_width_1)='0' and b($bit_width_1)='0'
                 and pre_result($bit_width_1)='1' )
            or ( a($bit_width_1)='1' and b($bit_width_1)='1'
                 and pre_result($bit_width_1)='0' ) then
          V := '1';
        end if;
      when "01010" | "01110" | "10110" | "10111" =>
        if     ( a($bit_width_1)='0' and b($bit_width_1)='1'
                 and pre_result($bit_width_1)='1' )
            or ( a($bit_width_1)='1' and b($bit_width_1)='0'
                 and pre_result($bit_width_1)='0' ) then
          V := '1';
        end if;
      when "01011" | "01111" =>
        if a($bit_width_1)='1' and pre_result($bit_width_1)='0' then
          V := '1';
        end if;
      when others =>
        V := '0';
    end case;


    if a($bit_width_1) = '0' and b($bit_width_1) = '1' then
      s_max := a;
    elsif a($bit_width_1) = '1' and b($bit_width_1) = '0' then
      s_max := b;
    elsif a($bit_width_1) = '0' and C = '1' then
      s_max := a;
    else
      s_max := b;
    end if;

    if a($bit_width_1) = '0' and b($bit_width_1) = '1' then
      s_min := b;
    elsif a($bit_width_1) = '1' and b($bit_width_1) = '0' then
      s_min := a;
    elsif a($bit_width_1) = '0' and C = '1' then
      s_min := b;
    else
      s_min := a;
    end if;

    if mode(3 downto 2) = "01" then
      if C = '1' and mode(1) = '0' then
        pre_result := $one;
      elsif C = '0' and mode(1) = '1' then
        pre_result := $zero;
      end if;
    elsif mode (3 downto 2) = "11" and V = '1' then
      if pre_result($bit_width_1) = '1' then
        pre_result := $maxint;
      else
        pre_result := $minint;
      end if;
    end if;

    if mode(4 downto 1) = "1010" then
      if (C = '1' and mode(0) = '0') or (C = '0' and mode(0) = '1') then
        pre_result := a;
      elsif (C = '1' and mode(0) = '1') or (C = '0' and mode(0) = '0') then
        pre_result := b;
      end if;
    end if;

    if mode(4 downto 1) = "1011" then
      if ( a($bit_width_1) = '0' and b($bit_width_1) = '1'
           and mode(0) = '0') or
         ( a($bit_width_1) = '1' and b($bit_width_1) = '0'
           and mode(0) = '1') then
        pre_result := a;
      elsif ( a($bit_width_1) = '1' and b($bit_width_1) = '0'
             and mode(0) = '0') or
           ( a($bit_width_1) = '0' and b($bit_width_1) = '1'
             and mode(0) = '1') then
        pre_result := b;
      elsif (C = '1' and mode(0) = '0') or (C = '0' and mode(0) = '1') then
        pre_result := a;
      elsif (C = '1' and mode(0) = '1') or (C = '0' and mode(0) = '0') then
        pre_result := b;
      end if;
    end if;

    if pre_result = $zero then
      Z := '1';
    else
      Z := '0';
    end if;

    S := pre_result($bit_width_1);

    result <= pre_result;
    flag <= C & Z & S & V;

  end process;
end behavior;
FHM_DL_INSTANCE
}
exit(0);
          ]]>
        </script>
      </instance>

      <entity></entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>

      <synthesis></synthesis>
    </design>

    <design>
      <design_lang> Verilog </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates alu instance in behavior level
# parameter : instance_name bit_width

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];

$bit_width_1 = $bit_width - 1;

$zero = "0" x $bit_width;
$zero = "\"" . $zero . "\"";
$one  = "1" x $bit_width;
$one  = "\"" . $one . "\"";

$x_str = "X" x $bit_width;
$x_str = "\"" . $x_str . "\"";

{
print <<FHM_DL_INSTANCE
// Module     : Arithmetic Logic Unit
// Feature    : 
// References : 
// Author     : Designed by T.Morifuji (c)1997,1998.
\n
// Version : 1.3  : Modified by Y.Yamane 2002/01/15 Tue
\n
// Comment : function table is followings.
//  +-----------+-------------+-------------+---------+
//  |   mode    |   cin = 0   |   cin = 1   |  flag   |
//  +-----------+-------------+-------------+---------+
//  | 4 3 2 1 0 |   result    |   result    | c z s v |
//  +-----------+-------------+-------------+---------+
//  | 0 0 0 0 0 | a           | a + 1       | * * * 0 | unsigned (c)
//  | 0 0 0 0 1 | a + b       | a + b + 1   | * * * 0 | unsigned (c)
//  | 0 0 0 1 0 | a - b - 1   | a - b       | * * * 0 | unsigned (c)
//  | 0 0 0 1 1 | a - 1       | a           | * * * 0 | unsigned (c)
//  | 0 0 1 0 0 | a           | a +] 1      | * * * 0 | unsigned clip
//  | 0 0 1 0 1 | a +] b      | a +] b +] 1 | * * * 0 | unsigned clip
//  | 0 0 1 1 0 | a -] b -] 1 | a -] b      | * * * 0 | unsigned clip
//  | 0 0 1 1 1 | a -] 1      | a           | * * * 0 | unsigned clip
//  | 0 1 0 0 0 | a           | a + 1       | * * * * | signed (v)
//  | 0 1 0 0 1 | a + b       | a + b + 1   | * * * * | signed (v)
//  | 0 1 0 1 0 | a - b - 1   | a - b       | * * * * | signed (v)
//  | 0 1 0 1 1 | a - 1       | a           | * * * * | signed (v)
//  | 0 1 1 0 0 | a           | a +] 1      | * * * * | signed clip
//  | 0 1 1 0 1 | a +] b      | a +] b +] 1 | * * * * | signed clip
//  | 0 1 1 1 0 | a -] b -] 1 | a -] b      | * * * * | signed clip
//  | 0 1 1 1 1 | a -] 1      | a           | * * * * | signed clip
//  | 1 0 0 0 0 |           a or b          | 0 * * 0 |
//  | 1 0 0 0 1 |          a xor b          | 0 * * 0 |
//  | 1 0 0 1 0 |          a and b          | 0 * * 0 |
//  | 1 0 0 1 1 |           not a           | 0 * * 0 |
//  | 1 0 1 0 0 |             | max(a, b)   | * * * 0 | unsigned
//  | 1 0 1 0 1 |             | min(a, b)   | * * * 0 | unsigned
//  | 1 0 1 1 0 |             | max(a, b)   | * * * * | signed
//  | 1 0 1 1 1 |             | min(a, b)   | * * * * | signed
//  | 1 1 0 0 0 |          a nor b          | 0 * * 0 |
//  | 1 1 0 0 1 |         a nxor b          | 0 * * 0 |
//  | 1 1 0 1 0 |         a nand b          | 0 * * 0 |
//  | 1 1 0 1 1 |             |             | 0 * * * |
//  | 1 1 1 0 0 |             |             | 0 * * * |
//  | 1 1 1 0 1 |             |             | 0 * * * |
//  | 1 1 1 1 0 |             |             | 0 * * * |
//  | 1 1 1 1 1 |             |             | 0 * * * |
//  +-----------+-------------+-------------+---------+
// C is '1' when (carry-occurred or not-bollowed) and unsigned-mode else
//      '0';
// V is '1' when overflowed and signed-mode else
//      '0';
// S is equal to MSB of result;
// Z is '1' when result = 0 else
//      '0';
\n
// Functionality : behavior level
//  port
//   a, b   : datas
//   cin    : carry in
//   mode   : control (refer to the above table)
//   result : result of calculation
//   flag   : flag of result (refer to the above table)
\n
module $instance_name (
  a      ,
  b      ,
  cin    ,
  mode   ,
  result ,
  flag   );
\n
input  [$bit_width_1:0] a, b   ;
input         cin    ;
input  [ 4:0] mode   ;
output [$bit_width_1:0] result ;
output [ 3:0] flag   ;
\n
wire  [$bit_width_1:0] a, b   ;
wire         cin    ;
wire  [ 4:0] mode   ;
reg   [$bit_width_1:0] result ;
reg   [ 3:0] flag   ;
\n
task ${instance_name}_add ;
input  [$bit_width_1:0] a, b   ;
input         cin    ;
output [$bit_width_1:0] result ;
output        cout   ;
  begin  // ${instance_name}_add
    {cout, result} = a + b + cin;
  end
endtask
\n
reg [$bit_width_1:0] pre_result   ;
reg [$bit_width_1:0] s_max, s_min ;
reg        C, Z, S, V   ;
\n
always@ (a or b or cin or mode)
begin
    case (mode)
      5'b00000 :
        ${instance_name}_add(a,\{$bit_width\{1'b0}},cin,pre_result,C);
      5'b00001 :
        ${instance_name}_add(a,b,cin,pre_result,C);
      5'b00010 :
        ${instance_name}_add(a,~b,cin,pre_result,C);
      5'b00011 :
        ${instance_name}_add(a,\{$bit_width\{1'b1}},cin,pre_result,C);
      5'b00100 :
        ${instance_name}_add(a,\{$bit_width\{1'b0}},cin,pre_result,C);
      5'b00101 :
        ${instance_name}_add(a,b,cin,pre_result,C);
      5'b00110 :
        ${instance_name}_add(a,~b,cin,pre_result,C);
      5'b00111 :
        ${instance_name}_add(a,\{$bit_width\{1'b1}},cin,pre_result,C);
      5'b01000 :
        ${instance_name}_add(a,\{$bit_width\{1'b0}},cin,pre_result,C);
      5'b01001 :
        ${instance_name}_add(a,b,cin,pre_result,C);
      5'b01010 :
        ${instance_name}_add(a,~b,cin,pre_result,C);
      5'b01011 :
        ${instance_name}_add(a,\{$bit_width\{1'b1}},cin,pre_result,C);
      5'b01100 :
        ${instance_name}_add(a,\{$bit_width\{1'b0}},cin,pre_result,C);
      5'b01101 :
        ${instance_name}_add(a,b,cin,pre_result,C);
      5'b01110 :
        ${instance_name}_add(a,~b,cin,pre_result,C);
      5'b01111 :
        ${instance_name}_add(a,\{$bit_width\{1'b1}},cin,pre_result,C);
      5'b10000 :
        begin
          pre_result = a | b;
          C = 1'b0;
        end
      5'b10001 :
        begin
          pre_result = a ^ b;
          C = 1'b0;
        end
      5'b10010 :
        begin
          pre_result = a & b;
          C = 1'b0;
        end
      5'b10011 :
        begin
          pre_result = ~a;
          C = 1'b0;
        end
      5'b10100 :
        ${instance_name}_add(a,~b,1'b1,pre_result,C);
      5'b10101 :
        ${instance_name}_add(a,~b,1'b1,pre_result,C);
      5'b10110 :
        ${instance_name}_add(a,~b,1'b1,pre_result,C);
      5'b10111 :
        ${instance_name}_add(a,~b,1'b1,pre_result,C);
      5'b11000 :
        begin
          pre_result = ~( a | b );
          C = 1'b0;
        end
      5'b11001 :
        begin
          pre_result = ~ ( a ^ b );
          C = 1'b0;
        end
      5'b11010 :
        begin
          pre_result = ~ ( a & b );
          C = 1'b0;
        end
      default :
        begin
          pre_result = \{$bit_width\{1'bX}};
          C = 1'bX;
        end
    endcase
\n
    if (mode[4:2] == 3'b100 || mode[4: 3] == 2'b11)
      C = 1'b0;
\n
    V = 1'b0;
    case (mode)
      5'b01000 , 5'b01100 :
      begin
        if (a[$bit_width_1]==1'b0 && pre_result[$bit_width_1]==1'b1)
          V = 1'b1;
      end
      5'b01001 , 5'b01101 :
      begin
        if     (( a[$bit_width_1]==1'b0 && b[$bit_width_1]==1'b0
                 && pre_result[$bit_width_1]==1'b1 )
            || ( a[$bit_width_1]==1'b1 && b[$bit_width_1]==1'b1
                 && pre_result[$bit_width_1]==1'b0 ))
          V = 1'b1;
      end
      5'b01010 , 5'b01110 , 5'b10110 , 5'b10111 :
      begin
        if     (( a[$bit_width_1]==1'b0 && b[$bit_width_1]==1'b1
                 && pre_result[$bit_width_1]==1'b1 )
            || ( a[$bit_width_1]==1'b1 && b[$bit_width_1]==1'b0
                 && pre_result[$bit_width_1]==1'b0 ))
          V = 1'b1;
      end
      5'b01011 , 5'b01111 :
      begin
        if (a[$bit_width_1]==1'b1 && pre_result[$bit_width_1]==1'b0)
          V = 1'b1;
      end
      default :
        V = 1'b0;
    endcase
\n
    if (a[$bit_width_1] == 1'b0 && b[$bit_width_1] == 1'b1)
      s_max = a;
    else if (a[$bit_width_1] == 1'b1 && b[$bit_width_1] == 1'b0)
      s_max = b;
    else if (a[$bit_width_1] == 1'b0 && C == 1'b1)
      s_max = a;
    else
      s_max = b;
\n
    if (a[$bit_width_1] == 1'b0 && b[$bit_width_1] == 1'b1)
      s_min = b;
    else if (a[$bit_width_1] == 1'b1 && b[$bit_width_1] == 1'b0)
      s_min = a;
    else if (a[$bit_width_1] == 1'b0 && C == 1'b1)
      s_min = b;
    else
      s_min = a;
\n
    if (mode[3:2] == 2'b01)
     begin
      if (C == 1'b1 && mode[1] == 1'b0)
        pre_result = \{$bit_width\{1'b1}};
      else if (C == 1'b0 && mode[1] == 1'b1)
        pre_result = \{$bit_width\{1'b0}};
     end
    else if (mode[3:2] == 2'b11 && V == 1'b1)
     begin
      if (pre_result[$bit_width_1] == 1'b1)
        pre_result = \{1'b0,\{$bit_width_1\{1'b1}}};
      else
        pre_result = \{1'b1,\{$bit_width_1\{1'b0}}};
     end
\n
    if (mode[4:1] == 4'b1010)
     begin
      if ((C == 1'b1 && mode[0] == 1'b0) || (C == 1'b0 && mode[0] == 1'b1))
        pre_result = a;
      else if ((C == 1'b1 && mode[0] == 1'b1) || (C == 1'b0 && mode[0] == 1'b0))
        pre_result = b;
     end
\n
    if (mode[4:1] == 4'b1011)
     begin
      if (( a[$bit_width_1] == 1'b0 && b[$bit_width_1] == 1'b1
           && mode[0] == 1'b0) ||
         ( a[$bit_width_1] == 1'b1 && b[$bit_width_1] == 1'b0
           && mode[0] == 1'b1))
        pre_result = a;
      else if (( a[$bit_width_1] == 1'b1 && b[$bit_width_1] == 1'b0
             && mode[0] == 1'b0) ||
           ( a[$bit_width_1] == 1'b0 && b[$bit_width_1] == 1'b1
             && mode[0] == 1'b1))
        pre_result = b;
      else if ((C == 1'b1 && mode[0] == 1'b0) || (C == 1'b0 && mode[0] == 1'b1))
        pre_result = a;
      else if ((C == 1'b1 && mode[0] == 1'b1) || (C == 1'b0 && mode[0] == 1'b0))
        pre_result = b;
     end
\n
    if (pre_result == \{$bit_width\{1'b0}})
      Z = 1'b1;
    else
      Z = 1'b0;
\n
    S = pre_result[$bit_width_1];
\n
    result = pre_result;
    flag = {C , Z , S , V};
\n
end
\n
endmodule
FHM_DL_INSTANCE
}
exit(0);
          ]]>
        </script>
      </instance>

      <entity></entity>

      <testvector></testvector>

      <synthesis></synthesis>
    </design>

    <design>
      <design_lang> SystemC Header </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates alu instance in behavior level
# parameter : name_space instance_name bit_width

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script name_space instance_name bit_width\n";
    exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];

$bit_width_1 = $bit_width - 1;

if($bit_width > 64) {
    $data_type = "sc_dt::sc_biguint<" . $bit_width . ">";
} else {
    $data_type = "sc_dt::sc_uint<" . $bit_width . ">";
}

$macro = "__" . uc($name_space) . "_" . uc($instance_name) . "_H__";

{
print <<FHM_DL_INSTANCE
#ifndef $macro
#define $macro 1

// Module     : Arithmetic Logic Unit
// Feature    : 
// References : 
// Author     : Designed by T.Morifuji (c)1997,1998.
\n
// Version : 1.3  : Modified by Y.Yamane 2002/01/15 Tue
\n
// Comment : function table is followings.
//  +-----------+-------------+-------------+---------+
//  |   mode    |   cin = 0   |   cin = 1   |  flag   |
//  +-----------+-------------+-------------+---------+
//  | 4 3 2 1 0 |   result    |   result    | c z s v |
//  +-----------+-------------+-------------+---------+
//  | 0 0 0 0 0 | a           | a + 1       | * * * 0 | unsigned (c)
//  | 0 0 0 0 1 | a + b       | a + b + 1   | * * * 0 | unsigned (c)
//  | 0 0 0 1 0 | a - b - 1   | a - b       | * * * 0 | unsigned (c)
//  | 0 0 0 1 1 | a - 1       | a           | * * * 0 | unsigned (c)
//  | 0 0 1 0 0 | a           | a +] 1      | * * * 0 | unsigned clip
//  | 0 0 1 0 1 | a +] b      | a +] b +] 1 | * * * 0 | unsigned clip
//  | 0 0 1 1 0 | a -] b -] 1 | a -] b      | * * * 0 | unsigned clip
//  | 0 0 1 1 1 | a -] 1      | a           | * * * 0 | unsigned clip
//  | 0 1 0 0 0 | a           | a + 1       | * * * * | signed (v)
//  | 0 1 0 0 1 | a + b       | a + b + 1   | * * * * | signed (v)
//  | 0 1 0 1 0 | a - b - 1   | a - b       | * * * * | signed (v)
//  | 0 1 0 1 1 | a - 1       | a           | * * * * | signed (v)
//  | 0 1 1 0 0 | a           | a +] 1      | * * * * | signed clip
//  | 0 1 1 0 1 | a +] b      | a +] b +] 1 | * * * * | signed clip
//  | 0 1 1 1 0 | a -] b -] 1 | a -] b      | * * * * | signed clip
//  | 0 1 1 1 1 | a -] 1      | a           | * * * * | signed clip
//  | 1 0 0 0 0 |           a or b          | 0 * * 0 |
//  | 1 0 0 0 1 |          a xor b          | 0 * * 0 |
//  | 1 0 0 1 0 |          a and b          | 0 * * 0 |
//  | 1 0 0 1 1 |           not a           | 0 * * 0 |
//  | 1 0 1 0 0 |             | max(a, b)   | * * * 0 | unsigned
//  | 1 0 1 0 1 |             | min(a, b)   | * * * 0 | unsigned
//  | 1 0 1 1 0 |             | max(a, b)   | * * * * | signed
//  | 1 0 1 1 1 |             | min(a, b)   | * * * * | signed
//  | 1 1 0 0 0 |          a nor b          | 0 * * 0 |
//  | 1 1 0 0 1 |         a nxor b          | 0 * * 0 |
//  | 1 1 0 1 0 |         a nand b          | 0 * * 0 |
//  | 1 1 0 1 1 |             |             | 0 * * * |
//  | 1 1 1 0 0 |             |             | 0 * * * |
//  | 1 1 1 0 1 |             |             | 0 * * * |
//  | 1 1 1 1 0 |             |             | 0 * * * |
//  | 1 1 1 1 1 |             |             | 0 * * * |
//  +-----------+-------------+-------------+---------+
// C is '1' when (carry-occurred or not-bollowed) and unsigned-mode else
//      '0';
// V is '1' when overflowed and signed-mode else
//      '0';
// S is equal to MSB of result;
// Z is '1' when result = 0 else
//      '0';

// Functionality : behavior level
//  port
//   a, b   : datas
//   cin    : carry in
//   mode   : control (refer to the above table)
//   result : result of calculation
//   flag   : flag of result (refer to the above table)

#include <systemc>

namespace ${name_space} {
  SC_MODULE($instance_name) {
    sc_core::sc_in< $data_type > a, b;
    sc_core::sc_in< bool > cin;
    sc_core::sc_in< sc_dt::sc_uint<5> > mode;
    sc_core::sc_out< $data_type > result;
    sc_core::sc_out< sc_dt::sc_uint<4> > flag;
  
    SC_CTOR($instance_name) :
      a("a"), b("b"), cin("cin"),
      mode("mode"), result("result"), flag("flag")
    {
      SC_METHOD(process);
      sensitive << a << b << cin << mode;
    }
  
    void process();
  };
};

#endif // $macro
FHM_DL_INSTANCE
}
exit(0);

          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <design>
      <design_lang> SystemC Program </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates alu instance in behavior level
# parameter : name_space instance_name bit_width

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script name_space instance_name bit_width\n";
    exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];

$bit_width_1 = $bit_width - 1;

if($bit_width > 64) {
    $data_type = "sc_dt::sc_biguint<" . $bit_width . ">";
} else {
    $data_type = "sc_dt::sc_uint<" . $bit_width . ">";
}

if($bit_width + 1 > 64) {
    $tmp_type = "sc_dt::sc_biguint<" . ($bit_width + 1) . ">";
} else {
    $tmp_type = "sc_dt::sc_uint<" . ($bit_width + 1) . ">";
}

$one  = "~ ${data_type}(0)";

{
print <<FHM_DL_INSTANCE
#include "$instance_name.h"

// Module     : Arithmetic Logic Unit
// Feature    : 
// References : 
// Author     : Designed by T.Morifuji (c)1997,1998.
\n
// Version : 1.3  : Modified by Y.Yamane 2002/01/15 Tue
\n
// Comment : function table is followings.
//  +-----------+-------------+-------------+---------+
//  |   mode    |   cin = 0   |   cin = 1   |  flag   |
//  +-----------+-------------+-------------+---------+
//  | 4 3 2 1 0 |   result    |   result    | c z s v |
//  +-----------+-------------+-------------+---------+
//  | 0 0 0 0 0 | a           | a + 1       | * * * 0 | unsigned (c)
//  | 0 0 0 0 1 | a + b       | a + b + 1   | * * * 0 | unsigned (c)
//  | 0 0 0 1 0 | a - b - 1   | a - b       | * * * 0 | unsigned (c)
//  | 0 0 0 1 1 | a - 1       | a           | * * * 0 | unsigned (c)
//  | 0 0 1 0 0 | a           | a +] 1      | * * * 0 | unsigned clip
//  | 0 0 1 0 1 | a +] b      | a +] b +] 1 | * * * 0 | unsigned clip
//  | 0 0 1 1 0 | a -] b -] 1 | a -] b      | * * * 0 | unsigned clip
//  | 0 0 1 1 1 | a -] 1      | a           | * * * 0 | unsigned clip
//  | 0 1 0 0 0 | a           | a + 1       | * * * * | signed (v)
//  | 0 1 0 0 1 | a + b       | a + b + 1   | * * * * | signed (v)
//  | 0 1 0 1 0 | a - b - 1   | a - b       | * * * * | signed (v)
//  | 0 1 0 1 1 | a - 1       | a           | * * * * | signed (v)
//  | 0 1 1 0 0 | a           | a +] 1      | * * * * | signed clip
//  | 0 1 1 0 1 | a +] b      | a +] b +] 1 | * * * * | signed clip
//  | 0 1 1 1 0 | a -] b -] 1 | a -] b      | * * * * | signed clip
//  | 0 1 1 1 1 | a -] 1      | a           | * * * * | signed clip
//  | 1 0 0 0 0 |           a or b          | 0 * * 0 |
//  | 1 0 0 0 1 |          a xor b          | 0 * * 0 |
//  | 1 0 0 1 0 |          a and b          | 0 * * 0 |
//  | 1 0 0 1 1 |           not a           | 0 * * 0 |
//  | 1 0 1 0 0 |             | max(a, b)   | * * * 0 | unsigned
//  | 1 0 1 0 1 |             | min(a, b)   | * * * 0 | unsigned
//  | 1 0 1 1 0 |             | max(a, b)   | * * * * | signed
//  | 1 0 1 1 1 |             | min(a, b)   | * * * * | signed
//  | 1 1 0 0 0 |          a nor b          | 0 * * 0 |
//  | 1 1 0 0 1 |         a nxor b          | 0 * * 0 |
//  | 1 1 0 1 0 |         a nand b          | 0 * * 0 |
//  | 1 1 0 1 1 |             |             | 0 * * * |
//  | 1 1 1 0 0 |             |             | 0 * * * |
//  | 1 1 1 0 1 |             |             | 0 * * * |
//  | 1 1 1 1 0 |             |             | 0 * * * |
//  | 1 1 1 1 1 |             |             | 0 * * * |
//  +-----------+-------------+-------------+---------+
// C is '1' when (carry-occurred or not-bollowed) and unsigned-mode else
//      '0';
// V is '1' when overflowed and signed-mode else
//      '0';
// S is equal to MSB of result;
// Z is '1' when result = 0 else
//      '0';

// Functionality : behavior level
//  port
//   a, b   : datas
//   cin    : carry in
//   mode   : control (refer to the above table)
//   result : result of calculation
//   flag   : flag of result (refer to the above table)


static void ${instance_name}_add( 
  const $data_type &a,
  const $data_type &b,
  const bool &cin, 
  $data_type &result,
  sc_dt::sc_uint<1> &cout )
{
  $tmp_type a_tmp(a);
  a_tmp += b;
  a_tmp += cin;
  result = a_tmp($bit_width - 1, 0);
  cout = a_tmp[$bit_width];
}

void ${name_space}::${instance_name}::process()
{
  $data_type pre_result, s_max, s_min;
  sc_dt::sc_uint<1> C, Z, S, V;

  $data_type tmp_a = a.read(), tmp_b = b.read();
  bool tmp_cin = cin.read();
  sc_dt::sc_uint<5> tmp_mode = mode.read();

  if( tmp_mode == 0 ) {
    ${instance_name}_add( tmp_a, 0, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 1 ) {
    ${instance_name}_add( tmp_a, tmp_b, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 2 ) {
    ${instance_name}_add( tmp_a, ~tmp_b, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 3 ) {
    ${instance_name}_add( tmp_a, $one, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 4 ) {
    ${instance_name}_add( tmp_a, 0, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 5 ) {
    ${instance_name}_add( tmp_a, tmp_b, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 6 ) {
    ${instance_name}_add( tmp_a, ~tmp_b, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 7 ) {
    ${instance_name}_add( tmp_a, $one, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 8 ) {
    ${instance_name}_add( tmp_a, 0, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 9 ) {
    ${instance_name}_add( tmp_a, tmp_b, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 10 ) {
    ${instance_name}_add( tmp_a, ~tmp_b, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 11 ) {
    ${instance_name}_add( tmp_a, $one, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 12 ) {
    ${instance_name}_add( tmp_a, 0, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 13 ) {
    ${instance_name}_add( tmp_a, tmp_b, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 14 ) {
    ${instance_name}_add( tmp_a, ~tmp_b, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 15 ) {
    ${instance_name}_add( tmp_a, $one, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 16 ) {
    pre_result = tmp_a | tmp_b;
    C = 0;
  } else if ( tmp_mode == 17 ) {
    pre_result = tmp_a ^ tmp_b;
    C = 0;
  } else if ( tmp_mode == 18 ) {
    pre_result = tmp_a & tmp_b;
    C = 0;
  } else if ( tmp_mode == 19 ) {
    pre_result = ~tmp_a;
    C = 0;
  } else if ( tmp_mode == 20 ) {
    ${instance_name}_add( tmp_a,~tmp_b, 1, pre_result, C);
  } else if ( tmp_mode == 21 ) {
    ${instance_name}_add( tmp_a, ~tmp_b, 1, pre_result, C);
  } else if ( tmp_mode == 22 ) {
    ${instance_name}_add( tmp_a, ~tmp_b, 1, pre_result, C);
  } else if ( tmp_mode == 23 ) {
    ${instance_name}_add( tmp_a, ~tmp_b, 1, pre_result, C);
  } else if ( tmp_mode == 24 ) {
    pre_result = ~( tmp_a | tmp_b );
    C = 0;
  } else if ( tmp_mode == 25 ) {
    pre_result = ~ ( tmp_a ^ tmp_b );
    C = 0;
  } else if ( tmp_mode == 26 ) {
    pre_result = ~ ( tmp_a & tmp_b );
    C = 0;
  } else {
    pre_result = 0;
    C = 1;
  }

  if ( tmp_mode(4, 2) == 4 || tmp_mode(4, 3) == 3 )
    C = 0;

  V = 0;
  if ( tmp_mode == 8 || tmp_mode == 12 ) {
    if ( tmp_a[$bit_width_1] == 0 && pre_result[$bit_width_1] == 1 )
      V = 1;
  } else if ( tmp_mode == 9 || tmp_mode == 13 ) {
    if (( tmp_a[$bit_width_1] == 0 && tmp_b[$bit_width_1] == 0
              && pre_result[$bit_width_1] == 1 )
     || ( tmp_a[$bit_width_1] == 1 && tmp_b[$bit_width_1] == 1
              && pre_result[$bit_width_1] == 0 )) {
      V = 1;
    }
  } else if ( ( tmp_mode == 10 || tmp_mode == 14 )
           || ( tmp_mode == 22 || tmp_mode == 23 ) ) {
    if (( tmp_a[$bit_width_1] == 0 && tmp_b[$bit_width_1] == 1
              && pre_result[$bit_width_1] == 1 )
     || ( tmp_a[$bit_width_1] == 1 && tmp_b[$bit_width_1] == 0
              && pre_result[$bit_width_1] == 0 )) {
      V = 1;
    }
  } else if ( tmp_mode == 11 || tmp_mode == 15 ) {
    if ( tmp_a[$bit_width_1] == 1 && pre_result[$bit_width_1] == 0 )
      V = 1;
  } else {
    V = 0;
  }

  if ( tmp_a[$bit_width_1] == 0 && tmp_b[$bit_width_1] == 1 )
    s_max = tmp_a;
  else if ( tmp_a[$bit_width_1] == 1 && tmp_b[$bit_width_1] == 0 )
    s_max = tmp_b;
  else if ( tmp_a[$bit_width_1] == 0 && C == 1 )
    s_max = tmp_a;
  else
    s_max = tmp_b;

  if ( tmp_a[$bit_width_1] == 0 && tmp_b[$bit_width_1] == 1 )
    s_min = b;
  else if ( tmp_a[$bit_width_1] == 1 && tmp_b[$bit_width_1] == 0 )
    s_min = a;
  else if ( tmp_a[$bit_width_1] == 0 && C == 1 )
    s_min = b;
  else
    s_min = a;

  if ( tmp_mode(3, 2) == 1 ) {
    if ( C == 1 && tmp_mode[1] == 0 )
      pre_result = $one;
    else if ( C == 0 && tmp_mode[1] == 1)
      pre_result = 0;
  } else if ( tmp_mode(3, 2) == 3 && V == 1 ) {
    if ( pre_result[$bit_width_1] == 1) {
      pre_result[$bit_width_1] = 0;
      pre_result($bit_width_1 - 1, 0) = -1;
    } else {
      pre_result[$bit_width_1] = 1;
      pre_result($bit_width_1 - 1, 0) = 0;
    }
  }

  if ( tmp_mode(4, 1) == 10 ) {
    if ((C == 1 && tmp_mode[0] == 0) || (C == 0 && tmp_mode[0] == 1))
      pre_result = tmp_a;
    else if ((C == 1 && tmp_mode[0] == 1) || (C == 0 && tmp_mode[0] == 0))
      pre_result = tmp_b;
  }

  if ( tmp_mode(4, 1) == 11 ) {
    if (( tmp_a[$bit_width_1] == 0 && tmp_b[$bit_width_1] == 1
         && tmp_mode[0] == 0) 
     || ( tmp_a[$bit_width_1] == 1 && tmp_b[$bit_width_1] == 0
         && tmp_mode[0] == 1))
      pre_result = tmp_a;
    else if (( tmp_a[$bit_width_1] == 1 && tmp_b[$bit_width_1] == 0
           && tmp_mode[0] == 0)
          || ( tmp_a[$bit_width_1] == 0 && tmp_b[$bit_width_1] == 1
           && tmp_mode[0] == 1))
      pre_result = tmp_b;
    else if ((C == 1 && tmp_mode[0] == 0)
          || (C == 0 && tmp_mode[0] == 1))
      pre_result = tmp_a;
    else if ((C == 1 && tmp_mode[0] == 1)
          || (C == 0 && tmp_mode[0] == 0))
      pre_result = tmp_b;
  }

  if ( pre_result == 0 )
    Z = 1;
  else
    Z = 0;

  S = pre_result[$bit_width_1];

  result.write( pre_result );
  flag.write( (C , Z , S , V ) );
}
FHM_DL_INSTANCE
}

exit(0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <estimation>
      <estimation_data>
        <library name="OSAKA">

          <est_type name="shape">
            <est_index name="area">
              <unit> mm2 </unit>
              <translate>
                <translate_value key="gate"> 4201.68 </translate_value>
                <translate_value key="mm2">  1 </translate_value>
              </translate>

              <parameters name="">
                <max>
                  <data bit_width="4"> 0.164985391557663 </data>
                  <data bit_width="8"> 0.257213515070162 </data>
                  <data bit_width="16"> 0.533158260505322 </data>
                  <data bit_width="32"> 1.04701481098037 </data>
                  <data bit_width="128"> 4.66936830172693 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.113589963300394 </data>
                  <data bit_width="8"> 0.197268678956989 </data>
                  <data bit_width="16"> 0.397879236400678 </data>
                  <data bit_width="32"> 0.755690911016546 </data>
                  <data bit_width="128"> 3.51382605434017 </data>
                </min>
                <typ>
                </typ>
              </parameters>
            </est_index>

            <est_index name="aspect_ratio">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="height">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="width">
              <!-- Dummy yet -->
            </est_index>
          </est_type>

          <est_type name="timing">
            <est_index name="delay">
              <unit> ns </unit>

              <parameters name="">
                <max>
                  <data bit_width="4"> 9.15 </data>
                  <data bit_width="8"> 12.25 </data>
                  <data bit_width="16"> 18.08 </data>
                  <data bit_width="32"> 31.02 </data>
                  <data bit_width="128"> 100.10 </data>
                </max>
                <min>
                  <data bit_width="4"> 4.65 </data>
                  <data bit_width="8"> 5.40 </data>
                  <data bit_width="16"> 7.12 </data>
                  <data bit_width="32"> 8.79 </data>
                  <data bit_width="128"> 33.00 </data>
                </min>
                <typ>
                </typ>
              </parameters>
            </est_index>

            <est_index name="delay_fullpath">
            <!-- Dummy yet -->
            </est_index>
          </est_type>

          <est_type name="power">
            <est_index name="static_power">
              <unit> mW </unit>
              <parameters name="">
                <max>
                  <data bit_width="4"> 70.0840 </data>
                  <data bit_width="8"> 108.6488 </data>
                  <data bit_width="16"> 214.1503 </data>
                  <data bit_width="32"> 392.6953 </data>
                  <data bit_width="128"> 1565.9 </data>
                </max>
                <min>
                  <data bit_width="4"> 40.3143 </data>
                  <data bit_width="8"> 64.8514 </data>
                  <data bit_width="16"> 139.7683 </data>
                  <data bit_width="32"> 266.0890 </data>
                  <data bit_width="128"> 1190.2 </data>
                </min>
                <typ>
                </typ>
              </parameters>
            </est_index>
          </est_type>

          <est_type name="function_cycle">
            <!-- Dummy yet -->
          </est_type>

          <est_type name="function_power">
            <!-- Dummy yet -->
          </est_type>
        </library>
      </estimation_data>

      <estimation_method>
         
        <est_type name="shape">

          <est_index name="area">

            <parameters name="">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for alu.
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$n = $i;

# numerator 1
$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;

# numerator 2
$nume_2 = &sum(@bit) * &sum(@data);
    
# denominator 1
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;

# denominator 2
$deno_2 = &sum(@bit) * &sum(@bit);
	

# divide by zero
if ($deno_1 == $deno_2) {
    exit(100);
}
if ($n == 0) {
    exit(100);
}


$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;

$ret_data = $a * $ARGV[1] + $b;


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$ret_data += $data[$i];
    }

    return($ret_data);
}

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

           <est_index name="aspect_ratio">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="height">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="width">

             <!-- Dummy yet -->

           </est_index>
		
        </est_type>

        <est_type name="timing">

          <est_index name="delay">

            <parameters name="">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for alu.
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$n = $i;

# numerator 1
$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;

# numerator 2
$nume_2 = &sum(@bit) * &sum(@data);
    
# denominator 1
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;

# denominator 2
$deno_2 = &sum(@bit) * &sum(@bit);
	

# divide by zero
if ($deno_1 == $deno_2) {
    exit(100);
}
if ($n == 0) {
    exit(100);
}


$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;

$ret_data = $a * $ARGV[1] + $b;


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$ret_data += $data[$i];
    }

    return($ret_data);
}

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

          <est_index name="delay_fullpath">

            <parameters name="">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay_fullpath for alu.
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

$Round = 1;

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression for delay_fullpath
#--------------------------------------------------------------------------#
$n = 0;

while (<TMP>) {

    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>/ ) {

	$bit_width = $1;
	$bit[$n] = $bit_width;
	$n++;
	$_ = <TMP>;
	
	$i = 0;
	while (! /\<\s*\/data\s*\>/ ) {

	    # path 
	    if ( /path\s+(\w+)\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "path\t $1\t $2\t ";
		$delay{$bit_width}[$i] = $3; 
		$i++;
	    }

	    # inport
	    if ( /inport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "inport\t $1\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }

	    # outport
	     if ( /outport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "outport\t $1\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }

	    # internal
	    if ( /internal\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "internal\t ";
		$delay{$bit_width}[$i] = $1;
		$i++;
	    }

	    $_ = <TMP>;
	}
    }
}
close(TMP);

$line_num = $i;



for ($j = 0; $j < $line_num; $j++) {

    # numerator 1
    $nume_1 = 0.00;
    foreach $bit_width (@bit) {
	$nume_1 += $bit_width * $delay{$bit_width}[$j];
    }
    $nume_1 *= $n;

    # numerator 2
    $nume_2 = &sum(@bit);

    $tmp = 0.00;
    foreach $bit_width (@bit) {
	$tmp += $delay{$bit_width}[$j];
    }
    $nume_2 *= $tmp;
    
    # denominator 1
    $deno_1 = 0.00;
    for ($i = 0; $i < $n; $i++) {
	$deno_1 += $bit[$i] * $bit[$i];
    }
    $deno_1 *= $n;

    # denominator 2
    $deno_2 = &sum(@bit) * &sum(@bit);
    

    # divide by zero
    if ($deno_1 == $deno_2) {
	exit(100);
    }
    if ($n == 0) {
	exit(100);
    }


    # a
    $a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);

    # b
    $tmp = 0.00;
    foreach $bit_width (@bit) {
	$tmp += $delay{$bit_width}[$j];
    }
    $b = ($tmp - $a * &sum(@bit)) / $n;
    
    $ret_data = $a * $ARGV[1] + $b;
    $ret_data = &data_round($ret_data, $Round);
    
    print "$line{$bit[0]}[$j] $ret_data\n";
}

exit(0);


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $return_data );

    $return_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$return_data += $data[$i];
    }

    return($return_data);
}


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}
                ]]>
              </script>
            </parameters>
          </est_index>

        </est_type>

        <est_type name="power">

          <est_index name="static_power">

            <parameters name="">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for alu.
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

        </est_type>

        <est_type name="function_cycle">

        </est_type>

        <est_type name="function_power">

        </est_type>

    
      </estimation_method>

    </estimation>


  </model>

  <model>
    <design_level> synthesis </design_level>
    <version> 1.0 </version>
    <author> <![CDATA[ Yamane Yukinori ]]> </author>
    <affiliation> <![CDATA[ Osaka Univ. ]]> </affiliation>
    <model_info> <![CDATA[
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                %
%    Copyright 2008 ASIP Solutions, Inc. All rights reserved.    %
%              Copyright 2002-2005 PEAS Project                  %
%                                                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
]]> </model_info>

    <parameter>
      <parameter_value key="bit_width">
        <value> 4 </value>
        <value> 8 </value>
        <value> 12 </value>
        <value> 16 </value>
        <value> 20 </value>
        <value> 24 </value>
        <value> 28 </value>
        <value> 32 </value>
        <value> 64 </value>
        <value> 128 </value>
        <value> 256 </value>
      </parameter_value>
      <parameter_value key="algorithm">
        <value> default </value>
      </parameter_value>
    </parameter>

    <function_description>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates alu function definition in synthesis level
# parameter : bit_width algorithm

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm\n";
    exit (100);
}

$bit_width = $ARGV[0];
$algorithm = $ARGV[1];

$bit_width_1 = $bit_width - 1;

{
print <<FHM_DL_FUNCTION
signed     add(twoscomp a, twoscomp b);
unsigned   addu(twoscomp a, twoscomp b);
signed     addi(twoscomp a, twoscomp b);
unsigned   addiu(twoscomp a, twoscomp b);
signed     cadd(twoscomp a, twoscomp b);
unsigned   caddu(twoscomp a, twoscomp b);
signed     caddi(twoscomp a, twoscomp b);
unsigned   caddiu(twoscomp a, twoscomp b);
signed     sub(twoscomp a, twoscomp b);
unsigned   subu(twoscomp a, twoscomp b);
signed     subd(twoscomp a, twoscomp b);
unsigned   subdu(twoscomp a, twoscomp b);
signed     csub(twoscomp a, twoscomp b);
unsigned   csubu(twoscomp a, twoscomp b);
signed     csubd(twoscomp a, twoscomp b);
unsigned   csubdu(twoscomp a, twoscomp b);
signed     inc(twoscomp a);
unsigned   incu(twoscomp a);
signed     cinc(twoscomp a);
unsigned   cincu(twoscomp a);
signed     dec(twoscomp a);
unsigned   decu(twoscomp a);
signed     cdec(twoscomp a);
unsigned   cdecu(twoscomp a);
unsigned   not(twoscomp a);
unsigned   and(twoscomp a, twoscomp b);
unsigned   or(twoscomp a, twoscomp b);
unsigned   xor(twoscomp a, twoscomp b);
unsigned   nor(twoscomp a, twoscomp b);
unsigned   nxor(twoscomp a, twoscomp b);
unsigned   nand(twoscomp a, twoscomp b);
signed     max(twoscomp a, twoscomp b);
unsigned   maxu(twoscomp a, twoscomp b);
signed     min(twoscomp a, twoscomp b);
unsigned   minu(twoscomp a, twoscomp b);
bit_vector alu_flag(bit_vector mode, bit_vector a, bit_vector b, bit cin);

/** ${bit_width}-bits alu */
model alu_${bit_width}{
  port{
    in  a[${bit_width_1}:0], b[${bit_width_1}:0], cin, mode[4:0];
    out result[${bit_width_1}:0], flag[3:0];
  }

   /** C is '1' when (carry-occurred or not-borrowed) and unsigned-mode else '0'
       Z is '1' when result = 0 else '0'
       S is equal to MSB of result
       V is '1' when overflowed and signed-mode else '0' */
 
  /** add : signed add, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function add{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = add(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01001" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** addu : unsigned add, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function addu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = addu(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00001" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** addi : signed add and inc, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function addi{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = addi(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01001" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** addiu : unsigned add and inc, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function addiu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = addiu(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00001" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** cadd : signed add with saturation, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function cadd{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = cadd(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01101" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** caddu : unsigned add with saturation, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function caddu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = caddu(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00101" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** caddi : signed add and inc with saturation, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function caddi{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = caddi(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01101" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }
  
  /** caddiu : unsigned add and inc with saturation, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function caddiu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = caddiu(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00101" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** sub : signed sub, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function sub{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = sub(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01010" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** subu : unsigned sub, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function subu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = subu(a, b, cin);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00010" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** subd : signed sub and dec, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function subd{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = subd(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01010" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** subdu : unsigned sub and dec, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function subdu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = subdu(a, b, cin);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00010" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** csub : signed sub with saturation, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function csub{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = csub(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01110" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** csubu : unsigned sub with saturation, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function csubu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = csubu(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00110" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** csubd : signed sub and dec with saturation, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function csubd{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = csubd(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01110" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** csubdu : unsigned sub and dec with saturation, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function csubdu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = csubdu(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00110" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** inc : signed inc, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function inc{
    input{
      unsigned a;
    }
    output{
      unsigned   result = inc(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01000" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** incu : unsigned inc, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function incu{
    input{
      unsigned a;
    }
    output{
      unsigned   result = incu(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00000" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** cinc : signed inc with saturation, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function cinc{
    input{
      unsigned a;
    }
    output{
      unsigned   result = cinc(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01100" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** cincu : unsigned inc with saturation, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function cincu{
    input{
      unsigned a;
    }
    output{
      unsigned   result = cincu(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00100" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** dec : signed dec, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function dec{
    input{
      unsigned a;
    }
    output{
      unsigned   result = dec(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01011" && cin = '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** decu : unsigned dec, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function decu{
    input{
      unsigned a;
    }
    output{
      unsigned   result = decu(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00011" && cin = '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** cdec : signed dec with saturation, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function cdec{
    input{
      unsigned a;
    }
    output{
      unsigned   result = cdec(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01111" && cin = '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** cdecu : unsigned dec with saturation, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function cdecu{
    input{
      unsigned a;
    }
    output{
      unsigned   result = cdecu(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00111" && cin = '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** not : not, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function not{
    input{
      unsigned a;
    }
    output{
      unsigned   result = not(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "10011"]{
	valid result;
	valid flag;
      }
    }
  }

  /** and : and, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function and{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = and(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "10010"]{
	valid result;
	valid flag;
      }
    }
  }

  /** or : or, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function or{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = or(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "10000"]{
	valid result;
	valid flag;
      }
    }
  }

  /** xor : xor, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function xor{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = xor(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "10001"]{
	valid result;
	valid flag;
      }
    }
  }

  /** nor : nor, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function nor{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = nor(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "11000"]{
	valid result;
	valid flag;
      }
    }
  }

  /** nxor : nxor, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function nxor{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = nxor(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "11001"]{
	valid result;
	valid flag;
      }
    }
  }

  /** nand : nand, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function nand{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = nand(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "11010"]{
	valid result;
	valid flag;
      }
    }
  }

  /** cmp : signed comp, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function cmp{
    input{
      unsigned a, b;
    }
    output{
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01010" && cin = '1']{
	valid flag;
      }
    }
  }

  /** cmpu : unsigned comp, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function cmpu{
    input{
      unsigned a, b;
    }
    output{
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00010" && cin = '1']{
	valid flag;
      }
    }
  }

  /** cmpz : signed comp with zero, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function cmpz{
    input{
      unsigned a;
    }
    output{
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01000" && cin = '0']{
	valid flag;
      }
    }
  }

  /** cmpzu : unsigned comp with zero, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function cmpzu{
    input{
      unsigned a;
    }
    output{
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00000" && cin = '0']{
	valid flag;
      }
    }
  }

  /** max : signed max, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function max{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = max(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "10110" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** maxu : unsigned max, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function maxu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = maxu(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "10100" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** min : signed min, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function min{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = min(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "10111" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** minu : unsigned min, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function minu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = minu(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "10101" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }
}
FHM_DL_FUNCTION
}
exit(0);
        ]]>
      </script>
    </function_description>

    <function_conv>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates alu function definition in synthesis level
# parameter : bit_width algorithm

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm\n";
    exit (100);
}

$bit_width = $ARGV[0];
$bit_width_1 = $bit_width - 1;

{
print <<FHM_DL_FUNCCONV
/** signed add, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function add {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01001";
      cin = '0';
    }
  }
}

/** unsigned add, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function addu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00001";
      cin = '0';
    }
  }
}

/** signed add and inc, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function addi {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01001";
      cin = '1';
    }
  }
}

/** unsigned add and inc, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function addiu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00001";
      cin = '1';
    }
  }
}

/** signed add with saturation, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function cadd {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01101";
      cin = '0';
    }
  }
}

/** unsigned add with saturation, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function caddu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00101";
      cin = '0';
    }
  }
}

/** signed add and inc with saturation, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function caddi {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01101";
      cin = '1';
    }
  }
}

/** unsigned add and inc with saturation, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function caddiu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00101";
      cin = '1';
    }
  }
}

/** signed sub, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function sub {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01010";
      cin = '1';
    }
  }
}

/** unsigned sub, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function subu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00010";
      cin = '1';
    }
  }
}

/** signed sub and dec, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function subd {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01010";
      cin = '0';
    }
  }
}

/** unsigned sub and dec, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function subdu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00010";
      cin = '0';
    }
  }
}

/** signed sub with saturation, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function csub {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01110";
      cin = '1';
    }
  }
}

/** unsigned sub with saturation, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function csubu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00110";
      cin = '1';
    }
  }
}

/** signed sub and dec with saturation, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function csubd {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01110";
      cin = '0';
    }
  }
}

/** unsigned sub and dec with saturation, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function csubdu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00110";
      cin = '0';
    }
  }
}

/** signed inc, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V */
function inc {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01000";
      cin = '1';
    }
  }
}

/** unsigned inc, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0 */
function incu {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00000";
      cin = '1';
    }
  }
}

/** signed inc with saturation, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V */
function cinc {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01100";
      cin = '1';
    }
  }
}

/** unsigned inc with saturation, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0 */
function cincu {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00100";
      cin = '1';
    }
  }
}

/** signed dec, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function dec {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01011";
      cin = '0';
    }
  }
}

/** unsigned dec, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function decu {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00011";
      cin = '0';
    }
  }
}

/** signed dec with saturation, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V */
function cdec {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01111";
      cin = '0';
    }
  }
}

/** unsigned dec with saturation, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cdecu {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00111";
      cin = '0';
    }
  }
}

/** not, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function not {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "10011";
    }
  }
}

/** and, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function and {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "10010";
    }
  }
}

/** or, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function or {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "10000";
    }
  }
}

/** xor, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function xor {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "10001";
    }
  }
}

/** nor, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function nor {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "11000";
    }
  }
}

/** nxor, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function nxor {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "11001";
    }
  }
}

/** nand, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function nand {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "11010";
    }
  }
}

/** signed cmp, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function cmp {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01010";
      cin = '1';
    }
  }
}

/** unsigned cmp, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cmpu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00010";
      cin = '1';
    }
  }
}

/** signed cmp zero, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cmpz {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01000";
      cin = '0';
    }
  }
}

/** unsigned cmp zero, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cmpzu {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00000";
      cin = '0';
    }
  }
}

/** signed max, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function max {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "10110";
      cin = '1';
    }
  }
}

/** unsigned max, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function maxu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "10100";
      cin = '1';
    }
  }
}

/** signed min, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function min {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "10111";
      cin = '1';
    }
  }
}

/** unsigned min, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function minu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "10101";
      cin = '1';
    }
  }
}
FHM_DL_FUNCCONV
}
exit(0);
        ]]>
      </script>
    </function_conv>

    <function_port>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates alu port infomation in synthesis level
# parameter : bit_width algorithm

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm\n";
    exit (100);
}


$bit_width = $ARGV[0];
$algorithm = $ARGV[1];

$bit_width_1 = $bit_width - 1;

{
print <<FHM_DL_PORTINFO
a	in	bit_vector   $bit_width_1   0	data
b	in	bit_vector   $bit_width_1   0	data
cin	in	bit		mode
mode	in	bit_vector   4   0	mode
result	out	bit_vector   $bit_width_1   0	data
flag	out	bit_vector   3   0	data
FHM_DL_PORTINFO
}
exit(0);
        ]]>
      </script>
    </function_port>

    <design>
      <design_lang> vhdl </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates alu instance in synthesis level
# parameter : instance_name bit_width algorithm

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width algorithm\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$algorithm     = $ARGV[2];

$bit_width_1 = $bit_width - 1;
$bit_width_2 = $bit_width - 2;

$zero = "0" x $bit_width;
$zero = "\"" . $zero . "\"";
$one  = "1" x $bit_width;
$one  = "\"" . $one . "\"";

$ones = "\"" . "1" x $bit_width . "\"";

$x_str = "X" x $bit_width;
$x_str = "\"" . $x_str . "\"";

if ("$algorithm" eq "default"){
    print <<FHM_DL_INSTANCE_default
-- Module     : N-bit Adder with operator

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_unsigned.all;

entity ${instance_name}_add is
  port (a, b   : in  std_logic_vector($bit_width_1 downto 0);
        cin    : in  std_logic;
        result : out std_logic_vector($bit_width_1 downto 0);
        cout   : out std_logic);
end ${instance_name}_add;

architecture synthesis of ${instance_name}_add is
begin

  process (a, b, cin)
    variable int_a, int_b : std_logic_vector($bit_width downto 0);
    variable int_result   : std_logic_vector($bit_width downto 0);
  begin
    int_a      := '0' & a;
    int_b      := '0' & b;

    int_result := int_a + int_b + cin;

    result     <= int_result($bit_width_1 downto 0);
    cout       <= int_result($bit_width);

  end process;

end synthesis;
FHM_DL_INSTANCE_default
}#default
else{
  print "false\n";
  exit (100);
}
# --- End of Adder

{
print <<FHM_DL_INSTANCE

--%
-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-- Module     : Arithmetic Logic Unit
-- Feature    : 
-- References : 
-- Author     : Designed by T.Morifuji (c)1997,1998.

-- Version : 1.1  : all test is ok.
-- Version : 1.2  : modified by Y.Yamane 2001/12/26

-- Comment : function table is followings.
--  +-----------+-------------+-------------+---------+
--  |   mode    |   cin = 0   |   cin = 1   |  flag   |
--  +-----------+-------------+-------------+---------+
--  | 4 3 2 1 0 |   result    |   result    | c z s v |
--  +-----------+-------------+-------------+---------+
--  | 0 0 0 0 0 | a           | a + 1       | * * * 0 | unsigned (c)
--  | 0 0 0 0 1 | a + b       | a + b + 1   | * * * 0 | unsigned (c)
--  | 0 0 0 1 0 | a - b - 1   | a - b       | * * * 0 | unsigned (c)
--  | 0 0 0 1 1 | a - 1       | a           | * * * 0 | unsigned (c)
--  | 0 0 1 0 0 | a           | a +] 1      | * * * 0 | unsigned clip
--  | 0 0 1 0 1 | a +] b      | a +] b +] 1 | * * * 0 | unsigned clip
--  | 0 0 1 1 0 | a -] b -] 1 | a -] b      | * * * 0 | unsigned clip
--  | 0 0 1 1 1 | a -] 1      | a           | * * * 0 | unsigned clip
--  | 0 1 0 0 0 | a           | a + 1       | * * * * | signed (v)
--  | 0 1 0 0 1 | a + b       | a + b + 1   | * * * * | signed (v)
--  | 0 1 0 1 0 | a - b - 1   | a - b       | * * * * | signed (v)
--  | 0 1 0 1 1 | a - 1       | a           | * * * * | signed (v)
--  | 0 1 1 0 0 | a           | a +] 1      | * * * * | signed clip
--  | 0 1 1 0 1 | a +] b      | a +] b +] 1 | * * * * | signed clip
--  | 0 1 1 1 0 | a -] b -] 1 | a -] b      | * * * * | signed clip
--  | 0 1 1 1 1 | a -] 1      | a           | * * * * | signed clip
--  | 1 0 0 0 0 |           a or b          | 0 * * 0 |
--  | 1 0 0 0 1 |          a xor b          | 0 * * 0 |
--  | 1 0 0 1 0 |          a and b          | 0 * * 0 |
--  | 1 0 0 1 1 |           not a           | 0 * * 0 |
--  | 1 0 1 0 0 |             | max(a, b)   | * * * 0 | unsigned
--  | 1 0 1 0 1 |             | min(a, b)   | * * * 0 | unsigned
--  | 1 0 1 1 0 |             | max(a, b)   | * * * * | signed
--  | 1 0 1 1 1 |             | min(a, b)   | * * * * | signed
--  | 1 1 0 0 0 |          a nor b          | 0 * * 0 |
--  | 1 1 0 0 1 |         a nxor b          | 0 * * 0 |
--  | 1 1 0 1 0 |         a nand b          | 0 * * 0 |
--  | 1 1 0 1 1 |             |             | 0 * * 0 |
--  | 1 1 1 0 0 |             |             | 0 * * * |
--  | 1 1 1 0 1 |             |             | 0 * * * |
--  | 1 1 1 1 0 |             |             | 0 * * * |
--  | 1 1 1 1 1 |             |             | 0 * * * |
--  +-----------+-------------+-------------+---------+
-- C is '1' when (carry-occurred or not-bollowed) and unsigned-mode else
--      '0';
-- V is '1' when overflowed and signed-mode else
--      '0';
-- S is equal to MSB of result;
-- Z is '1' when result = 0 else
--      '0';

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;
  use IEEE.std_logic_arith.all;

entity $instance_name is
  port (a, b 	: in std_logic_vector($bit_width_1 downto 0);
        cin     : in std_logic;
        mode 	: in std_logic_vector(4 downto 0);
        result 	: out std_logic_vector($bit_width_1 downto 0);
        flag 	: out std_logic_vector(3 downto 0) );
end $instance_name;

architecture synthesis of $instance_name is

  component ${instance_name}_add
    port (a, b 	 : in std_logic_vector($bit_width_1 downto 0);
          cin    : in std_logic;
          result : out std_logic_vector($bit_width_1 downto 0);
          cout 	 : out std_logic);
  end component;

  signal ain, bin             : std_logic_vector($bit_width_1 downto 0);
  signal sum                  : std_logic_vector($bit_width_1 downto 0);
  signal unsigned_max         : std_logic_vector($bit_width_1 downto 0);
  signal unsigned_min         : std_logic_vector($bit_width_1 downto 0);
  signal signed_max           : std_logic_vector($bit_width_1 downto 0);
  signal signed_min           : std_logic_vector($bit_width_1 downto 0);
  signal clipped_signed_sum   : std_logic_vector($bit_width_1 downto 0);
  signal clipped_unsigned_sum : std_logic_vector($bit_width_1 downto 0);
  signal clipped_sum          : std_logic_vector($bit_width_1 downto 0);
  signal tmp_cout             : std_logic;
  signal tmp_out              : std_logic_vector($bit_width_1 downto 0);
  signal pre_result           : std_logic_vector($bit_width_1 downto 0);
  signal V, C                 : std_logic;
  signal pre_pre_v            : std_logic;
  signal pre_v                : std_logic;
  signal unsigned_clipped     : std_logic;
  signal S, Z                 : std_logic;

  signal signed_max_value : std_logic_vector($bit_width_1 downto 0);
  signal signed_min_value : std_logic_vector($bit_width_1 downto 0);

begin

  --  input value of adder
  ain <= a;
  bin <= $zero when mode(1 downto 0) = "00"
                    and mode(4) = '0'          else -- a
         b     when mode(1 downto 0) = "01"
                    and mode(4) = '0'          else -- a + b
         not b when mode(1 downto 0) = "10"
                    or mode(4) = '1'           else -- a - b
         $one  when mode(1 downto 0) = "11"
                    and mode(4) = '0'          else -- a - 1
         $x_str;

  unsigned_clipped <= tmp_cout xor mode(1);

  clipped_unsigned_sum <= sum when unsigned_clipped = '0' else
                          $one when mode(1) = '0' else -- (+)
                          $zero;                        -- (-)

  signed_max_value($bit_width_1) <= '0';
  signed_max_value($bit_width_2 downto 0) <= conv_std_logic_vector(-1, $bit_width_1);
  signed_min_value($bit_width_1) <= '1';
  signed_min_value($bit_width_2 downto 0) <= conv_std_logic_vector(0, $bit_width_1);

  clipped_signed_sum <= sum when pre_pre_v = '0' else
                        signed_max_value  -- (+)
                           when sum($bit_width_1) = '1' else
                        signed_min_value; -- (-)

  clipped_sum <= sum when mode(2) = '0' else
                 clipped_unsigned_sum when mode(3) = '0' else
                 clipped_signed_sum;

  unsigned_max <= a when tmp_cout = '1' else
                  b;

  unsigned_min <= a when tmp_cout = '0' else
                  b;

  signed_max <= a when (a($bit_width_1) = '0' and b($bit_width_1) = '1') else
                b when (a($bit_width_1) = '1' and b($bit_width_1) = '0') else
                a when (tmp_cout = '1') else
                b;

  signed_min <= b when (a($bit_width_1) = '0' and b($bit_width_1) = '1') else
                a when (a($bit_width_1) = '1' and b($bit_width_1) = '0') else
                b when (tmp_cout = '1') else
                a;

  -- output
  tmp_out <= sum         when mode(2) = '0' else -- no clip
             clipped_sum when mode(2) = '1' else
             $x_str;

  S <= pre_result($bit_width_1);

  C <= tmp_cout         when mode(4 downto 2) /= "100"
                         and mode(4 downto 2) /= "110" else
       '0';

  Z <= '1' when pre_result = conv_std_logic_vector(0, $bit_width) else
       '0';

  pre_pre_v <= '1' when ((ain($bit_width_1)='0' and bin($bit_width_1) = '0'
                          and sum($bit_width_1) = '1' )
                      or (ain($bit_width_1)='1' and bin($bit_width_1) = '1'
                                       and sum($bit_width_1) = '0' )) else
               '0';

  pre_v <= '1' when mode(2) = '0' and pre_pre_v = '1' else
           '0';

  V <= pre_v     when mode(4 downto 2) = "010" else
       pre_pre_v when mode(4 downto 2) = "011"
               or mode(4 downto 1) = "1011" else
       '0';

  flag <= C & Z & S & V;

  pre_result <= tmp_out      when mode(4) = '0' else
               a or b        when mode(3 downto 0) = "0000" else
               a xor b       when mode(3 downto 0) = "0001" else
               a and b       when mode(3 downto 0) = "0010" else
               not a         when mode(3 downto 0) = "0011" else
               unsigned_max  when mode(3 downto 0) = "0100" else
               unsigned_min  when mode(3 downto 0) = "0101" else
               signed_max    when mode(3 downto 0) = "0110" else
               signed_min    when mode(3 downto 0) = "0111" else
               not (a or b)  when mode(3 downto 0) = "1000" else
               not (a xor b) when mode(3 downto 0) = "1001" else
               not (a and b) when mode(3 downto 0) = "1010" else
               $x_str;

  result <= pre_result;

  -- port mapping add
  a0 : ${instance_name}_add
    port map (ain, bin, cin,
              sum, tmp_cout);

end synthesis;
FHM_DL_INSTANCE
}

exit (0);
          ]]>
        </script>
      </instance>

      <entity></entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>

      <synthesis>
        <parameter></parameter>
        <synthesis_script>
          <script>
            <![CDATA[
#!/usr/bin/perl
# this script generates alu synthesis script in synthesis level
# parameter : instance_name priority bit_width

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name priority bit_width algorithm\n";
    exit (100);
}


$instance_name = $ARGV[0];
$priority      = $ARGV[1];
$bit_width     = $ARGV[2];
$algorithm     = $ARGV[3];


if ($priority eq "area"){
  $priority_const = "set_max_area 0";
}
elsif ($priority eq "performance"){
  $priority_const = "set_max_delay -from all_inputs() -to all_outputs() 0";
}
elsif ($priority eq "power"){
  $priority_const = "";
}
elsif ($priority eq "none"){
  $priority_const = "";
}
else{
  print "Not supported priority\n";
  exit (100);
}

{
print <<FHM_DL_SCRIPT
hdlin_auto_save_templates = TRUE

analyze -f vhdl $instance_name.vhd

elaborate $instance_name
uniquify

$priority_const

compile 

write -hierarchy -output $instance_name.db

report_area
report_timing

quit
FHM_DL_SCRIPT
}
exit (0);
            ]]>
          </script>
        </synthesis_script>
      </synthesis>
    </design>

    <design>
      <design_lang> Verilog </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates instance for adder in synthesis level
# parameter : instance_name bit_width algorithm


if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width algorithm\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$algorithm     = $ARGV[2];

$bit_width_1 = $bit_width - 1;
$bit_width_2 = $bit_width - 2;

$zero = "0" x $bit_width;
$zero = "\"" . $zero . "\"";
$one  = "1" x $bit_width;
$one  = "\"" . $one . "\"";

$ones = "\"" . "1" x $bit_width . "\"";

$x_str = "X" x $bit_width;
$x_str = "\"" . $x_str . "\"";

if ("$algorithm" eq "default"){
   print <<FHM_DL_INSTANCE_default
// Module     : N-bit Adder with operator

module ${instance_name}_add (
  a     ,
  b     ,
  cin   ,
  result,
  cout  );
\n
input  [${bit_width_1}:0] a     ;
input  [${bit_width_1}:0] b     ;
input         cin   ;
output [${bit_width_1}:0] result;
output        cout  ;
\n 
assign {cout, result} = a + b + cin;
\n
endmodule
\n
FHM_DL_INSTANCE_default
}#default
else{
  print "false\n";
  exit(100);
}
# ---- End of Adder

{
print <<FHM_DL_INSTANCE
//%
//
//  	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// Module     : Arithmetic Logic Unit
// Feature    : 
// References : 
// Author     : Designed by T.Morifuji (c)1997,1998.

// Version : 1.1  : all test is ok.
// Version : 1.2  : modified by Y.Yamane 2001/12/26

// Comment : function table is followings.
//  +-----------+-------------+-------------+---------+
//  |   mode    |   cin = 0   |   cin = 1   |  flag   |
//  +-----------+-------------+-------------+---------+
//  | 4 3 2 1 0 |   result    |   result    | c z s v |
//  +-----------+-------------+-------------+---------+
//  | 0 0 0 0 0 | a           | a + 1       | * * * 0 | unsigned (c)
//  | 0 0 0 0 1 | a + b       | a + b + 1   | * * * 0 | unsigned (c)
//  | 0 0 0 1 0 | a - b - 1   | a - b       | * * * 0 | unsigned (c)
//  | 0 0 0 1 1 | a - 1       | a           | * * * 0 | unsigned (c)
//  | 0 0 1 0 0 | a           | a +] 1      | * * * 0 | unsigned clip
//  | 0 0 1 0 1 | a +] b      | a +] b +] 1 | * * * 0 | unsigned clip
//  | 0 0 1 1 0 | a -] b -] 1 | a -] b      | * * * 0 | unsigned clip
//  | 0 0 1 1 1 | a -] 1      | a           | * * * 0 | unsigned clip
//  | 0 1 0 0 0 | a           | a + 1       | * * * * | signed (v)
//  | 0 1 0 0 1 | a + b       | a + b + 1   | * * * * | signed (v)
//  | 0 1 0 1 0 | a - b - 1   | a - b       | * * * * | signed (v)
//  | 0 1 0 1 1 | a - 1       | a           | * * * * | signed (v)
//  | 0 1 1 0 0 | a           | a +] 1      | * * * * | signed clip
//  | 0 1 1 0 1 | a +] b      | a +] b +] 1 | * * * * | signed clip
//  | 0 1 1 1 0 | a -] b -] 1 | a -] b      | * * * * | signed clip
//  | 0 1 1 1 1 | a -] 1      | a           | * * * * | signed clip
//  | 1 0 0 0 0 |           a or b          | 0 * * 0 |
//  | 1 0 0 0 1 |          a xor b          | 0 * * 0 |
//  | 1 0 0 1 0 |          a and b          | 0 * * 0 |
//  | 1 0 0 1 1 |           not a           | 0 * * 0 |
//  | 1 0 1 0 0 |             | max(a, b)   | * * * 0 | unsigned
//  | 1 0 1 0 1 |             | min(a, b)   | * * * 0 | unsigned
//  | 1 0 1 1 0 |             | max(a, b)   | * * * * | signed
//  | 1 0 1 1 1 |             | min(a, b)   | * * * * | signed
//  | 1 1 0 0 0 |          a nor b          | 0 * * 0 |
//  | 1 1 0 0 1 |         a nxor b          | 0 * * 0 |
//  | 1 1 0 1 0 |         a nand b          | 0 * * 0 |
//  | 1 1 0 1 1 |             |             | 0 * * 0 |
//  | 1 1 1 0 0 |             |             | 0 * * * |
//  | 1 1 1 0 1 |             |             | 0 * * * |
//  | 1 1 1 1 0 |             |             | 0 * * * |
//  | 1 1 1 1 1 |             |             | 0 * * * |
//  +-----------+-------------+-------------+---------+
// C is '1' when (carry-occurred or not-bollowed) and unsigned-mode
//     else
//      '0';
// V is '1' when overflowed and signed-mode else
//      '0';
// S is equal to MSB of result;
// Z is '1' when result = 0 else
//      '0';

module $instance_name (
  a     ,
  b     ,
  cin   ,
  mode  , 
  result,
  flag  );
\n
input  [${bit_width_1}:0] a     ;
input  [${bit_width_1}:0] b     ;
input         cin   ;
input  [ 4:0] mode  ;
output [${bit_width_1}:0] result;
output [ 3:0] flag  ;
\n
wire [${bit_width_1}:0] ain, bin            ;
wire [${bit_width_1}:0] sum                 ;
wire [${bit_width_1}:0] unsigned_max        ;
wire [${bit_width_1}:0] unsigned_min        ;
wire [${bit_width_1}:0] signed_max          ;
wire [${bit_width_1}:0] signed_min          ;
wire [${bit_width_1}:0] clipped_signed_sum  ;
wire [${bit_width_1}:0] clipped_unsigned_sum;
wire [${bit_width_1}:0] clipped_sum         ;
wire        tmp_cout            ;
wire [${bit_width_1}:0] tmp_out             ;
wire [${bit_width_1}:0] pre_result          ;
wire        V, C                ;
wire        pre_pre_v           ;
wire        pre_v               ;
wire        unsigned_clipped    ;
wire        S, Z                ;
\n
wire [${bit_width_1}:0] signed_max_value    ;
wire [${bit_width_1}:0] signed_min_value    ;
\n
//  input value of adder
assign ain = a ;
assign bin = (mode[1:0] == 2'b00 && mode[4] == 1'b0) ? {${bit_width}{1'b0}} : // a 
             (mode[1:0] == 2'b01 && mode[4] == 1'b0) ? b            : // a + b
             (mode[1:0] == 2'b10 || mode[4] == 1'b1) ? ~b           : // a - b
             (mode[1:0] == 2'b11 && mode[4] == 1'b0) ? {${bit_width}{1'b1}} : // a - 1
                                                       {${bit_width}{1'bX}} ;
\n
assign unsigned_clipped = tmp_cout ^ mode[1];
\n
assign clipped_unsigned_sum = (unsigned_clipped == 1'b0) ? sum :
                              (mode[1] == 1'b0) ? {${bit_width}{1'b1}} : // (+)
                                                  {${bit_width}{1'b0}} ; // (-)
\n
assign signed_max_value[$bit_width_1]   = 1'b0  ;
assign signed_max_value[${bit_width_2}:0] = \{${bit_width_1}\{1'b1}} ;
assign signed_min_value[$bit_width_1]   = 1'b1  ;
assign signed_min_value[${bit_width_2}:0] = \{${bit_width_1}\{1'b0}} ;
\n
assign clipped_signed_sum = (pre_pre_v == 1'b0) ? sum :
                            (sum[$bit_width_1] == 1'b1) ? signed_max_value : // (+)
                                                          signed_min_value ; // (-)
\n
assign clipped_sum = (mode[2] == 1'b0) ? sum :
                     (mode[3] == 1'b0) ? clipped_unsigned_sum :
                                         clipped_signed_sum   ;
\n
assign unsigned_max = (tmp_cout == 1'b1) ? a : b ;
\n
assign unsigned_min = (tmp_cout == 1'b0) ? a : b ;
\n
assign signed_max = (a[$bit_width_1] == 1'b0 && b[$bit_width_1] == 1'b1) ? a :
                    (a[$bit_width_1] == 1'b1 && b[$bit_width_1] == 1'b0) ? b :
                    (tmp_cout == 1'b1) ? a : b ;
\n
assign signed_min = (a[$bit_width_1] == 1'b0 && b[$bit_width_1] == 1'b1) ? b :
                    (a[$bit_width_1] == 1'b1 && b[$bit_width_1] == 1'b0) ? a :
                    (tmp_cout == 1'b1) ? b : a ;
\n
// output
assign tmp_out = (mode[2] == 1'b0) ? sum : // no clip
                 (mode[2] == 1'b1) ? clipped_sum : {${bit_width}{1'bX}} ;
\n
assign S = pre_result[$bit_width_1] ;
\n
assign C = (mode[4:2] != 3'b100 && mode[4:2] != 3'b110) ? tmp_cout : 1'b0 ;
\n
assign Z = (pre_result == {${bit_width}{1'b0}}) ? 1'b1 : 1'b0 ;
\n
assign pre_pre_v = ((ain[$bit_width_1] == 1'b0 && bin[$bit_width_1] == 1'b0 && sum[$bit_width_1] == 1'b1) ||
                    (ain[$bit_width_1] == 1'b1 && bin[$bit_width_1] == 1'b1 && sum[$bit_width_1] == 1'b0)) ? 1'b1 : 1'b0 ;
\n
assign pre_v = (mode[2] == 1'b0 && pre_pre_v == 1'b1) ? 1'b1 : 1'b0 ;
\n
assign V = (mode[4:2] == 3'b010) ? pre_v :
           (mode[4:2] == 3'b011 || mode[4:1] == 4'b1011) ? pre_pre_v : 1'b0 ;
\n
assign flag = {C, Z, S, V};
\n
assign pre_result = (mode[4] == 1'b0) ? tmp_out :
                    (mode[3:0] == 4'b0000) ? a | b :
                    (mode[3:0] == 4'b0001) ? a ^ b :
                    (mode[3:0] == 4'b0010) ? a & b :
                    (mode[3:0] == 4'b0011) ? ~a :
                    (mode[3:0] == 4'b0100) ? unsigned_max :
                    (mode[3:0] == 4'b0101) ? unsigned_min :
                    (mode[3:0] == 4'b0110) ? signed_max :
                    (mode[3:0] == 4'b0111) ? signed_min :
                    (mode[3:0] == 4'b1000) ? ~(a | b) :
                    (mode[3:0] == 4'b1001) ? ~(a ^ b) :
                    (mode[3:0] == 4'b1010) ? ~(a & b) : {${bit_width}{1'bX}};
\n
assign result = pre_result ;
\n
// port mapping add
${instance_name}_add A0 (
  .a(ain),
  .b(bin),
  .cin(cin),
  .result(sum),
  .cout(tmp_cout));
\n
endmodule
\n
FHM_DL_INSTANCE
}

exit(0);
          ]]>
        </script>
      </instance>

      <entity></entity>

      <testvector></testvector>

      <synthesis></synthesis>
    </design>

    <design>
      <design_lang> SystemC Header </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates alu instance in behavior level
# parameter : name_space instance_name bit_width

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script name_space instance_name bit_width algorithm\n";
    exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];
$algorithm     = $ARGV[3];

$bit_width_1 = $bit_width - 1;

if($bit_width > 64) {
    $data_type = "sc_dt::sc_biguint<" . $bit_width . ">";
} else {
    $data_type = "sc_dt::sc_uint<" . $bit_width . ">";
}

$macro = "__" . uc($name_space) . "_" . uc($instance_name) . "_H__";

{
print <<FHM_DL_INSTANCE
#ifndef $macro
#define $macro 1

// Module     : Arithmetic Logic Unit
// Feature    : 
// References : 
// Author     : Designed by T.Morifuji (c)1997,1998.
\n
// Version : 1.3  : Modified by Y.Yamane 2002/01/15 Tue
\n
// Comment : function table is followings.
//  +-----------+-------------+-------------+---------+
//  |   mode    |   cin = 0   |   cin = 1   |  flag   |
//  +-----------+-------------+-------------+---------+
//  | 4 3 2 1 0 |   result    |   result    | c z s v |
//  +-----------+-------------+-------------+---------+
//  | 0 0 0 0 0 | a           | a + 1       | * * * 0 | unsigned (c)
//  | 0 0 0 0 1 | a + b       | a + b + 1   | * * * 0 | unsigned (c)
//  | 0 0 0 1 0 | a - b - 1   | a - b       | * * * 0 | unsigned (c)
//  | 0 0 0 1 1 | a - 1       | a           | * * * 0 | unsigned (c)
//  | 0 0 1 0 0 | a           | a +] 1      | * * * 0 | unsigned clip
//  | 0 0 1 0 1 | a +] b      | a +] b +] 1 | * * * 0 | unsigned clip
//  | 0 0 1 1 0 | a -] b -] 1 | a -] b      | * * * 0 | unsigned clip
//  | 0 0 1 1 1 | a -] 1      | a           | * * * 0 | unsigned clip
//  | 0 1 0 0 0 | a           | a + 1       | * * * * | signed (v)
//  | 0 1 0 0 1 | a + b       | a + b + 1   | * * * * | signed (v)
//  | 0 1 0 1 0 | a - b - 1   | a - b       | * * * * | signed (v)
//  | 0 1 0 1 1 | a - 1       | a           | * * * * | signed (v)
//  | 0 1 1 0 0 | a           | a +] 1      | * * * * | signed clip
//  | 0 1 1 0 1 | a +] b      | a +] b +] 1 | * * * * | signed clip
//  | 0 1 1 1 0 | a -] b -] 1 | a -] b      | * * * * | signed clip
//  | 0 1 1 1 1 | a -] 1      | a           | * * * * | signed clip
//  | 1 0 0 0 0 |           a or b          | 0 * * 0 |
//  | 1 0 0 0 1 |          a xor b          | 0 * * 0 |
//  | 1 0 0 1 0 |          a and b          | 0 * * 0 |
//  | 1 0 0 1 1 |           not a           | 0 * * 0 |
//  | 1 0 1 0 0 |             | max(a, b)   | * * * 0 | unsigned
//  | 1 0 1 0 1 |             | min(a, b)   | * * * 0 | unsigned
//  | 1 0 1 1 0 |             | max(a, b)   | * * * * | signed
//  | 1 0 1 1 1 |             | min(a, b)   | * * * * | signed
//  | 1 1 0 0 0 |          a nor b          | 0 * * 0 |
//  | 1 1 0 0 1 |         a nxor b          | 0 * * 0 |
//  | 1 1 0 1 0 |         a nand b          | 0 * * 0 |
//  | 1 1 0 1 1 |             |             | 0 * * * |
//  | 1 1 1 0 0 |             |             | 0 * * * |
//  | 1 1 1 0 1 |             |             | 0 * * * |
//  | 1 1 1 1 0 |             |             | 0 * * * |
//  | 1 1 1 1 1 |             |             | 0 * * * |
//  +-----------+-------------+-------------+---------+
// C is '1' when (carry-occurred or not-bollowed) and unsigned-mode else
//      '0';
// V is '1' when overflowed and signed-mode else
//      '0';
// S is equal to MSB of result;
// Z is '1' when result = 0 else
//      '0';

// Functionality : behavior level
//  port
//   a, b   : datas
//   cin    : carry in
//   mode   : control (refer to the above table)
//   result : result of calculation
//   flag   : flag of result (refer to the above table)

#include <systemc>

namespace ${name_space} {
  SC_MODULE($instance_name) {
    sc_core::sc_in< $data_type > a, b;
    sc_core::sc_in< bool > cin;
    sc_core::sc_in< sc_dt::sc_uint<5> > mode;
    sc_core::sc_out< $data_type > result;
    sc_core::sc_out< sc_dt::sc_uint<4> > flag;
  
    SC_CTOR($instance_name) :
      a("a"), b("b"), cin("cin"),
      mode("mode"), result("result"), flag("flag")
    {
      SC_METHOD(process);
      sensitive << a << b << cin << mode;
    }
  
    void process();
  };
};

#endif // $macro
FHM_DL_INSTANCE
}
exit(0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <design>
      <design_lang> SystemC Program </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates alu instance in behavior level
# parameter : name_space instance_name bit_width

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script name_space instance_name bit_width algorithm\n";
    exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];
$algorithm     = $ARGV[3];

$bit_width_1 = $bit_width - 1;

if($bit_width > 64) {
    $data_type = "sc_dt::sc_biguint<" . $bit_width . ">";
} else {
    $data_type = "sc_dt::sc_uint<" . $bit_width . ">";
}

if($bit_width + 1 > 64) {
    $tmp_type = "sc_dt::sc_biguint<" . ($bit_width + 1) . ">";
} else {
    $tmp_type = "sc_dt::sc_uint<" . ($bit_width + 1) . ">";
}

$one  = "~ ${data_type}(0)";

{
print <<FHM_DL_INSTANCE
#include "$instance_name.h"

// Module     : Arithmetic Logic Unit
// Feature    : 
// References : 
// Author     : Designed by T.Morifuji (c)1997,1998.
\n
// Version : 1.3  : Modified by Y.Yamane 2002/01/15 Tue
\n
// Comment : function table is followings.
//  +-----------+-------------+-------------+---------+
//  |   mode    |   cin = 0   |   cin = 1   |  flag   |
//  +-----------+-------------+-------------+---------+
//  | 4 3 2 1 0 |   result    |   result    | c z s v |
//  +-----------+-------------+-------------+---------+
//  | 0 0 0 0 0 | a           | a + 1       | * * * 0 | unsigned (c)
//  | 0 0 0 0 1 | a + b       | a + b + 1   | * * * 0 | unsigned (c)
//  | 0 0 0 1 0 | a - b - 1   | a - b       | * * * 0 | unsigned (c)
//  | 0 0 0 1 1 | a - 1       | a           | * * * 0 | unsigned (c)
//  | 0 0 1 0 0 | a           | a +] 1      | * * * 0 | unsigned clip
//  | 0 0 1 0 1 | a +] b      | a +] b +] 1 | * * * 0 | unsigned clip
//  | 0 0 1 1 0 | a -] b -] 1 | a -] b      | * * * 0 | unsigned clip
//  | 0 0 1 1 1 | a -] 1      | a           | * * * 0 | unsigned clip
//  | 0 1 0 0 0 | a           | a + 1       | * * * * | signed (v)
//  | 0 1 0 0 1 | a + b       | a + b + 1   | * * * * | signed (v)
//  | 0 1 0 1 0 | a - b - 1   | a - b       | * * * * | signed (v)
//  | 0 1 0 1 1 | a - 1       | a           | * * * * | signed (v)
//  | 0 1 1 0 0 | a           | a +] 1      | * * * * | signed clip
//  | 0 1 1 0 1 | a +] b      | a +] b +] 1 | * * * * | signed clip
//  | 0 1 1 1 0 | a -] b -] 1 | a -] b      | * * * * | signed clip
//  | 0 1 1 1 1 | a -] 1      | a           | * * * * | signed clip
//  | 1 0 0 0 0 |           a or b          | 0 * * 0 |
//  | 1 0 0 0 1 |          a xor b          | 0 * * 0 |
//  | 1 0 0 1 0 |          a and b          | 0 * * 0 |
//  | 1 0 0 1 1 |           not a           | 0 * * 0 |
//  | 1 0 1 0 0 |             | max(a, b)   | * * * 0 | unsigned
//  | 1 0 1 0 1 |             | min(a, b)   | * * * 0 | unsigned
//  | 1 0 1 1 0 |             | max(a, b)   | * * * * | signed
//  | 1 0 1 1 1 |             | min(a, b)   | * * * * | signed
//  | 1 1 0 0 0 |          a nor b          | 0 * * 0 |
//  | 1 1 0 0 1 |         a nxor b          | 0 * * 0 |
//  | 1 1 0 1 0 |         a nand b          | 0 * * 0 |
//  | 1 1 0 1 1 |             |             | 0 * * * |
//  | 1 1 1 0 0 |             |             | 0 * * * |
//  | 1 1 1 0 1 |             |             | 0 * * * |
//  | 1 1 1 1 0 |             |             | 0 * * * |
//  | 1 1 1 1 1 |             |             | 0 * * * |
//  +-----------+-------------+-------------+---------+
// C is '1' when (carry-occurred or not-bollowed) and unsigned-mode else
//      '0';
// V is '1' when overflowed and signed-mode else
//      '0';
// S is equal to MSB of result;
// Z is '1' when result = 0 else
//      '0';

// Functionality : behavior level
//  port
//   a, b   : datas
//   cin    : carry in
//   mode   : control (refer to the above table)
//   result : result of calculation
//   flag   : flag of result (refer to the above table)


static void ${instance_name}_add( 
  const $data_type &a,
  const $data_type &b,
  const bool &cin, 
  $data_type &result,
  sc_dt::sc_uint<1> &cout )
{
  $tmp_type a_tmp(a);
  a_tmp += b;
  a_tmp += cin;
  result = a_tmp($bit_width - 1, 0);
  cout = a_tmp[$bit_width];
}

void ${name_space}::${instance_name}::process()
{
  $data_type pre_result, s_max, s_min;
  sc_dt::sc_uint<1> C, Z, S, V;

  $data_type tmp_a = a.read(), tmp_b = b.read();
  bool tmp_cin = cin.read();
  sc_dt::sc_uint<5> tmp_mode = mode.read();

  if( tmp_mode == 0 ) {
    ${instance_name}_add( tmp_a, 0, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 1 ) {
    ${instance_name}_add( tmp_a, tmp_b, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 2 ) {
    ${instance_name}_add( tmp_a, ~tmp_b, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 3 ) {
    ${instance_name}_add( tmp_a, $one, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 4 ) {
    ${instance_name}_add( tmp_a, 0, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 5 ) {
    ${instance_name}_add( tmp_a, tmp_b, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 6 ) {
    ${instance_name}_add( tmp_a, ~tmp_b, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 7 ) {
    ${instance_name}_add( tmp_a, $one, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 8 ) {
    ${instance_name}_add( tmp_a, 0, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 9 ) {
    ${instance_name}_add( tmp_a, tmp_b, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 10 ) {
    ${instance_name}_add( tmp_a, ~tmp_b, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 11 ) {
    ${instance_name}_add( tmp_a, $one, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 12 ) {
    ${instance_name}_add( tmp_a, 0, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 13 ) {
    ${instance_name}_add( tmp_a, tmp_b, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 14 ) {
    ${instance_name}_add( tmp_a, ~tmp_b, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 15 ) {
    ${instance_name}_add( tmp_a, $one, tmp_cin, pre_result, C);
  } else if ( tmp_mode == 16 ) {
    pre_result = tmp_a | tmp_b;
    C = 0;
  } else if ( tmp_mode == 17 ) {
    pre_result = tmp_a ^ tmp_b;
    C = 0;
  } else if ( tmp_mode == 18 ) {
    pre_result = tmp_a & tmp_b;
    C = 0;
  } else if ( tmp_mode == 19 ) {
    pre_result = ~tmp_a;
    C = 0;
  } else if ( tmp_mode == 20 ) {
    ${instance_name}_add( tmp_a,~tmp_b, 1, pre_result, C);
  } else if ( tmp_mode == 21 ) {
    ${instance_name}_add( tmp_a, ~tmp_b, 1, pre_result, C);
  } else if ( tmp_mode == 22 ) {
    ${instance_name}_add( tmp_a, ~tmp_b, 1, pre_result, C);
  } else if ( tmp_mode == 23 ) {
    ${instance_name}_add( tmp_a, ~tmp_b, 1, pre_result, C);
  } else if ( tmp_mode == 24 ) {
    pre_result = ~( tmp_a | tmp_b );
    C = 0;
  } else if ( tmp_mode == 25 ) {
    pre_result = ~ ( tmp_a ^ tmp_b );
    C = 0;
  } else if ( tmp_mode == 26 ) {
    pre_result = ~ ( tmp_a & tmp_b );
    C = 0;
  } else {
    pre_result = 0;
    C = 1;
  }

  if ( tmp_mode(4, 2) == 4 || tmp_mode(4, 3) == 3 )
    C = 0;

  V = 0;
  if ( tmp_mode == 8 || tmp_mode == 12 ) {
    if ( tmp_a[$bit_width_1] == 0 && pre_result[$bit_width_1] == 1 )
      V = 1;
  } else if ( tmp_mode == 9 || tmp_mode == 13 ) {
    if (( tmp_a[$bit_width_1] == 0 && tmp_b[$bit_width_1] == 0
              && pre_result[$bit_width_1] == 1 )
     || ( tmp_a[$bit_width_1] == 1 && tmp_b[$bit_width_1] == 1
              && pre_result[$bit_width_1] == 0 )) {
      V = 1;
    }
  } else if ( ( tmp_mode == 10 || tmp_mode == 14 )
           || ( tmp_mode == 22 || tmp_mode == 23 ) ) {
    if (( tmp_a[$bit_width_1] == 0 && tmp_b[$bit_width_1] == 1
              && pre_result[$bit_width_1] == 1 )
     || ( tmp_a[$bit_width_1] == 1 && tmp_b[$bit_width_1] == 0
              && pre_result[$bit_width_1] == 0 )) {
      V = 1;
    }
  } else if ( tmp_mode == 11 || tmp_mode == 15 ) {
    if ( tmp_a[$bit_width_1] == 1 && pre_result[$bit_width_1] == 0 )
      V = 1;
  } else {
    V = 0;
  }

  if ( tmp_a[$bit_width_1] == 0 && tmp_b[$bit_width_1] == 1 )
    s_max = tmp_a;
  else if ( tmp_a[$bit_width_1] == 1 && tmp_b[$bit_width_1] == 0 )
    s_max = tmp_b;
  else if ( tmp_a[$bit_width_1] == 0 && C == 1 )
    s_max = tmp_a;
  else
    s_max = tmp_b;

  if ( tmp_a[$bit_width_1] == 0 && tmp_b[$bit_width_1] == 1 )
    s_min = b;
  else if ( tmp_a[$bit_width_1] == 1 && tmp_b[$bit_width_1] == 0 )
    s_min = a;
  else if ( tmp_a[$bit_width_1] == 0 && C == 1 )
    s_min = b;
  else
    s_min = a;

  if ( tmp_mode(3, 2) == 1 ) {
    if ( C == 1 && tmp_mode[1] == 0 )
      pre_result = $one;
    else if ( C == 0 && tmp_mode[1] == 1)
      pre_result = 0;
  } else if ( tmp_mode(3, 2) == 3 && V == 1 ) {
    if ( pre_result[$bit_width_1] == 1) {
      pre_result[$bit_width_1] = 0;
      pre_result($bit_width_1 - 1, 0) = -1;
    } else {
      pre_result[$bit_width_1] = 1;
      pre_result($bit_width_1 - 1, 0) = 0;
    }
  }

  if ( tmp_mode(4, 1) == 10 ) {
    if ((C == 1 && tmp_mode[0] == 0) || (C == 0 && tmp_mode[0] == 1))
      pre_result = tmp_a;
    else if ((C == 1 && tmp_mode[0] == 1) || (C == 0 && tmp_mode[0] == 0))
      pre_result = tmp_b;
  }

  if ( tmp_mode(4, 1) == 11 ) {
    if (( tmp_a[$bit_width_1] == 0 && tmp_b[$bit_width_1] == 1
         && tmp_mode[0] == 0) 
     || ( tmp_a[$bit_width_1] == 1 && tmp_b[$bit_width_1] == 0
         && tmp_mode[0] == 1))
      pre_result = tmp_a;
    else if (( tmp_a[$bit_width_1] == 1 && tmp_b[$bit_width_1] == 0
           && tmp_mode[0] == 0)
          || ( tmp_a[$bit_width_1] == 0 && tmp_b[$bit_width_1] == 1
           && tmp_mode[0] == 1))
      pre_result = tmp_b;
    else if ((C == 1 && tmp_mode[0] == 0)
          || (C == 0 && tmp_mode[0] == 1))
      pre_result = tmp_a;
    else if ((C == 1 && tmp_mode[0] == 1)
          || (C == 0 && tmp_mode[0] == 0))
      pre_result = tmp_b;
  }

  if ( pre_result == 0 )
    Z = 1;
  else
    Z = 0;

  S = pre_result[$bit_width_1];

  result.write( pre_result );
  flag.write( (C , Z , S , V ) );
}
FHM_DL_INSTANCE
}

exit(0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <estimation>
      <estimation_data>
        <library name="OSAKA">

          <est_type name="shape">
            <est_index name="area">
              <unit> mm2 </unit>
              <translate>
                <translate_value key="gate"> 4201.68 </translate_value>
                <translate_value key="mm2">  1 </translate_value>
              </translate>

              <parameters name="default">
                <max>
                  <data bit_width="4"> 0.13935300260848 </data>
                  <data bit_width="8"> 0.237479093362655 </data>
                  <data bit_width="16"> 0.499193691094991 </data>
                  <data bit_width="32"> 0.987219277051084 </data>
                  <data bit_width="128"> 4.62417990399078 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.113589963300394 </data>
                  <data bit_width="8"> 0.197268678956989 </data>
                  <data bit_width="16"> 0.397879236400678 </data>
                  <data bit_width="32"> 0.755690911016546 </data>
                  <data bit_width="128"> 3.6908162701586 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.113589963300394 </data>
                    <data bit_width="8"> 0.197268678956989 </data>
                    <data bit_width="16"> 0.41874581429333 </data>
                    <data bit_width="32"> 0.782818615410978 </data>
                    <data bit_width="128"> 3.6908162701586 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.136427290036366 </data>
                    <data bit_width="8"> 0.209247283229565 </data>
                    <data bit_width="16"> 0.397879236400678 </data>
                    <data bit_width="32"> 0.755690911016546 </data>
                    <data bit_width="128"> 4.62417990399078 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.13935300260848 </data>
                    <data bit_width="8"> 0.237479093362655 </data>
                    <data bit_width="16"> 0.499193691094991 </data>
                    <data bit_width="32"> 0.987219277051084 </data>
                    <data bit_width="128"> 4.51300041745207 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>

            <est_index name="aspect_ratio">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="height">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="width">
              <!-- Dummy yet -->
            </est_index>
          </est_type>

          <est_type name="timing">
            <est_index name="delay">
              <unit> ns </unit>

              <parameters name="default">
                <max>
                  <data bit_width="4"> 9.15 </data>
                  <data bit_width="8"> 12.25 </data>
                  <data bit_width="16"> 18.08 </data>
                  <data bit_width="32"> 31.02 </data>
                  <data bit_width="128"> 100.10 </data>
                </max>
                <min>
                  <data bit_width="4"> 4.84 </data>
                  <data bit_width="8"> 7.60 </data>
                  <data bit_width="16"> 11.66 </data>
                  <data bit_width="32"> 19.65 </data>
                  <data bit_width="128"> 70.00 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 8.13 </data>
                    <data bit_width="8"> 10.29 </data>
                    <data bit_width="16"> 14.77 </data>
                    <data bit_width="32"> 23.42 </data>
                    <data bit_width="128"> 76.03 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 4.84 </data>
                    <data bit_width="8"> 7.60 </data>
                    <data bit_width="16"> 11.66 </data>
                    <data bit_width="32"> 19.65 </data>
                    <data bit_width="128"> 70.00 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 9.15 </data>
                    <data bit_width="8"> 12.25 </data>
                    <data bit_width="16"> 18.08 </data>
                    <data bit_width="32"> 31.02 </data>
                    <data bit_width="128"> 100.10 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>

            <est_index name="delay_fullpath">
              <unit> ns </unit>

              <parameters name="default">
                <max>
                  <data bit_width="4">
                    path	 a	 result	 4.60
                    path	 b	 result	 4.84
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 7.52
                    path	 b	 result	 8.12
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 10.95
                    path	 b	 result	 11.74
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 18.41
                    path	 b	 result	 19.17
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 result	 4.60
                    path	 b	 result	 4.84
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 7.52
                    path	 b	 result	 8.12
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 10.95
                    path	 b	 result	 11.74
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 18.41
                    path	 b	 result	 19.17
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 result	 4.48
                      path	 b	 result	 5.27
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 7.02
                      path	 b	 result	 8.05
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 11.16
                      path	 b	 result	 11.99
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 18.55
                      path	 b	 result	 19.54
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 result	 2.34
                      path	 b	 result	 2.34
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 2.19
                      path	 b	 result	 2.31
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 2.67
                      path	 b	 result	 2.76
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 2.96
                      path	 b	 result	 3.01
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 result	 4.60
                      path	 b	 result	 4.84
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 7.52
                      path	 b	 result	 8.12
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 10.95
                      path	 b	 result	 11.74
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 18.41
                      path	 b	 result	 19.17
                    </data>
                  </priority>
                </typ>
              </parameters>

            </est_index>
          </est_type>

          <est_type name="power">
            <est_index name="static_power">
              <unit> mW </unit>
              <parameters name="default">
                <max>
                  <data bit_width="4"> 54.3717 </data>
                  <data bit_width="8"> 87.0715 </data>
                  <data bit_width="16"> 164.5019 </data>
                  <data bit_width="32"> 302.4174 </data>
                  <data bit_width="128"> 1565.9 </data>
                </max>
                <min>
                  <data bit_width="4"> 40.3143 </data>
                  <data bit_width="8"> 64.8514 </data>
                  <data bit_width="16"> 139.7683 </data>
                  <data bit_width="32"> 266.0890 </data>
                  <data bit_width="128"> 1190.2 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 45.2199 </data>
                    <data bit_width="8"> 79.9842 </data>
                    <data bit_width="16"> 164.5019 </data>
                    <data bit_width="32"> 302.4174 </data>
                    <data bit_width="128"> 1311.8 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 54.3717 </data>
                    <data bit_width="8"> 87.0715 </data>
                    <data bit_width="16"> 154.2068 </data>
                    <data bit_width="32"> 266.0890 </data>
                    <data bit_width="128"> 1565.9 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 40.3143 </data>
                    <data bit_width="8"> 64.8514 </data>
                    <data bit_width="16"> 139.7683 </data>
                    <data bit_width="32"> 267.5416 </data>
                    <data bit_width="128"> 1190.2 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>
          </est_type>

          <est_type name="function_cycle">
            <unit> cycle </unit>

            <est_index name="cycle">
              <parameters name="default">
                <function name="add">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="addu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="addi">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="addiu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cadd">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="caddu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="caddi">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="caddiu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="sub">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="subu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="subd">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="subdu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csub">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csubu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csubd">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csubdu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="inc">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="incu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cinc">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cincu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="dec">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="decu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cdec">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cdecu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="not">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="and">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="or">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="xor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="nor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="nxor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="nand">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmp">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpz">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpzu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="max">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="maxu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="min">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="minu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
              </parameters>
            </est_index>

            <est_index name="latency">

              <parameters name="default">
                <function name="add">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="addu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="addi">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="addiu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cadd">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="caddu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="caddi">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="caddiu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="sub">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="subu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="subd">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="subdu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csub">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csubu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csubd">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csubdu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="inc">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="incu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cinc">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cincu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="dec">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="decu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cdec">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cdecu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="not">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="and">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="or">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="xor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="nor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="nxor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="nand">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmp">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpz">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpzu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="max">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="maxu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="min">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="minu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
              </parameters>
            </est_index>

            <est_index name="throughput">
              <parameters name="default">
                <function name="add">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="addu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="addi">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="addiu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cadd">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="caddu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="caddi">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="caddiu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="sub">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="subu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="subd">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="subdu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csub">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csubu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csubd">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csubdu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="inc">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="incu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cinc">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cincu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="dec">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="decu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cdec">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cdecu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="not">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="and">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="or">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="xor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="nor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="nxor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="nand">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmp">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpz">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpzu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="max">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="maxu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="min">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="minu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
              </parameters>
            </est_index>

          </est_type>

          <est_type name="function_power">
            <!-- Dummy yet -->
          </est_type>
        </library>
      </estimation_data>

      <estimation_method>
         
        <est_type name="shape">

          <est_index name="area">

            <parameters name="default">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for alu(default) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$n = $i;

# numerator 1
$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;

# numerator 2
$nume_2 = &sum(@bit) * &sum(@data);
    
# denominator 1
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;

# denominator 2
$deno_2 = &sum(@bit) * &sum(@bit);
	

# divide by zero
if ($deno_1 == $deno_2) {
    exit(100);
}
if ($n == 0) {
    exit(100);
}


$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;

$ret_data = $a * $ARGV[1] + $b;


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$ret_data += $data[$i];
    }

    return($ret_data);
}

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

           <est_index name="aspect_ratio">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="height">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="width">

             <!-- Dummy yet -->

           </est_index>
		
        </est_type>

        <est_type name="timing">

          <est_index name="delay">

            <parameters name="default">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for alu(default) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$n = $i;

# numerator 1
$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;

# numerator 2
$nume_2 = &sum(@bit) * &sum(@data);
    
# denominator 1
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;

# denominator 2
$deno_2 = &sum(@bit) * &sum(@bit);
	

# divide by zero
if ($deno_1 == $deno_2) {
    exit(100);
}
if ($n == 0) {
    exit(100);
}


$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;

$ret_data = $a * $ARGV[1] + $b;


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$ret_data += $data[$i];
    }

    return($ret_data);
}

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

          <est_index name="delay_fullpath">

            <parameters name="default">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay_fullpath for alu(default) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

$Round = 1;

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression for delay_fullpath
#--------------------------------------------------------------------------#
$n = 0;

while (<TMP>) {

    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>/ ) {

	$bit_width = $1;
	$bit[$n] = $bit_width;
	$n++;
	$_ = <TMP>;
	
	$i = 0;
	while (! /\<\s*\/data\s*\>/ ) {

	    # path 
	    if ( /path\s+(\w+)\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "path\t $1\t $2\t ";
		$delay{$bit_width}[$i] = $3; 
		$i++;
	    }

	    # inport
	    if ( /inport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "inport\t $1\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }

	    # outport
	     if ( /outport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "outport\t $1\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }

	    # internal
	    if ( /internal\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "internal\t ";
		$delay{$bit_width}[$i] = $1;
		$i++;
	    }

	    $_ = <TMP>;
	}
    }
}
close(TMP);

$line_num = $i;



for ($j = 0; $j < $line_num; $j++) {

    # numerator 1
    $nume_1 = 0.00;
    foreach $bit_width (@bit) {
	$nume_1 += $bit_width * $delay{$bit_width}[$j];
    }
    $nume_1 *= $n;

    # numerator 2
    $nume_2 = &sum(@bit);

    $tmp = 0.00;
    foreach $bit_width (@bit) {
	$tmp += $delay{$bit_width}[$j];
    }
    $nume_2 *= $tmp;
    
    # denominator 1
    $deno_1 = 0.00;
    for ($i = 0; $i < $n; $i++) {
	$deno_1 += $bit[$i] * $bit[$i];
    }
    $deno_1 *= $n;

    # denominator 2
    $deno_2 = &sum(@bit) * &sum(@bit);
    

    # divide by zero
    if ($deno_1 == $deno_2) {
	exit(100);
    }
    if ($n == 0) {
	exit(100);
    }


    # a
    $a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);

    # b
    $tmp = 0.00;
    foreach $bit_width (@bit) {
	$tmp += $delay{$bit_width}[$j];
    }
    $b = ($tmp - $a * &sum(@bit)) / $n;
    
    $ret_data = $a * $ARGV[1] + $b;
    $ret_data = &data_round($ret_data, $Round);
    
    print "$line{$bit[0]}[$j] $ret_data\n";
}

exit(0);


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $return_data );

    $return_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$return_data += $data[$i];
    }

    return($return_data);
}


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

        </est_type>

        <est_type name="power">

          <est_index name="static_power">

            <parameters name="default">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for alu(default) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

        </est_type>

        <est_type name="function_cycle">
          <est_index name="cycle">
            <parameters name="default">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
                ]]>
              </script>
            </parameters>
          </est_index>

          <est_index name="latency">
            <parameters name="default">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
                ]]>
              </script>
            </parameters>
          </est_index>

          <est_index name="throughput">
            <parameters name="default">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
                ]]>
              </script>
            </parameters>
          </est_index>
        </est_type>

        <est_type name="function_power">

        </est_type>

    
      </estimation_method>

    </estimation>


  </model>
</FHM>
