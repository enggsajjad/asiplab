<?xml version="1.0" encoding="UTF-8" ?>
<!-- Modified by T.Hamabe on 2006/12/05 -->
<!-- Modified by T.Hamabe on 2006/11/30 -->
<FHM>
  <model_name> register </model_name>

  <model>
    <design_level> behavior </design_level>
    <version> 1.0 </version>
    <author> <![CDATA[ Sasaki Toshiyuki ]]> </author>
    <affiliation> <![CDATA[ Osaka Univ. ]]> </affiliation>
    <model_info> <![CDATA[
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                %
%    Copyright 2008 ASIP Solutions, Inc. All rights reserved.    %
%              Copyright 2002-2005 PEAS Project                  %
%                                                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
]]> </model_info>

    <parameter>
      <parameter_value key="bit_width">
        <value> 1 </value>
        <value> 2 </value>
        <value> 3 </value>
        <value> 4 </value>
        <value> 5 </value>
        <value> 6 </value>
        <value> 7 </value>
        <value> 8 </value>
        <value> 9 </value>
        <value> 10 </value>
        <value> 11 </value>
        <value> 12 </value>
        <value> 13 </value>
        <value> 14 </value>
        <value> 15 </value>
        <value> 16 </value>
        <value> 17 </value>
        <value> 18 </value>
        <value> 19 </value>
        <value> 20 </value>
        <value> 21 </value>
        <value> 22 </value>
        <value> 23 </value>
        <value> 24 </value>
        <value> 25 </value>
        <value> 26 </value>
        <value> 27 </value>
        <value> 28 </value>
        <value> 29 </value>
        <value> 30 </value>
        <value> 31 </value>
        <value> 32 </value>
        <value> 33 </value>
        <value> 34 </value>
        <value> 35 </value>
        <value> 36 </value>
        <value> 37 </value>
        <value> 38 </value>
        <value> 39 </value>
        <value> 40 </value>
        <value> 41 </value>
        <value> 42 </value>
        <value> 43 </value>
        <value> 44 </value>
        <value> 45 </value>
        <value> 46 </value>
        <value> 47 </value>
        <value> 48 </value>
        <value> 49 </value>
        <value> 50 </value>
        <value> 51 </value>
        <value> 52 </value>
        <value> 53 </value>
        <value> 54 </value>
        <value> 55 </value>
        <value> 56 </value>
        <value> 57 </value>
        <value> 58 </value>
        <value> 59 </value>
        <value> 60 </value>
        <value> 61 </value>
        <value> 62 </value>
        <value> 63 </value>
        <value> 64 </value>
        <value> 65 </value>
        <value> 66 </value>
        <value> 67 </value>
        <value> 68 </value>
        <value> 69 </value>
        <value> 70 </value>
        <value> 71 </value>
        <value> 72 </value>
        <value> 73 </value>
        <value> 74 </value>
        <value> 75 </value>
        <value> 76 </value>
        <value> 77 </value>
        <value> 78 </value>
        <value> 79 </value>
        <value> 80 </value>
        <value> 128 </value>
      </parameter_value>
    </parameter>

    <function_description>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates register function definition in behavior level
# parameter : bit_width

if ($#ARGV != 0) {
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width\n";
    exit (100);
}

$bit_width    = $ARGV[0];

if ($bit_width > 80) {
    if ($bit_width != 128) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
    }
}
elsif ($bit_width < 1) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$bit_width" == "1") {
    $range = "";
    $type  = "bit";
}
else {
    $W1 = $bit_width - 1;
    $range = "[$W1:0]";
    $type  = "bit_vector";
}

{
print <<FHM_DL_FUNCTION
/** ${bit_width}-bit register */
model reg${bit_width}{
  port{
    clock clock;
    in    async_reset, reset, enb;
    in    data_in${range};
    out   data_out${range};
  }
  storage{
    register reg${range};
  }
  default_control{
    reset = 0;
    enb   = 0;
  }

  /** no operation */
  function nop : idle{
    control{
      in reset, enb;
    }
    protocol{
      [reset == 0 && enb == 0]{
      }
    }
  }

  /** reset */
  function reset: reset{
    assignment{
      reg = 0;
    }
    control{
      in reset;
    }protocol{
      [reset == 1]{
	store reg;
      }
    }
  }

  /** write */
  function write{
    input{
      ${type} data_in;
    }
    assignment{
      reg = data_in;
    }
    control{
      in enb;
    }
    protocol{
      [enb == 1 && hold data_in]{
	store reg;
      }
    }
  }

  /** read */
  function read{
    input{
    }
    output{
      ${type} data_out = reg;
    }
  }

  priority{ ( reset > ( nop | write )), read }
}
FHM_DL_FUNCTION
}
exit (0);
        ]]>
      </script>
    </function_description>

    <function_conv>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates register function definition in behavior level
# parameter : bit_width

if ($#ARGV != 0) {
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width\n";
    exit (100);
}

$bit_width    = $ARGV[0];

if ($bit_width > 80) {
    if ($bit_width != 128) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
    }
}
elsif ($bit_width < 1) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$bit_width" == "1") {
    $range = "";
}
else {
    $W1 = $bit_width - 1;
    $range = "[$W1:0]";
}

{
print <<FHM_DL_FUNCTION
/** No operation */
function nop {
  input {
  }
  output {
  }
  control {
    in bit enb;
    in bit reset;
  }
  protocol {
    single_cycle_protocol {
      enb = '0';
      reset = '0';
    }
  }
}

/** reset */
function reset {
  input {
  }
  output {
  }
  control {
    in bit reset;
  }
  protocol {
    single_cycle_protocol {
      reset = '1';
    }
  }
}

/** register write */
function write {
  input {
    bit $range data_in;
  }
  output {
  }
  control {
    in bit enb;
  }
  protocol {
    single_cycle_protocol {
      enb = '1';
    }
  }
}

/** register read */
function read {
  input {
  }
  output {
    bit $range data_out;
  }
  control {
  }
  protocol {
  }
}
FHM_DL_FUNCTION
}
exit (0);
        ]]>
      </script>
    </function_conv>

    <function_port>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates register port information in behavior level
# parameter : bit_width

if ($#ARGV != 0) {
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width\n";
    exit (100);
}

$bit_width    = $ARGV[0];

if ($bit_width > 80) {
    if ($bit_width != 128) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
    }
}
elsif ($bit_width < 1) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

$msb = $bit_width-1;

{
print <<FHM_DL_TOP
clock	in	bit		clock
async_reset	in	bit		reset
reset	in	bit		ctrl
enb	in	bit		ctrl
FHM_DL_TOP
}
if ("$bit_width" == "1") {
print <<FHM_DL_ONE
data_in	in	bit		data
data_out	out	bit		data
FHM_DL_ONE
}
else {
print <<FHM_DL_MORE
data_in	in	bit_vector   $msb   0	data
data_out	out	bit_vector   $msb   0	data
FHM_DL_MORE
}
exit (0);
        ]]>
      </script>
    </function_port>

    <design>
      <design_lang> vhdl </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# This script generates register instance in behavior level
# parameter : instance_name bit_width

if ($#ARGV != 1) {
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];

if ($bit_width > 80) {
    if ($bit_width != 128) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
    }
}
elsif ($bit_width < 1) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ($bit_width == 1) {
    $zero = "\'0\'";
}
else {
    $zero = "\"" . "0" x $bit_width . "\"";
}

$W1 = $bit_width - 1;

{
print <<FHM_DL_COMMON

-- Module     : $bit_width-bit Positive Edge Trigger Register
-- Feature    : positive edge trigger
-- References : Started from scratch
-- Author     : Designed by T.Morifuji (c)1997.

-- Version    : 1.0  :

-- Functionality :
--  port
--   clock       : clock port
--   async_reset : asynchronous reset port
--   reset       : synchronous reset port
--   enb         : write enable control
--   data_in     : input data
--   data_out    : output data

-- Comment :

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity $instance_name is
  port (clock       : in std_logic;
        async_reset : in std_logic;
        reset       : in std_logic;
        enb         : in std_logic;
FHM_DL_COMMON
}
if ("$bit_width" == "1") {
    print <<FHM_DL_ONE
        data_in     : in std_logic;
        data_out    : out std_logic);
FHM_DL_ONE
}
else {
    print <<FHM_DL_MORE
        data_in     : in std_logic_vector($W1 downto 0);
        data_out    : out std_logic_vector($W1 downto 0) );
FHM_DL_MORE
}
{
print <<FHM_DL_TOP_OF_ARCHITECTURE
end $instance_name;

architecture logic of $instance_name is
begin

  process (clock, async_reset)
  begin
    if (async_reset = '1') then
FHM_DL_TOP_OF_ARCHITECTURE
}
if ("$bit_width" == "1") {
    print <<FHM_DL_ONE_BIT
      data_out <= '0';
FHM_DL_ONE_BIT
}
else {
    print <<FHM_DL_MORE_BIT
      data_out <= $zero;
FHM_DL_MORE_BIT
}
{
print <<FHM_DL_EOF
    elsif (clock'event and clock = '1') then
      if (reset = '1') then
FHM_DL_EOF
}
if ("$bit_width" == "1") {
    print "        data_out <= '0';\n";
}
else{
    print "        data_out <= (others => '0');\n";
}
{
print <<FHM_DL_EOF
      elsif (enb = '1') then
        data_out <= data_in;
      end if;
    end if;
  end process;

end logic;

FHM_DL_EOF
}
exit (0);
          ]]>
        </script>
      </instance>

      <entity></entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>

      <synthesis></synthesis>
    </design>

    <design>
      <design_lang> Verilog </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates instance for register in behavior level
# parameter : instance_name bit_width


if ($#ARGV != 1) {
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];

if ($bit_width > 80) {
    if ($bit_width != 128) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
    }
}
elsif ($bit_width < 1) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}
$W1 = $bit_width - 1;

{
print <<FHM_DL_COMMON
// Module     : $bit_width-bit Positive Edge Trigger Register
// Feature    : positive edge trigger
// References : Started from scratch
// Author     : Designed by T.Morifuji (c)1997.
\n
// Version    : 1.0  :
\n
// Functionality :
//  port
//   clock       : clock port
//   async_reset : asynchronous reset port
//   reset       : synchronous reset port
//   enb         : write enable control
//   data_in     : input data
//   data_out    : output data
\n
// Comment :
\n
module $instance_name (
    clock      ,
    async_reset,
    reset      ,
    enb        ,
    data_in    ,
    data_out   );
\n
input         clock      ;
input         async_reset;
input         reset      ;
input         enb        ;
FHM_DL_COMMON
}
if ("$bit_width" == "1"){
 print <<FHM_DL_ONE
input         data_in    ;
output        data_out   ;
\n
FHM_DL_ONE
}
else{
print <<FHM_DL_MULTIPLE
input  [$W1:0] data_in    ;
output [$W1:0] data_out   ;
\n
FHM_DL_MULTIPLE
}
{
print <<FHM_DL_COMMON
wire        clock      ;
wire        async_reset;
wire        reset      ;
wire        enb        ;
FHM_DL_COMMON
}
if ("$bit_width" == "1"){
 print <<FHM_DL_ONE
wire       data_in    ;
reg        data_out   ;
\n
FHM_DL_ONE
}
else{
print <<FHM_DL_MULTIPLE
wire  [$W1:0] data_in    ;
reg   [$W1:0] data_out   ;
\n
FHM_DL_MULTIPLE
}
{
print <<FHM_DL_COMMON
always@ (posedge clock or posedge async_reset)
begin
  if (async_reset == 1'b1)
FHM_DL_COMMON
}
if ("$bit_width" == "1"){
  print <<FHM_DL_ONE_BIT
    data_out <= 1'b0;
FHM_DL_ONE_BIT
}
else{
  print "    data_out <= {$bit_width\{1'b0}};\n";
}
{
print <<FHM_DL_COMMON
  else
  begin
    if (reset == 1'b1)
FHM_DL_COMMON
}
if ("$bit_width" == "1"){
  print <<FHM_DL_ONE_BIT
      data_out <= 1'b0;
FHM_DL_ONE_BIT
}
else{
  print "      data_out <={$bit_width\{1'b0}};\n";
}
{
print <<FHM_DL_COMMON
    else if (enb == 1'b1)
      data_out <= data_in;
  end
end

endmodule
FHM_DL_COMMON
}
exit(0);
          ]]>
        </script>
      </instance>

      <entity></entity>

      <testvector></testvector>

      <synthesis></synthesis>
    </design>

    <design>
      <design_lang> SystemC Header </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates instance for register in behavior level
# parameter : name_space instance_name bit_width


if ($#ARGV != 2) {
    print "number of parameters is wrong.\n";
    print "usage : this_script name_space instance_name bit_width\n";
    exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];

if ($bit_width > 80) {
    if ($bit_width != 128) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
    }
}
elsif ($bit_width < 1) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}
$W1 = $bit_width - 1;

if ($bit_width <= 64) {
    $data_type = "sc_dt::sc_uint<" . $bit_width . ">";
} else {
    $data_type = "sc_dt::sc_biguint<" . $bit_width . ">";
}

$macro = "__" . uc($name_space) . "_" . uc($instance_name) . "_H__";

{
print <<FHM_DL_COMMON
#ifndef $macro
#define $macro 1

// Module     : $bit_width-bit Positive Edge Trigger Register
// Feature    : positive edge trigger
// References : Started from scratch
// Author     : Designed by T.Morifuji (c)1997.

// Version    : 1.0  :

// Functionality :
//  port
//   clock       : clock port
//   async_reset : asynchronous reset port
//   reset       : synchronous reset port
//   enb         : write enable control
//   data_in     : input data
//   data_out    : output data

// Comment :

#include <systemc>

namespace $name_space {
  SC_MODULE($instance_name) {
    sc_core::sc_in< bool > clock;
    sc_core::sc_in< bool > async_reset;
    sc_core::sc_in< bool > reset;
    sc_core::sc_in< bool > enb;
FHM_DL_COMMON
}
if ("$bit_width" == "1"){
 print <<FHM_DL_ONE
    sc_core::sc_in< bool > data_in;
    sc_core::sc_out< bool > data_out;
\n
FHM_DL_ONE
}
else{
print <<FHM_DL_MULTIPLE
    sc_core::sc_in< $data_type > data_in;
    sc_core::sc_out< $data_type > data_out;
\n
FHM_DL_MULTIPLE
}
{
print <<FHM_DL_COMMON
    SC_CTOR($instance_name) :
      clock("clock"),
      async_reset("async_reset"),
      reset("reset"),
      data_in("data_in"),
      data_out("data_out")
    {
       SC_METHOD( process );
       sensitive << clock.pos() << async_reset.pos();
    }
  
    void process();
  };
};

#endif // $macro
FHM_DL_COMMON
}
exit(0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <design>
      <design_lang> SystemC Program </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates instance for register in behavior level
# parameter : name_space instance_name bit_width


if ($#ARGV != 2) {
    print "number of parameters is wrong.\n";
    print "usage : this_script name_space instance_name bit_width\n";
    exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];

if ($bit_width > 80) {
    if ($bit_width != 128) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
    }
}
elsif ($bit_width < 1) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}
$W1 = $bit_width - 1;

{
print <<FHM_DL_COMMON
#include "$instance_name.h"

// Module     : $bit_width-bit Positive Edge Trigger Register
// Feature    : positive edge trigger
// References : Started from scratch
// Author     : Designed by T.Morifuji (c)1997.

// Version    : 1.0  :

// Functionality :
//  port
//   clock       : clock port
//   async_reset : asynchronous reset port
//   reset       : synchronous reset port
//   enb         : write enable control
//   data_in     : input data
//   data_out    : output data

// Comment :

FHM_DL_COMMON
}
{
print <<FHM_DL_COMMON
void ${name_space}::${instance_name}::process()
{
  if ( async_reset.read() == 1 ) {
FHM_DL_COMMON
}
if ("$bit_width" == "1"){
  print <<FHM_DL_ONE_BIT
    data_out.write( false );
FHM_DL_ONE_BIT
}
else{
  print "    data_out.write(0);\n";
}
{
print <<FHM_DL_COMMON
  } else if ( clock.event() && clock.read() == 1 ) {
    if (reset.read() == 1)
FHM_DL_COMMON
}
if ("$bit_width" == "1"){
  print <<FHM_DL_ONE_BIT
      data_out.write( false );
FHM_DL_ONE_BIT
}
else{
  print "      data_out.write(0);\n";
}
{
print <<FHM_DL_COMMON
    else if (enb.read() == 1)
      data_out.write(data_in.read());
  }
}
FHM_DL_COMMON
}
exit(0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <estimation>
      <estimation_data>
        <library name="OSAKA">

          <est_type name="shape">
            <est_index name="area">
              <unit> mm2 </unit>
              <translate>
                <translate_value key="gate"> 4201.68 </translate_value>
                <translate_value key="mm2">  1 </translate_value>
              </translate>

              <parameters name="">
                <max>
                  <data bit_width="1"> 0.00412316025970564 </data>
                  <data bit_width="4"> 0.0158804432988709 </data>
                  <data bit_width="8"> 0.0316758201481312 </data>
                  <data bit_width="16"> 0.0631475735896118 </data>
                  <data bit_width="32"> 0.125972080929533 </data>
                  <data bit_width="128"> 0.53139981459797 </data>
                </max>
                <min>
                  <data bit_width="1"> 0.00335802821728451 </data>
                  <data bit_width="4"> 0.0128199151291864 </data>
                  <data bit_width="8"> 0.0255547638087622 </data>
                  <data bit_width="16"> 0.0509054611488738 </data>
                  <data bit_width="32"> 0.101487856048057 </data>
                  <data bit_width="128"> 0.426996705127473 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1"> 0.00335802821728451 </data>
                    <data bit_width="4"> 0.0128199151291864 </data>
                    <data bit_width="8"> 0.0255547638087622 </data>
                    <data bit_width="16"> 0.0509054611488738 </data>
                    <data bit_width="32"> 0.101487856048057 </data>
                    <data bit_width="128"> 0.426996705127473 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1"> 0.00412316025970564 </data>
                    <data bit_width="4"> 0.0158804432988709 </data>
                    <data bit_width="8"> 0.0316758201481312 </data>
                    <data bit_width="16"> 0.0631475735896118 </data>
                    <data bit_width="32"> 0.125972080929533 </data>
                    <data bit_width="128"> 0.53139981459797 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1"> 0.00347702823632452 </data>
                    <data bit_width="4"> 0.0132959152053464 </data>
                    <data bit_width="8"> 0.0268042640086822 </data>
                    <data bit_width="16"> 0.0529879614820738 </data>
                    <data bit_width="32"> 0.105474356685897 </data>
                    <data bit_width="128"> 0.500815066354411 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>

            <est_index name="aspect_ratio">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="height">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="width">
              <!-- Dummy yet -->
            </est_index>
          </est_type>

          <est_type name="timing">
            <est_index name="delay">
              <unit> ns </unit>

              <parameters name="">
                <max>
                  <data bit_width="1"> 0.75 </data>
                  <data bit_width="4"> 0.75 </data>
                  <data bit_width="8"> 0.75 </data>
                  <data bit_width="16"> 0.75 </data>
                  <data bit_width="32"> 0.75 </data>
                  <data bit_width="128"> 0.76 </data>
                </max>
                <min>
                  <data bit_width="1"> 0.72 </data>
                  <data bit_width="4"> 0.72 </data>
                  <data bit_width="8"> 0.72 </data>
                  <data bit_width="16"> 0.72 </data>
                  <data bit_width="32"> 0.72 </data>
                  <data bit_width="128"> 0.72 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1"> 0.75 </data>
                    <data bit_width="4"> 0.75 </data>
                    <data bit_width="8"> 0.75 </data>
                    <data bit_width="16"> 0.75 </data>
                    <data bit_width="32"> 0.75 </data>
                    <data bit_width="128"> 0.75 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1"> 0.72 </data>
                    <data bit_width="4"> 0.72 </data>
                    <data bit_width="8"> 0.72 </data>
                    <data bit_width="16"> 0.72 </data>
                    <data bit_width="32"> 0.72 </data>
                    <data bit_width="128"> 0.72 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1"> 0.75 </data>
                    <data bit_width="4"> 0.75 </data>
                    <data bit_width="8"> 0.75 </data>
                    <data bit_width="16"> 0.75 </data>
                    <data bit_width="32"> 0.75 </data>
                    <data bit_width="128"> 0.76 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>

            <est_index name="delay_fullpath">
            <!-- Dummy yet -->
            </est_index>
          </est_type>

          <est_type name="power">
            <est_index name="static_power">
              <unit> mW </unit>
              <parameters name="">
                <max>
                  <data bit_width="1"> 0.6449194 </data>
                  <data bit_width="4"> 2.2203 </data>
                  <data bit_width="8"> 4.4270 </data>
                  <data bit_width="16"> 8.7214 </data>
                  <data bit_width="32"> 17.2327 </data>
                  <data bit_width="128"> 72.2256 </data>
                </max>
                <min>
                  <data bit_width="1"> 0.6026836 </data>
                  <data bit_width="4"> 2.2153 </data>
                  <data bit_width="8"> 4.3512 </data>
                  <data bit_width="16"> 8.5400 </data>
                  <data bit_width="32"> 17.0462 </data>
                  <data bit_width="128"> 70.1949 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1"> 0.6028486 </data>
                    <data bit_width="4"> 2.2159 </data>
                    <data bit_width="8"> 4.4179 </data>
                    <data bit_width="16"> 8.7033 </data>
                    <data bit_width="32"> 17.2202 </data>
                    <data bit_width="128"> 71.6659 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1"> 0.6449194 </data>
                    <data bit_width="4"> 2.2203 </data>
                    <data bit_width="8"> 4.4270 </data>
                    <data bit_width="16"> 8.7214 </data>
                    <data bit_width="32"> 17.2327 </data>
                    <data bit_width="128"> 72.2256 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1"> 0.6026836 </data>
                    <data bit_width="4"> 2.2153 </data>
                    <data bit_width="8"> 4.3512 </data>
                    <data bit_width="16"> 8.5400 </data>
                    <data bit_width="32"> 17.0462 </data>
                    <data bit_width="128"> 70.1949 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>
          </est_type>

          <est_type name="function_cycle">
            <!-- Dummy yet -->
          </est_type>

          <est_type name="function_power">
            <!-- Dummy yet -->
          </est_type>
        </library>
      </estimation_data>

      <estimation_method>

        <est_type name="shape">

          <est_index name="area">

               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for reg(positive) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
    $bit[$i]  = $1;
    $data[$i] = $2;
    $i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
    $ret_data = $data[$j];
    goto END;
    }
}

if ($bit_width < $bit[0]) {

    # divide by zero
    if ($bit[1] == $bit[0]) {
    exit(100);
    }

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
    exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
    $j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
    exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}


END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;

    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>

          </est_index>

           <est_index name="aspect_ratio">

             <!-- Dummy yet -->

           </est_index>

           <est_index name="height">

             <!-- Dummy yet -->

           </est_index>

           <est_index name="width">

             <!-- Dummy yet -->

           </est_index>

        </est_type>

        <est_type name="timing">

          <est_index name="delay">

               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for reg(positive) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
    $bit[$i]  = $1;
    $data[$i] = $2;
    $i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
    $ret_data = $data[$j];
    goto END;
    }
}

if ($bit_width < $bit[0]) {

    # divide by zero
    if ($bit[1] == $bit[0]) {
    exit(100);
    }

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
    exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
    $j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
    exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}


END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;

    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>

          </est_index>

          <est_index name="delay_fullpath">

               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay_fullpath for reg(positive) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

$Round = 1;

#--------------------------------------------------------------------------#
# Type: Table lookup for delay_fullpath
#--------------------------------------------------------------------------#
$n = 0;

while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>/ ) {

    $bit_width = $1;
    $bit[$n]   = $bit_width;
    $n++;

    $_ = <TMP>;
    $i = 0;

    while (! /\<\s*\/data\s*\>/ ) {

        # path
        if ( /path\s+(\w+)\s+(\w+)\s+(\d+\.?\d+)/ ) {
        $line{$bit_width}[$i]  = "path\t $1\t $2\t ";
        $delay{$bit_width}[$i] = $3;
        $i++;
        }

        # inport
        if ( /inport\s+(\w+)\s+(\d+\.?\d+)/ ) {
        $line{$bit_width}[$i]  = "inport\t $1\t ";
        $delay{$bit_width}[$i] = $2;
        $i++;
        }

        # outport
         if ( /outport\s+(\w+)\s+(\d+\.?\d+)/ ) {
        $line{$bit_width}[$i]  = "outport\t $1\t ";
        $delay{$bit_width}[$i] = $2;
        $i++;
        }

        # internal
        if ( /internal\s+(\d+\.?\d+)/ ) {
        $line{$bit_width}[$i]  = "internal\t ";
        $delay{$bit_width}[$i] = $1;
        $i++;
        }

        $_ = <TMP>;
    }
    }
}
close(TMP);

$bit_width = $ARGV[1];
$line_num = $i;


for ($k = 0; $k < $line_num; $k++) {

    for ($j = 0; $j < $n; $j++) {
    if ($bit_width == $bit[$j]) {
        $ret_data = $delay{$bit_width}[$k];
        $ret_data = &data_round($ret_data, $Round);
        print "$line{$bit_width}[$k] $ret_data\n";
        goto NEXT;
    }
    }

    if ($bit_width < $bit[0]) {

    # divide by zero
    if ( $bit[1] - $bit[0] ) {
        exit(100);
    }

    $ret_data = $delay{$bit[0]}[$k] - (($delay{$bit[1]}[$k] - $delay{$bit[0]}[$k]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
    }

    elsif ($bit[$n-1] < $bit_width) {

    # divide by zero
    if ( $bit[$n-1] - $bit[$n-2] ) {
        exit(100);
    }

    $ret_data = $delay{$bit[$n-1]}[$k] + (($delay{$bit[$n-1]}[$k] - $delay{$bit[$n-2]}[$k]) / ($bit[$n-1] - $bit[$n-2])) * ($bit_width - $bit[$n-1]);
    }

    else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
        $j++;
    }

    # divide by zero
    if ( $bit[$j] - $bit[$j-1] ) {
        exit(100);
    }

    $ret_data = $delay{$bit[$j-1]}[$k] + (($delay{$bit[$j]}[$k] - $delay{$bit[$j-1]}[$k]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
    }

    $ret_data = &data_round($ret_data, $Round);
    print "$line{$bit[0]}[$k] $ret_data\n";


  NEXT:
}


exit(0);


sub data_round
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;

    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}


                ]]>
             </script>
          </est_index>

        </est_type>

        <est_type name="power">

          <est_index name="static_power">

               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for reg(positive) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
    $bit[$i]  = $1;
    $data[$i] = $2;
    $i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
    $ret_data = $data[$j];
    goto END;
    }
}

if ($bit_width < $bit[0]) {

    # divide by zero
    if ($bit[1] == $bit[0]) {
    exit(100);
    }

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
    exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
    $j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
    exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}


END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;

    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>

          </est_index>

        </est_type>

        <est_type name="function_cycle">

        </est_type>

        <est_type name="function_power">

        </est_type>


      </estimation_method>

    </estimation>


  </model>

  <model>
    <design_level> synthesis </design_level>
    <version> 1.0 </version>
    <author> <![CDATA[ Sasaki Toshiyuki ]]> </author>
    <affiliation> <![CDATA[ Osaka Univ. ]]> </affiliation>
    <model_info> <![CDATA[
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                %
%    Copyright 2008 ASIP Solutions, Inc. All rights reserved.    %
%              Copyright 2002-2005 PEAS Project                  %
%                                                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
]]> </model_info>

    <parameter>
      <parameter_value key="bit_width">
        <value> 1 </value>
        <value> 2 </value>
        <value> 3 </value>
        <value> 4 </value>
        <value> 5 </value>
        <value> 6 </value>
        <value> 7 </value>
        <value> 8 </value>
        <value> 9 </value>
        <value> 10 </value>
        <value> 11 </value>
        <value> 12 </value>
        <value> 13 </value>
        <value> 14 </value>
        <value> 15 </value>
        <value> 16 </value>
        <value> 17 </value>
        <value> 18 </value>
        <value> 19 </value>
        <value> 20 </value>
        <value> 21 </value>
        <value> 22 </value>
        <value> 23 </value>
        <value> 24 </value>
        <value> 25 </value>
        <value> 26 </value>
        <value> 27 </value>
        <value> 28 </value>
        <value> 29 </value>
        <value> 30 </value>
        <value> 31 </value>
        <value> 32 </value>
        <value> 33 </value>
        <value> 34 </value>
        <value> 35 </value>
        <value> 36 </value>
        <value> 37 </value>
        <value> 38 </value>
        <value> 39 </value>
        <value> 40 </value>
        <value> 41 </value>
        <value> 42 </value>
        <value> 43 </value>
        <value> 44 </value>
        <value> 45 </value>
        <value> 46 </value>
        <value> 47 </value>
        <value> 48 </value>
        <value> 49 </value>
        <value> 50 </value>
        <value> 51 </value>
        <value> 52 </value>
        <value> 53 </value>
        <value> 54 </value>
        <value> 55 </value>
        <value> 56 </value>
        <value> 57 </value>
        <value> 58 </value>
        <value> 59 </value>
        <value> 60 </value>
        <value> 61 </value>
        <value> 62 </value>
        <value> 63 </value>
        <value> 64 </value>
        <value> 65 </value>
        <value> 66 </value>
        <value> 67 </value>
        <value> 68 </value>
        <value> 69 </value>
        <value> 70 </value>
        <value> 71 </value>
        <value> 72 </value>
        <value> 73 </value>
        <value> 74 </value>
        <value> 75 </value>
        <value> 76 </value>
        <value> 77 </value>
        <value> 78 </value>
        <value> 79 </value>
        <value> 80 </value>
        <value> 128 </value>
      </parameter_value>
    </parameter>

    <function_description>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates register function definition in synthesis level
# parameter : bit_width

if ($#ARGV != 0) {
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width\n";
    exit (100);
}

$bit_width    = $ARGV[0];

if ($bit_width > 80) {
    if ($bit_width != 128) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
    }
}
elsif ($bit_width < 1) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$bit_width" == "1") {
    $range = "";
    $type  = "bit";
}
else {
    $W1 = $bit_width - 1;
    $range = "[$W1:0]";
    $type  = "bit_vector";
}

{
print <<FHM_DL_FUNCTION
/** ${bit_width}-bit register */
model reg${bit_width}{
  port{
    clock clock;
    in    async_reset, reset, enb;
    in    data_in${range};
    out   data_out${range};
  }
  storage{
    register reg${range};
  }
  default_control{
    reset = 0;
    enb   = 0;
  }

  /** no operation */
  function nop : idle{
    control{
      in reset, enb;
    }
    protocol{
      [reset == 0 && enb == 0]{
      }
    }
  }

  /** reset */
  function reset: reset{
    assignment{
      reg = 0;
    }
    control{
      in reset;
    }protocol{
      [reset == 1]{
	store reg;
      }
    }
  }

  /** write */
  function write{
    input{
      ${type} data_in;
    }
    assignment{
      reg = data_in;
    }
    control{
      in enb;
    }
    protocol{
      [enb == 1 && hold data_in]{
	store reg;
      }
    }
  }

  /** read */
  function read{
    input{
    }
    output{
      ${type} data_out = reg;
    }
  }

  priority{ ( reset > ( nop | write )), read }
}
FHM_DL_FUNCTION
}
exit (0);
        ]]>
      </script>
    </function_description>

    <function_conv>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates register function definition in synthesis level
# parameter : bit_width

if ($#ARGV != 0) {
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width\n";
    exit (100);
}

$bit_width    = $ARGV[0];

if ($bit_width > 80) {
    if ($bit_width != 128) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
    }
}
elsif ($bit_width < 1) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$bit_width" == "1") {
    $range = "";
}
else {
    $W1 = $bit_width - 1;
    $range = "[$W1:0]";
}

{
print <<FHM_DL_FUNCTION
/** No operation */
function nop {
  input {
  }
  output {
  }
  control {
    in bit enb;
    in bit reset;
  }
  protocol {
    single_cycle_protocol {
      enb = '0';
      reset = '0';
    }
  }
}

/** reset */
function reset {
  input {
  }
  output {
  }
  control {
    in bit reset;
  }
  protocol {
    single_cycle_protocol {
      reset = '1';
    }
  }
}

/** register write */
function write {
  input {
    bit $range data_in;
  }
  output {
  }
  control {
    in bit enb;
  }
  protocol {
    single_cycle_protocol {
      enb = '1';
    }
  }
}

/** register read */
function read {
  input {
  }
  output {
    bit $range data_out;
  }
  control {
  }
  protocol {
  }
}
FHM_DL_FUNCTION
}
exit (0);
        ]]>
      </script>
    </function_conv>

    <function_port>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates register port information in synthesis level
# parameter : bit_width

if ($#ARGV != 0) {
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width\n";
    exit (100);
}

$bit_width    = $ARGV[0];

if ($bit_width > 80) {
    if ($bit_width != 128) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
    }
}
elsif ($bit_width < 1) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

$msb = $bit_width-1;

{
print <<FHM_DL_TOP
clock	in	bit		clock
async_reset	in	bit		reset
reset	in	bit		ctrl
enb	in	bit		ctrl
FHM_DL_TOP
}
if ("$bit_width" == "1") {
print <<FHM_DL_ONE
data_in	in	bit		data
data_out	out	bit		data
FHM_DL_ONE
}
else {
print <<FHM_DL_MORE
data_in	in	bit_vector   $msb   0	data
data_out	out	bit_vector   $msb   0	data
FHM_DL_MORE
}
exit (0);
        ]]>
      </script>
    </function_port>

    <design>
      <design_lang> vhdl </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# This script generates register instance in synthesis level
# parameter : instance_name bit_width

if ($#ARGV != 1) {
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];

if ($bit_width > 80) {
    if ($bit_width != 128) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
    }
}
elsif ($bit_width < 1) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ($bit_width == 1) {
    $zero = "\'0\'";
}
else {
    $zero = "\"" . "0" x $bit_width . "\"";
}

$W1 = $bit_width - 1;

{
print <<FHM_DL_COMMON

-- Module     : $bit_width-bit Positive Edge Trigger Register
-- Feature    : positive edge trigger
-- References : Started from scratch
-- Author     : Designed by T.Morifuji (c)1997.

-- Version    : 1.0  :

-- Functionality :
--  port
--   clock       : clock port
--   async_reset : asynchronous reset port
--   reset       : synchronous reset port
--   enb         : write enable control
--   data_in     : input data
--   data_out    : output data

-- Comment :

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity $instance_name is
  port (clock       : in std_logic;
        async_reset : in std_logic;
        reset       : in std_logic;
        enb         : in std_logic;
FHM_DL_COMMON
}
if ("$bit_width" == "1") {
    print <<FHM_DL_ONE
        data_in     : in std_logic;
        data_out    : out std_logic);
FHM_DL_ONE
}
else {
    print <<FHM_DL_MORE
        data_in     : in std_logic_vector($W1 downto 0);
        data_out    : out std_logic_vector($W1 downto 0) );
FHM_DL_MORE
}
{
print <<FHM_DL_TOP_OF_ARCHITECTURE
end $instance_name;

architecture logic of $instance_name is
begin

  process (clock, async_reset)
  begin
    if (async_reset = '1') then
FHM_DL_TOP_OF_ARCHITECTURE
}
if ("$bit_width" == "1") {
    print <<FHM_DL_ONE_BIT
      data_out <= '0';
FHM_DL_ONE_BIT
}
else {
    print <<FHM_DL_MORE_BIT
      data_out <= $zero;
FHM_DL_MORE_BIT
}
{
    print <<FHM_DL_EOF
    elsif (clock'event and clock = '1') then
      if (reset = '1') then
FHM_DL_EOF
}
if ("$bit_width" == "1") {
    print "        data_out <= '0';\n";
}
else{
    print "        data_out <= (others => '0');\n";
}
{
    print <<FHM_DL_EOF
      elsif (enb = '1') then
        data_out <= data_in;
      end if;
    end if;
  end process;

end logic;

FHM_DL_EOF
}
exit (0);
          ]]>
        </script>
      </instance>

      <entity></entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>

      <synthesis>
        <parameter></parameter>
        <synthesis_script>
          <script>
            <![CDATA[
#!/usr/bin/perl
# This script generates register synthesis script in synthesis level
# parameter : instance_name priority bit_width

if ($#ARGV != 2) {
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name priority bit_width\n";
    exit (100);
}

$instance_name = $ARGV[0];
$priority      = $ARGV[1];
$bit_width     = $ARGV[2];

if ($bit_width > 80) {
    if ($bit_width != 128) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
    }
}
elsif ($bit_width < 1) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ($priority eq "area"){
  $priority_const = "set_max_area 0";
}
elsif ($priority eq "performance"){
  $priority_const = "set_max_delay -from all_inputs() -to all_outputs() 0";
}
elsif ($priority eq "power"){
  $priority_const = "";
}
elsif ($priority eq "none"){
  $priority_const = "";
}
else {
    print "priority $priority is not supported.\n";
    exit(100);
}

{
print <<FHM_DL_END_OF_SCRIPT
hdlin_auto_save_templates = TRUE

analyze -f vhdl $instance_name.vhd

elaborate $instance_name
uniquify

$priority_const

create_clock -period 10 -waveform{0 5} clock

compile

write -hierarchy -output $instance_name.db

report_area
report_timing

quit
FHM_DL_END_OF_SCRIPT
}
exit(0);
            ]]>
          </script>
        </synthesis_script>
      </synthesis>
    </design>

    <design>
      <design_lang> Verilog </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates instance for register in synthesis level
# parameter : instance_name bit_width


if ($#ARGV != 1) {
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];

if ($bit_width > 80) {
    if ($bit_width != 128) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
    }
}
elsif ($bit_width < 1) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}
$W1 = $bit_width - 1;

{
print <<FHM_DL_COMMON
// Module     : $bit_width-bit Positive Edge Trigger Register
// Feature    : positive edge trigger
// References : Started from scratch
// Author     : Designed by T.Morifuji (c)1997.
\n
// Version    : 1.0  :
\n
// Functionality :
//  port
//   clock       : clock port
//   async_reset : asynchronous reset port
//   reset       : synchronous reset port
//   enb         : write enable control
//   data_in     : input data
//   data_out    : output data
\n
// Comment :
\n
module $instance_name (
    clock      ,
    async_reset,
    reset      ,
    enb        ,
    data_in    ,
    data_out   );
\n
input         clock      ;
input         async_reset;
input         reset      ;
input         enb        ;
FHM_DL_COMMON
}
if ("$bit_width" == "1"){
 print <<FHM_DL_ONE
input         data_in    ;
output        data_out   ;
\n
FHM_DL_ONE
}
else{
print <<FHM_DL_MULTIPLE
input  [$W1:0] data_in    ;
output [$W1:0] data_out   ;
\n
FHM_DL_MULTIPLE
}
{
print <<FHM_DL_COMMON
wire        clock      ;
wire        async_reset;
wire        reset      ;
wire        enb        ;
FHM_DL_COMMON
}
if ("$bit_width" == "1"){
 print <<FHM_DL_ONE
wire         data_in    ;
reg          data_out   ;
\n
FHM_DL_ONE
}
else{
print <<FHM_DL_MULTIPLE
wire  [$W1:0] data_in    ;
reg   [$W1:0] data_out   ;
\n
FHM_DL_MULTIPLE
}
{
print <<FHM_DL_COMMON
always@ (posedge clock or posedge async_reset)
begin
  if (async_reset == 1'b1)
FHM_DL_COMMON
}
if ("$bit_width" == "1"){
  print <<FHM_DL_ONE_BIT
    data_out <= 1'b0;
FHM_DL_ONE_BIT
}
else{
  print "    data_out <= {$bit_width\{1'b0}};\n";
}
{
print <<FHM_DL_COMMON
  else
  begin
    if (reset == 1'b1)
FHM_DL_COMMON
}
if ("$bit_width" == "1"){
  print <<FHM_DL_ONE_BIT
      data_out <= 1'b0;
FHM_DL_ONE_BIT
}
else{
  print "      data_out <= {$bit_width\{1'b0}};\n";
}
{
print <<FHM_DL_COMMON
    else if (enb == 1'b1)
      data_out <= data_in;
  end
end

endmodule
FHM_DL_COMMON
}
exit(0);
          ]]>
        </script>
      </instance>

      <entity></entity>

      <testvector></testvector>

      <synthesis></synthesis>
    </design>   

    <design>
      <design_lang> SystemC Header </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates instance for register in synthesis level
# parameter : name_space instance_name bit_width


if ($#ARGV != 2) {
    print "number of parameters is wrong.\n";
    print "usage : this_script name_space instance_name bit_width\n";
    exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];

if ($bit_width > 80) {
    if ($bit_width != 128) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
    }
}
elsif ($bit_width < 1) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}
$W1 = $bit_width - 1;

if ($bit_width <= 64) {
    $data_type = "sc_dt::sc_uint<" . $bit_width . ">";
} else {
    $data_type = "sc_dt::sc_biguint<" . $bit_width . ">";
}

$macro = "__" . uc($name_space) . "_" . uc($instance_name) . "_H__";

{
print <<FHM_DL_COMMON
#ifndef $macro
#define $macro 1

// Module     : $bit_width-bit Positive Edge Trigger Register
// Feature    : positive edge trigger
// References : Started from scratch
// Author     : Designed by T.Morifuji (c)1997.

// Version    : 1.0  :

// Functionality :
//  port
//   clock       : clock port
//   async_reset : asynchronous reset port
//   reset       : synchronous reset port
//   enb         : write enable control
//   data_in     : input data
//   data_out    : output data

// Comment :

#include <systemc>

namespace $name_space {
  SC_MODULE($instance_name) {
    sc_core::sc_in< bool > clock;
    sc_core::sc_in< bool > async_reset;
    sc_core::sc_in< bool > reset;
    sc_core::sc_in< bool > enb;
FHM_DL_COMMON
}
if ("$bit_width" == "1"){
 print <<FHM_DL_ONE
    sc_core::sc_in< bool > data_in;
    sc_core::sc_out< bool > data_out;

FHM_DL_ONE
}
else{
print <<FHM_DL_MULTIPLE
    sc_core::sc_in< $data_type > data_in;
    sc_core::sc_out< $data_type > data_out;

FHM_DL_MULTIPLE
}
{
print <<FHM_DL_COMMON
    SC_CTOR($instance_name) :
      clock("clock"),
      async_reset("async_reset"),
      reset("reset"),
      data_in("data_in"),
      data_out("data_out")
    {
       SC_METHOD( process );
       sensitive << clock.pos() << async_reset.pos();
    }

    void process();
  };
};

#endif // $macro
FHM_DL_COMMON
}
exit(0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <design>
      <design_lang> SystemC Program </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates instance for register in synthesis level
# parameter : name_space instance_name bit_width


if ($#ARGV != 2) {
    print "number of parameters is wrong.\n";
    print "usage : this_script name_space instance_name bit_width\n";
    exit (100);
}

$name_space    = $ARGV[0];
$instance_name = $ARGV[1];
$bit_width     = $ARGV[2];

if ($bit_width > 80) {
    if ($bit_width != 128) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
    }
}
elsif ($bit_width < 1) {
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}
$W1 = $bit_width - 1;

{
print <<FHM_DL_COMMON
#include "$instance_name.h"

// Module     : $bit_width-bit Positive Edge Trigger Register
// Feature    : positive edge trigger
// References : Started from scratch
// Author     : Designed by T.Morifuji (c)1997.

// Version    : 1.0  :

// Functionality :
//  port
//   clock       : clock port
//   async_reset : asynchronous reset port
//   reset       : synchronous reset port
//   enb         : write enable control
//   data_in     : input data
//   data_out    : output data

// Comment :

FHM_DL_COMMON
}
{
print <<FHM_DL_COMMON
void ${name_space}::${instance_name}::process()
{
  if ( async_reset.read() == 1 ) {
FHM_DL_COMMON
}
if ("$bit_width" == "1"){
  print <<FHM_DL_ONE_BIT
    data_out.write( false );
FHM_DL_ONE_BIT
}
else{
  print "    data_out.write( 0 );\n";
}
{
print <<FHM_DL_COMMON
  } else if ( clock.event() && clock.read() == 1 ) {
    if (reset.read() == 1)
FHM_DL_COMMON
}
if ("$bit_width" == "1"){
  print <<FHM_DL_ONE_BIT
      data_out.write( false );
FHM_DL_ONE_BIT
}
else{
  print "    data_out.write( 0 );\n";
}
{
print <<FHM_DL_COMMON
    else if (enb.read() == 1)
      data_out.write(data_in.read());
  }
}
FHM_DL_COMMON
}
exit(0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>
    </design>

    <estimation>
      <estimation_data>
        <library name="OSAKA">

          <est_type name="shape">
            <est_index name="area">
              <unit> mm2 </unit>
              <translate>
                <translate_value key="gate"> 4201.68 </translate_value>
                <translate_value key="mm2">  1 </translate_value>
              </translate>

              <parameters name="">
                <max>
                  <data bit_width="1"> 0.00412316025970564 </data>
                  <data bit_width="4"> 0.0158804432988709 </data>
                  <data bit_width="8"> 0.0316758201481312 </data>
                  <data bit_width="16"> 0.0631475735896118 </data>
                  <data bit_width="32"> 0.125972080929533 </data>
                  <data bit_width="128"> 0.53139981459797 </data>
                </max>
                <min>
                  <data bit_width="1"> 0.00335802821728451 </data>
                  <data bit_width="4"> 0.0128199151291864 </data>
                  <data bit_width="8"> 0.0255547638087622 </data>
                  <data bit_width="16"> 0.0509054611488738 </data>
                  <data bit_width="32"> 0.101487856048057 </data>
                  <data bit_width="128"> 0.426996705127473 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1"> 0.00335802821728451 </data>
                    <data bit_width="4"> 0.0128199151291864 </data>
                    <data bit_width="8"> 0.0255547638087622 </data>
                    <data bit_width="16"> 0.0509054611488738 </data>
                    <data bit_width="32"> 0.101487856048057 </data>
                    <data bit_width="128"> 0.426996705127473 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1"> 0.00412316025970564 </data>
                    <data bit_width="4"> 0.0158804432988709 </data>
                    <data bit_width="8"> 0.0316758201481312 </data>
                    <data bit_width="16"> 0.0631475735896118 </data>
                    <data bit_width="32"> 0.125972080929533 </data>
                    <data bit_width="128"> 0.53139981459797 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1"> 0.00347702823632452 </data>
                    <data bit_width="4"> 0.0132959152053464 </data>
                    <data bit_width="8"> 0.0268042640086822 </data>
                    <data bit_width="16"> 0.0529879614820738 </data>
                    <data bit_width="32"> 0.105474356685897 </data>
                    <data bit_width="128"> 0.500815066354411 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>

            <est_index name="aspect_ratio">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="height">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="width">
              <!-- Dummy yet -->
            </est_index>
          </est_type>

          <est_type name="timing">
            <est_index name="delay">
              <unit> ns </unit>

              <parameters name="">
                <max>
                  <data bit_width="1"> 0.75 </data>
                  <data bit_width="4"> 0.75 </data>
                  <data bit_width="8"> 0.75 </data>
                  <data bit_width="16"> 0.75 </data>
                  <data bit_width="32"> 0.75 </data>
                  <data bit_width="128"> 0.76 </data>
                </max>
                <min>
                  <data bit_width="1"> 0.72 </data>
                  <data bit_width="4"> 0.72 </data>
                  <data bit_width="8"> 0.72 </data>
                  <data bit_width="16"> 0.72 </data>
                  <data bit_width="32"> 0.72 </data>
                  <data bit_width="128"> 0.72 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1"> 0.75 </data>
                    <data bit_width="4"> 0.75 </data>
                    <data bit_width="8"> 0.75 </data>
                    <data bit_width="16"> 0.75 </data>
                    <data bit_width="32"> 0.75 </data>
                    <data bit_width="128"> 0.75 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1"> 0.72 </data>
                    <data bit_width="4"> 0.72 </data>
                    <data bit_width="8"> 0.72 </data>
                    <data bit_width="16"> 0.72 </data>
                    <data bit_width="32"> 0.72 </data>
                    <data bit_width="128"> 0.72 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1"> 0.75 </data>
                    <data bit_width="4"> 0.75 </data>
                    <data bit_width="8"> 0.75 </data>
                    <data bit_width="16"> 0.75 </data>
                    <data bit_width="32"> 0.75 </data>
                    <data bit_width="128"> 0.76 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>

            <est_index name="delay_fullpath">
              <unit> ns </unit>

	      <parameters name="">
                <max>
                  <data bit_width="1">
                    internal     0.67
                  </data>
                  <data bit_width="4">
                    inport   data_in     0.24
                    outport  data_out_reg    0.46
                    internal     0.67
                  </data>
                  <data bit_width="8">
                    inport   data_in     0.24
                    outport  data_out_reg    0.48
                    internal     0.70
                  </data>
                  <data bit_width="16">
                    inport   data_in     0.23
                    outport  data_out_reg    0.49
                    internal     0.70
                  </data>
                  <data bit_width="32">
                    inport   data_in     0.24
                    outport  data_out_reg    0.46
                    internal     0.67
                  </data>
                </max>
                <min>
                  <data bit_width="1">
                    internal     0.61
                  </data>
                  <data bit_width="4">
                    inport   data_in     0.24
                    outport  data_out_reg    0.46
                    internal     0.67
                  </data>
                  <data bit_width="8">
                    inport   data_in     0.24
                    outport  data_out_reg    0.48
                    internal     0.70
                  </data>
                  <data bit_width="16">
                    inport   data_in     0.23
                    outport  data_out_reg    0.49
                    internal     0.70
                  </data>
                  <data bit_width="32">
                    inport   data_in     0.24
                    outport  data_out_reg    0.46
                    internal     0.67
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1">
                      internal   0.70
                    </data>
                    <data bit_width="4">
                      inport     data_in     0.23
                      outport    data_out_reg    0.49
                      internal   0.70
                    </data>
                    <data bit_width="8">
                      inport     data_in     0.23
                      outport    data_out_reg    0.49
                      internal   0.70
                    </data>
                    <data bit_width="16">
                      inport     data_in     0.23
                      outport    data_out_reg    0.49
                      internal   0.70
                    </data>
                    <data bit_width="32">
                      inport     data_in     0.23
                      outport    data_out_reg    0.49
                      internal   0.70
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1">
                      internal   0.61
                    </data>
                    <data bit_width="4">
                      inport     data_in     0.39
                      outport    data_out_reg    0.46
                      internal   0.61
                    </data>
                    <data bit_width="8">
                      inport     data_in     0.39
                      outport    data_out_reg    0.46
                      internal   0.61
                    </data>
                    <data bit_width="16">
                      inport     data_in     0.39
                      outport    data_out_reg    0.46
                      internal   0.61
                    </data>
                    <data bit_width="32">
                      inport     data_in     0.39
                      outport    data_out_reg    0.46
                      internal   0.61
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1">
                      internal   0.67
                    </data>
                    <data bit_width="4">
                      inport     data_in     0.24
                      outport    data_out_reg    0.46
                      internal   0.67
                    </data>
                    <data bit_width="8">
                      inport     data_in     0.24
                      outport    data_out_reg    0.48
                      internal   0.70
                    </data>
                    <data bit_width="16">
                      inport     data_in     0.23
                      outport    data_out_reg    0.49
                      internal   0.70
                    </data>
                    <data bit_width="32">
                      inport     data_in     0.24
                      outport    data_out_reg    0.46
                      internal   0.67
                    </data>
                  </priority>
                </typ>
	    </parameters>


            </est_index>
          </est_type>

          <est_type name="power">
            <est_index name="static_power">
              <unit> mW </unit>
              <parameters name="">
                <max>
                  <data bit_width="1"> 0.6449194 </data>
                  <data bit_width="4"> 2.2203 </data>
                  <data bit_width="8"> 4.4270 </data>
                  <data bit_width="16"> 8.7214 </data>
                  <data bit_width="32"> 17.2327 </data>
                  <data bit_width="128"> 72.2256 </data>
                </max>
                <min>
                  <data bit_width="1"> 0.6026836 </data>
                  <data bit_width="4"> 2.2153 </data>
                  <data bit_width="8"> 4.3512 </data>
                  <data bit_width="16"> 8.5400 </data>
                  <data bit_width="32"> 17.0462 </data>
                  <data bit_width="128"> 70.1949 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="1"> 0.6028486 </data>
                    <data bit_width="4"> 2.2159 </data>
                    <data bit_width="8"> 4.4179 </data>
                    <data bit_width="16"> 8.7033 </data>
                    <data bit_width="32"> 17.2202 </data>
                    <data bit_width="128"> 71.6659 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="1"> 0.6449194 </data>
                    <data bit_width="4"> 2.2203 </data>
                    <data bit_width="8"> 4.4270 </data>
                    <data bit_width="16"> 8.7214 </data>
                    <data bit_width="32"> 17.2327 </data>
                    <data bit_width="128"> 72.2256 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="1"> 0.6026836 </data>
                    <data bit_width="4"> 2.2153 </data>
                    <data bit_width="8"> 4.3512 </data>
                    <data bit_width="16"> 8.5400 </data>
                    <data bit_width="32"> 17.0462 </data>
                    <data bit_width="128"> 70.1949 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>
          </est_type>

          <est_type name="function_cycle">
            <unit> cycle </unit>

            <est_index name="cycle">
              <parameters name="">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="write">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                <function name="read">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>
            </est_index>

            <est_index name="latency">
              <parameters name="">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="write">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                <function name="read">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>
            </est_index>

            <est_index name="throughput">
              <parameters name="">
                <function name="nop">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="reset">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="write">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
                <function name="read">
                  <priority name="area"><data bit_width="0">1</data></priority>
                  <priority name="delay"><data bit_width="0">1</data></priority>
                  <priority name="power"><data bit_width="0">1</data></priority>
                </function>
              </parameters>
            </est_index>

          </est_type>

          <est_type name="function_power">
            <!-- Dummy yet -->
          </est_type>
        </library>
      </estimation_data>

      <estimation_method>

        <est_type name="shape">

          <est_index name="area">

               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for reg(positive) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[2]")) {
    print STDOUT ("Data file '$ARGV[2]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
    $bit[$i]  = $1;
    $data[$i] = $2;
    $i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
    $ret_data = $data[$j];
    goto END;
    }
}

if ($bit_width < $bit[0]) {

    # divide by zero
    if ($bit[1] == $bit[0]) {
    exit(100);
    }

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
    exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
    $j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
    exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}


END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;

    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>

          </est_index>

           <est_index name="aspect_ratio">

             <!-- Dummy yet -->

           </est_index>

           <est_index name="height">

             <!-- Dummy yet -->

           </est_index>

           <est_index name="width">

             <!-- Dummy yet -->

           </est_index>

        </est_type>

        <est_type name="timing">

          <est_index name="delay">

               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for reg(positive) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[2]")) {
    print STDOUT ("Data file '$ARGV[2]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
    $bit[$i]  = $1;
    $data[$i] = $2;
    $i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
    $ret_data = $data[$j];
    goto END;
    }
}

if ($bit_width < $bit[0]) {

    # divide by zero
    if ($bit[1] == $bit[0]) {
    exit(100);
    }

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
    exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
    $j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
    exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}


END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;

    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>

          </est_index>

          <est_index name="delay_fullpath">

               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay_fullpath for reg(positive) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[2]")) {
    print STDOUT ("Data file '$ARGV[2]' not found.\n");
    exit(100);
}

$Round = 1;

#--------------------------------------------------------------------------#
# Type: Table lookup for delay_fullpath
#--------------------------------------------------------------------------#
$n = 0;

while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>/ ) {

    $bit_width = $1;
    $bit[$n]   = $bit_width;
    $n++;

    $_ = <TMP>;
    $i = 0;

    while (! /\<\s*\/data\s*\>/ ) {

        # path
        if ( /path\s+(\w+)\s+(\w+)\s+(\d+\.?\d+)/ ) {
        $line{$bit_width}[$i]  = "path\t $1\t $2\t ";
        $delay{$bit_width}[$i] = $3;
        $i++;
        }

        # inport
        if ( /inport\s+(\w+)\s+(\d+\.?\d+)/ ) {
        $line{$bit_width}[$i]  = "inport\t $1\t ";
        $delay{$bit_width}[$i] = $2;
        $i++;
        }

        # outport
         if ( /outport\s+(\w+)\s+(\d+\.?\d+)/ ) {
        $line{$bit_width}[$i]  = "outport\t $1\t ";
        $delay{$bit_width}[$i] = $2;
        $i++;
        }

        # internal
        if ( /internal\s+(\d+\.?\d+)/ ) {
        $line{$bit_width}[$i]  = "internal\t ";
        $delay{$bit_width}[$i] = $1;
        $i++;
        }

        $_ = <TMP>;
    }
    }
}
close(TMP);

$bit_width = $ARGV[1];
$line_num = $i;


for ($k = 0; $k < $line_num; $k++) {

    for ($j = 0; $j < $n; $j++) {
    if ($bit_width == $bit[$j]) {
        $ret_data = $delay{$bit_width}[$k];
        $ret_data = &data_round($ret_data, $Round);
        print "$line{$bit_width}[$k] $ret_data\n";
        goto NEXT;
    }
    }

    if ($bit_width < $bit[0]) {

    # divide by zero
    if ( $bit[1] - $bit[0] ) {
        exit(100);
    }

    $ret_data = $delay{$bit[0]}[$k] - (($delay{$bit[1]}[$k] - $delay{$bit[0]}[$k]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
    }

    elsif ($bit[$n-1] < $bit_width) {

    # divide by zero
    if ( $bit[$n-1] - $bit[$n-2] ) {
        exit(100);
    }

    $ret_data = $delay{$bit[$n-1]}[$k] + (($delay{$bit[$n-1]}[$k] - $delay{$bit[$n-2]}[$k]) / ($bit[$n-1] - $bit[$n-2])) * ($bit_width - $bit[$n-1]);
    }

    else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
        $j++;
    }

    # divide by zero
    if ( $bit[$j] - $bit[$j-1] ) {
        exit(100);
    }

    $ret_data = $delay{$bit[$j-1]}[$k] + (($delay{$bit[$j]}[$k] - $delay{$bit[$j-1]}[$k]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
    }

    $ret_data = &data_round($ret_data, $Round);
    print "$line{$bit[0]}[$k] $ret_data\n";


  NEXT:
}


exit(0);


sub data_round
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;

    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}


                ]]>
              </script>

          </est_index>

        </est_type>

        <est_type name="power">

          <est_index name="static_power">

               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for reg(positive) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[2]")) {
    print STDOUT ("Data file '$ARGV[2]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
    $bit[$i]  = $1;
    $data[$i] = $2;
    $i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
    $ret_data = $data[$j];
    goto END;
    }
}

if ($bit_width < $bit[0]) {

    # divide by zero
    if ($bit[1] == $bit[0]) {
    exit(100);
    }

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
    exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
    $j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
    exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}


END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;

    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>

          </est_index>

        </est_type>

        <est_type name="function_cycle">
          <est_index name="cycle">
            <parameters name="">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[1]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;
print "$tmp";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

          <est_index name="latency">
            <parameters name="">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[1]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;
print "$tmp";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

          <est_index name="throughput">
            <parameters name="">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[1]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="0">//;
$tmp =~ s/<\/data>//;
print "$tmp";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

        </est_type>

        <est_type name="function_power">

        </est_type>


      </estimation_method>

    </estimation>


  </model>
</FHM>
