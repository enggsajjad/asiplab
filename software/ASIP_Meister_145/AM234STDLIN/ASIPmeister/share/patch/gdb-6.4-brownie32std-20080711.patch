Index: config-ml.in
===================================================================
RCS file: /home/prj/asip/cvs/gdb/config-ml.in,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- config-ml.in	31 Jul 2007 11:40:20 -0000	1.1.1.1
+++ config-ml.in	8 Aug 2007 08:49:53 -0000	1.2
@@ -4,6 +4,8 @@
 # Copyright (C) 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
 #   Free Software Foundation, Inc.
 #
+# Copyright (C) 2005,2006  Upwind technology, Inc.
+#
 # This file is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
@@ -400,6 +402,64 @@ mips*-*-*)
 	  ;;
 	esac
 	;;
+brownie32*-*-*)
+	if [ x$enable_single_float = xno ]
+	then
+	  old_multidirs="${multidirs}"
+	  multidirs=""
+	  for x in ${old_multidirs}; do
+	    case "$x" in
+	      *single* ) : ;;
+	      *) multidirs="${multidirs} ${x}" ;;
+	    esac
+	  done
+	fi
+	if [ x$enable_biendian = xno ]
+	then
+	  old_multidirs="${multidirs}"
+	  multidirs=""
+	  for x in ${old_multidirs}; do
+	    case "$x" in
+	      *el* ) : ;;
+	      *eb* ) : ;;
+	      *) multidirs="${multidirs} ${x}" ;;
+	    esac
+	  done
+	fi
+	if [ x$enable_softfloat = xno ]
+	then
+	  old_multidirs="${multidirs}"
+	  multidirs=""
+	  for x in ${old_multidirs}; do
+	    case "$x" in
+	      *soft-float* ) : ;;
+	      *) multidirs="${multidirs} ${x}" ;;
+	    esac
+	  done
+	fi
+	case " $multidirs " in
+	*" mabi=64 "*)
+	  # We will not be able to create libraries with -mabi=64 if
+	  # we cannot even link a trivial program.  It usually
+	  # indicates the 64bit libraries are missing.
+	  if echo 'main() {}' > conftest.c &&
+	     ${CC-gcc} -mabi=64 conftest.c -o conftest; then
+	    :
+	  else
+	    echo Could not link program with -mabi=64, disabling it.
+	    old_multidirs="${multidirs}"
+	    multidirs=""
+	    for x in ${old_multidirs}; do
+	      case "$x" in
+	      *mabi=64* ) : ;;
+	      *) multidirs="${multidirs} ${x}" ;;
+	      esac
+	    done
+	  fi
+	  rm -f conftest.c conftest
+	  ;;
+	esac
+	;;
 powerpc*-*-* | rs6000*-*-*)
 	if [ x$enable_aix64 = xno ]
 	then
Index: config.guess
===================================================================
RCS file: /home/prj/asip/cvs/gdb/config.guess,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- config.guess	31 Jul 2007 11:40:21 -0000	1.1.1.1
+++ config.guess	8 Aug 2007 08:49:53 -0000	1.2
@@ -2,8 +2,10 @@
 # Attempt to guess a canonical system name.
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 #   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+#
+#   Copyright (C) 2005,2006  Upwind technology, Inc.
 
-timestamp='2005-07-08'
+timestamp='2006-10-17'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -434,6 +436,35 @@ EOF
 	    { echo "$SYSTEM_NAME"; exit; }
 	echo mips-mips-riscos${UNAME_RELEASE}
 	exit ;;
+    brownie32:*:*:UMIPS | brownie32:*:*:RISCos)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+#ifdef __cplusplus
+#include <stdio.h>  /* for printf() prototype */
+	int main (int argc, char *argv[]) {
+#else
+	int main (argc, argv) int argc; char *argv[]; {
+#endif
+	#if defined (host_brownie32) && defined (MIPSEB)
+	#if defined (SYSTYPE_SYSV)
+	  printf ("brownie32-brownie32-riscos%ssysv\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_SVR4)
+	  printf ("brownie32-brownie32-riscos%ssvr4\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
+	  printf ("brownie32-brownie32-riscos%sbsd\n", argv[1]); exit (0);
+	#endif
+	#endif
+	  exit (-1);
+	}
+EOF
+	$CC_FOR_BUILD -o $dummy $dummy.c &&
+	  dummyarg=`echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` &&
+	  SYSTEM_NAME=`$dummy $dummyarg` &&
+	    { echo "$SYSTEM_NAME"; exit; }
+	echo brownie32-brownie32-riscos${UNAME_RELEASE}
+	exit ;;
     Motorola:PowerMAX_OS:*:*)
 	echo powerpc-motorola-powermax
 	exit ;;
@@ -873,6 +904,44 @@ EOF
 	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
 	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
 	;;
+    brownie32:Linux:*:*)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#undef CPU
+	#undef brownie32
+	#undef brownie32el
+	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
+	CPU=brownie32el
+	#else
+	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
+	CPU=brownie32
+	#else
+	CPU=
+	#endif
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
+	;;
+    brownie3264:Linux:*:*)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#undef CPU
+	#undef brownie3264
+	#undef brownie3264el
+	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
+	CPU=brownie3264el
+	#else
+	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
+	CPU=brownie3264
+	#else
+	CPU=
+	#endif
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
+	;;
     ppc:Linux:*:*)
 	echo powerpc-unknown-linux-gnu
 	exit ;;
Index: config.h.in
===================================================================
RCS file: config.h.in
diff -N config.h.in
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ config.h.in	8 Aug 2007 08:49:53 -0000	1.1
@@ -0,0 +1 @@
+/* config.h.in.  Generated automatically from configure.in by autoheader.  */
Index: config.sub
===================================================================
RCS file: /home/prj/asip/cvs/gdb/config.sub,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- config.sub	31 Jul 2007 11:40:21 -0000	1.1.1.1
+++ config.sub	8 Aug 2007 08:49:53 -0000	1.2
@@ -2,8 +2,9 @@
 # Configuration validation subroutine script.
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 #   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+# Copyright (C) 2005,2006  Upwind technology, Inc.
 
-timestamp='2005-07-08'
+timestamp='2006-10-17'
 
 # This file is (in principle) common to ALL GNU software.
 # The presence of a machine in this file suggests that SOME GNU software
@@ -140,7 +141,7 @@ case $os in
 	-sun*os*)
 		# Prevent following clause from handling this invalid input.
 		;;
-	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
+	-dec* | -mips* | -brownie32* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
 	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
 	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
 	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
@@ -256,6 +257,22 @@ case $basic_machine in
 	| mipsisa64sb1 | mipsisa64sb1el \
 	| mipsisa64sr71k | mipsisa64sr71kel \
 	| mipstx39 | mipstx39el \
+	| brownie32 | brownie32be | brownie32eb | brownie32el | brownie32le \
+	| brownie3216 \
+	| brownie3264 | brownie3264el \
+	| brownie3264vr | brownie3264vrel \
+	| brownie3264orion | brownie3264orionel \
+	| brownie3264vr4100 | brownie3264vr4100el \
+	| brownie3264vr4300 | brownie3264vr4300el \
+	| brownie3264vr5000 | brownie3264vr5000el \
+	| brownie3264vr5900 | brownie3264vr5900el \
+	| brownie32isa32 | brownie32isa32el \
+	| brownie32isa32r2 | brownie32isa32r2el \
+	| brownie32isa64 | brownie32isa64el \
+	| brownie32isa64r2 | brownie32isa64r2el \
+	| brownie32isa64sb1 | brownie32isa64sb1el \
+	| brownie32isa64sr71k | brownie32isa64sr71kel \
+	| brownie32tx39 | brownie32tx39el \
 	| mn10200 | mn10300 \
 	| ms1 \
 	| msp430 \
@@ -335,6 +352,22 @@ case $basic_machine in
 	| mipsisa64sb1-* | mipsisa64sb1el-* \
 	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
 	| mipstx39-* | mipstx39el-* \
+	| brownie32-* | brownie32be-* | brownie32eb-* | brownie32el-* | brownie32le-* \
+	| brownie3216-* \
+	| brownie3264-* | brownie3264el-* \
+	| brownie3264vr-* | brownie3264vrel-* \
+	| brownie3264orion-* | brownie3264orionel-* \
+	| brownie3264vr4100-* | brownie3264vr4100el-* \
+	| brownie3264vr4300-* | brownie3264vr4300el-* \
+	| brownie3264vr5000-* | brownie3264vr5000el-* \
+	| brownie3264vr5900-* | brownie3264vr5900el-* \
+	| brownie32isa32-* | brownie32isa32el-* \
+	| brownie32isa32r2-* | brownie32isa32r2el-* \
+	| brownie32isa64-* | brownie32isa64el-* \
+	| brownie32isa64r2-* | brownie32isa64r2el-* \
+	| brownie32isa64sb1-* | brownie32isa64sb1el-* \
+	| brownie32isa64sr71k-* | brownie32isa64sr71kel-* \
+	| brownie32tx39-* | brownie32tx39el-* \
 	| mmix-* \
 	| ms1-* \
 	| msp430-* \
@@ -684,6 +717,12 @@ case $basic_machine in
 	mips3*)
 		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
 		;;
+	brownie323*-*)
+		basic_machine=`echo $basic_machine | sed -e 's/brownie323/brownie3264/'`
+		;;
+	brownie323*)
+		basic_machine=`echo $basic_machine | sed -e 's/brownie323/brownie3264/'`-unknown
+		;;
 	monitor)
 		basic_machine=m68k-rom68k
 		os=-coff
@@ -1383,6 +1422,12 @@ case $basic_machine in
 	mips*-*)
 		os=-elf
 		;;
+	brownie32*-cisco)
+		os=-elf
+		;;
+	brownie32*-*)
+		os=-elf
+		;;
 	or32-*)
 		os=-coff
 		;;
Index: configure
===================================================================
RCS file: /home/prj/asip/cvs/gdb/configure,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- configure	31 Jul 2007 11:40:21 -0000	1.1.1.1
+++ configure	8 Aug 2007 08:49:53 -0000	1.2
@@ -3,6 +3,8 @@
 # Guess values for system-dependent variables and create Makefiles.
 # Generated automatically using autoconf version 2.13 
 # Copyright (C) 1992, 93, 94, 95, 96 Free Software Foundation, Inc.
+# Copyright (C) 2005,2006  Upwind technology, Inc.
+#
 #
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
@@ -888,7 +890,7 @@ host_libs="intl mmalloc libiberty opcode
 # know that we are building the simulator.
 # binutils, gas and ld appear in that order because it makes sense to run
 # "make check" in that particular order.
-host_tools="texinfo byacc flex bison binutils gas ld fixincludes gcc sid sim gdb make patch prms send-pr gprof etc expect dejagnu ash bash bzip2 m4 autoconf automake libtool diff rcs fileutils shellutils time textutils wdiff find uudecode hello tar gzip indent recode release sed utils guile perl gawk findutils gettext zip fastjar gnattools"
+host_tools="byacc flex bison binutils gas ld fixincludes gcc sid sim gdb make patch prms send-pr gprof etc expect dejagnu ash bash bzip2 m4 autoconf automake libtool diff rcs fileutils shellutils time textutils wdiff find uudecode hello tar gzip indent recode release sed utils guile perl gawk findutils gettext zip fastjar gnattools"
 
 # libgcj represents the runtime libraries only used by gcj.
 libgcj="target-libffi \
@@ -1241,7 +1243,7 @@ case "${target}" in
   sh-*-linux*)
     noconfigdirs="$noconfigdirs ${libgcj} target-newlib target-libgloss"
     ;;    
-  sh*-*-pe|mips*-*-pe|*arm-wince-pe)
+  sh*-*-pe|mips*-*-pe|*arm-wince-pe|brownie32*-*-pe)
     noconfigdirs="$noconfigdirs ${libgcj}"
     noconfigdirs="$noconfigdirs target-examples"
     noconfigdirs="$noconfigdirs target-libiberty texinfo send-pr"
@@ -1515,6 +1517,9 @@ case "${target}" in
   mips*-*-irix5*)
     noconfigdirs="$noconfigdirs gprof target-libgloss ${libgcj}"
     ;;
+  brownie32*-*-irix5*)
+    noconfigdirs="$noconfigdirs gprof target-libgloss ${libgcj}"
+    ;;
   mips*-*-irix6*)
     # Linking libjava exceeds command-line length limits on at least
     # IRIX 6.2, but not on IRIX 6.5.
@@ -1522,24 +1527,49 @@ case "${target}" in
     # <oldham@codesourcery.com>
     noconfigdirs="$noconfigdirs gprof target-libgloss ${libgcj}"
     ;;
+  brownie32*-*-irix6*)
+    # Linking libjava exceeds command-line length limits on at least
+    # IRIX 6.2, but not on IRIX 6.5.
+    # Also, boehm-gc won't build on IRIX 6.5, according to Jeffrey Oldham
+    # <oldham@codesourcery.com>
+    noconfigdirs="$noconfigdirs gprof target-libgloss ${libgcj}"
+    ;;
   mips*-dec-bsd*)
     noconfigdirs="$noconfigdirs gprof target-libgloss ${libgcj}"
     ;;
+  brownie32*-dec-bsd*)
+    noconfigdirs="$noconfigdirs gprof target-libgloss ${libgcj}"
+    ;;
   mips*-*-bsd*)
     noconfigdirs="$noconfigdirs gprof target-libgloss ${libgcj}"
     ;;
+  brownie32*-*-bsd*)
+    noconfigdirs="$noconfigdirs gprof target-libgloss ${libgcj}"
+    ;;
   mipstx39-*-*)
     noconfigdirs="$noconfigdirs gprof ${libgcj}"   # same as generic mips
     ;;
+  brownie32tx39-*-*)
+    noconfigdirs="$noconfigdirs gprof ${libgcj}"   # same as generic mips
+    ;;
   mips64*-*-linux*)
     noconfigdirs="$noconfigdirs target-newlib ${libgcj}"
     ;;
+  brownie3264*-*-linux*)
+    noconfigdirs="$noconfigdirs target-newlib ${libgcj}"
+    ;;
   mips*-*-linux*)
     noconfigdirs="$noconfigdirs target-newlib target-libgloss"
     ;;
+  brownie32*-*-linux*)
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss"
+    ;;
   mips*-*-*)
     noconfigdirs="$noconfigdirs gprof ${libgcj}"
     ;;
+  brownie32*-*-*)
+    noconfigdirs="$noconfigdirs gprof ${libgcj}"
+    ;;
   romp-*-*)
     noconfigdirs="$noconfigdirs bfd binutils ld gas opcodes target-libgloss ${libgcj}"
     ;;
@@ -1655,20 +1685,38 @@ case "${host}" in
     tentative_cc="cc -Wf,-XNg1000"
     host_makefile_frag="config/mh-decstation"
     ;;
+  brownie32*-dec-ultrix*)
+    tentative_cc="cc -Wf,-XNg1000"
+    host_makefile_frag="config/mh-decstation"
+    ;;
   mips*-nec-sysv4*)
     # The C compiler on NEC MIPS SVR4 needs bigger tables.
     tentative_cc="cc -ZXNd=5000 -ZXNg=1000"
     host_makefile_frag="config/mh-necv4"
     ;;
+  brownie32*-nec-sysv4*)
+    # The C compiler on NEC MIPS SVR4 needs bigger tables.
+    tentative_cc="cc -ZXNd=5000 -ZXNg=1000"
+    host_makefile_frag="config/mh-necv4"
+    ;;
   mips*-sgi-irix4*)
     # Tell compiler to use K&R C.  We can't compile under the SGI Ansi
     # environment.  Also bump switch table size so that cp-parse will
     # compile.  Bump string length limit so linker builds.
     tentative_cc="cc -cckr -Wf,-XNg1500 -Wf,-XNk1000 -Wf,-XNh2000 -Wf,-XNl8192"
     ;;
+  brownie32*-sgi-irix4*)
+    # Tell compiler to use K&R C.  We can't compile under the SGI Ansi
+    # environment.  Also bump switch table size so that cp-parse will
+    # compile.  Bump string length limit so linker builds.
+    tentative_cc="cc -cckr -Wf,-XNg1500 -Wf,-XNk1000 -Wf,-XNh2000 -Wf,-XNl8192"
+    ;;
   mips*-*-sysv4*)
     host_makefile_frag="config/mh-sysv4"
     ;;
+  brownie32*-*-sysv4*)
+    host_makefile_frag="config/mh-sysv4"
+    ;;
   mips*-*-sysv*)
     # This is for a MIPS running RISC/os 4.52C.
 
@@ -1684,6 +1732,21 @@ case "${host}" in
     # option.
     tentative_cc="cc -systype sysv"
     ;;
+  brownie32*-*-sysv*)
+    # This is for a MIPS running RISC/os 4.52C.
+
+    # This is needed for GDB, but needs to be in the top-level make because
+    # if a library is compiled with the bsd headers and gets linked with the
+    # sysv system libraries all hell can break loose (e.g. a jmp_buf might be
+    # a different size).
+    # ptrace(2) apparently has problems in the BSD environment.  No workaround is
+    # known except to select the sysv environment.  Could we use /proc instead?
+    # These "sysv environments" and "bsd environments" often end up being a pain.
+    #
+    # This is not part of CFLAGS because perhaps not all C compilers have this
+    # option.
+    tentative_cc="cc -systype sysv"
+    ;;
   i370-ibm-opened*)
     tentative_cc="c89"
     ;;
@@ -1821,7 +1884,7 @@ else
   # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1825: checking for $ac_word" >&5
+echo "configure:1886: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1851,7 +1914,7 @@ if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1855: checking for $ac_word" >&5
+echo "configure:1916: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1902,7 +1965,7 @@ fi
       # Extract the first word of "cl", so it can be a program name with args.
 set dummy cl; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1906: checking for $ac_word" >&5
+echo "configure:1967: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1934,7 +1997,7 @@ fi
 fi
 
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:1938: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+echo "configure:1999: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
 
 ac_ext=c
 # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
@@ -1945,12 +2008,12 @@ cross_compiling=$ac_cv_prog_cc_cross
 
 cat > conftest.$ac_ext << EOF
 
-#line 1949 "configure"
+#line 2010 "configure"
 #include "confdefs.h"
 
 main(){return(0);}
 EOF
-if { (eval echo configure:1954: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2015: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   ac_cv_prog_cc_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
@@ -1976,12 +2039,12 @@ if test $ac_cv_prog_cc_works = no; then
   { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:1980: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:2041: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
 cross_compiling=$ac_cv_prog_cc_cross
 
 echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
-echo "configure:1985: checking whether we are using GNU C" >&5
+echo "configure:2046: checking whether we are using GNU C" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1990,7 +2053,7 @@ else
   yes;
 #endif
 EOF
-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1994: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:2055: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gcc=yes
 else
   ac_cv_prog_gcc=no
@@ -2009,7 +2072,7 @@ ac_test_CFLAGS="${CFLAGS+set}"
 ac_save_CFLAGS="$CFLAGS"
 CFLAGS=
 echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
-echo "configure:2013: checking whether ${CC-cc} accepts -g" >&5
+echo "configure:2074: checking whether ${CC-cc} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2076,7 +2139,7 @@ fi
 # Extract the first word of "${ac_tool_prefix}gnatbind", so it can be a program name with args.
 set dummy ${ac_tool_prefix}gnatbind; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2080: checking for $ac_word" >&5
+echo "configure:2141: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_GNATBIND'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2108,7 +2171,7 @@ if test -n "$ac_tool_prefix"; then
   # Extract the first word of "gnatbind", so it can be a program name with args.
 set dummy gnatbind; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2112: checking for $ac_word" >&5
+echo "configure:2173: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_GNATBIND'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2141,7 +2204,7 @@ fi
 fi
 
 echo $ac_n "checking whether compiler driver understands Ada""... $ac_c" 1>&6
-echo "configure:2145: checking whether compiler driver understands Ada" >&5
+echo "configure:2206: checking whether compiler driver understands Ada" >&5
 if eval "test \"`echo '$''{'acx_cv_cc_gcc_supports_ada'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2173,7 +2236,7 @@ else
 fi
 
 echo $ac_n "checking how to compare bootstrapped objects""... $ac_c" 1>&6
-echo "configure:2177: checking how to compare bootstrapped objects" >&5
+echo "configure:2238: checking how to compare bootstrapped objects" >&5
 if eval "test \"`echo '$''{'gcc_cv_prog_cmp_skip'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2271,9 +2334,9 @@ saved_CFLAGS="$CFLAGS"
 CFLAGS="$CFLAGS $gmpinc"
 # Check GMP actually works
 echo $ac_n "checking for correct version of gmp.h""... $ac_c" 1>&6
-echo "configure:2275: checking for correct version of gmp.h" >&5
+echo "configure:2336: checking for correct version of gmp.h" >&5
 cat > conftest.$ac_ext <<EOF
-#line 2277 "configure"
+#line 2338 "configure"
 #include "confdefs.h"
 #include "gmp.h"
 int main() {
@@ -2284,7 +2347,7 @@ choke me
 
 ; return 0; }
 EOF
-if { (eval echo configure:2288: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2349: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   echo "$ac_t""yes" 1>&6
 else
@@ -2297,12 +2360,12 @@ rm -f conftest*
 
 if test x"$have_gmp" = xyes; then
   echo $ac_n "checking for MPFR""... $ac_c" 1>&6
-echo "configure:2301: checking for MPFR" >&5
+echo "configure:2362: checking for MPFR" >&5
 
   saved_LIBS="$LIBS"
   LIBS="$LIBS $gmplibs"
   cat > conftest.$ac_ext <<EOF
-#line 2306 "configure"
+#line 2367 "configure"
 #include "confdefs.h"
 #include <gmp.h>
 #include <mpfr.h>
@@ -2310,7 +2373,7 @@ int main() {
 mpfr_t n; mpfr_init(n);
 ; return 0; }
 EOF
-if { (eval echo configure:2314: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2375: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   echo "$ac_t""yes" 1>&6
 else
@@ -2723,7 +2786,7 @@ case "${target}" in
     # ranlib from Darwin requires the -c flag to look at common symbols.
     extra_ranlibflags_for_target=" -c"
     ;;
-  mips*-*-pe | sh*-*-pe | *arm-wince-pe)
+  mips*-*-pe | sh*-*-pe | *arm-wince-pe | brownie32*-*-pe)
     target_makefile_frag="config/mt-wince"
     ;;
 esac
@@ -2794,9 +2857,9 @@ fi
 # Default to using --with-stabs for certain targets.
 if test x${with_stabs} = x ; then
   case "${target}" in
-  mips*-*-irix[56]*)
+  mips*-*-irix[56]* | brownie32*-*-irix[56]* )
     ;;
-  mips*-*-* | alpha*-*-osf*)
+  mips*-*-* | alpha*-*-osf* | brownie32*-*-* )
     with_stabs=yes;
     extra_host_args="${extra_host_args} --with-stabs"
     ;;
@@ -2825,7 +2888,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2829: checking for $ac_word" >&5
+echo "configure:2890: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CONFIGURED_BISON'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2860,7 +2923,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2864: checking for $ac_word" >&5
+echo "configure:2925: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CONFIGURED_YACC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2895,7 +2958,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2899: checking for $ac_word" >&5
+echo "configure:2960: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CONFIGURED_M4'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2930,7 +2993,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2934: checking for $ac_word" >&5
+echo "configure:2995: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CONFIGURED_FLEX'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2965,7 +3028,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2969: checking for $ac_word" >&5
+echo "configure:3030: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CONFIGURED_LEX'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3000,7 +3063,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:3004: checking for $ac_word" >&5
+echo "configure:3065: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CONFIGURED_MAKEINFO'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3521,7 +3584,7 @@ test -n "$target_alias" && ncn_target_to
     # Extract the first word of "${ncn_tool_prefix}${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_tool_prefix}${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:3525: checking for $ac_word" >&5
+echo "configure:3586: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_AR'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3552,7 +3615,7 @@ fi
     # Extract the first word of "${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:3556: checking for $ac_word" >&5
+echo "configure:3617: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_AR'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3596,7 +3659,7 @@ fi
     # Extract the first word of "${ncn_tool_prefix}${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_tool_prefix}${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:3600: checking for $ac_word" >&5
+echo "configure:3661: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_AS'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3627,7 +3690,7 @@ fi
     # Extract the first word of "${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:3631: checking for $ac_word" >&5
+echo "configure:3692: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_AS'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3671,7 +3734,7 @@ fi
     # Extract the first word of "${ncn_tool_prefix}${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_tool_prefix}${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:3675: checking for $ac_word" >&5
+echo "configure:3736: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_DLLTOOL'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3702,7 +3765,7 @@ fi
     # Extract the first word of "${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:3706: checking for $ac_word" >&5
+echo "configure:3767: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_DLLTOOL'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3746,7 +3809,7 @@ fi
     # Extract the first word of "${ncn_tool_prefix}${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_tool_prefix}${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:3750: checking for $ac_word" >&5
+echo "configure:3811: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_LD'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3777,7 +3840,7 @@ fi
     # Extract the first word of "${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:3781: checking for $ac_word" >&5
+echo "configure:3842: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_LD'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3821,7 +3884,7 @@ fi
     # Extract the first word of "${ncn_tool_prefix}${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_tool_prefix}${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:3825: checking for $ac_word" >&5
+echo "configure:3886: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_NM'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3852,7 +3915,7 @@ fi
     # Extract the first word of "${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:3856: checking for $ac_word" >&5
+echo "configure:3917: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_NM'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3896,7 +3959,7 @@ fi
     # Extract the first word of "${ncn_tool_prefix}${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_tool_prefix}${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:3900: checking for $ac_word" >&5
+echo "configure:3961: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3927,7 +3990,7 @@ fi
     # Extract the first word of "${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:3931: checking for $ac_word" >&5
+echo "configure:3992: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3966,7 +4029,7 @@ fi
     # Extract the first word of "${ncn_tool_prefix}${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_tool_prefix}${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:3970: checking for $ac_word" >&5
+echo "configure:4031: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_WINDRES'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3997,7 +4060,7 @@ fi
     # Extract the first word of "${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4001: checking for $ac_word" >&5
+echo "configure:4062: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_WINDRES'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4041,7 +4104,7 @@ fi
     # Extract the first word of "${ncn_tool_prefix}${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_tool_prefix}${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4045: checking for $ac_word" >&5
+echo "configure:4106: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_OBJCOPY'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4072,7 +4135,7 @@ fi
     # Extract the first word of "${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4076: checking for $ac_word" >&5
+echo "configure:4137: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_OBJCOPY'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4116,7 +4179,7 @@ fi
     # Extract the first word of "${ncn_tool_prefix}${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_tool_prefix}${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4120: checking for $ac_word" >&5
+echo "configure:4181: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_OBJDUMP'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4147,7 +4210,7 @@ fi
     # Extract the first word of "${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4151: checking for $ac_word" >&5
+echo "configure:4212: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_OBJDUMP'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4199,7 +4262,7 @@ fi
     # Extract the first word of "${ncn_target_tool_prefix}${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4203: checking for $ac_word" >&5
+echo "configure:4264: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_AR_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4230,7 +4293,7 @@ fi
     # Extract the first word of "${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4234: checking for $ac_word" >&5
+echo "configure:4295: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_AR_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4274,7 +4337,7 @@ fi
     # Extract the first word of "${ncn_target_tool_prefix}${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4278: checking for $ac_word" >&5
+echo "configure:4339: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_AS_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4305,7 +4368,7 @@ fi
     # Extract the first word of "${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4309: checking for $ac_word" >&5
+echo "configure:4370: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_AS_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4349,7 +4412,7 @@ fi
     # Extract the first word of "${ncn_target_tool_prefix}${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4353: checking for $ac_word" >&5
+echo "configure:4414: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4380,7 +4443,7 @@ fi
     # Extract the first word of "${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4384: checking for $ac_word" >&5
+echo "configure:4445: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4424,7 +4487,7 @@ fi
     # Extract the first word of "${ncn_target_tool_prefix}${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4428: checking for $ac_word" >&5
+echo "configure:4489: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CXX_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4455,7 +4518,7 @@ fi
     # Extract the first word of "${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4459: checking for $ac_word" >&5
+echo "configure:4520: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CXX_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4499,7 +4562,7 @@ fi
     # Extract the first word of "${ncn_target_tool_prefix}${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4503: checking for $ac_word" >&5
+echo "configure:4564: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_DLLTOOL_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4530,7 +4593,7 @@ fi
     # Extract the first word of "${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4534: checking for $ac_word" >&5
+echo "configure:4595: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_DLLTOOL_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4574,7 +4637,7 @@ fi
     # Extract the first word of "${ncn_target_tool_prefix}${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4578: checking for $ac_word" >&5
+echo "configure:4639: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_GCC_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4605,7 +4668,7 @@ fi
     # Extract the first word of "${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4609: checking for $ac_word" >&5
+echo "configure:4670: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_GCC_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4644,7 +4707,7 @@ fi
     # Extract the first word of "${ncn_target_tool_prefix}${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4648: checking for $ac_word" >&5
+echo "configure:4709: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_GCJ_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4675,7 +4738,7 @@ fi
     # Extract the first word of "${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4679: checking for $ac_word" >&5
+echo "configure:4740: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_GCJ_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4719,7 +4782,7 @@ fi
     # Extract the first word of "${ncn_target_tool_prefix}${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4723: checking for $ac_word" >&5
+echo "configure:4784: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_GFORTRAN_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4750,7 +4813,7 @@ fi
     # Extract the first word of "${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4754: checking for $ac_word" >&5
+echo "configure:4815: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_GFORTRAN_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4794,7 +4857,7 @@ fi
     # Extract the first word of "${ncn_target_tool_prefix}${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4798: checking for $ac_word" >&5
+echo "configure:4859: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_LD_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4825,7 +4888,7 @@ fi
     # Extract the first word of "${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4829: checking for $ac_word" >&5
+echo "configure:4890: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_LD_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4869,7 +4932,7 @@ fi
     # Extract the first word of "${ncn_target_tool_prefix}${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4873: checking for $ac_word" >&5
+echo "configure:4934: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_LIPO_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4900,7 +4963,7 @@ fi
     # Extract the first word of "${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4904: checking for $ac_word" >&5
+echo "configure:4965: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_LIPO_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4944,7 +5007,7 @@ fi
     # Extract the first word of "${ncn_target_tool_prefix}${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4948: checking for $ac_word" >&5
+echo "configure:5009: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_NM_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4975,7 +5038,7 @@ fi
     # Extract the first word of "${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4979: checking for $ac_word" >&5
+echo "configure:5040: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_NM_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -5019,7 +5082,7 @@ fi
     # Extract the first word of "${ncn_target_tool_prefix}${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:5023: checking for $ac_word" >&5
+echo "configure:5084: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_OBJDUMP_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -5050,7 +5113,7 @@ fi
     # Extract the first word of "${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:5054: checking for $ac_word" >&5
+echo "configure:5115: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_OBJDUMP_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -5094,7 +5157,7 @@ fi
     # Extract the first word of "${ncn_target_tool_prefix}${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:5098: checking for $ac_word" >&5
+echo "configure:5159: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_RANLIB_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -5125,7 +5188,7 @@ fi
     # Extract the first word of "${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:5129: checking for $ac_word" >&5
+echo "configure:5190: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_RANLIB_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -5164,7 +5227,7 @@ fi
     # Extract the first word of "${ncn_target_tool_prefix}${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:5168: checking for $ac_word" >&5
+echo "configure:5229: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_STRIP_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -5195,7 +5258,7 @@ fi
     # Extract the first word of "${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:5199: checking for $ac_word" >&5
+echo "configure:5260: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_STRIP_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -5239,7 +5302,7 @@ fi
     # Extract the first word of "${ncn_target_tool_prefix}${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:5243: checking for $ac_word" >&5
+echo "configure:5304: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_WINDRES_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -5270,7 +5333,7 @@ fi
     # Extract the first word of "${ncn_progname}", so it can be a program name with args.
 set dummy ${ncn_progname}; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:5274: checking for $ac_word" >&5
+echo "configure:5335: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_WINDRES_FOR_TARGET'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -5380,7 +5443,7 @@ RANLIB_FOR_TARGET=${RANLIB_FOR_TARGET}${
 NM_FOR_TARGET=${NM_FOR_TARGET}${extra_nmflags_for_target}
 
 echo $ac_n "checking whether to enable maintainer-specific portions of Makefiles""... $ac_c" 1>&6
-echo "configure:5384: checking whether to enable maintainer-specific portions of Makefiles" >&5
+echo "configure:5445: checking whether to enable maintainer-specific portions of Makefiles" >&5
 # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.
 if test "${enable_maintainer_mode+set}" = set; then
   enableval="$enable_maintainer_mode"
@@ -5427,7 +5490,7 @@ esac
 # gcc for stageN-gcc and stagePREV-gcc for stage(N-1).  In case this is not
 # possible, however, we can resort to mv.
 echo $ac_n "checking if symbolic links between directories work""... $ac_c" 1>&6
-echo "configure:5431: checking if symbolic links between directories work" >&5
+echo "configure:5492: checking if symbolic links between directories work" >&5
 if eval "test \"`echo '$''{'gcc_cv_prog_ln_s_dir'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
Index: configure.in
===================================================================
RCS file: /home/prj/asip/cvs/gdb/configure.in,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- configure.in	31 Jul 2007 11:40:20 -0000	1.1.1.1
+++ configure.in	8 Aug 2007 08:49:53 -0000	1.2
@@ -1,5 +1,6 @@
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,
 #   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+#   Copyright (C) 2005,2006  Upwind technology, Inc.
 #
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -449,7 +450,7 @@ case "${target}" in
   sh-*-linux*)
     noconfigdirs="$noconfigdirs ${libgcj} target-newlib target-libgloss"
     ;;    
-  sh*-*-pe|mips*-*-pe|*arm-wince-pe)
+  sh*-*-pe|mips*-*-pe|*arm-wince-pe|brownie32*-*-pe)
     noconfigdirs="$noconfigdirs ${libgcj}"
     noconfigdirs="$noconfigdirs target-examples"
     noconfigdirs="$noconfigdirs target-libiberty texinfo send-pr"
@@ -723,6 +724,9 @@ case "${target}" in
   mips*-*-irix5*)
     noconfigdirs="$noconfigdirs gprof target-libgloss ${libgcj}"
     ;;
+  brownie32*-*-irix5*)
+    noconfigdirs="$noconfigdirs gprof target-libgloss ${libgcj}"
+    ;;
   mips*-*-irix6*)
     # Linking libjava exceeds command-line length limits on at least
     # IRIX 6.2, but not on IRIX 6.5.
@@ -730,24 +734,49 @@ case "${target}" in
     # <oldham@codesourcery.com>
     noconfigdirs="$noconfigdirs gprof target-libgloss ${libgcj}"
     ;;
+  brownie32*-*-irix6*)
+    # Linking libjava exceeds command-line length limits on at least
+    # IRIX 6.2, but not on IRIX 6.5.
+    # Also, boehm-gc won't build on IRIX 6.5, according to Jeffrey Oldham
+    # <oldham@codesourcery.com>
+    noconfigdirs="$noconfigdirs gprof target-libgloss ${libgcj}"
+    ;;
   mips*-dec-bsd*)
     noconfigdirs="$noconfigdirs gprof target-libgloss ${libgcj}"
     ;;
+  brownie32*-dec-bsd*)
+    noconfigdirs="$noconfigdirs gprof target-libgloss ${libgcj}"
+    ;;
   mips*-*-bsd*)
     noconfigdirs="$noconfigdirs gprof target-libgloss ${libgcj}"
     ;;
+  brownie32*-*-bsd*)
+    noconfigdirs="$noconfigdirs gprof target-libgloss ${libgcj}"
+    ;;
   mipstx39-*-*)
     noconfigdirs="$noconfigdirs gprof ${libgcj}"   # same as generic mips
     ;;
+  brownie32tx39-*-*)
+    noconfigdirs="$noconfigdirs gprof ${libgcj}"   # same as generic mips
+    ;;
   mips64*-*-linux*)
     noconfigdirs="$noconfigdirs target-newlib ${libgcj}"
     ;;
+  brownie3264*-*-linux*)
+    noconfigdirs="$noconfigdirs target-newlib ${libgcj}"
+    ;;
   mips*-*-linux*)
     noconfigdirs="$noconfigdirs target-newlib target-libgloss"
     ;;
+  brownie32*-*-linux*)
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss"
+    ;;
   mips*-*-*)
     noconfigdirs="$noconfigdirs gprof ${libgcj}"
     ;;
+  brownie32*-*-*)
+    noconfigdirs="$noconfigdirs gprof ${libgcj}"
+    ;;
   romp-*-*)
     noconfigdirs="$noconfigdirs bfd binutils ld gas opcodes target-libgloss ${libgcj}"
     ;;
@@ -863,20 +892,38 @@ case "${host}" in
     tentative_cc="cc -Wf,-XNg1000"
     host_makefile_frag="config/mh-decstation"
     ;;
+  brownie32*-dec-ultrix*)
+    tentative_cc="cc -Wf,-XNg1000"
+    host_makefile_frag="config/mh-decstation"
+    ;;
   mips*-nec-sysv4*)
     # The C compiler on NEC MIPS SVR4 needs bigger tables.
     tentative_cc="cc -ZXNd=5000 -ZXNg=1000"
     host_makefile_frag="config/mh-necv4"
     ;;
+  brownie32*-nec-sysv4*)
+    # The C compiler on NEC MIPS SVR4 needs bigger tables.
+    tentative_cc="cc -ZXNd=5000 -ZXNg=1000"
+    host_makefile_frag="config/mh-necv4"
+    ;;
   mips*-sgi-irix4*)
     # Tell compiler to use K&R C.  We can't compile under the SGI Ansi
     # environment.  Also bump switch table size so that cp-parse will
     # compile.  Bump string length limit so linker builds.
     tentative_cc="cc -cckr -Wf,-XNg1500 -Wf,-XNk1000 -Wf,-XNh2000 -Wf,-XNl8192"
     ;;
+  brownie32*-sgi-irix4*)
+    # Tell compiler to use K&R C.  We can't compile under the SGI Ansi
+    # environment.  Also bump switch table size so that cp-parse will
+    # compile.  Bump string length limit so linker builds.
+    tentative_cc="cc -cckr -Wf,-XNg1500 -Wf,-XNk1000 -Wf,-XNh2000 -Wf,-XNl8192"
+    ;;
   mips*-*-sysv4*)
     host_makefile_frag="config/mh-sysv4"
     ;;
+  brownie32*-*-sysv4*)
+    host_makefile_frag="config/mh-sysv4"
+    ;;
   mips*-*-sysv*)
     # This is for a MIPS running RISC/os 4.52C.
 
@@ -892,6 +939,21 @@ case "${host}" in
     # option.
     tentative_cc="cc -systype sysv"
     ;;
+  brownie32*-*-sysv*)
+    # This is for a MIPS running RISC/os 4.52C.
+
+    # This is needed for GDB, but needs to be in the top-level make because
+    # if a library is compiled with the bsd headers and gets linked with the
+    # sysv system libraries all hell can break loose (e.g. a jmp_buf might be
+    # a different size).
+    # ptrace(2) apparently has problems in the BSD environment.  No workaround is
+    # known except to select the sysv environment.  Could we use /proc instead?
+    # These "sysv environments" and "bsd environments" often end up being a pain.
+    #
+    # This is not part of CFLAGS because perhaps not all C compilers have this
+    # option.
+    tentative_cc="cc -systype sysv"
+    ;;
   i370-ibm-opened*)
     tentative_cc="c89"
     ;;
@@ -1518,7 +1580,7 @@ case "${target}" in
     # ranlib from Darwin requires the -c flag to look at common symbols.
     extra_ranlibflags_for_target=" -c"
     ;;
-  mips*-*-pe | sh*-*-pe | *arm-wince-pe)
+  mips*-*-pe | sh*-*-pe | *arm-wince-pe | brownie32*-*-pe)
     target_makefile_frag="config/mt-wince"
     ;;
 esac
@@ -1589,9 +1651,9 @@ fi
 # Default to using --with-stabs for certain targets.
 if test x${with_stabs} = x ; then
   case "${target}" in
-  mips*-*-irix[[56]]*)
+  mips*-*-irix[[56]]* | brownie32*-*-irix[[56]]* )
     ;;
-  mips*-*-* | alpha*-*-osf*)
+  mips*-*-* | alpha*-*-osf* | brownie32*-*-* )
     with_stabs=yes;
     extra_host_args="${extra_host_args} --with-stabs"
     ;;
Index: bfd/Makefile.am
===================================================================
RCS file: /home/prj/asip/cvs/gdb/bfd/Makefile.am,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- bfd/Makefile.am	31 Jul 2007 11:40:32 -0000	1.1.1.1
+++ bfd/Makefile.am	8 Aug 2007 08:49:53 -0000	1.2
@@ -88,6 +88,7 @@ ALL_MACHINES = \
 	cpu-maxq.lo \
 	cpu-mcore.lo \
 	cpu-mips.lo \
+	cpu-brownie32.lo \
 	cpu-mmix.lo \
 	cpu-ms1.lo \
 	cpu-msp430.lo \
@@ -149,6 +150,7 @@ ALL_MACHINES_CFILES = \
 	cpu-maxq.c \
 	cpu-mcore.c \
 	cpu-mips.c \
+	cpu-brownie32.c \
 	cpu-mmix.c \
 	cpu-ms1.c \
 	cpu-msp430.c \
@@ -203,6 +205,7 @@ BFD32_BACKENDS = \
 	coff-m88k.lo \
 	coff-maxq.lo \
 	coff-mips.lo \
+	coff-brownie32.lo \
 	coff-or32.lo \
 	coff-rs6000.lo \
 	coff-sh.lo \
@@ -258,6 +261,8 @@ BFD32_BACKENDS = \
 	elf32-mcore.lo \
 	elfxx-mips.lo \
 	elf32-mips.lo \
+	elfxx-brownie32.lo \
+	elf32-brownie32.lo \
 	elf32-ms1.lo \
 	elf32-msp430.lo \
 	elf32-openrisc.lo \
@@ -303,6 +308,7 @@ BFD32_BACKENDS = \
 	m88kopenbsd.lo \
 	mach-o.lo \
 	mipsbsd.lo \
+	brownie32bsd.lo \
 	newsos3.lo \
 	nlm.lo \
 	nlm32-i386.lo \
@@ -326,6 +332,8 @@ BFD32_BACKENDS = \
 	pei-sh.lo \
 	pe-mips.lo \
 	pei-mips.lo \
+	pe-brownie32.lo \
+	pei-brownie32.lo \
 	peigen.lo \
 	ppcboot.lo \
 	reloc16.lo \
@@ -374,6 +382,7 @@ BFD32_BACKENDS_CFILES = \
 	coff-m88k.c \
 	coff-maxq.c \
 	coff-mips.c \
+	coff-brownie32.c \
 	coff-or32.c \
 	coff-rs6000.c \
 	coff-sh.c \
@@ -429,6 +438,8 @@ BFD32_BACKENDS_CFILES = \
 	elf32-mcore.c \
 	elfxx-mips.c \
 	elf32-mips.c \
+	elfxx-brownie32.c \
+	elf32-brownie32.c \
 	elf32-ms1.c \
 	elf32-msp430.c \
 	elf32-openrisc.c \
@@ -474,6 +485,7 @@ BFD32_BACKENDS_CFILES = \
 	m88kopenbsd.c \
 	mach-o.c \
 	mipsbsd.c \
+	brownie32bsd.c \
 	newsos3.c \
 	nlm.c \
 	nlm32-i386.c \
@@ -497,6 +509,8 @@ BFD32_BACKENDS_CFILES = \
 	pei-sh.c \
 	pe-mips.c \
 	pei-mips.c \
+	pe-brownie32.c \
+	pei-brownie32.c \
 	ppcboot.c \
 	reloc16.c \
 	riscix.c \
@@ -538,6 +552,8 @@ BFD64_BACKENDS = \
 	elf64-gen.lo \
 	elfn32-mips.lo \
 	elf64-mips.lo \
+	elfn32-brownie32.lo \
+	elf64-brownie32.lo \
 	elf64-mmix.lo \
 	elf64-sh64.lo \
 	elf64-ppc.lo \
@@ -562,6 +578,8 @@ BFD64_BACKENDS_CFILES = \
 	elf64-gen.c \
 	elfn32-mips.c \
 	elf64-mips.c \
+	elfn32-brownie32.c \
+	elf64-brownie32.c \
 	elf64-mmix.c \
 	elf64-ppc.c \
 	elf64-s390.c \
@@ -1003,6 +1021,7 @@ cpu-m10300.lo: cpu-m10300.c $(INCDIR)/fi
 cpu-maxq.lo: cpu-maxq.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-mcore.lo: cpu-mcore.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-mips.lo: cpu-mips.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
+cpu-brownie32.lo: cpu-brownie32.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-mmix.lo: cpu-mmix.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-ms1.lo: cpu-ms1.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-msp430.lo: cpu-msp430.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
@@ -1126,6 +1145,11 @@ coff-mips.lo: coff-mips.c $(INCDIR)/file
   $(INCDIR)/coff/symconst.h $(INCDIR)/coff/ecoff.h $(INCDIR)/coff/mips.h \
   $(INCDIR)/coff/external.h libcoff.h libecoff.h coffswap.h \
   ecoffswap.h
+coff-brownie32.lo: coff-brownie32.c $(INCDIR)/filenames.h $(INCDIR)/bfdlink.h \
+  $(INCDIR)/hashtab.h $(INCDIR)/coff/internal.h $(INCDIR)/coff/sym.h \
+  $(INCDIR)/coff/symconst.h $(INCDIR)/coff/ecoff.h $(INCDIR)/coff/brownie32.h \
+  $(INCDIR)/coff/external.h libcoff.h libecoff.h coffswap.h \
+  ecoffswap.h
 coff-or32.lo: coff-or32.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   $(INCDIR)/coff/or32.h $(INCDIR)/coff/internal.h libcoff.h \
   $(INCDIR)/bfdlink.h coffcode.h coffswap.h
@@ -1351,6 +1375,19 @@ elf32-mips.lo: elf32-mips.c $(INCDIR)/fi
   $(INCDIR)/coff/symconst.h $(INCDIR)/coff/internal.h \
   $(INCDIR)/coff/ecoff.h $(INCDIR)/coff/mips.h $(INCDIR)/coff/external.h \
   ecoffswap.h elf32-target.h
+elfxx-brownie32.lo: elfxx-brownie32.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
+  $(INCDIR)/libiberty.h elf-bfd.h $(INCDIR)/elf/common.h \
+  $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h \
+  elfxx-brownie32.h $(INCDIR)/elf/brownie32.h $(INCDIR)/elf/reloc-macros.h \
+  $(INCDIR)/coff/sym.h $(INCDIR)/coff/symconst.h $(INCDIR)/coff/ecoff.h \
+  $(INCDIR)/coff/brownie32.h $(INCDIR)/coff/external.h
+elf32-brownie32.lo: elf32-brownie32.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
+  $(INCDIR)/bfdlink.h genlink.h elf-bfd.h $(INCDIR)/elf/common.h \
+  $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h elfxx-brownie32.h \
+  $(INCDIR)/elf/brownie32.h $(INCDIR)/elf/reloc-macros.h $(INCDIR)/coff/sym.h \
+  $(INCDIR)/coff/symconst.h $(INCDIR)/coff/internal.h \
+  $(INCDIR)/coff/ecoff.h $(INCDIR)/coff/brownie32.h $(INCDIR)/coff/external.h \
+  ecoffswap.h elf32-target.h
 elf32-ms1.lo: elf32-ms1.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
   $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(INCDIR)/elf/ms1.h \
@@ -1530,6 +1567,9 @@ mach-o.lo: mach-o.c mach-o.h $(INCDIR)/f
 mipsbsd.lo: mipsbsd.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   libaout.h $(INCDIR)/bfdlink.h aout-target.h $(INCDIR)/aout/aout64.h \
   $(INCDIR)/aout/stab_gnu.h $(INCDIR)/aout/stab.def $(INCDIR)/aout/ar.h
+brownie32bsd.lo: brownie32bsd.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
+  libaout.h $(INCDIR)/bfdlink.h aout-target.h $(INCDIR)/aout/aout64.h \
+  $(INCDIR)/aout/stab_gnu.h $(INCDIR)/aout/stab.def $(INCDIR)/aout/ar.h
 newsos3.lo: newsos3.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   $(INCDIR)/aout/aout64.h $(INCDIR)/aout/stab_gnu.h $(INCDIR)/aout/stab.def \
   $(INCDIR)/aout/ar.h libaout.h $(INCDIR)/bfdlink.h aout-target.h
@@ -1617,6 +1657,14 @@ pei-mips.lo: pei-mips.c $(INCDIR)/filena
   $(INCDIR)/hashtab.h $(INCDIR)/coff/mipspe.h $(INCDIR)/coff/external.h \
   $(INCDIR)/coff/internal.h $(INCDIR)/coff/pe.h libcoff.h \
   $(INCDIR)/bfdlink.h coffcode.h peicode.h libpei.h
+pe-brownie32.lo: pe-brownie32.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
+  $(INCDIR)/coff/brownie32pe.h $(INCDIR)/coff/external.h $(INCDIR)/coff/internal.h \
+  $(INCDIR)/coff/pe.h libcoff.h $(INCDIR)/bfdlink.h coffcode.h \
+  peicode.h libpei.h
+pei-brownie32.lo: pei-brownie32.c $(INCDIR)/filenames.h pe-brownie32.c \
+  $(INCDIR)/hashtab.h $(INCDIR)/coff/brownie32pe.h $(INCDIR)/coff/external.h \
+  $(INCDIR)/coff/internal.h $(INCDIR)/coff/pe.h libcoff.h \
+  $(INCDIR)/bfdlink.h coffcode.h peicode.h libpei.h
 ppcboot.lo: ppcboot.c $(INCDIR)/safe-ctype.h $(INCDIR)/filenames.h \
   $(INCDIR)/hashtab.h
 reloc16.lo: reloc16.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
@@ -1728,6 +1776,20 @@ elf64-mips.lo: elf64-mips.c $(INCDIR)/fi
   $(INCDIR)/coff/sym.h $(INCDIR)/coff/symconst.h $(INCDIR)/coff/internal.h \
   $(INCDIR)/coff/ecoff.h $(INCDIR)/coff/alpha.h ecoffswap.h \
   elf64-target.h
+elfn32-brownie32.lo: elfn32-brownie32.c $(INCDIR)/filenames.h \
+  $(INCDIR)/hashtab.h $(INCDIR)/bfdlink.h genlink.h elf-bfd.h \
+  $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
+  elfxx-brownie32.h $(INCDIR)/elf/brownie32.h $(INCDIR)/elf/reloc-macros.h \
+  $(INCDIR)/coff/sym.h $(INCDIR)/coff/symconst.h $(INCDIR)/coff/internal.h \
+  $(INCDIR)/coff/ecoff.h $(INCDIR)/coff/brownie32.h $(INCDIR)/coff/external.h \
+  ecoffswap.h elf32-target.h
+elf64-brownie32.lo: elf64-brownie32.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
+  $(INCDIR)/aout/ar.h $(INCDIR)/bfdlink.h genlink.h elf-bfd.h \
+  $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
+  elfxx-brownie32.h $(INCDIR)/elf/brownie32.h $(INCDIR)/elf/reloc-macros.h \
+  $(INCDIR)/coff/sym.h $(INCDIR)/coff/symconst.h $(INCDIR)/coff/internal.h \
+  $(INCDIR)/coff/ecoff.h $(INCDIR)/coff/alpha.h ecoffswap.h \
+  elf64-target.h
 elf64-mmix.lo: elf64-mmix.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
   $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(INCDIR)/elf/mmix.h \
Index: bfd/Makefile.in
===================================================================
RCS file: /home/prj/asip/cvs/gdb/bfd/Makefile.in,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- bfd/Makefile.in	31 Jul 2007 11:40:33 -0000	1.1.1.1
+++ bfd/Makefile.in	8 Aug 2007 08:49:53 -0000	1.2
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.9.5 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
@@ -15,8 +15,6 @@
 @SET_MAKE@
 
 
-SOURCES = $(libbfd_a_SOURCES) $(libbfd_la_SOURCES)
-
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
@@ -40,6 +38,7 @@ POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
 target_triplet = @target@
+LIBOBJDIR =
 DIST_COMMON = $(srcdir)/../config.guess $(srcdir)/../config.sub README \
 	ChangeLog $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
 	$(top_srcdir)/configure $(am__configure_deps) \
@@ -325,6 +324,7 @@ ALL_MACHINES = \
 	cpu-maxq.lo \
 	cpu-mcore.lo \
 	cpu-mips.lo \
+	cpu-brownie32.lo \
 	cpu-mmix.lo \
 	cpu-ms1.lo \
 	cpu-msp430.lo \
@@ -386,6 +386,7 @@ ALL_MACHINES_CFILES = \
 	cpu-maxq.c \
 	cpu-mcore.c \
 	cpu-mips.c \
+	cpu-brownie32.c \
 	cpu-mmix.c \
 	cpu-ms1.c \
 	cpu-msp430.c \
@@ -441,6 +442,7 @@ BFD32_BACKENDS = \
 	coff-m88k.lo \
 	coff-maxq.lo \
 	coff-mips.lo \
+	coff-brownie32.lo \
 	coff-or32.lo \
 	coff-rs6000.lo \
 	coff-sh.lo \
@@ -496,6 +498,8 @@ BFD32_BACKENDS = \
 	elf32-mcore.lo \
 	elfxx-mips.lo \
 	elf32-mips.lo \
+	elfxx-brownie32.lo \
+	elf32-brownie32.lo \
 	elf32-ms1.lo \
 	elf32-msp430.lo \
 	elf32-openrisc.lo \
@@ -541,6 +545,7 @@ BFD32_BACKENDS = \
 	m88kopenbsd.lo \
 	mach-o.lo \
 	mipsbsd.lo \
+	brownie32bsd.lo \
 	newsos3.lo \
 	nlm.lo \
 	nlm32-i386.lo \
@@ -564,6 +569,8 @@ BFD32_BACKENDS = \
 	pei-sh.lo \
 	pe-mips.lo \
 	pei-mips.lo \
+	pe-brownie32.lo \
+	pei-brownie32.lo \
 	peigen.lo \
 	ppcboot.lo \
 	reloc16.lo \
@@ -612,6 +619,7 @@ BFD32_BACKENDS_CFILES = \
 	coff-m88k.c \
 	coff-maxq.c \
 	coff-mips.c \
+	coff-brownie32.c \
 	coff-or32.c \
 	coff-rs6000.c \
 	coff-sh.c \
@@ -667,6 +675,8 @@ BFD32_BACKENDS_CFILES = \
 	elf32-mcore.c \
 	elfxx-mips.c \
 	elf32-mips.c \
+	elfxx-brownie32.c \
+	elf32-brownie32.c \
 	elf32-ms1.c \
 	elf32-msp430.c \
 	elf32-openrisc.c \
@@ -712,6 +722,7 @@ BFD32_BACKENDS_CFILES = \
 	m88kopenbsd.c \
 	mach-o.c \
 	mipsbsd.c \
+	brownie32bsd.c \
 	newsos3.c \
 	nlm.c \
 	nlm32-i386.c \
@@ -735,6 +746,8 @@ BFD32_BACKENDS_CFILES = \
 	pei-sh.c \
 	pe-mips.c \
 	pei-mips.c \
+	pe-brownie32.c \
+	pei-brownie32.c \
 	ppcboot.c \
 	reloc16.c \
 	riscix.c \
@@ -777,6 +790,8 @@ BFD64_BACKENDS = \
 	elf64-gen.lo \
 	elfn32-mips.lo \
 	elf64-mips.lo \
+	elfn32-brownie32.lo \
+	elf64-brownie32.lo \
 	elf64-mmix.lo \
 	elf64-sh64.lo \
 	elf64-ppc.lo \
@@ -801,6 +816,8 @@ BFD64_BACKENDS_CFILES = \
 	elf64-gen.c \
 	elfn32-mips.c \
 	elf64-mips.c \
+	elfn32-brownie32.c \
+	elf64-brownie32.c \
 	elf64-mmix.c \
 	elf64-ppc.c \
 	elf64-s390.c \
@@ -1570,6 +1587,7 @@ cpu-m10300.lo: cpu-m10300.c $(INCDIR)/fi
 cpu-maxq.lo: cpu-maxq.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-mcore.lo: cpu-mcore.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-mips.lo: cpu-mips.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
+cpu-brownie32.lo: cpu-brownie32.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-mmix.lo: cpu-mmix.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-ms1.lo: cpu-ms1.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-msp430.lo: cpu-msp430.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
@@ -1693,6 +1711,11 @@ coff-mips.lo: coff-mips.c $(INCDIR)/file
   $(INCDIR)/coff/symconst.h $(INCDIR)/coff/ecoff.h $(INCDIR)/coff/mips.h \
   $(INCDIR)/coff/external.h libcoff.h libecoff.h coffswap.h \
   ecoffswap.h
+coff-brownie32.lo: coff-brownie32.c $(INCDIR)/filenames.h $(INCDIR)/bfdlink.h \
+  $(INCDIR)/hashtab.h $(INCDIR)/coff/internal.h $(INCDIR)/coff/sym.h \
+  $(INCDIR)/coff/symconst.h $(INCDIR)/coff/ecoff.h $(INCDIR)/coff/brownie32.h \
+  $(INCDIR)/coff/external.h libcoff.h libecoff.h coffswap.h \
+  ecoffswap.h
 coff-or32.lo: coff-or32.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   $(INCDIR)/coff/or32.h $(INCDIR)/coff/internal.h libcoff.h \
   $(INCDIR)/bfdlink.h coffcode.h coffswap.h
@@ -1918,6 +1941,19 @@ elf32-mips.lo: elf32-mips.c $(INCDIR)/fi
   $(INCDIR)/coff/symconst.h $(INCDIR)/coff/internal.h \
   $(INCDIR)/coff/ecoff.h $(INCDIR)/coff/mips.h $(INCDIR)/coff/external.h \
   ecoffswap.h elf32-target.h
+elfxx-brownie32.lo: elfxx-brownie32.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
+  $(INCDIR)/libiberty.h elf-bfd.h $(INCDIR)/elf/common.h \
+  $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h \
+  elfxx-brownie32.h $(INCDIR)/elf/brownie32.h $(INCDIR)/elf/reloc-macros.h \
+  $(INCDIR)/coff/sym.h $(INCDIR)/coff/symconst.h $(INCDIR)/coff/ecoff.h \
+  $(INCDIR)/coff/brownie32.h $(INCDIR)/coff/external.h
+elf32-brownie32.lo: elf32-brownie32.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
+  $(INCDIR)/bfdlink.h genlink.h elf-bfd.h $(INCDIR)/elf/common.h \
+  $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h elfxx-brownie32.h \
+  $(INCDIR)/elf/brownie32.h $(INCDIR)/elf/reloc-macros.h $(INCDIR)/coff/sym.h \
+  $(INCDIR)/coff/symconst.h $(INCDIR)/coff/internal.h \
+  $(INCDIR)/coff/ecoff.h $(INCDIR)/coff/brownie32.h $(INCDIR)/coff/external.h \
+  ecoffswap.h elf32-target.h
 elf32-ms1.lo: elf32-ms1.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
   $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(INCDIR)/elf/ms1.h \
@@ -2097,6 +2133,9 @@ mach-o.lo: mach-o.c mach-o.h $(INCDIR)/f
 mipsbsd.lo: mipsbsd.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   libaout.h $(INCDIR)/bfdlink.h aout-target.h $(INCDIR)/aout/aout64.h \
   $(INCDIR)/aout/stab_gnu.h $(INCDIR)/aout/stab.def $(INCDIR)/aout/ar.h
+brownie32bsd.lo: brownie32bsd.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
+  libaout.h $(INCDIR)/bfdlink.h aout-target.h $(INCDIR)/aout/aout64.h \
+  $(INCDIR)/aout/stab_gnu.h $(INCDIR)/aout/stab.def $(INCDIR)/aout/ar.h
 newsos3.lo: newsos3.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   $(INCDIR)/aout/aout64.h $(INCDIR)/aout/stab_gnu.h $(INCDIR)/aout/stab.def \
   $(INCDIR)/aout/ar.h libaout.h $(INCDIR)/bfdlink.h aout-target.h
@@ -2184,6 +2223,14 @@ pei-mips.lo: pei-mips.c $(INCDIR)/filena
   $(INCDIR)/hashtab.h $(INCDIR)/coff/mipspe.h $(INCDIR)/coff/external.h \
   $(INCDIR)/coff/internal.h $(INCDIR)/coff/pe.h libcoff.h \
   $(INCDIR)/bfdlink.h coffcode.h peicode.h libpei.h
+pe-brownie32.lo: pe-brownie32.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
+  $(INCDIR)/coff/brownie32pe.h $(INCDIR)/coff/external.h $(INCDIR)/coff/internal.h \
+  $(INCDIR)/coff/pe.h libcoff.h $(INCDIR)/bfdlink.h coffcode.h \
+  peicode.h libpei.h
+pei-brownie32.lo: pei-brownie32.c $(INCDIR)/filenames.h pe-brownie32.c \
+  $(INCDIR)/hashtab.h $(INCDIR)/coff/brownie32pe.h $(INCDIR)/coff/external.h \
+  $(INCDIR)/coff/internal.h $(INCDIR)/coff/pe.h libcoff.h \
+  $(INCDIR)/bfdlink.h coffcode.h peicode.h libpei.h
 ppcboot.lo: ppcboot.c $(INCDIR)/safe-ctype.h $(INCDIR)/filenames.h \
   $(INCDIR)/hashtab.h
 reloc16.lo: reloc16.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
@@ -2295,6 +2342,20 @@ elf64-mips.lo: elf64-mips.c $(INCDIR)/fi
   $(INCDIR)/coff/sym.h $(INCDIR)/coff/symconst.h $(INCDIR)/coff/internal.h \
   $(INCDIR)/coff/ecoff.h $(INCDIR)/coff/alpha.h ecoffswap.h \
   elf64-target.h
+elfn32-brownie32.lo: elfn32-brownie32.c $(INCDIR)/filenames.h \
+  $(INCDIR)/hashtab.h $(INCDIR)/bfdlink.h genlink.h elf-bfd.h \
+  $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
+  elfxx-brownie32.h $(INCDIR)/elf/brownie32.h $(INCDIR)/elf/reloc-macros.h \
+  $(INCDIR)/coff/sym.h $(INCDIR)/coff/symconst.h $(INCDIR)/coff/internal.h \
+  $(INCDIR)/coff/ecoff.h $(INCDIR)/coff/brownie32.h $(INCDIR)/coff/external.h \
+  ecoffswap.h elf32-target.h
+elf64-brownie32.lo: elf64-brownie32.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
+  $(INCDIR)/aout/ar.h $(INCDIR)/bfdlink.h genlink.h elf-bfd.h \
+  $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
+  elfxx-brownie32.h $(INCDIR)/elf/brownie32.h $(INCDIR)/elf/reloc-macros.h \
+  $(INCDIR)/coff/sym.h $(INCDIR)/coff/symconst.h $(INCDIR)/coff/internal.h \
+  $(INCDIR)/coff/ecoff.h $(INCDIR)/coff/alpha.h ecoffswap.h \
+  elf64-target.h
 elf64-mmix.lo: elf64-mmix.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
   $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(INCDIR)/elf/mmix.h \
Index: bfd/aclocal.m4
===================================================================
RCS file: /home/prj/asip/cvs/gdb/bfd/aclocal.m4,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- bfd/aclocal.m4	31 Jul 2007 11:40:32 -0000	1.1.1.1
+++ bfd/aclocal.m4	8 Aug 2007 08:49:53 -0000	1.2
@@ -1,4 +1,4 @@
-# generated automatically by aclocal 1.9.5 -*- Autoconf -*-
+# generated automatically by aclocal 1.9.6 -*- Autoconf -*-
 
 # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
 # 2005  Free Software Foundation, Inc.
@@ -28,7 +28,7 @@ AC_DEFUN([AM_AUTOMAKE_VERSION], [am__api
 # Call AM_AUTOMAKE_VERSION so it can be traced.
 # This function is AC_REQUIREd by AC_INIT_AUTOMAKE.
 AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-	 [AM_AUTOMAKE_VERSION([1.9.5])])
+	 [AM_AUTOMAKE_VERSION([1.9.6])])
 
 # AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
 
Index: bfd/aoutx.h
===================================================================
RCS file: /home/prj/asip/cvs/gdb/bfd/aoutx.h,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- bfd/aoutx.h	31 Jul 2007 11:40:33 -0000	1.1.1.1
+++ bfd/aoutx.h	8 Aug 2007 08:49:53 -0000	1.2
@@ -4,6 +4,8 @@
    Free Software Foundation, Inc.
    Written by Cygnus Support.
 
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
    This file is part of BFD, the Binary File Descriptor library.
 
    This program is free software; you can redistribute it and/or modify
@@ -777,6 +779,18 @@ NAME (aout, machine_type) (enum bfd_arch
 	  break;
 	}
       break;
+    case bfd_arch_brownie32:
+      switch (machine)
+	{
+	case 0:
+	case bfd_mach_brownie32_std:
+	  arch_flags = M_BROWNIE32_STD;
+	  break;
+	default:
+	  arch_flags = M_UNKNOWN;
+	  break;
+	}
+      break;
 
     case bfd_arch_ns32k:
       switch (machine)
@@ -849,6 +863,7 @@ NAME (aout, set_arch_mach) (bfd *abfd,
     {
     case bfd_arch_sparc:
     case bfd_arch_mips:
+    case bfd_arch_brownie32:
       obj_reloc_entry_size (abfd) = RELOC_EXT_SIZE;
       break;
     default:
Index: bfd/archures.c
===================================================================
RCS file: /home/prj/asip/cvs/gdb/bfd/archures.c,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- bfd/archures.c	31 Jul 2007 11:40:33 -0000	1.1.1.1
+++ bfd/archures.c	8 Aug 2007 08:49:53 -0000	1.2
@@ -4,6 +4,8 @@
    Free Software Foundation, Inc.
    Hacked by John Gilmore and Steve Chamberlain of Cygnus Support.
 
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
    This file is part of BFD, the Binary File Descriptor library.
 
    This program is free software; you can redistribute it and/or modify
@@ -440,6 +442,7 @@ extern const bfd_arch_info_type bfd_m88k
 extern const bfd_arch_info_type bfd_maxq_arch;
 extern const bfd_arch_info_type bfd_mcore_arch;
 extern const bfd_arch_info_type bfd_mips_arch;
+extern const bfd_arch_info_type bfd_brownie32_arch;
 extern const bfd_arch_info_type bfd_mmix_arch;
 extern const bfd_arch_info_type bfd_mn10200_arch;
 extern const bfd_arch_info_type bfd_mn10300_arch;
@@ -506,6 +509,7 @@ static const bfd_arch_info_type * const 
     &bfd_maxq_arch,
     &bfd_mcore_arch,
     &bfd_mips_arch,
+    &bfd_brownie32_arch,
     &bfd_mmix_arch,
     &bfd_mn10200_arch,
     &bfd_mn10300_arch,
Index: bfd/bfd-in2.h
===================================================================
RCS file: /home/prj/asip/cvs/gdb/bfd/bfd-in2.h,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -p -r1.1.1.1 -r1.3
--- bfd/bfd-in2.h	31 Jul 2007 11:40:33 -0000	1.1.1.1
+++ bfd/bfd-in2.h	9 Aug 2007 11:34:30 -0000	1.3
@@ -9,9 +9,10 @@
 
    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
    1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
-
    Contributed by Cygnus Support.
 
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
    This file is part of BFD, the Binary File Descriptor library.
 
    This program is free software; you can redistribute it and/or modify
@@ -1806,6 +1807,9 @@ enum bfd_architecture
 #define bfd_mach_d10v_ts3      3
   bfd_arch_d30v,      /* Mitsubishi D30V */
   bfd_arch_dlx,       /* DLX */
+  bfd_arch_brownie32,       /* Brownie32 */
+#define bfd_mach_brownie32_std	1
+
   bfd_arch_m68hc11,   /* Motorola 68HC11 */
   bfd_arch_m68hc12,   /* Motorola 68HC12 */
 #define bfd_mach_m6812_default 0
@@ -2497,6 +2501,16 @@ simple reloc otherwise.  */
 /* High 16 bits of 32-bit value; simple reloc.  */
   BFD_RELOC_HI16,
 
+/* Bits 27..2 of the relocation address shifted right 2 bits;
+simple reloc otherwise.  */
+  BFD_RELOC_BROWNIE32_JMP,
+
+/* The BROWNIE3216 jump instruction.  */
+  BFD_RELOC_BROWNIE3216_JMP,
+
+/* BROWNIE3216 GP relative reloc.  */
+  BFD_RELOC_BROWNIE3216_GPREL,
+
 /* High 16 bits of 32-bit value but the low 16 bits will be sign
 extended and added to form the final result.  If the low 16
 bits form a negative number, we need to add one to the high value
@@ -2530,6 +2544,22 @@ to compensate for the borrow when the lo
 /* Relocation against a MIPS literal section.  */
   BFD_RELOC_MIPS_LITERAL,
 
+/* BROWNIE3216 high 16 bits of 32-bit value.  */
+  BFD_RELOC_BROWNIE3216_HI16,
+
+/* BROWNIE3216 high 16 bits of 32-bit value but the low 16 bits will be sign
+extended and added to form the final result.  If the low 16
+bits form a negative number, we need to add one to the high value
+to compensate for the borrow when the low bits are added.  */
+  BFD_RELOC_BROWNIE3216_HI16_S,
+
+/* BROWNIE3216 low 16 bits.  */
+  BFD_RELOC_BROWNIE3216_LO16,
+
+/* Relocation against a BROWNIE32 literal section.  */
+  BFD_RELOC_BROWNIE32_LITERAL,
+
+
 /* MIPS ELF relocations.  */
   BFD_RELOC_MIPS_GOT16,
   BFD_RELOC_MIPS_CALL16,
@@ -2566,6 +2596,41 @@ to compensate for the borrow when the lo
   BFD_RELOC_MIPS_TLS_TPREL_HI16,
   BFD_RELOC_MIPS_TLS_TPREL_LO16,
 
+/* BROWNIE32 ELF relocations.  */
+  BFD_RELOC_BROWNIE32_GOT16,
+  BFD_RELOC_BROWNIE32_CALL16,
+  BFD_RELOC_BROWNIE32_GOT_HI16,
+  BFD_RELOC_BROWNIE32_GOT_LO16,
+  BFD_RELOC_BROWNIE32_CALL_HI16,
+  BFD_RELOC_BROWNIE32_CALL_LO16,
+  BFD_RELOC_BROWNIE32_SUB,
+  BFD_RELOC_BROWNIE32_GOT_PAGE,
+  BFD_RELOC_BROWNIE32_GOT_OFST,
+  BFD_RELOC_BROWNIE32_GOT_DISP,
+  BFD_RELOC_BROWNIE32_SHIFT5,
+  BFD_RELOC_BROWNIE32_SHIFT6,
+  BFD_RELOC_BROWNIE32_INSERT_A,
+  BFD_RELOC_BROWNIE32_INSERT_B,
+  BFD_RELOC_BROWNIE32_DELETE,
+  BFD_RELOC_BROWNIE32_HIGHEST,
+  BFD_RELOC_BROWNIE32_HIGHER,
+  BFD_RELOC_BROWNIE32_SCN_DISP,
+  BFD_RELOC_BROWNIE32_REL16,
+  BFD_RELOC_BROWNIE32_RELGOT,
+  BFD_RELOC_BROWNIE32_JALR,
+  BFD_RELOC_BROWNIE32_TLS_DTPMOD32,
+  BFD_RELOC_BROWNIE32_TLS_DTPREL32,
+  BFD_RELOC_BROWNIE32_TLS_DTPMOD64,
+  BFD_RELOC_BROWNIE32_TLS_DTPREL64,
+  BFD_RELOC_BROWNIE32_TLS_GD,
+  BFD_RELOC_BROWNIE32_TLS_LDM,
+  BFD_RELOC_BROWNIE32_TLS_DTPREL_HI16,
+  BFD_RELOC_BROWNIE32_TLS_DTPREL_LO16,
+  BFD_RELOC_BROWNIE32_TLS_GOTTPREL,
+  BFD_RELOC_BROWNIE32_TLS_TPREL32,
+  BFD_RELOC_BROWNIE32_TLS_TPREL64,
+  BFD_RELOC_BROWNIE32_TLS_TPREL_HI16,
+  BFD_RELOC_BROWNIE32_TLS_TPREL_LO16,
 
 /* Fujitsu Frv Relocations.  */
   BFD_RELOC_FRV_LABEL16,
@@ -3179,12 +3244,21 @@ of the container.  */
 /* DLX relocs  */
   BFD_RELOC_DLX_HI16_S,
 
+/* BROWNIE32 relocs  */
+  BFD_RELOC_BROWNIE32_HI16_S,
+
 /* DLX relocs  */
   BFD_RELOC_DLX_LO16,
 
+/* BROWNIE32 relocs  */
+  BFD_RELOC_BROWNIE32_LO16,
+
 /* DLX relocs  */
   BFD_RELOC_DLX_JMP26,
 
+/* DLX relocs  */
+  BFD_RELOC_BROWNIE32_JMP26,
+
 /* Renesas M16C/M32C Relocations.  */
   BFD_RELOC_M32C_HI8,
 
@@ -4074,6 +4148,7 @@ BFD_RELOC_XTENSA_ASM_EXPAND.  */
 
 /* 4 bit value.  */
   BFD_RELOC_Z8K_IMM4L,
+
   BFD_RELOC_UNUSED };
 typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
 reloc_howto_type *bfd_reloc_type_lookup
Index: bfd/brownie32bsd.c
===================================================================
RCS file: bfd/brownie32bsd.c
diff -N bfd/brownie32bsd.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ bfd/brownie32bsd.c	8 Aug 2007 08:49:53 -0000	1.1
@@ -0,0 +1,484 @@
+/* BFD backend for BROWNIE32 BSD (a.out) binaries.
+   Copyright 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+   Free Software Foundation, Inc.
+   Written by Ralph Campbell.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* #define ENTRY_CAN_BE_ZERO */
+#define N_HEADER_IN_TEXT(x) 1
+#define N_SHARED_LIB(x) 0
+#define N_TXTADDR(x) \
+    (N_MAGIC(x) != ZMAGIC ? (x).a_entry :	/* object file or NMAGIC */\
+	    TEXT_START_ADDR + EXEC_BYTES_SIZE	/* no padding */\
+    )
+#define N_DATADDR(x) (N_TXTADDR(x)+N_TXTSIZE(x))
+#define TEXT_START_ADDR 4096
+#define TARGET_PAGE_SIZE 4096
+#define SEGMENT_SIZE TARGET_PAGE_SIZE
+#define DEFAULT_ARCH bfd_arch_brownie32
+#define MACHTYPE_OK(mtype) ((mtype) == M_UNKNOWN \
+			    || (mtype) == M_BROWNIE321 || (mtype) == M_BROWNIE322)
+#define MY_symbol_leading_char '\0'
+
+/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
+   remove whitespace added here, and thus will fail to concatenate
+   the tokens.  */
+#define MY(OP) CONCAT2 (brownie32bsd_,OP)
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "libbfd.h"
+#include "libaout.h"
+
+#define SET_ARCH_MACH(ABFD, EXEC) \
+  MY(set_arch_mach) (ABFD, N_MACHTYPE (EXEC)); \
+  MY(choose_reloc_size) (ABFD);
+static void MY(set_arch_mach) PARAMS ((bfd *abfd, unsigned long machtype));
+static void MY(choose_reloc_size) PARAMS ((bfd *abfd));
+
+#define MY_write_object_contents MY(write_object_contents)
+static bfd_boolean MY(write_object_contents) PARAMS ((bfd *abfd));
+
+/* We can't use MY(x) here because it leads to a recursive call to CONCAT2
+   when expanded inside JUMP_TABLE.  */
+#define MY_bfd_reloc_type_lookup brownie32bsd_reloc_howto_type_lookup
+#define MY_canonicalize_reloc brownie32bsd_canonicalize_reloc
+
+#define MY_bfd_link_hash_table_create _bfd_generic_link_hash_table_create
+#define MY_bfd_link_add_symbols _bfd_generic_link_add_symbols
+#define MY_final_link_callback unused
+#define MY_bfd_final_link _bfd_generic_final_link
+
+#define MY_backend_data &MY(backend_data)
+#define MY_BFD_TARGET
+
+#include "aout-target.h"
+
+static bfd_reloc_status_type brownie32_fix_jmp_addr
+  PARAMS ((bfd *, arelent *, struct bfd_symbol *, PTR, asection *,
+	   bfd *, char **));
+static reloc_howto_type *MY(reloc_howto_type_lookup)
+  PARAMS ((bfd *, bfd_reloc_code_real_type));
+
+long MY(canonicalize_reloc) PARAMS ((bfd *, sec_ptr, arelent **, asymbol **));
+
+static void
+MY(set_arch_mach) (abfd, machtype)
+     bfd *abfd;
+     unsigned long machtype;
+{
+  enum bfd_architecture arch;
+  unsigned int machine;
+
+  /* Determine the architecture and machine type of the object file.  */
+  switch (machtype)
+    {
+    case M_BROWNIE321:
+      arch = bfd_arch_brownie32;
+      machine = bfd_mach_brownie323000;
+      break;
+
+    case M_BROWNIE322:
+      arch = bfd_arch_brownie32;
+      machine = bfd_mach_brownie324000;
+      break;
+
+    default:
+      arch = bfd_arch_obscure;
+      machine = 0;
+      break;
+    }
+
+  bfd_set_arch_mach (abfd, arch, machine);
+}
+
+/* Determine the size of a relocation entry, based on the architecture */
+static void
+MY (choose_reloc_size) (abfd)
+     bfd *abfd;
+{
+  switch (bfd_get_arch (abfd))
+    {
+    case bfd_arch_sparc:
+    case bfd_arch_brownie32:
+      obj_reloc_entry_size (abfd) = RELOC_EXT_SIZE;
+      break;
+    default:
+      obj_reloc_entry_size (abfd) = RELOC_STD_SIZE;
+      break;
+    }
+}
+
+/* Write an object file in BSD a.out format.
+  Section contents have already been written.  We write the
+  file header, symbols, and relocation.  */
+
+static bfd_boolean
+MY (write_object_contents) (abfd)
+     bfd *abfd;
+{
+  struct external_exec exec_bytes;
+  struct internal_exec *execp = exec_hdr (abfd);
+
+  /* Magic number, maestro, please!  */
+  switch (bfd_get_arch (abfd))
+    {
+    case bfd_arch_m68k:
+      switch (bfd_get_mach (abfd))
+	{
+	case bfd_mach_m68010:
+	  N_SET_MACHTYPE (*execp, M_68010);
+	  break;
+	default:
+	case bfd_mach_m68020:
+	  N_SET_MACHTYPE (*execp, M_68020);
+	  break;
+	}
+      break;
+    case bfd_arch_sparc:
+      N_SET_MACHTYPE (*execp, M_SPARC);
+      break;
+    case bfd_arch_i386:
+      N_SET_MACHTYPE (*execp, M_386);
+      break;
+    case bfd_arch_brownie32:
+      switch (bfd_get_mach (abfd))
+	{
+	case bfd_mach_brownie324000:
+	case bfd_mach_brownie326000:
+	  N_SET_MACHTYPE (*execp, M_BROWNIE322);
+	  break;
+	default:
+	  N_SET_MACHTYPE (*execp, M_BROWNIE321);
+	  break;
+	}
+      break;
+    default:
+      N_SET_MACHTYPE (*execp, M_UNKNOWN);
+    }
+
+  MY (choose_reloc_size) (abfd);
+
+  WRITE_HEADERS (abfd, execp);
+
+  return TRUE;
+}
+
+/* BROWNIE32 relocation types.  */
+#define BROWNIE32_RELOC_32		0
+#define BROWNIE32_RELOC_JMP		1
+#define BROWNIE32_RELOC_WDISP16	2
+#define BROWNIE32_RELOC_HI16		3
+#define BROWNIE32_RELOC_HI16_S	4
+#define BROWNIE32_RELOC_LO16		5
+
+/* This is only called when performing a BFD_RELOC_BROWNIE32_JMP relocation.
+   The jump destination address is formed from the upper 4 bits of the
+   "current" program counter concatenated with the jump instruction's
+   26 bit field and two trailing zeros.
+   If the destination address is not in the same segment as the "current"
+   program counter, then we need to signal an error.  */
+
+static bfd_reloc_status_type
+brownie32_fix_jmp_addr (abfd, reloc_entry, symbol, data, input_section, output_bfd,
+		   error_message)
+     bfd *abfd ATTRIBUTE_UNUSED;
+     arelent *reloc_entry;
+     struct bfd_symbol *symbol;
+     PTR data ATTRIBUTE_UNUSED;
+     asection *input_section;
+     bfd *output_bfd;
+     char **error_message ATTRIBUTE_UNUSED;
+{
+  bfd_vma relocation, pc;
+
+  /* If this is a partial relocation, just continue.  */
+  if (output_bfd != (bfd *)NULL)
+    return bfd_reloc_continue;
+
+  /* If this is an undefined symbol, return error */
+  if (bfd_is_und_section (symbol->section)
+      && (symbol->flags & BSF_WEAK) == 0)
+    return bfd_reloc_undefined;
+
+  /* Work out which section the relocation is targeted at and the
+     initial relocation command value.  */
+  if (bfd_is_com_section (symbol->section))
+    relocation = 0;
+  else
+    relocation = symbol->value;
+
+  relocation += symbol->section->output_section->vma;
+  relocation += symbol->section->output_offset;
+  relocation += reloc_entry->addend;
+
+  pc = input_section->output_section->vma + input_section->output_offset +
+    reloc_entry->address + 4;
+
+  if ((relocation & 0xF0000000) != (pc & 0xF0000000))
+    return bfd_reloc_overflow;
+
+  return bfd_reloc_continue;
+}
+
+/* This is only called when performing a BFD_RELOC_HI16_S relocation.
+   We need to see if bit 15 is set in the result. If it is, we add
+   0x10000 and continue normally. This will compensate for the sign extension
+   when the low bits are added at run time.  */
+
+static bfd_reloc_status_type
+brownie32_fix_hi16_s PARAMS ((bfd *, arelent *, asymbol *, PTR,
+			 asection *, bfd *, char **));
+
+static bfd_reloc_status_type
+brownie32_fix_hi16_s (abfd, reloc_entry, symbol, data, input_section,
+		 output_bfd, error_message)
+     bfd *abfd ATTRIBUTE_UNUSED;
+     arelent *reloc_entry;
+     asymbol *symbol;
+     PTR data ATTRIBUTE_UNUSED;
+     asection *input_section ATTRIBUTE_UNUSED;
+     bfd *output_bfd;
+     char **error_message ATTRIBUTE_UNUSED;
+{
+  bfd_vma relocation;
+
+  /* If this is a partial relocation, just continue.  */
+  if (output_bfd != (bfd *)NULL)
+    return bfd_reloc_continue;
+
+  /* If this is an undefined symbol, return error.  */
+  if (bfd_is_und_section (symbol->section)
+      && (symbol->flags & BSF_WEAK) == 0)
+    return bfd_reloc_undefined;
+
+  /* Work out which section the relocation is targeted at and the
+     initial relocation command value.  */
+  if (bfd_is_com_section (symbol->section))
+    relocation = 0;
+  else
+    relocation = symbol->value;
+
+  relocation += symbol->section->output_section->vma;
+  relocation += symbol->section->output_offset;
+  relocation += reloc_entry->addend;
+
+  if (relocation & 0x8000)
+    reloc_entry->addend += 0x10000;
+
+  return bfd_reloc_continue;
+}
+
+static reloc_howto_type brownie32_howto_table_ext[] = {
+  {BROWNIE32_RELOC_32,      0, 2, 32, FALSE, 0,  complain_overflow_bitfield, 0,
+	"32",       FALSE, 0, 0xffffffff, FALSE},
+  {BROWNIE32_RELOC_JMP,     2, 2, 26, FALSE, 0, complain_overflow_dont,
+	brownie32_fix_jmp_addr,
+	"BROWNIE32_JMP", FALSE, 0, 0x03ffffff, FALSE},
+  {BROWNIE32_RELOC_WDISP16, 2, 2, 16, TRUE,  0, complain_overflow_signed, 0,
+	"WDISP16",  FALSE, 0, 0x0000ffff, FALSE},
+  {BROWNIE32_RELOC_HI16,   16, 2, 16, FALSE, 0, complain_overflow_bitfield, 0,
+	"HI16",     FALSE, 0, 0x0000ffff, FALSE},
+  {BROWNIE32_RELOC_HI16_S, 16, 2, 16, FALSE, 0, complain_overflow_bitfield,
+        brownie32_fix_hi16_s,
+        "HI16_S",   FALSE, 0, 0x0000ffff, FALSE},
+  {BROWNIE32_RELOC_LO16,    0, 2, 16, FALSE, 0, complain_overflow_dont, 0,
+	"LO16",     FALSE, 0, 0x0000ffff, FALSE},
+};
+
+static reloc_howto_type *
+MY(reloc_howto_type_lookup) (abfd, code)
+     bfd *abfd;
+     bfd_reloc_code_real_type code;
+{
+
+  if (bfd_get_arch (abfd) != bfd_arch_brownie32)
+    return 0;
+
+  switch (code)
+    {
+    case BFD_RELOC_CTOR:
+    case BFD_RELOC_32:
+      return (&brownie32_howto_table_ext[BROWNIE32_RELOC_32]);
+    case BFD_RELOC_BROWNIE32_JMP:
+      return (&brownie32_howto_table_ext[BROWNIE32_RELOC_JMP]);
+    case BFD_RELOC_16_PCREL_S2:
+      return (&brownie32_howto_table_ext[BROWNIE32_RELOC_WDISP16]);
+    case BFD_RELOC_HI16:
+      return (&brownie32_howto_table_ext[BROWNIE32_RELOC_HI16]);
+    case BFD_RELOC_HI16_S:
+      return (&brownie32_howto_table_ext[BROWNIE32_RELOC_HI16_S]);
+    case BFD_RELOC_LO16:
+      return (&brownie32_howto_table_ext[BROWNIE32_RELOC_LO16]);
+    default:
+      return 0;
+    }
+}
+
+/* This is just like the standard aoutx.h version but we need to do our
+   own mapping of external reloc type values to howto entries.  */
+long
+MY(canonicalize_reloc) (abfd, section, relptr, symbols)
+      bfd *abfd;
+      sec_ptr section;
+      arelent **relptr;
+      asymbol **symbols;
+{
+  arelent *tblptr = section->relocation;
+  unsigned int count, c;
+  extern reloc_howto_type NAME(aout,ext_howto_table)[];
+
+  /* If we have already read in the relocation table, return the values.  */
+  if (section->flags & SEC_CONSTRUCTOR)
+    {
+      arelent_chain *chain = section->constructor_chain;
+
+      for (count = 0; count < section->reloc_count; count++)
+	{
+	  *relptr++ = &chain->relent;
+	  chain = chain->next;
+	}
+      *relptr = 0;
+      return section->reloc_count;
+    }
+
+  if (tblptr && section->reloc_count)
+    {
+      for (count = 0; count++ < section->reloc_count;)
+	*relptr++ = tblptr++;
+      *relptr = 0;
+      return section->reloc_count;
+    }
+
+  if (!NAME(aout,slurp_reloc_table) (abfd, section, symbols))
+    return -1;
+  tblptr = section->relocation;
+
+  /* fix up howto entries.  */
+  for (count = 0; count++ < section->reloc_count;)
+    {
+      c = tblptr->howto - NAME(aout,ext_howto_table);
+      tblptr->howto = &brownie32_howto_table_ext[c];
+
+      *relptr++ = tblptr++;
+    }
+  *relptr = 0;
+  return section->reloc_count;
+}
+
+static const struct aout_backend_data MY(backend_data) = {
+  0,				/* zmagic contiguous */
+  1,				/* text incl header */
+  0,				/* entry is text address */
+  0,				/* exec_hdr_flags */
+  TARGET_PAGE_SIZE,			/* text vma */
+  MY_set_sizes,
+  0,				/* text size includes exec header */
+  0,				/* add_dynamic_symbols */
+  0,				/* add_one_symbol */
+  0,				/* link_dynamic_object */
+  0,				/* write_dynamic_symbol */
+  0,				/* check_dynamic_reloc */
+  0				/* finish_dynamic_link */
+};
+
+extern const bfd_target aout_brownie32_big_vec;
+
+const bfd_target aout_brownie32_little_vec =
+  {
+    "a.out-brownie32-little",		/* name */
+    bfd_target_aout_flavour,
+    BFD_ENDIAN_LITTLE,		/* target byte order (little) */
+    BFD_ENDIAN_LITTLE,		/* target headers byte order (little) */
+    (HAS_RELOC | EXEC_P |		/* object flags */
+     HAS_LINENO | HAS_DEBUG |
+     HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
+    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
+    MY_symbol_leading_char,
+    ' ',				/* ar_pad_char */
+    15,				/* ar_max_namelen */
+    bfd_getl64, bfd_getl_signed_64, bfd_putl64,
+    bfd_getl32, bfd_getl_signed_32, bfd_putl32,
+    bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* data */
+    bfd_getl64, bfd_getl_signed_64, bfd_putl64,
+    bfd_getl32, bfd_getl_signed_32, bfd_putl32,
+    bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* hdrs */
+    {_bfd_dummy_target, MY_object_p, /* bfd_check_format */
+     bfd_generic_archive_p, MY_core_file_p},
+    {bfd_false, MY_mkobject,	/* bfd_set_format */
+     _bfd_generic_mkarchive, bfd_false},
+    {bfd_false, MY_write_object_contents, /* bfd_write_contents */
+     _bfd_write_archive_contents, bfd_false},
+
+    BFD_JUMP_TABLE_GENERIC (MY),
+    BFD_JUMP_TABLE_COPY (MY),
+    BFD_JUMP_TABLE_CORE (MY),
+    BFD_JUMP_TABLE_ARCHIVE (MY),
+    BFD_JUMP_TABLE_SYMBOLS (MY),
+    BFD_JUMP_TABLE_RELOCS (MY),
+    BFD_JUMP_TABLE_WRITE (MY),
+    BFD_JUMP_TABLE_LINK (MY),
+    BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
+
+    & aout_brownie32_big_vec,
+
+    (PTR) MY_backend_data
+  };
+
+const bfd_target aout_brownie32_big_vec =
+  {
+    "a.out-brownie32-big",		/* name */
+    bfd_target_aout_flavour,
+    BFD_ENDIAN_BIG,		/* target byte order (big) */
+    BFD_ENDIAN_BIG,		/* target headers byte order (big) */
+    (HAS_RELOC | EXEC_P |		/* object flags */
+     HAS_LINENO | HAS_DEBUG |
+     HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
+    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
+    MY_symbol_leading_char,
+    ' ',				/* ar_pad_char */
+    15,				/* ar_max_namelen */
+    bfd_getb64, bfd_getb_signed_64, bfd_putb64,
+    bfd_getb32, bfd_getb_signed_32, bfd_putb32,
+    bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* data */
+    bfd_getb64, bfd_getb_signed_64, bfd_putb64,
+    bfd_getb32, bfd_getb_signed_32, bfd_putb32,
+    bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* hdrs */
+    {_bfd_dummy_target, MY_object_p, /* bfd_check_format */
+     bfd_generic_archive_p, MY_core_file_p},
+    {bfd_false, MY_mkobject,	/* bfd_set_format */
+     _bfd_generic_mkarchive, bfd_false},
+    {bfd_false, MY_write_object_contents, /* bfd_write_contents */
+     _bfd_write_archive_contents, bfd_false},
+
+    BFD_JUMP_TABLE_GENERIC (MY),
+    BFD_JUMP_TABLE_COPY (MY),
+    BFD_JUMP_TABLE_CORE (MY),
+    BFD_JUMP_TABLE_ARCHIVE (MY),
+    BFD_JUMP_TABLE_SYMBOLS (MY),
+    BFD_JUMP_TABLE_RELOCS (MY),
+    BFD_JUMP_TABLE_WRITE (MY),
+    BFD_JUMP_TABLE_LINK (MY),
+    BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
+
+    & aout_brownie32_little_vec,
+
+    (PTR) MY_backend_data
+  };
Index: bfd/coff-brownie32.c
===================================================================
RCS file: bfd/coff-brownie32.c
diff -N bfd/coff-brownie32.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ bfd/coff-brownie32.c	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,1534 @@
+/* BFD back-end for BROWNIE32 Extended-Coff files.
+   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+   2000, 2001, 2002, 2003, 2004
+   Free Software Foundation, Inc.
+   Original version by Per Bothner.
+   Full support added by Ian Lance Taylor, ian@cygnus.com.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "bfdlink.h"
+#include "libbfd.h"
+#include "coff/internal.h"
+#include "coff/sym.h"
+#include "coff/symconst.h"
+#include "coff/ecoff.h"
+#include "coff/brownie32.h"
+#include "libcoff.h"
+#include "libecoff.h"
+
+/* Prototypes for static functions.  */
+
+static bfd_boolean brownie32_ecoff_bad_format_hook
+  PARAMS ((bfd *abfd, PTR filehdr));
+static void brownie32_ecoff_swap_reloc_in
+  PARAMS ((bfd *, PTR, struct internal_reloc *));
+static void brownie32_ecoff_swap_reloc_out
+  PARAMS ((bfd *, const struct internal_reloc *, PTR));
+static void brownie32_adjust_reloc_in
+  PARAMS ((bfd *, const struct internal_reloc *, arelent *));
+static void brownie32_adjust_reloc_out
+  PARAMS ((bfd *, const arelent *, struct internal_reloc *));
+static bfd_reloc_status_type brownie32_generic_reloc
+  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
+	   asection *section, bfd *output_bfd, char **error));
+static bfd_reloc_status_type brownie32_refhi_reloc
+  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
+	   asection *section, bfd *output_bfd, char **error));
+static bfd_reloc_status_type brownie32_reflo_reloc
+  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
+	   asection *section, bfd *output_bfd, char **error));
+static bfd_reloc_status_type brownie32_gprel_reloc
+  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
+	   asection *section, bfd *output_bfd, char **error));
+static void brownie32_relocate_hi
+  PARAMS ((struct internal_reloc *refhi, struct internal_reloc *reflo,
+	   bfd *input_bfd, asection *input_section, bfd_byte *contents,
+	   bfd_vma relocation));
+static bfd_boolean brownie32_relocate_section
+  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, PTR));
+static reloc_howto_type *brownie32_bfd_reloc_type_lookup
+  PARAMS ((bfd *, bfd_reloc_code_real_type));
+
+/* ECOFF has COFF sections, but the debugging information is stored in
+   a completely different format.  ECOFF targets use some of the
+   swapping routines from coffswap.h, and some of the generic COFF
+   routines in coffgen.c, but, unlike the real COFF targets, do not
+   use coffcode.h itself.
+
+   Get the generic COFF swapping routines, except for the reloc,
+   symbol, and lineno ones.  Give them ECOFF names.  */
+#define BROWNIE32ECOFF
+#define NO_COFF_RELOCS
+#define NO_COFF_SYMBOLS
+#define NO_COFF_LINENOS
+#define coff_swap_filehdr_in brownie32_ecoff_swap_filehdr_in
+#define coff_swap_filehdr_out brownie32_ecoff_swap_filehdr_out
+#define coff_swap_aouthdr_in brownie32_ecoff_swap_aouthdr_in
+#define coff_swap_aouthdr_out brownie32_ecoff_swap_aouthdr_out
+#define coff_swap_scnhdr_in brownie32_ecoff_swap_scnhdr_in
+#define coff_swap_scnhdr_out brownie32_ecoff_swap_scnhdr_out
+#include "coffswap.h"
+
+/* Get the ECOFF swapping routines.  */
+#define ECOFF_32
+#include "ecoffswap.h"
+
+/* How to process the various relocs types.  */
+
+static reloc_howto_type brownie32_howto_table[] =
+{
+  /* Reloc type 0 is ignored.  The reloc reading code ensures that
+     this is a reference to the .abs section, which will cause
+     bfd_perform_relocation to do nothing.  */
+  HOWTO (BROWNIE32_R_IGNORE,	/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 8,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 0,			/* special_function */
+	 "IGNORE",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 16 bit reference to a symbol, normally from a data section.  */
+  HOWTO (BROWNIE32_R_REFHALF,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 brownie32_generic_reloc,	/* special_function */
+	 "REFHALF",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffff,		/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 32 bit reference to a symbol, normally from a data section.  */
+  HOWTO (BROWNIE32_R_REFWORD,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 brownie32_generic_reloc,	/* special_function */
+	 "REFWORD",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 26 bit absolute jump address.  */
+  HOWTO (BROWNIE32_R_JMPADDR,	/* type */
+	 2,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 26,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 			/* This needs complex overflow
+				   detection, because the upper four
+				   bits must match the PC.  */
+	 brownie32_generic_reloc,	/* special_function */
+	 "JMPADDR",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0x3ffffff,		/* src_mask */
+	 0x3ffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* The high 16 bits of a symbol value.  Handled by the function
+     brownie32_refhi_reloc.  */
+  HOWTO (BROWNIE32_R_REFHI,		/* type */
+	 16,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 brownie32_refhi_reloc,	/* special_function */
+	 "REFHI",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffff,		/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* The low 16 bits of a symbol value.  */
+  HOWTO (BROWNIE32_R_REFLO,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 brownie32_reflo_reloc,	/* special_function */
+	 "REFLO",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffff,		/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A reference to an offset from the gp register.  Handled by the
+     function brownie32_gprel_reloc.  */
+  HOWTO (BROWNIE32_R_GPREL,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 brownie32_gprel_reloc,	/* special_function */
+	 "GPREL",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffff,		/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A reference to a literal using an offset from the gp register.
+     Handled by the function brownie32_gprel_reloc.  */
+  HOWTO (BROWNIE32_R_LITERAL,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 brownie32_gprel_reloc,	/* special_function */
+	 "LITERAL",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffff,		/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  EMPTY_HOWTO (8),
+  EMPTY_HOWTO (9),
+  EMPTY_HOWTO (10),
+  EMPTY_HOWTO (11),
+
+  /* FIXME: This relocation is used (internally only) to represent branches
+     when assembling.  It should never appear in output files, and
+     be removed.  (It used to be used for embedded-PIC support.)  */
+  HOWTO (BROWNIE32_R_PCREL16,	/* type */
+	 2,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 brownie32_generic_reloc,	/* special_function */
+	 "PCREL16",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffff,		/* src_mask */
+	 0xffff,		/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+};
+
+#define BROWNIE32_HOWTO_COUNT \
+  (sizeof brownie32_howto_table / sizeof brownie32_howto_table[0])
+
+/* See whether the magic number matches.  */
+
+static bfd_boolean
+brownie32_ecoff_bad_format_hook (abfd, filehdr)
+     bfd *abfd;
+     PTR filehdr;
+{
+  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;
+
+  switch (internal_f->f_magic)
+    {
+    case BROWNIE32_MAGIC_1:
+      /* I don't know what endianness this implies.  */
+      return TRUE;
+
+    case BROWNIE32_MAGIC_BIG:
+    case BROWNIE32_MAGIC_BIG2:
+    case BROWNIE32_MAGIC_BIG3:
+      return bfd_big_endian (abfd);
+
+    case BROWNIE32_MAGIC_LITTLE:
+    case BROWNIE32_MAGIC_LITTLE2:
+    case BROWNIE32_MAGIC_LITTLE3:
+      return bfd_little_endian (abfd);
+
+    default:
+      return FALSE;
+    }
+}
+
+/* Reloc handling.  BROWNIE32 ECOFF relocs are packed into 8 bytes in
+   external form.  They use a bit which indicates whether the symbol
+   is external.  */
+
+/* Swap a reloc in.  */
+
+static void
+brownie32_ecoff_swap_reloc_in (abfd, ext_ptr, intern)
+     bfd *abfd;
+     PTR ext_ptr;
+     struct internal_reloc *intern;
+{
+  const RELOC *ext = (RELOC *) ext_ptr;
+
+  intern->r_vaddr = H_GET_32 (abfd, ext->r_vaddr);
+  if (bfd_header_big_endian (abfd))
+    {
+      intern->r_symndx = (((int) ext->r_bits[0]
+			   << RELOC_BITS0_SYMNDX_SH_LEFT_BIG)
+			  | ((int) ext->r_bits[1]
+			     << RELOC_BITS1_SYMNDX_SH_LEFT_BIG)
+			  | ((int) ext->r_bits[2]
+			     << RELOC_BITS2_SYMNDX_SH_LEFT_BIG));
+      intern->r_type = ((ext->r_bits[3] & RELOC_BITS3_TYPE_BIG)
+			>> RELOC_BITS3_TYPE_SH_BIG);
+      intern->r_extern = (ext->r_bits[3] & RELOC_BITS3_EXTERN_BIG) != 0;
+    }
+  else
+    {
+      intern->r_symndx = (((int) ext->r_bits[0]
+			   << RELOC_BITS0_SYMNDX_SH_LEFT_LITTLE)
+			  | ((int) ext->r_bits[1]
+			     << RELOC_BITS1_SYMNDX_SH_LEFT_LITTLE)
+			  | ((int) ext->r_bits[2]
+			     << RELOC_BITS2_SYMNDX_SH_LEFT_LITTLE));
+      intern->r_type = (((ext->r_bits[3] & RELOC_BITS3_TYPE_LITTLE)
+			 >> RELOC_BITS3_TYPE_SH_LITTLE)
+			| ((ext->r_bits[3] & RELOC_BITS3_TYPEHI_LITTLE)
+			   << RELOC_BITS3_TYPEHI_SH_LITTLE));
+      intern->r_extern = (ext->r_bits[3] & RELOC_BITS3_EXTERN_LITTLE) != 0;
+    }
+}
+
+/* Swap a reloc out.  */
+
+static void
+brownie32_ecoff_swap_reloc_out (abfd, intern, dst)
+     bfd *abfd;
+     const struct internal_reloc *intern;
+     PTR dst;
+{
+  RELOC *ext = (RELOC *) dst;
+  long r_symndx;
+
+  BFD_ASSERT (intern->r_extern
+	      || (intern->r_symndx >= 0 && intern->r_symndx <= 12));
+
+  r_symndx = intern->r_symndx;
+
+  H_PUT_32 (abfd, intern->r_vaddr, ext->r_vaddr);
+  if (bfd_header_big_endian (abfd))
+    {
+      ext->r_bits[0] = r_symndx >> RELOC_BITS0_SYMNDX_SH_LEFT_BIG;
+      ext->r_bits[1] = r_symndx >> RELOC_BITS1_SYMNDX_SH_LEFT_BIG;
+      ext->r_bits[2] = r_symndx >> RELOC_BITS2_SYMNDX_SH_LEFT_BIG;
+      ext->r_bits[3] = (((intern->r_type << RELOC_BITS3_TYPE_SH_BIG)
+			 & RELOC_BITS3_TYPE_BIG)
+			| (intern->r_extern ? RELOC_BITS3_EXTERN_BIG : 0));
+    }
+  else
+    {
+      ext->r_bits[0] = r_symndx >> RELOC_BITS0_SYMNDX_SH_LEFT_LITTLE;
+      ext->r_bits[1] = r_symndx >> RELOC_BITS1_SYMNDX_SH_LEFT_LITTLE;
+      ext->r_bits[2] = r_symndx >> RELOC_BITS2_SYMNDX_SH_LEFT_LITTLE;
+      ext->r_bits[3] = (((intern->r_type << RELOC_BITS3_TYPE_SH_LITTLE)
+			 & RELOC_BITS3_TYPE_LITTLE)
+			| ((intern->r_type >> RELOC_BITS3_TYPEHI_SH_LITTLE
+			    & RELOC_BITS3_TYPEHI_LITTLE))
+			| (intern->r_extern ? RELOC_BITS3_EXTERN_LITTLE : 0));
+    }
+}
+
+/* Finish canonicalizing a reloc.  Part of this is generic to all
+   ECOFF targets, and that part is in ecoff.c.  The rest is done in
+   this backend routine.  It must fill in the howto field.  */
+
+static void
+brownie32_adjust_reloc_in (abfd, intern, rptr)
+     bfd *abfd;
+     const struct internal_reloc *intern;
+     arelent *rptr;
+{
+  if (intern->r_type > BROWNIE32_R_PCREL16)
+    abort ();
+
+  if (! intern->r_extern
+      && (intern->r_type == BROWNIE32_R_GPREL
+	  || intern->r_type == BROWNIE32_R_LITERAL))
+    rptr->addend += ecoff_data (abfd)->gp;
+
+  /* If the type is BROWNIE32_R_IGNORE, make sure this is a reference to
+     the absolute section so that the reloc is ignored.  */
+  if (intern->r_type == BROWNIE32_R_IGNORE)
+    rptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
+
+  rptr->howto = &brownie32_howto_table[intern->r_type];
+}
+
+/* Make any adjustments needed to a reloc before writing it out.  None
+   are needed for BROWNIE32.  */
+
+static void
+brownie32_adjust_reloc_out (abfd, rel, intern)
+     bfd *abfd ATTRIBUTE_UNUSED;
+     const arelent *rel ATTRIBUTE_UNUSED;
+     struct internal_reloc *intern ATTRIBUTE_UNUSED;
+{
+}
+
+/* ECOFF relocs are either against external symbols, or against
+   sections.  If we are producing relocatable output, and the reloc
+   is against an external symbol, and nothing has given us any
+   additional addend, the resulting reloc will also be against the
+   same symbol.  In such a case, we don't want to change anything
+   about the way the reloc is handled, since it will all be done at
+   final link time.  Rather than put special case code into
+   bfd_perform_relocation, all the reloc types use this howto
+   function.  It just short circuits the reloc if producing
+   relocatable output against an external symbol.  */
+
+static bfd_reloc_status_type
+brownie32_generic_reloc (abfd,
+		    reloc_entry,
+		    symbol,
+		    data,
+		    input_section,
+		    output_bfd,
+		    error_message)
+     bfd *abfd ATTRIBUTE_UNUSED;
+     arelent *reloc_entry;
+     asymbol *symbol;
+     PTR data ATTRIBUTE_UNUSED;
+     asection *input_section;
+     bfd *output_bfd;
+     char **error_message ATTRIBUTE_UNUSED;
+{
+  if (output_bfd != (bfd *) NULL
+      && (symbol->flags & BSF_SECTION_SYM) == 0
+      && reloc_entry->addend == 0)
+    {
+      reloc_entry->address += input_section->output_offset;
+      return bfd_reloc_ok;
+    }
+
+  return bfd_reloc_continue;
+}
+
+/* Do a REFHI relocation.  This has to be done in combination with a
+   REFLO reloc, because there is a carry from the REFLO to the REFHI.
+   Here we just save the information we need; we do the actual
+   relocation when we see the REFLO.  BROWNIE32 ECOFF requires that the
+   REFLO immediately follow the REFHI.  As a GNU extension, we permit
+   an arbitrary number of HI relocs to be associated with a single LO
+   reloc.  This extension permits gcc to output the HI and LO relocs
+   itself.  */
+
+struct brownie32_hi
+{
+  struct brownie32_hi *next;
+  bfd_byte *addr;
+  bfd_vma addend;
+};
+
+/* FIXME: This should not be a static variable.  */
+
+static struct brownie32_hi *brownie32_refhi_list;
+
+static bfd_reloc_status_type
+brownie32_refhi_reloc (abfd,
+		  reloc_entry,
+		  symbol,
+		  data,
+		  input_section,
+		  output_bfd,
+		  error_message)
+     bfd *abfd ATTRIBUTE_UNUSED;
+     arelent *reloc_entry;
+     asymbol *symbol;
+     PTR data;
+     asection *input_section;
+     bfd *output_bfd;
+     char **error_message ATTRIBUTE_UNUSED;
+{
+  bfd_reloc_status_type ret;
+  bfd_vma relocation;
+  struct brownie32_hi *n;
+
+  /* If we're relocating, and this an external symbol, we don't want
+     to change anything.  */
+  if (output_bfd != (bfd *) NULL
+      && (symbol->flags & BSF_SECTION_SYM) == 0
+      && reloc_entry->addend == 0)
+    {
+      reloc_entry->address += input_section->output_offset;
+      return bfd_reloc_ok;
+    }
+
+  ret = bfd_reloc_ok;
+  if (bfd_is_und_section (symbol->section)
+      && output_bfd == (bfd *) NULL)
+    ret = bfd_reloc_undefined;
+
+  if (bfd_is_com_section (symbol->section))
+    relocation = 0;
+  else
+    relocation = symbol->value;
+
+  relocation += symbol->section->output_section->vma;
+  relocation += symbol->section->output_offset;
+  relocation += reloc_entry->addend;
+
+  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
+    return bfd_reloc_outofrange;
+
+  /* Save the information, and let REFLO do the actual relocation.  */
+  n = (struct brownie32_hi *) bfd_malloc ((bfd_size_type) sizeof *n);
+  if (n == NULL)
+    return bfd_reloc_outofrange;
+  n->addr = (bfd_byte *) data + reloc_entry->address;
+  n->addend = relocation;
+  n->next = brownie32_refhi_list;
+  brownie32_refhi_list = n;
+
+  if (output_bfd != (bfd *) NULL)
+    reloc_entry->address += input_section->output_offset;
+
+  return ret;
+}
+
+/* Do a REFLO relocation.  This is a straightforward 16 bit inplace
+   relocation; this function exists in order to do the REFHI
+   relocation described above.  */
+
+static bfd_reloc_status_type
+brownie32_reflo_reloc (abfd,
+		  reloc_entry,
+		  symbol,
+		  data,
+		  input_section,
+		  output_bfd,
+		  error_message)
+     bfd *abfd;
+     arelent *reloc_entry;
+     asymbol *symbol;
+     PTR data;
+     asection *input_section;
+     bfd *output_bfd;
+     char **error_message;
+{
+  if (brownie32_refhi_list != NULL)
+    {
+      struct brownie32_hi *l;
+
+      l = brownie32_refhi_list;
+      while (l != NULL)
+	{
+	  unsigned long insn;
+	  unsigned long val;
+	  unsigned long vallo;
+	  struct brownie32_hi *next;
+
+	  /* Do the REFHI relocation.  Note that we actually don't
+	     need to know anything about the REFLO itself, except
+	     where to find the low 16 bits of the addend needed by the
+	     REFHI.  */
+	  insn = bfd_get_32 (abfd, l->addr);
+	  vallo = (bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address)
+		   & 0xffff);
+	  val = ((insn & 0xffff) << 16) + vallo;
+	  val += l->addend;
+
+	  /* The low order 16 bits are always treated as a signed
+	     value.  Therefore, a negative value in the low order bits
+	     requires an adjustment in the high order bits.  We need
+	     to make this adjustment in two ways: once for the bits we
+	     took from the data, and once for the bits we are putting
+	     back in to the data.  */
+	  if ((vallo & 0x8000) != 0)
+	    val -= 0x10000;
+	  if ((val & 0x8000) != 0)
+	    val += 0x10000;
+
+	  insn = (insn &~ (unsigned) 0xffff) | ((val >> 16) & 0xffff);
+	  bfd_put_32 (abfd, (bfd_vma) insn, l->addr);
+
+	  next = l->next;
+	  free (l);
+	  l = next;
+	}
+
+      brownie32_refhi_list = NULL;
+    }
+
+  /* Now do the REFLO reloc in the usual way.  */
+  return brownie32_generic_reloc (abfd, reloc_entry, symbol, data,
+			      input_section, output_bfd, error_message);
+}
+
+/* Do a GPREL relocation.  This is a 16 bit value which must become
+   the offset from the gp register.  */
+
+static bfd_reloc_status_type
+brownie32_gprel_reloc (abfd,
+		  reloc_entry,
+		  symbol,
+		  data,
+		  input_section,
+		  output_bfd,
+		  error_message)
+     bfd *abfd;
+     arelent *reloc_entry;
+     asymbol *symbol;
+     PTR data;
+     asection *input_section;
+     bfd *output_bfd;
+     char **error_message;
+{
+  bfd_boolean relocatable;
+  bfd_vma gp;
+  bfd_vma relocation;
+  unsigned long val;
+  unsigned long insn;
+
+  /* If we're relocating, and this is an external symbol with no
+     addend, we don't want to change anything.  We will only have an
+     addend if this is a newly created reloc, not read from an ECOFF
+     file.  */
+  if (output_bfd != (bfd *) NULL
+      && (symbol->flags & BSF_SECTION_SYM) == 0
+      && reloc_entry->addend == 0)
+    {
+      reloc_entry->address += input_section->output_offset;
+      return bfd_reloc_ok;
+    }
+
+  if (output_bfd != (bfd *) NULL)
+    relocatable = TRUE;
+  else
+    {
+      relocatable = FALSE;
+      output_bfd = symbol->section->output_section->owner;
+    }
+
+  if (bfd_is_und_section (symbol->section) && ! relocatable)
+    return bfd_reloc_undefined;
+
+  /* We have to figure out the gp value, so that we can adjust the
+     symbol value correctly.  We look up the symbol _gp in the output
+     BFD.  If we can't find it, we're stuck.  We cache it in the ECOFF
+     target data.  We don't need to adjust the symbol value for an
+     external symbol if we are producing relocatable output.  */
+  gp = _bfd_get_gp_value (output_bfd);
+  if (gp == 0
+      && (! relocatable
+	  || (symbol->flags & BSF_SECTION_SYM) != 0))
+    {
+      if (relocatable)
+	{
+	  /* Make up a value.  */
+	  gp = symbol->section->output_section->vma + 0x4000;
+	  _bfd_set_gp_value (output_bfd, gp);
+	}
+      else
+	{
+	  unsigned int count;
+	  asymbol **sym;
+	  unsigned int i;
+
+	  count = bfd_get_symcount (output_bfd);
+	  sym = bfd_get_outsymbols (output_bfd);
+
+	  if (sym == (asymbol **) NULL)
+	    i = count;
+	  else
+	    {
+	      for (i = 0; i < count; i++, sym++)
+		{
+		  register const char *name;
+
+		  name = bfd_asymbol_name (*sym);
+		  if (*name == '_' && strcmp (name, "_gp") == 0)
+		    {
+		      gp = bfd_asymbol_value (*sym);
+		      _bfd_set_gp_value (output_bfd, gp);
+		      break;
+		    }
+		}
+	    }
+
+	  if (i >= count)
+	    {
+	      /* Only get the error once.  */
+	      gp = 4;
+	      _bfd_set_gp_value (output_bfd, gp);
+	      *error_message =
+		(char *) _("GP relative relocation when _gp not defined");
+	      return bfd_reloc_dangerous;
+	    }
+	}
+    }
+
+  if (bfd_is_com_section (symbol->section))
+    relocation = 0;
+  else
+    relocation = symbol->value;
+
+  relocation += symbol->section->output_section->vma;
+  relocation += symbol->section->output_offset;
+
+  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
+    return bfd_reloc_outofrange;
+
+  insn = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
+
+  /* Set val to the offset into the section or symbol.  */
+  val = ((insn & 0xffff) + reloc_entry->addend) & 0xffff;
+  if (val & 0x8000)
+    val -= 0x10000;
+
+  /* Adjust val for the final section location and GP value.  If we
+     are producing relocatable output, we don't want to do this for
+     an external symbol.  */
+  if (! relocatable
+      || (symbol->flags & BSF_SECTION_SYM) != 0)
+    val += relocation - gp;
+
+  insn = (insn &~ (unsigned) 0xffff) | (val & 0xffff);
+  bfd_put_32 (abfd, (bfd_vma) insn, (bfd_byte *) data + reloc_entry->address);
+
+  if (relocatable)
+    reloc_entry->address += input_section->output_offset;
+
+  /* Make sure it fit in 16 bits.  */
+  if ((long) val >= 0x8000 || (long) val < -0x8000)
+    return bfd_reloc_overflow;
+
+  return bfd_reloc_ok;
+}
+
+/* Get the howto structure for a generic reloc type.  */
+
+static reloc_howto_type *
+brownie32_bfd_reloc_type_lookup (abfd, code)
+     bfd *abfd ATTRIBUTE_UNUSED;
+     bfd_reloc_code_real_type code;
+{
+  int brownie32_type;
+
+  switch (code)
+    {
+    case BFD_RELOC_16:
+      brownie32_type = BROWNIE32_R_REFHALF;
+      break;
+    case BFD_RELOC_32:
+    case BFD_RELOC_CTOR:
+      brownie32_type = BROWNIE32_R_REFWORD;
+      break;
+    case BFD_RELOC_BROWNIE32_JMP:
+      brownie32_type = BROWNIE32_R_JMPADDR;
+      break;
+    case BFD_RELOC_HI16_S:
+      brownie32_type = BROWNIE32_R_REFHI;
+      break;
+    case BFD_RELOC_LO16:
+      brownie32_type = BROWNIE32_R_REFLO;
+      break;
+    case BFD_RELOC_GPREL16:
+      brownie32_type = BROWNIE32_R_GPREL;
+      break;
+    case BFD_RELOC_BROWNIE32_LITERAL:
+      brownie32_type = BROWNIE32_R_LITERAL;
+      break;
+    case BFD_RELOC_16_PCREL_S2:
+      brownie32_type = BROWNIE32_R_PCREL16;
+      break;
+    default:
+      return (reloc_howto_type *) NULL;
+    }
+
+  return &brownie32_howto_table[brownie32_type];
+}
+
+/* A helper routine for brownie32_relocate_section which handles the REFHI
+   relocations.  The REFHI relocation must be followed by a REFLO
+   relocation, and the addend used is formed from the addends of both
+   instructions.  */
+
+static void
+brownie32_relocate_hi (refhi, reflo, input_bfd, input_section, contents,
+		  relocation)
+     struct internal_reloc *refhi;
+     struct internal_reloc *reflo;
+     bfd *input_bfd;
+     asection *input_section;
+     bfd_byte *contents;
+     bfd_vma relocation;
+{
+  unsigned long insn;
+  unsigned long val;
+  unsigned long vallo;
+
+  if (refhi == NULL)
+    return;
+
+  insn = bfd_get_32 (input_bfd,
+		     contents + refhi->r_vaddr - input_section->vma);
+  if (reflo == NULL)
+    vallo = 0;
+  else
+    vallo = (bfd_get_32 (input_bfd,
+			 contents + reflo->r_vaddr - input_section->vma)
+	     & 0xffff);
+
+  val = ((insn & 0xffff) << 16) + vallo;
+  val += relocation;
+
+  /* The low order 16 bits are always treated as a signed value.
+     Therefore, a negative value in the low order bits requires an
+     adjustment in the high order bits.  We need to make this
+     adjustment in two ways: once for the bits we took from the data,
+     and once for the bits we are putting back in to the data.  */
+  if ((vallo & 0x8000) != 0)
+    val -= 0x10000;
+
+  if ((val & 0x8000) != 0)
+    val += 0x10000;
+
+  insn = (insn &~ (unsigned) 0xffff) | ((val >> 16) & 0xffff);
+  bfd_put_32 (input_bfd, (bfd_vma) insn,
+	      contents + refhi->r_vaddr - input_section->vma);
+}
+
+/* Relocate a section while linking a BROWNIE32 ECOFF file.  */
+
+static bfd_boolean
+brownie32_relocate_section (output_bfd, info, input_bfd, input_section,
+		       contents, external_relocs)
+     bfd *output_bfd;
+     struct bfd_link_info *info;
+     bfd *input_bfd;
+     asection *input_section;
+     bfd_byte *contents;
+     PTR external_relocs;
+{
+  asection **symndx_to_section;
+  struct ecoff_link_hash_entry **sym_hashes;
+  bfd_vma gp;
+  bfd_boolean gp_undefined;
+  struct external_reloc *ext_rel;
+  struct external_reloc *ext_rel_end;
+  unsigned int i;
+  bfd_boolean got_lo;
+  struct internal_reloc lo_int_rel;
+  bfd_size_type amt;
+
+  BFD_ASSERT (input_bfd->xvec->byteorder
+	      == output_bfd->xvec->byteorder);
+
+  /* We keep a table mapping the symndx found in an internal reloc to
+     the appropriate section.  This is faster than looking up the
+     section by name each time.  */
+  symndx_to_section = ecoff_data (input_bfd)->symndx_to_section;
+  if (symndx_to_section == (asection **) NULL)
+    {
+      amt = NUM_RELOC_SECTIONS * sizeof (asection *);
+      symndx_to_section = (asection **) bfd_alloc (input_bfd, amt);
+      if (!symndx_to_section)
+	return FALSE;
+
+      symndx_to_section[RELOC_SECTION_NONE] = NULL;
+      symndx_to_section[RELOC_SECTION_TEXT] =
+	bfd_get_section_by_name (input_bfd, ".text");
+      symndx_to_section[RELOC_SECTION_RDATA] =
+	bfd_get_section_by_name (input_bfd, ".rdata");
+      symndx_to_section[RELOC_SECTION_DATA] =
+	bfd_get_section_by_name (input_bfd, ".data");
+      symndx_to_section[RELOC_SECTION_SDATA] =
+	bfd_get_section_by_name (input_bfd, ".sdata");
+      symndx_to_section[RELOC_SECTION_SBSS] =
+	bfd_get_section_by_name (input_bfd, ".sbss");
+      symndx_to_section[RELOC_SECTION_BSS] =
+	bfd_get_section_by_name (input_bfd, ".bss");
+      symndx_to_section[RELOC_SECTION_INIT] =
+	bfd_get_section_by_name (input_bfd, ".init");
+      symndx_to_section[RELOC_SECTION_LIT8] =
+	bfd_get_section_by_name (input_bfd, ".lit8");
+      symndx_to_section[RELOC_SECTION_LIT4] =
+	bfd_get_section_by_name (input_bfd, ".lit4");
+      symndx_to_section[RELOC_SECTION_XDATA] = NULL;
+      symndx_to_section[RELOC_SECTION_PDATA] = NULL;
+      symndx_to_section[RELOC_SECTION_FINI] =
+	bfd_get_section_by_name (input_bfd, ".fini");
+      symndx_to_section[RELOC_SECTION_LITA] = NULL;
+      symndx_to_section[RELOC_SECTION_ABS] = NULL;
+
+      ecoff_data (input_bfd)->symndx_to_section = symndx_to_section;
+    }
+
+  sym_hashes = ecoff_data (input_bfd)->sym_hashes;
+
+  gp = _bfd_get_gp_value (output_bfd);
+  if (gp == 0)
+    gp_undefined = TRUE;
+  else
+    gp_undefined = FALSE;
+
+  got_lo = FALSE;
+
+  ext_rel = (struct external_reloc *) external_relocs;
+  ext_rel_end = ext_rel + input_section->reloc_count;
+  for (i = 0; ext_rel < ext_rel_end; ext_rel++, i++)
+    {
+      struct internal_reloc int_rel;
+      bfd_boolean use_lo = FALSE;
+      bfd_vma addend;
+      reloc_howto_type *howto;
+      struct ecoff_link_hash_entry *h = NULL;
+      asection *s = NULL;
+      bfd_vma relocation;
+      bfd_reloc_status_type r;
+
+      if (! got_lo)
+	brownie32_ecoff_swap_reloc_in (input_bfd, (PTR) ext_rel, &int_rel);
+      else
+	{
+	  int_rel = lo_int_rel;
+	  got_lo = FALSE;
+	}
+
+      BFD_ASSERT (int_rel.r_type
+		  < sizeof brownie32_howto_table / sizeof brownie32_howto_table[0]);
+
+      /* The REFHI reloc requires special handling.  It must be followed
+	 by a REFLO reloc, and the addend is formed from both relocs.  */
+      if (int_rel.r_type == BROWNIE32_R_REFHI)
+	{
+	  struct external_reloc *lo_ext_rel;
+
+	  /* As a GNU extension, permit an arbitrary number of REFHI
+             relocs before the REFLO reloc.  This permits gcc to emit
+	     the HI and LO relocs itself.  */
+	  for (lo_ext_rel = ext_rel + 1;
+	       lo_ext_rel < ext_rel_end;
+	       lo_ext_rel++)
+	    {
+	      brownie32_ecoff_swap_reloc_in (input_bfd, (PTR) lo_ext_rel,
+					&lo_int_rel);
+	      if (lo_int_rel.r_type != int_rel.r_type)
+		break;
+	    }
+
+	  if (lo_ext_rel < ext_rel_end
+	      && lo_int_rel.r_type == BROWNIE32_R_REFLO
+	      && int_rel.r_extern == lo_int_rel.r_extern
+	      && int_rel.r_symndx == lo_int_rel.r_symndx)
+	    {
+	      use_lo = TRUE;
+	      if (lo_ext_rel == ext_rel + 1)
+		got_lo = TRUE;
+	    }
+	}
+
+      howto = &brownie32_howto_table[int_rel.r_type];
+
+      if (int_rel.r_extern)
+	{
+	  h = sym_hashes[int_rel.r_symndx];
+	  /* If h is NULL, that means that there is a reloc against an
+	     external symbol which we thought was just a debugging
+	     symbol.  This should not happen.  */
+	  if (h == (struct ecoff_link_hash_entry *) NULL)
+	    abort ();
+	}
+      else
+	{
+	  if (int_rel.r_symndx < 0 || int_rel.r_symndx >= NUM_RELOC_SECTIONS)
+	    s = NULL;
+	  else
+	    s = symndx_to_section[int_rel.r_symndx];
+
+	  if (s == (asection *) NULL)
+	    abort ();
+	}
+
+      /* The GPREL reloc uses an addend: the difference in the GP
+	 values.  */
+      if (int_rel.r_type != BROWNIE32_R_GPREL
+	  && int_rel.r_type != BROWNIE32_R_LITERAL)
+	addend = 0;
+      else
+	{
+	  if (gp_undefined)
+	    {
+	      if (! ((*info->callbacks->reloc_dangerous)
+		     (info, _("GP relative relocation used when GP not defined"),
+		      input_bfd, input_section,
+		      int_rel.r_vaddr - input_section->vma)))
+		return FALSE;
+	      /* Only give the error once per link.  */
+	      gp = 4;
+	      _bfd_set_gp_value (output_bfd, gp);
+	      gp_undefined = FALSE;
+	    }
+	  if (! int_rel.r_extern)
+	    {
+	      /* This is a relocation against a section.  The current
+		 addend in the instruction is the difference between
+		 INPUT_SECTION->vma and the GP value of INPUT_BFD.  We
+		 must change this to be the difference between the
+		 final definition (which will end up in RELOCATION)
+		 and the GP value of OUTPUT_BFD (which is in GP).  */
+	      addend = ecoff_data (input_bfd)->gp - gp;
+	    }
+	  else if (! info->relocatable
+		   || h->root.type == bfd_link_hash_defined
+		   || h->root.type == bfd_link_hash_defweak)
+	    {
+	      /* This is a relocation against a defined symbol.  The
+		 current addend in the instruction is simply the
+		 desired offset into the symbol (normally zero).  We
+		 are going to change this into a relocation against a
+		 defined symbol, so we want the instruction to hold
+		 the difference between the final definition of the
+		 symbol (which will end up in RELOCATION) and the GP
+		 value of OUTPUT_BFD (which is in GP).  */
+	      addend = - gp;
+	    }
+	  else
+	    {
+	      /* This is a relocation against an undefined or common
+		 symbol.  The current addend in the instruction is
+		 simply the desired offset into the symbol (normally
+		 zero).  We are generating relocatable output, and we
+		 aren't going to define this symbol, so we just leave
+		 the instruction alone.  */
+	      addend = 0;
+	    }
+	}
+
+      if (info->relocatable)
+	{
+	  /* We are generating relocatable output, and must convert
+	     the existing reloc.  */
+	  if (int_rel.r_extern)
+	    {
+	      if ((h->root.type == bfd_link_hash_defined
+		   || h->root.type == bfd_link_hash_defweak)
+		  && ! bfd_is_abs_section (h->root.u.def.section))
+		{
+		  const char *name;
+
+		  /* This symbol is defined in the output.  Convert
+		     the reloc from being against the symbol to being
+		     against the section.  */
+
+		  /* Clear the r_extern bit.  */
+		  int_rel.r_extern = 0;
+
+		  /* Compute a new r_symndx value.  */
+		  s = h->root.u.def.section;
+		  name = bfd_get_section_name (output_bfd,
+					       s->output_section);
+
+		  int_rel.r_symndx = -1;
+		  switch (name[1])
+		    {
+		    case 'b':
+		      if (strcmp (name, ".bss") == 0)
+			int_rel.r_symndx = RELOC_SECTION_BSS;
+		      break;
+		    case 'd':
+		      if (strcmp (name, ".data") == 0)
+			int_rel.r_symndx = RELOC_SECTION_DATA;
+		      break;
+		    case 'f':
+		      if (strcmp (name, ".fini") == 0)
+			int_rel.r_symndx = RELOC_SECTION_FINI;
+		      break;
+		    case 'i':
+		      if (strcmp (name, ".init") == 0)
+			int_rel.r_symndx = RELOC_SECTION_INIT;
+		      break;
+		    case 'l':
+		      if (strcmp (name, ".lit8") == 0)
+			int_rel.r_symndx = RELOC_SECTION_LIT8;
+		      else if (strcmp (name, ".lit4") == 0)
+			int_rel.r_symndx = RELOC_SECTION_LIT4;
+		      break;
+		    case 'r':
+		      if (strcmp (name, ".rdata") == 0)
+			int_rel.r_symndx = RELOC_SECTION_RDATA;
+		      break;
+		    case 's':
+		      if (strcmp (name, ".sdata") == 0)
+			int_rel.r_symndx = RELOC_SECTION_SDATA;
+		      else if (strcmp (name, ".sbss") == 0)
+			int_rel.r_symndx = RELOC_SECTION_SBSS;
+		      break;
+		    case 't':
+		      if (strcmp (name, ".text") == 0)
+			int_rel.r_symndx = RELOC_SECTION_TEXT;
+		      break;
+		    }
+
+		  if (int_rel.r_symndx == -1)
+		    abort ();
+
+		  /* Add the section VMA and the symbol value.  */
+		  relocation = (h->root.u.def.value
+				+ s->output_section->vma
+				+ s->output_offset);
+
+		  /* For a PC relative relocation, the object file
+		     currently holds just the addend.  We must adjust
+		     by the address to get the right value.  */
+		  if (howto->pc_relative)
+		    relocation -= int_rel.r_vaddr - input_section->vma;
+
+		  h = NULL;
+		}
+	      else
+		{
+		  /* Change the symndx value to the right one for the
+		     output BFD.  */
+		  int_rel.r_symndx = h->indx;
+		  if (int_rel.r_symndx == -1)
+		    {
+		      /* This symbol is not being written out.  */
+		      if (! ((*info->callbacks->unattached_reloc)
+			     (info, h->root.root.string, input_bfd,
+			      input_section,
+			      int_rel.r_vaddr - input_section->vma)))
+			return FALSE;
+		      int_rel.r_symndx = 0;
+		    }
+		  relocation = 0;
+		}
+	    }
+	  else
+	    {
+	      /* This is a relocation against a section.  Adjust the
+		 value by the amount the section moved.  */
+	      relocation = (s->output_section->vma
+			    + s->output_offset
+			    - s->vma);
+	    }
+
+	  relocation += addend;
+	  addend = 0;
+
+	  /* Adjust a PC relative relocation by removing the reference
+	     to the original address in the section and including the
+	     reference to the new address.  */
+	  if (howto->pc_relative)
+	    relocation -= (input_section->output_section->vma
+			   + input_section->output_offset
+			   - input_section->vma);
+
+	  /* Adjust the contents.  */
+	  if (relocation == 0)
+	    r = bfd_reloc_ok;
+	  else
+	    {
+	      if (int_rel.r_type != BROWNIE32_R_REFHI)
+		r = _bfd_relocate_contents (howto, input_bfd, relocation,
+					    (contents
+					     + int_rel.r_vaddr
+					     - input_section->vma));
+	      else
+		{
+		  brownie32_relocate_hi (&int_rel,
+				    use_lo ? &lo_int_rel : NULL,
+				    input_bfd, input_section, contents,
+				    relocation);
+		  r = bfd_reloc_ok;
+		}
+	    }
+
+	  /* Adjust the reloc address.  */
+	  int_rel.r_vaddr += (input_section->output_section->vma
+			      + input_section->output_offset
+			      - input_section->vma);
+
+	  /* Save the changed reloc information.  */
+	  brownie32_ecoff_swap_reloc_out (input_bfd, &int_rel, (PTR) ext_rel);
+	}
+      else
+	{
+	  /* We are producing a final executable.  */
+	  if (int_rel.r_extern)
+	    {
+	      /* This is a reloc against a symbol.  */
+	      if (h->root.type == bfd_link_hash_defined
+		  || h->root.type == bfd_link_hash_defweak)
+		{
+		  asection *hsec;
+
+		  hsec = h->root.u.def.section;
+		  relocation = (h->root.u.def.value
+				+ hsec->output_section->vma
+				+ hsec->output_offset);
+		}
+	      else
+		{
+		  if (! ((*info->callbacks->undefined_symbol)
+			 (info, h->root.root.string, input_bfd,
+			  input_section,
+			  int_rel.r_vaddr - input_section->vma, TRUE)))
+		    return FALSE;
+		  relocation = 0;
+		}
+	    }
+	  else
+	    {
+	      /* This is a reloc against a section.  */
+	      relocation = (s->output_section->vma
+			    + s->output_offset
+			    - s->vma);
+
+	      /* A PC relative reloc is already correct in the object
+		 file.  Make it look like a pcrel_offset relocation by
+		 adding in the start address.  */
+	      if (howto->pc_relative)
+		relocation += int_rel.r_vaddr;
+	    }
+
+	  if (int_rel.r_type != BROWNIE32_R_REFHI)
+	    r = _bfd_final_link_relocate (howto,
+					  input_bfd,
+					  input_section,
+					  contents,
+					  (int_rel.r_vaddr
+					   - input_section->vma),
+					  relocation,
+					  addend);
+	  else
+	    {
+	      brownie32_relocate_hi (&int_rel,
+				use_lo ? &lo_int_rel : NULL,
+				input_bfd, input_section, contents,
+				relocation);
+	      r = bfd_reloc_ok;
+	    }
+	}
+
+      /* BROWNIE32_R_JMPADDR requires peculiar overflow detection.  The
+	 instruction provides a 28 bit address (the two lower bits are
+	 implicit zeroes) which is combined with the upper four bits
+	 of the instruction address.  */
+      if (r == bfd_reloc_ok
+	  && int_rel.r_type == BROWNIE32_R_JMPADDR
+	  && (((relocation
+		+ addend
+		+ (int_rel.r_extern ? 0 : s->vma))
+	       & 0xf0000000)
+	      != ((input_section->output_section->vma
+		   + input_section->output_offset
+		   + (int_rel.r_vaddr - input_section->vma))
+		  & 0xf0000000)))
+	r = bfd_reloc_overflow;
+
+      if (r != bfd_reloc_ok)
+	{
+	  switch (r)
+	    {
+	    default:
+	    case bfd_reloc_outofrange:
+	      abort ();
+	    case bfd_reloc_overflow:
+	      {
+		const char *name;
+
+		if (int_rel.r_extern)
+		  name = NULL;
+		else
+		  name = bfd_section_name (input_bfd, s);
+		if (! ((*info->callbacks->reloc_overflow)
+		       (info, (h ? &h->root : NULL), name, howto->name,
+			(bfd_vma) 0, input_bfd, input_section,
+			int_rel.r_vaddr - input_section->vma)))
+		  return FALSE;
+	      }
+	      break;
+	    }
+	}
+    }
+
+  return TRUE;
+}
+
+/* This is the ECOFF backend structure.  The backend field of the
+   target vector points to this.  */
+
+static const struct ecoff_backend_data brownie32_ecoff_backend_data =
+{
+  /* COFF backend structure.  */
+  {
+    (void (*) PARAMS ((bfd *,PTR,int,int,int,int,PTR))) bfd_void, /* aux_in */
+    (void (*) PARAMS ((bfd *,PTR,PTR))) bfd_void, /* sym_in */
+    (void (*) PARAMS ((bfd *,PTR,PTR))) bfd_void, /* lineno_in */
+    (unsigned (*) PARAMS ((bfd *,PTR,int,int,int,int,PTR)))bfd_void,/*aux_out*/
+    (unsigned (*) PARAMS ((bfd *,PTR,PTR))) bfd_void, /* sym_out */
+    (unsigned (*) PARAMS ((bfd *,PTR,PTR))) bfd_void, /* lineno_out */
+    (unsigned (*) PARAMS ((bfd *,PTR,PTR))) bfd_void, /* reloc_out */
+    brownie32_ecoff_swap_filehdr_out, brownie32_ecoff_swap_aouthdr_out,
+    brownie32_ecoff_swap_scnhdr_out,
+    FILHSZ, AOUTSZ, SCNHSZ, 0, 0, 0, 0, FILNMLEN, TRUE, FALSE, 4, FALSE, 2,
+    brownie32_ecoff_swap_filehdr_in, brownie32_ecoff_swap_aouthdr_in,
+    brownie32_ecoff_swap_scnhdr_in, NULL,
+    brownie32_ecoff_bad_format_hook, _bfd_ecoff_set_arch_mach_hook,
+    _bfd_ecoff_mkobject_hook, _bfd_ecoff_styp_to_sec_flags,
+    _bfd_ecoff_set_alignment_hook, _bfd_ecoff_slurp_symbol_table,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL
+  },
+  /* Supported architecture.  */
+  bfd_arch_brownie32,
+  /* Initial portion of armap string.  */
+  "__________",
+  /* The page boundary used to align sections in a demand-paged
+     executable file.  E.g., 0x1000.  */
+  0x1000,
+  /* TRUE if the .rdata section is part of the text segment, as on the
+     Alpha.  FALSE if .rdata is part of the data segment, as on the
+     BROWNIE32.  */
+  FALSE,
+  /* Bitsize of constructor entries.  */
+  32,
+  /* Reloc to use for constructor entries.  */
+  &brownie32_howto_table[BROWNIE32_R_REFWORD],
+  {
+    /* Symbol table magic number.  */
+    magicSym,
+    /* Alignment of debugging information.  E.g., 4.  */
+    4,
+    /* Sizes of external symbolic information.  */
+    sizeof (struct hdr_ext),
+    sizeof (struct dnr_ext),
+    sizeof (struct pdr_ext),
+    sizeof (struct sym_ext),
+    sizeof (struct opt_ext),
+    sizeof (struct fdr_ext),
+    sizeof (struct rfd_ext),
+    sizeof (struct ext_ext),
+    /* Functions to swap in external symbolic data.  */
+    ecoff_swap_hdr_in,
+    ecoff_swap_dnr_in,
+    ecoff_swap_pdr_in,
+    ecoff_swap_sym_in,
+    ecoff_swap_opt_in,
+    ecoff_swap_fdr_in,
+    ecoff_swap_rfd_in,
+    ecoff_swap_ext_in,
+    _bfd_ecoff_swap_tir_in,
+    _bfd_ecoff_swap_rndx_in,
+    /* Functions to swap out external symbolic data.  */
+    ecoff_swap_hdr_out,
+    ecoff_swap_dnr_out,
+    ecoff_swap_pdr_out,
+    ecoff_swap_sym_out,
+    ecoff_swap_opt_out,
+    ecoff_swap_fdr_out,
+    ecoff_swap_rfd_out,
+    ecoff_swap_ext_out,
+    _bfd_ecoff_swap_tir_out,
+    _bfd_ecoff_swap_rndx_out,
+    /* Function to read in symbolic data.  */
+    _bfd_ecoff_slurp_symbolic_info
+  },
+  /* External reloc size.  */
+  RELSZ,
+  /* Reloc swapping functions.  */
+  brownie32_ecoff_swap_reloc_in,
+  brownie32_ecoff_swap_reloc_out,
+  /* Backend reloc tweaking.  */
+  brownie32_adjust_reloc_in,
+  brownie32_adjust_reloc_out,
+  /* Relocate section contents while linking.  */
+  brownie32_relocate_section,
+  /* Do final adjustments to filehdr and aouthdr.  */
+  NULL,
+  /* Read an element from an archive at a given file position.  */
+  _bfd_get_elt_at_filepos
+};
+
+/* Looking up a reloc type is BROWNIE32 specific.  */
+#define _bfd_ecoff_bfd_reloc_type_lookup brownie32_bfd_reloc_type_lookup
+
+/* Getting relocated section contents is generic.  */
+#define _bfd_ecoff_bfd_get_relocated_section_contents \
+  bfd_generic_get_relocated_section_contents
+
+/* Handling file windows is generic.  */
+#define _bfd_ecoff_get_section_contents_in_window \
+  _bfd_generic_get_section_contents_in_window
+
+/* Relaxing sections is BROWNIE32 specific.  */
+#define _bfd_ecoff_bfd_relax_section bfd_generic_relax_section
+
+/* GC of sections is not done.  */
+#define _bfd_ecoff_bfd_gc_sections bfd_generic_gc_sections
+
+/* Merging of sections is not done.  */
+#define _bfd_ecoff_bfd_merge_sections bfd_generic_merge_sections
+
+#define _bfd_ecoff_bfd_is_group_section bfd_generic_is_group_section
+#define _bfd_ecoff_bfd_discard_group bfd_generic_discard_group
+#define _bfd_ecoff_section_already_linked \
+  _bfd_generic_section_already_linked
+
+extern const bfd_target ecoff_big_vec;
+
+const bfd_target ecoff_little_vec =
+{
+  "ecoff-littlebrownie32",		/* name */
+  bfd_target_ecoff_flavour,
+  BFD_ENDIAN_LITTLE,		/* data byte order is little */
+  BFD_ENDIAN_LITTLE,		/* header byte order is little */
+
+  (HAS_RELOC | EXEC_P |		/* object flags */
+   HAS_LINENO | HAS_DEBUG |
+   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
+
+  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
+  0,				/* leading underscore */
+  ' ',				/* ar_pad_char */
+  15,				/* ar_max_namelen */
+  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
+     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
+     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* data */
+  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
+     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
+     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* hdrs */
+
+  {_bfd_dummy_target, coff_object_p, /* bfd_check_format */
+     _bfd_ecoff_archive_p, _bfd_dummy_target},
+  {bfd_false, _bfd_ecoff_mkobject,  /* bfd_set_format */
+     _bfd_generic_mkarchive, bfd_false},
+  {bfd_false, _bfd_ecoff_write_object_contents, /* bfd_write_contents */
+     _bfd_write_archive_contents, bfd_false},
+
+     BFD_JUMP_TABLE_GENERIC (_bfd_ecoff),
+     BFD_JUMP_TABLE_COPY (_bfd_ecoff),
+     BFD_JUMP_TABLE_CORE (_bfd_nocore),
+     BFD_JUMP_TABLE_ARCHIVE (_bfd_ecoff),
+     BFD_JUMP_TABLE_SYMBOLS (_bfd_ecoff),
+     BFD_JUMP_TABLE_RELOCS (_bfd_ecoff),
+     BFD_JUMP_TABLE_WRITE (_bfd_ecoff),
+     BFD_JUMP_TABLE_LINK (_bfd_ecoff),
+     BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
+
+  & ecoff_big_vec,
+
+  (PTR) &brownie32_ecoff_backend_data
+};
+
+const bfd_target ecoff_big_vec =
+{
+  "ecoff-bigbrownie32",		/* name */
+  bfd_target_ecoff_flavour,
+  BFD_ENDIAN_BIG,		/* data byte order is big */
+  BFD_ENDIAN_BIG,		/* header byte order is big */
+
+  (HAS_RELOC | EXEC_P |		/* object flags */
+   HAS_LINENO | HAS_DEBUG |
+   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
+
+  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
+  0,				/* leading underscore */
+  ' ',				/* ar_pad_char */
+  15,				/* ar_max_namelen */
+  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
+     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
+     bfd_getb16, bfd_getb_signed_16, bfd_putb16,
+  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
+     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
+     bfd_getb16, bfd_getb_signed_16, bfd_putb16,
+ {_bfd_dummy_target, coff_object_p, /* bfd_check_format */
+    _bfd_ecoff_archive_p, _bfd_dummy_target},
+ {bfd_false, _bfd_ecoff_mkobject, /* bfd_set_format */
+    _bfd_generic_mkarchive, bfd_false},
+ {bfd_false, _bfd_ecoff_write_object_contents, /* bfd_write_contents */
+    _bfd_write_archive_contents, bfd_false},
+
+     BFD_JUMP_TABLE_GENERIC (_bfd_ecoff),
+     BFD_JUMP_TABLE_COPY (_bfd_ecoff),
+     BFD_JUMP_TABLE_CORE (_bfd_nocore),
+     BFD_JUMP_TABLE_ARCHIVE (_bfd_ecoff),
+     BFD_JUMP_TABLE_SYMBOLS (_bfd_ecoff),
+     BFD_JUMP_TABLE_RELOCS (_bfd_ecoff),
+     BFD_JUMP_TABLE_WRITE (_bfd_ecoff),
+     BFD_JUMP_TABLE_LINK (_bfd_ecoff),
+     BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
+
+  & ecoff_little_vec,
+
+  (PTR) &brownie32_ecoff_backend_data
+};
+
+const bfd_target ecoff_biglittle_vec =
+{
+  "ecoff-biglittlebrownie32",		/* name */
+  bfd_target_ecoff_flavour,
+  BFD_ENDIAN_LITTLE,		/* data byte order is little */
+  BFD_ENDIAN_BIG,		/* header byte order is big */
+
+  (HAS_RELOC | EXEC_P |		/* object flags */
+   HAS_LINENO | HAS_DEBUG |
+   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
+
+  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
+  0,				/* leading underscore */
+  ' ',				/* ar_pad_char */
+  15,				/* ar_max_namelen */
+  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
+     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
+     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* data */
+  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
+     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
+     bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* hdrs */
+
+  {_bfd_dummy_target, coff_object_p, /* bfd_check_format */
+     _bfd_ecoff_archive_p, _bfd_dummy_target},
+  {bfd_false, _bfd_ecoff_mkobject,  /* bfd_set_format */
+     _bfd_generic_mkarchive, bfd_false},
+  {bfd_false, _bfd_ecoff_write_object_contents, /* bfd_write_contents */
+     _bfd_write_archive_contents, bfd_false},
+
+     BFD_JUMP_TABLE_GENERIC (_bfd_ecoff),
+     BFD_JUMP_TABLE_COPY (_bfd_ecoff),
+     BFD_JUMP_TABLE_CORE (_bfd_nocore),
+     BFD_JUMP_TABLE_ARCHIVE (_bfd_ecoff),
+     BFD_JUMP_TABLE_SYMBOLS (_bfd_ecoff),
+     BFD_JUMP_TABLE_RELOCS (_bfd_ecoff),
+     BFD_JUMP_TABLE_WRITE (_bfd_ecoff),
+     BFD_JUMP_TABLE_LINK (_bfd_ecoff),
+     BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
+
+  NULL,
+
+  (PTR) &brownie32_ecoff_backend_data
+};
Index: bfd/config.bfd
===================================================================
RCS file: /home/prj/asip/cvs/gdb/bfd/config.bfd,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- bfd/config.bfd	31 Jul 2007 11:40:33 -0000	1.1.1.1
+++ bfd/config.bfd	8 Aug 2007 08:49:54 -0000	1.2
@@ -58,6 +58,7 @@ case $targ in
  *-go32-rtems* | \
  i[3-7]86*-*-rtemscoff* | \
  mips*el-*-rtems* | \
+ brownie32*el-*-rtems* | \
  powerpcle-*-rtems* | \
  sparc*-*-rtemsaout* | \
  null)
@@ -87,6 +88,7 @@ m68*)		 targ_archs=bfd_m68k_arch ;;
 m88*)		 targ_archs=bfd_m88k_arch ;;
 maxq*)		 targ_archs=bfd_maxq_arch ;;
 mips*)		 targ_archs=bfd_mips_arch ;;
+brownie32*)		 targ_archs=bfd_brownie32_arch ;;
 or32*)		 targ_archs=bfd_or32_arch ;;
 pdp11*)		 targ_archs=bfd_pdp11_arch ;;
 pj*)		 targ_archs="bfd_pj_arch bfd_i386_arch";;
@@ -131,6 +133,20 @@ case "${targ}" in
     echo "This target is obsolete and has been removed."
     exit 1
     ;;
+  brownie32*-dec-bsd*)
+    echo "This target is obsolete and has been removed."
+    exit 1
+    ;;
+
+  brownie32*-*-mach3*)
+    echo "This target is obsolete and has been removed."
+    exit 1
+    ;;
+
+  brownie32*-*-pe*)
+    echo "This target is obsolete and has been removed."
+    exit 1
+    ;;
 
 # START OF targmatch.h
 #ifdef BFD64
@@ -910,6 +926,98 @@ case "${targ}" in
     targ_selvecs="bfd_elf32_tradlittlemips_vec ecoff_big_vec ecoff_little_vec bfd_elf32_ntradbigmips_vec bfd_elf64_tradbigmips_vec bfd_elf32_ntradlittlemips_vec bfd_elf64_tradlittlemips_vec"
     want64=true
     ;;
+  brownie32*-big-*)
+    targ_defvec=ecoff_big_vec
+    targ_selvecs=ecoff_little_vec
+    ;;
+  brownie32*el-*-netbsd*)
+    targ_defvec=bfd_elf32_littlebrownie32_vec
+    targ_selvecs="bfd_elf32_bigbrownie32_vec bfd_elf64_bigbrownie32_vec bfd_elf64_littlebrownie32_vec ecoff_little_vec ecoff_big_vec"
+    ;;
+  brownie32*-*-netbsd*)
+    targ_defvec=bfd_elf32_bigbrownie32_vec
+    targ_selvecs="bfd_elf32_littlebrownie32_vec bfd_elf64_bigbrownie32_vec bfd_elf64_littlebrownie32_vec ecoff_big_vec ecoff_little_vec"
+    ;;
+  brownie32*-dec-* | brownie32*el-*-ecoff*)
+    targ_defvec=ecoff_little_vec
+    targ_selvecs=ecoff_big_vec
+    ;;
+  brownie32*-*-ecoff*)
+    targ_defvec=ecoff_big_vec
+    targ_selvecs=ecoff_little_vec
+    ;;
+#ifdef BFD64
+  brownie32*-*-irix6*)
+    targ_defvec=bfd_elf32_nbigbrownie32_vec
+    targ_selvecs="bfd_elf32_nlittlebrownie32_vec bfd_elf32_bigbrownie32_vec bfd_elf32_littlebrownie32_vec bfd_elf64_bigbrownie32_vec bfd_elf64_littlebrownie32_vec"
+    ;;
+#endif
+  brownie32*-*-irix5*)
+    targ_defvec=bfd_elf32_bigbrownie32_vec
+    targ_selvecs="bfd_elf32_littlebrownie32_vec ecoff_big_vec ecoff_little_vec"
+    ;;
+  brownie32*-sgi-* | brownie32*-*-bsd*)
+    targ_defvec=ecoff_big_vec
+    targ_selvecs=ecoff_little_vec
+    ;;
+  brownie32*-*-lnews*)
+    targ_defvec=ecoff_biglittle_vec
+    targ_selvecs="ecoff_little_vec ecoff_big_vec"
+    ;;
+  brownie32*-*-sysv4*)
+    targ_defvec=bfd_elf32_tradbigbrownie32_vec
+    targ_selvecs="bfd_elf32_tradlittlebrownie32_vec ecoff_big_vec ecoff_little_vec"
+    ;;
+  brownie32*-*-sysv* | brownie32*-*-riscos*)
+    targ_defvec=ecoff_big_vec
+    targ_selvecs=ecoff_little_vec
+    ;;
+  brownie32*el-*-elf* | brownie32*el-*-vxworks* | brownie32*-*-chorus*)
+    targ_defvec=bfd_elf32_littlebrownie32_vec
+    targ_selvecs="bfd_elf32_bigbrownie32_vec bfd_elf64_bigbrownie32_vec bfd_elf64_littlebrownie32_vec"
+    ;;
+  brownie32*-*-elf* | brownie32*-*-rtems* | brownie32*-*-vxworks | brownie32*-*-windiss)
+    targ_defvec=bfd_elf32_bigbrownie32_vec
+    targ_selvecs="bfd_elf32_littlebrownie32_vec bfd_elf64_bigbrownie32_vec bfd_elf64_littlebrownie32_vec"
+    ;;
+  brownie32*-*-none)
+    targ_defvec=bfd_elf32_bigbrownie32_vec
+    targ_selvecs="bfd_elf32_littlebrownie32_vec bfd_elf64_bigbrownie32_vec bfd_elf64_littlebrownie32_vec"
+    ;;
+#ifdef BFD64
+  brownie3264*-*-openbsd*)
+    targ_defvec=bfd_elf64_tradbigbrownie32_vec
+    targ_selvecs="bfd_elf32_ntradlittlebrownie32_vec bfd_elf32_ntradbigbrownie32_vec bfd_elf32_tradlittlebrownie32_vec bfd_elf32_tradbigbrownie32_vec bfd_elf64_tradlittlebrownie32_vec"
+    ;;
+#endif
+  brownie32*el-*-openbsd*)
+    targ_defvec=bfd_elf32_littlebrownie32_vec
+    targ_selvecs="bfd_elf32_bigbrownie32_vec bfd_elf64_bigbrownie32_vec bfd_elf64_littlebrownie32_vec ecoff_little_vec ecoff_big_vec"
+    ;;
+  brownie32*-*-openbsd*)
+    targ_defvec=bfd_elf32_bigbrownie32_vec
+    targ_selvecs="bfd_elf32_littlebrownie32_vec bfd_elf64_bigbrownie32_vec bfd_elf64_littlebrownie32_vec ecoff_big_vec ecoff_little_vec"
+    ;;
+#ifdef BFD64
+  brownie3264*el-*-linux*)
+    targ_defvec=bfd_elf32_ntradlittlebrownie32_vec
+    targ_selvecs="bfd_elf32_ntradbigbrownie32_vec bfd_elf32_tradlittlebrownie32_vec bfd_elf32_tradbigbrownie32_vec bfd_elf64_tradlittlebrownie32_vec bfd_elf64_tradbigbrownie32_vec"
+    ;;
+  brownie3264*-*-linux*)
+    targ_defvec=bfd_elf32_ntradbigbrownie32_vec
+    targ_selvecs="bfd_elf32_ntradlittlebrownie32_vec bfd_elf32_tradbigbrownie32_vec bfd_elf32_tradlittlebrownie32_vec bfd_elf64_tradbigbrownie32_vec bfd_elf64_tradlittlebrownie32_vec"
+    ;;
+#endif
+  brownie32*el-*-linux*)
+    targ_defvec=bfd_elf32_tradlittlebrownie32_vec
+    targ_selvecs="bfd_elf32_tradbigbrownie32_vec ecoff_little_vec ecoff_big_vec bfd_elf32_ntradlittlebrownie32_vec bfd_elf64_tradlittlebrownie32_vec bfd_elf32_ntradbigbrownie32_vec bfd_elf64_tradbigbrownie32_vec"
+    want64=true
+    ;;
+  brownie32*-*-linux*)
+    targ_defvec=bfd_elf32_tradbigbrownie32_vec
+    targ_selvecs="bfd_elf32_tradlittlebrownie32_vec ecoff_big_vec ecoff_little_vec bfd_elf32_ntradbigbrownie32_vec bfd_elf64_tradbigbrownie32_vec bfd_elf32_ntradlittlebrownie32_vec bfd_elf64_tradlittlebrownie32_vec"
+    want64=true
+    ;;
 #ifdef BFD64
   mmix-*-*)
     targ_defvec=bfd_elf64_mmix_vec
@@ -1414,7 +1522,7 @@ esac
 # to be used on an arbitrary ELF file for anything other than
 # relocation information.
 case "${targ_defvec} ${targ_selvecs}" in
-  *bfd_elf64* | *bfd_elf32_n*mips*)
+  *bfd_elf64* | *bfd_elf32_n*mips* | *bfd_elf32_n*brownie32*)
     targ_selvecs="${targ_selvecs} bfd_elf64_little_generic_vec bfd_elf64_big_generic_vec bfd_elf32_little_generic_vec bfd_elf32_big_generic_vec"
     ;;
   *bfd_elf32*)
Index: bfd/configure
===================================================================
RCS file: /home/prj/asip/cvs/gdb/bfd/configure,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- bfd/configure	31 Jul 2007 11:40:32 -0000	1.1.1.1
+++ bfd/configure	8 Aug 2007 08:49:54 -0000	1.2
@@ -3,6 +3,8 @@
 # Generated by GNU Autoconf 2.59.
 #
 # Copyright (C) 2003 Free Software Foundation, Inc.
+# Copyright (C) 2005,2006  Upwind technology, Inc.
+#
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
 ## --------------------- ##
@@ -975,7 +977,7 @@ esac
     else
       echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
     fi
-    cd "$ac_popdir"
+    cd $ac_popdir
   done
 fi
 
@@ -1999,7 +2001,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2057,7 +2060,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2173,7 +2177,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2227,7 +2232,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2272,7 +2278,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2316,7 +2323,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2394,7 +2402,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2448,7 +2457,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2828,7 +2838,7 @@ fi
 
 # Define the identity of the package.
  PACKAGE=bfd
- VERSION=2.16.91
+ VERSION=1.9.5
 
 
 cat >>confdefs.h <<_ACEOF
@@ -3968,7 +3978,7 @@ test x"$pic_mode" = xno && libtool_flags
 case $host in
 *-*-irix6*)
   # Find out which ABI we are using.
-  echo '#line 3971 "configure"' > conftest.$ac_ext
+  echo '#line 3979 "configure"' > conftest.$ac_ext
   if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
@@ -4064,7 +4074,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4787,7 +4798,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4845,7 +4857,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4961,7 +4974,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5015,7 +5029,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5060,7 +5075,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5104,7 +5120,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5514,7 +5531,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5721,7 +5739,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5781,7 +5800,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5860,7 +5880,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5925,7 +5946,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5990,7 +6012,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6054,7 +6077,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6135,7 +6159,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6276,7 +6301,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6414,7 +6440,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6598,7 +6625,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6849,7 +6877,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7043,7 +7072,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7146,7 +7176,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7217,7 +7248,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7314,7 +7346,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7450,7 +7483,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7514,7 +7548,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7569,7 +7604,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7709,7 +7745,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7842,7 +7879,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8119,7 +8157,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8391,7 +8430,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8449,7 +8489,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8511,7 +8552,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8551,7 +8593,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8607,7 +8650,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8647,7 +8691,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8711,7 +8756,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8742,8 +8788,10 @@ See \`config.log' for more details." >&2
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: internal error: not reached in cross-compile" >&5
-echo "$as_me: error: internal error: not reached in cross-compile" >&2;}
+  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
@@ -8857,7 +8905,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8919,7 +8968,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8959,7 +9009,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -9015,7 +9066,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -9055,7 +9107,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -9119,7 +9172,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -9150,8 +9204,10 @@ See \`config.log' for more details." >&2
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: internal error: not reached in cross-compile" >&5
-echo "$as_me: error: internal error: not reached in cross-compile" >&2;}
+  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
@@ -9330,7 +9386,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -9481,7 +9538,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -9629,7 +9687,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -9700,7 +9759,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -9772,7 +9832,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -9826,7 +9887,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -9897,7 +9959,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -9951,7 +10014,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -10015,7 +10079,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -10121,7 +10186,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -10222,7 +10288,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -10287,7 +10354,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -10358,7 +10426,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -10429,7 +10498,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -10500,7 +10570,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -10571,7 +10642,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -10653,7 +10725,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -10724,7 +10797,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -10795,7 +10869,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -10866,7 +10941,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -10937,7 +11013,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -11008,7 +11085,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -11079,7 +11157,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -11150,7 +11229,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -11221,7 +11301,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -11363,6 +11444,25 @@ if test "${target}" = "${host}"; then
 	COREFILE=trad-core.lo
 	TRAD_HEADER='"hosts/news-mips.h"'
 	;;
+  brownie32-*-netbsd* | brownie32*-*-openbsd*)
+	COREFILE=netbsd-core.lo
+	;;
+  brownie32-dec-*)
+	COREFILE=trad-core.lo
+	TRAD_HEADER='"hosts/decstation.h"'
+	;;
+  brownie32-sgi-irix4*)	COREFILE=irix-core.lo ;;
+  brownie32-sgi-irix5*)	COREFILE=irix-core.lo ;;
+  brownie32-sgi-irix6*)	COREFILE=irix-core.lo ;;
+  brownie32-*-sysv4*)	;;
+  brownie32-*-sysv* | brownie32-*-riscos*)
+	COREFILE=trad-core.lo
+	TRAD_HEADER='"hosts/riscos.h"'
+	;;
+  brownie32-sony-bsd*)
+	COREFILE=trad-core.lo
+	TRAD_HEADER='"hosts/news-brownie32.h"'
+	;;
   m68*-bull*-sysv*)
 	COREFILE=trad-core.lo
 	TRAD_HEADER='"hosts/dpx2.h"'
@@ -11448,7 +11548,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -11568,7 +11669,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -11715,7 +11817,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -11779,7 +11882,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -11843,7 +11947,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -11907,7 +12012,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -11971,7 +12077,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -12035,7 +12142,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -12099,7 +12207,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -12163,7 +12272,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -12227,7 +12337,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -12291,7 +12402,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -12355,7 +12467,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -12419,7 +12532,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -12483,7 +12597,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -12547,7 +12662,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -12611,7 +12727,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -12675,7 +12792,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -12734,7 +12852,7 @@ case "${host}" in
   # We borrow WIN32LIBADD so that the shared libbfd won't depend on
   # libiberty.a.
   case "${host}" in
-  mips*-*-linux*)
+  mips*-*-linux* | brownie32*-*-linux*)
     # Linux/MIPS uses PIC by default.
     if test "$enable_shared" = "yes"; then
       WIN32LIBADD="-L../libiberty -liberty"
@@ -12874,6 +12992,7 @@ do
     bfd_elf32_bigarm_vxworks_vec)
                                 tb="$tb elf32-arm.lo elf32.lo $elf" ;;
     bfd_elf32_bigmips_vec) 	tb="$tb elf32-mips.lo elfxx-mips.lo elf32.lo $elf ecofflink.lo" ;;
+    bfd_elf32_bigbrownie32_vec) 	tb="$tb elf32-brownie32.lo elfxx-brownie32.lo elf32.lo $elf ecofflink.lo" ;;
     bfd_elf32_cr16c_vec)	tb="$tb elf32-cr16c.lo elf32.lo $elf" ;;
     bfd_elf32_cris_vec)		tb="$tb elf32-cris.lo elf32.lo $elf" ;;
     bfd_elf32_crx_vec)          tb="$tb elf32-crx.lo elf32.lo $elf" ;;
@@ -12906,6 +13025,7 @@ do
                                 tb="$tb elf32-arm.lo elf32.lo $elf" ;;
     bfd_elf32_littlearm_vec)	tb="$tb elf32-arm.lo elf32.lo $elf" ;;
     bfd_elf32_littlemips_vec) 	tb="$tb elf32-mips.lo elfxx-mips.lo elf32.lo $elf ecofflink.lo" ;;
+    bfd_elf32_littlebrownie32_vec) 	tb="$tb elf32-brownie32.lo elfxx-brownie32.lo elf32.lo $elf ecofflink.lo" ;;
     bfd_elf32_m32c_vec)         tb="$tb elf32-m32c.lo elf32.lo $elf" ;;
     bfd_elf32_m32r_vec)		tb="$tb elf32-m32r.lo elf32.lo $elf" ;;
     bfd_elf32_m32rle_vec)       tb="$tb elf32-m32r.lo elf32.lo $elf" ;;
@@ -12925,6 +13045,10 @@ do
     bfd_elf32_nlittlemips_vec)	tb="$tb elfn32-mips.lo elfxx-mips.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf32_ntradbigmips_vec)	tb="$tb elfn32-mips.lo elfxx-mips.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf32_ntradlittlemips_vec) tb="$tb elfn32-mips.lo elfxx-mips.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
+    bfd_elf32_nbigbrownie32_vec)	tb="$tb elfn32-brownie32.lo elfxx-brownie32.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
+    bfd_elf32_nlittlebrownie32_vec)	tb="$tb elfn32-brownie32.lo elfxx-brownie32.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
+    bfd_elf32_ntradbigbrownie32_vec)	tb="$tb elfn32-brownie32.lo elfxx-brownie32.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
+    bfd_elf32_ntradlittlebrownie32_vec) tb="$tb elfn32-brownie32.lo elfxx-brownie32.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf32_openrisc_vec)	tb="$tb elf32-openrisc.lo elf32.lo $elf" ;;
     bfd_elf32_or32_big_vec)	tb="$tb elf32-or32.lo elf32.lo $elf" ;;
     bfd_elf32_pj_vec)           tb="$tb elf32-pj.lo elf32.lo $elf";;
@@ -12952,6 +13076,8 @@ do
     bfd_elf32_sparc_vec)	tb="$tb elf32-sparc.lo elfxx-sparc.lo elf32.lo $elf" ;;
     bfd_elf32_tradbigmips_vec)  tb="$tb elf32-mips.lo elfxx-mips.lo elf32.lo $elf ecofflink.lo" ;;
     bfd_elf32_tradlittlemips_vec) tb="$tb elf32-mips.lo elfxx-mips.lo elf32.lo $elf ecofflink.lo" ;;
+    bfd_elf32_tradbigbrownie32_vec)  tb="$tb elf32-brownie32.lo elfxx-brownie32.lo elf32.lo $elf ecofflink.lo" ;;
+    bfd_elf32_tradlittlebrownie32_vec) tb="$tb elf32-brownie32.lo elfxx-brownie32.lo elf32.lo $elf ecofflink.lo" ;;
     bfd_elf32_us_cris_vec)	tb="$tb elf32-cris.lo elf32.lo $elf" ;;
     bfd_elf32_v850_vec)		tb="$tb elf32-v850.lo elf32.lo $elf" ;;
     bfd_elf32_vax_vec)		tb="$tb elf32-vax.lo elf32.lo $elf" ;;
@@ -12962,6 +13088,7 @@ do
     bfd_elf64_alpha_vec)	tb="$tb elf64-alpha.lo elf64.lo $elf"; target_size=64 ;;
     bfd_elf64_big_generic_vec) 	tb="$tb elf64-gen.lo elf64.lo $elf"; target_size=64 ;;
     bfd_elf64_bigmips_vec) 	tb="$tb elf64-mips.lo elf64.lo elfxx-mips.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
+    bfd_elf64_bigbrownie32_vec) 	tb="$tb elf64-brownie32.lo elf64.lo elfxx-brownie32.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf64_hppa_linux_vec)	tb="$tb elf64-hppa.lo elf64.lo $elf"; target_size=64 ;;
     bfd_elf64_hppa_vec)		tb="$tb elf64-hppa.lo elf64.lo $elf"; target_size=64 ;;
     bfd_elf64_ia64_big_vec)	tb="$tb elf64-ia64.lo elf64.lo $elf"; target_size=64 ;;
@@ -12969,6 +13096,7 @@ do
     bfd_elf64_ia64_little_vec)	tb="$tb elf64-ia64.lo elf64.lo $elf"; target_size=64 ;;
     bfd_elf64_little_generic_vec) tb="$tb elf64-gen.lo elf64.lo $elf"; target_size=64 ;;
     bfd_elf64_littlemips_vec) 	tb="$tb elf64-mips.lo elf64.lo elfxx-mips.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
+    bfd_elf64_littlebrownie32_vec) 	tb="$tb elf64-brownie32.lo elf64.lo elfxx-brownie32.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf64_mmix_vec) 	tb="$tb elf64-mmix.lo elf64.lo $elf" target_size=64 ;;
     bfd_elf64_powerpc_vec)	tb="$tb elf64-ppc.lo elf64-gen.lo elf64.lo $elf"; target_size=64 ;;
     bfd_elf64_powerpcle_vec)	tb="$tb elf64-ppc.lo elf64-gen.lo elf64.lo $elf" target_size=64 ;;
@@ -12982,6 +13110,8 @@ do
     bfd_elf64_sparc_vec)	tb="$tb elf64-sparc.lo elfxx-sparc.lo elf64.lo $elf"; target_size=64 ;;
     bfd_elf64_tradbigmips_vec)	tb="$tb elf64-mips.lo elf64.lo elfxx-mips.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf64_tradlittlemips_vec) tb="$tb elf64-mips.lo elf64.lo elfxx-mips.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
+    bfd_elf64_tradbigbrownie32_vec)	tb="$tb elf64-brownie32.lo elf64.lo elfxx-brownie32.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
+    bfd_elf64_tradlittlebrownie32_vec) tb="$tb elf64-brownie32.lo elf64.lo elfxx-brownie32.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf64_x86_64_vec)	tb="$tb elf64-x86-64.lo elf64.lo $elf"; target_size=64 ;;
     bfd_mmo_vec)		tb="$tb mmo.lo" target_size=64 ;;
     bfd_powerpc_pe_vec)         tb="$tb pe-ppc.lo peigen.lo cofflink.lo" ;;
@@ -12993,6 +13123,9 @@ do
     ecoff_big_vec)		tb="$tb coff-mips.lo ecoff.lo ecofflink.lo" ;;
     ecoff_biglittle_vec)	tb="$tb coff-mips.lo ecoff.lo ecofflink.lo" ;;
     ecoff_little_vec)		tb="$tb coff-mips.lo ecoff.lo ecofflink.lo" ;;
+    ecoffbrownie32_big_vec)		tb="$tb coff-brownie32.lo ecoff.lo ecofflink.lo" ;;
+    ecoffbrownie32_biglittle_vec)	tb="$tb coff-brownie32.lo ecoff.lo ecofflink.lo" ;;
+    ecoffbrownie32_little_vec)		tb="$tb coff-brownie32.lo ecoff.lo ecofflink.lo" ;;
     ecoffalpha_little_vec)	tb="$tb coff-alpha.lo ecoff.lo ecofflink.lo"; target_size=64 ;;
     go32coff_vec)		tb="$tb coff-go32.lo cofflink.lo" ;;
     go32stubbedcoff_vec)	tb="$tb coff-stgo32.lo cofflink.lo" ;;
@@ -13039,6 +13172,8 @@ do
     mcore_pei_little_vec)	tb="$tb pei-mcore.lo peigen.lo cofflink.lo" ;;
     mipslpe_vec)		tb="$tb pe-mips.lo peigen.lo cofflink.lo" ;;
     mipslpei_vec)		tb="$tb pei-mips.lo peigen.lo cofflink.lo" ;;
+    brownie32lpe_vec)		tb="$tb pe-brownie32.lo peigen.lo cofflink.lo" ;;
+    brownie32lpei_vec)		tb="$tb pei-brownie32.lo peigen.lo cofflink.lo" ;;
     newsos3_vec)		tb="$tb newsos3.lo aout32.lo" ;;
     nlm32_alpha_vec)		tb="$tb nlm32-alpha.lo nlm32.lo nlm.lo"; target_size=64 ;;
     nlm32_i386_vec)		tb="$tb nlm32-i386.lo nlm32.lo nlm.lo" ;;
@@ -13298,7 +13433,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -13363,7 +13499,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -13425,7 +13562,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -13465,7 +13603,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -13521,7 +13660,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -13561,7 +13701,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -13625,7 +13766,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -13656,8 +13798,10 @@ See \`config.log' for more details." >&2
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: internal error: not reached in cross-compile" >&5
-echo "$as_me: error: internal error: not reached in cross-compile" >&2;}
+  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
@@ -13796,7 +13940,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -13980,7 +14125,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -14257,7 +14403,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -14384,9 +14531,10 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   # 1. Remove the extension, and $U if already installed.
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
-  # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
-  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
 
@@ -15238,6 +15386,11 @@ esac
   *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
   esac
 
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
   # Let's still pretend it is `configure' which instantiates (i.e., don't
   # use $as_me), people would be surprised to read:
   #    /* config.h.  Generated by config.status.  */
@@ -15276,12 +15429,6 @@ echo "$as_me: error: cannot find input f
 	 fi;;
       esac
     done` || { (exit 1); exit 1; }
-
-  if test x"$ac_file" != x-; then
-    { echo "$as_me:$LINENO: creating $ac_file" >&5
-echo "$as_me: creating $ac_file" >&6;}
-    rm -f "$ac_file"
-  fi
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF
   sed "$ac_vpsub
Index: bfd/configure.host
===================================================================
RCS file: /home/prj/asip/cvs/gdb/bfd/configure.host,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- bfd/configure.host	31 Jul 2007 11:40:33 -0000	1.1.1.1
+++ bfd/configure.host	8 Aug 2007 08:49:54 -0000	1.2
@@ -50,6 +50,17 @@ mips*-*-sysv4*)		;;
 mips*-*-sysv*)		HDEFINES="-G 4" ;;
 mips*-*-riscos*)	HDEFINES="-G 4" ;;
 
+brownie32*-*-netbsd*)	;;
+brownie32*-*-openbsd*)	;;
+brownie32*-dec-*)		HDEFINES="-G 4"	;;
+brownie32*-sgi-irix3*)	HDEFINES="-G 4" ;;
+brownie32*-sgi-irix4*)	HDEFINES="-G 4" ;;
+brownie32*-sgi-irix6*)	host64=true;;
+brownie3264*-*-linux*)	host64=true;;
+brownie32*-*-sysv4*)		;;
+brownie32*-*-sysv*)		HDEFINES="-G 4" ;;
+brownie32*-*-riscos*)	HDEFINES="-G 4" ;;
+
 m68*-hp-hpux*)		HDEFINES=-DHOST_HP300HPUX ;;
 
 *-*-windows*)
Index: bfd/configure.in
===================================================================
RCS file: /home/prj/asip/cvs/gdb/bfd/configure.in,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- bfd/configure.in	31 Jul 2007 11:40:32 -0000	1.1.1.1
+++ bfd/configure.in	8 Aug 2007 08:49:54 -0000	1.2
@@ -285,6 +285,25 @@ changequote([,])dnl
 	COREFILE=trad-core.lo
 	TRAD_HEADER='"hosts/news-mips.h"'
 	;;
+  brownie32-*-netbsd* | brownie32*-*-openbsd*)
+	COREFILE=netbsd-core.lo
+	;;
+  brownie32-dec-*)
+	COREFILE=trad-core.lo
+	TRAD_HEADER='"hosts/decstation.h"'
+	;;
+  brownie32-sgi-irix4*)	COREFILE=irix-core.lo ;;
+  brownie32-sgi-irix5*)	COREFILE=irix-core.lo ;;
+  brownie32-sgi-irix6*)	COREFILE=irix-core.lo ;;
+  brownie32-*-sysv4*)	;;
+  brownie32-*-sysv* | brownie32-*-riscos*)
+	COREFILE=trad-core.lo
+	TRAD_HEADER='"hosts/riscos.h"'
+	;;
+  brownie32-sony-bsd*)
+	COREFILE=trad-core.lo
+	TRAD_HEADER='"hosts/news-brownie32.h"'
+	;;
   m68*-bull*-sysv*)
 	COREFILE=trad-core.lo
 	TRAD_HEADER='"hosts/dpx2.h"'
@@ -450,7 +469,7 @@ case "${host}" in
   # We borrow WIN32LIBADD so that the shared libbfd won't depend on
   # libiberty.a.
   case "${host}" in
-  mips*-*-linux*)
+  mips*-*-linux* | brownie32*-*-linux*)
     # Linux/MIPS uses PIC by default.
     if test "$enable_shared" = "yes"; then
       WIN32LIBADD="-L../libiberty -liberty"
@@ -592,6 +611,7 @@ do
     bfd_elf32_bigarm_vxworks_vec)	
                                 tb="$tb elf32-arm.lo elf32.lo $elf" ;;
     bfd_elf32_bigmips_vec) 	tb="$tb elf32-mips.lo elfxx-mips.lo elf32.lo $elf ecofflink.lo" ;;
+    bfd_elf32_bigbrownie32_vec) 	tb="$tb elf32-brownie32.lo elfxx-brownie32.lo elf32.lo $elf ecofflink.lo" ;;
     bfd_elf32_cr16c_vec)	tb="$tb elf32-cr16c.lo elf32.lo $elf" ;;
     bfd_elf32_cris_vec)		tb="$tb elf32-cris.lo elf32.lo $elf" ;;
     bfd_elf32_crx_vec)          tb="$tb elf32-crx.lo elf32.lo $elf" ;;    
@@ -624,6 +644,7 @@ do
                                 tb="$tb elf32-arm.lo elf32.lo $elf" ;;
     bfd_elf32_littlearm_vec)	tb="$tb elf32-arm.lo elf32.lo $elf" ;;
     bfd_elf32_littlemips_vec) 	tb="$tb elf32-mips.lo elfxx-mips.lo elf32.lo $elf ecofflink.lo" ;;
+    bfd_elf32_littlebrownie32_vec) 	tb="$tb elf32-brownie32.lo elfxx-brownie32.lo elf32.lo $elf ecofflink.lo" ;;
     bfd_elf32_m32c_vec)         tb="$tb elf32-m32c.lo elf32.lo $elf" ;;
     bfd_elf32_m32r_vec)		tb="$tb elf32-m32r.lo elf32.lo $elf" ;;
     bfd_elf32_m32rle_vec)       tb="$tb elf32-m32r.lo elf32.lo $elf" ;;
@@ -643,6 +664,10 @@ do
     bfd_elf32_nlittlemips_vec)	tb="$tb elfn32-mips.lo elfxx-mips.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf32_ntradbigmips_vec)	tb="$tb elfn32-mips.lo elfxx-mips.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf32_ntradlittlemips_vec) tb="$tb elfn32-mips.lo elfxx-mips.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
+    bfd_elf32_nbigbrownie32_vec)	tb="$tb elfn32-brownie32.lo elfxx-brownie32.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
+    bfd_elf32_nlittlebrownie32_vec)	tb="$tb elfn32-brownie32.lo elfxx-brownie32.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
+    bfd_elf32_ntradbigbrownie32_vec)	tb="$tb elfn32-brownie32.lo elfxx-brownie32.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
+    bfd_elf32_ntradlittlebrownie32_vec) tb="$tb elfn32-brownie32.lo elfxx-brownie32.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf32_openrisc_vec)	tb="$tb elf32-openrisc.lo elf32.lo $elf" ;;
     bfd_elf32_or32_big_vec)	tb="$tb elf32-or32.lo elf32.lo $elf" ;;
     bfd_elf32_pj_vec)           tb="$tb elf32-pj.lo elf32.lo $elf";;
@@ -670,6 +695,8 @@ do
     bfd_elf32_sparc_vec)	tb="$tb elf32-sparc.lo elfxx-sparc.lo elf32.lo $elf" ;;
     bfd_elf32_tradbigmips_vec)  tb="$tb elf32-mips.lo elfxx-mips.lo elf32.lo $elf ecofflink.lo" ;;
     bfd_elf32_tradlittlemips_vec) tb="$tb elf32-mips.lo elfxx-mips.lo elf32.lo $elf ecofflink.lo" ;;
+    bfd_elf32_tradbigbrownie32_vec)  tb="$tb elf32-brownie32.lo elfxx-brownie32.lo elf32.lo $elf ecofflink.lo" ;;
+    bfd_elf32_tradlittlebrownie32_vec) tb="$tb elf32-brownie32.lo elfxx-brownie32.lo elf32.lo $elf ecofflink.lo" ;;
     bfd_elf32_us_cris_vec)	tb="$tb elf32-cris.lo elf32.lo $elf" ;;
     bfd_elf32_v850_vec)		tb="$tb elf32-v850.lo elf32.lo $elf" ;;
     bfd_elf32_vax_vec)		tb="$tb elf32-vax.lo elf32.lo $elf" ;;
@@ -680,6 +707,7 @@ do
     bfd_elf64_alpha_vec)	tb="$tb elf64-alpha.lo elf64.lo $elf"; target_size=64 ;;
     bfd_elf64_big_generic_vec) 	tb="$tb elf64-gen.lo elf64.lo $elf"; target_size=64 ;;
     bfd_elf64_bigmips_vec) 	tb="$tb elf64-mips.lo elf64.lo elfxx-mips.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
+    bfd_elf64_bigbrownie32_vec) 	tb="$tb elf64-brownie32.lo elf64.lo elfxx-brownie32.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf64_hppa_linux_vec)	tb="$tb elf64-hppa.lo elf64.lo $elf"; target_size=64 ;;
     bfd_elf64_hppa_vec)		tb="$tb elf64-hppa.lo elf64.lo $elf"; target_size=64 ;;
     bfd_elf64_ia64_big_vec)	tb="$tb elf64-ia64.lo elf64.lo $elf"; target_size=64 ;;
@@ -687,6 +715,7 @@ do
     bfd_elf64_ia64_little_vec)	tb="$tb elf64-ia64.lo elf64.lo $elf"; target_size=64 ;;
     bfd_elf64_little_generic_vec) tb="$tb elf64-gen.lo elf64.lo $elf"; target_size=64 ;;
     bfd_elf64_littlemips_vec) 	tb="$tb elf64-mips.lo elf64.lo elfxx-mips.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
+    bfd_elf64_littlebrownie32_vec) 	tb="$tb elf64-brownie32.lo elf64.lo elfxx-brownie32.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf64_mmix_vec) 	tb="$tb elf64-mmix.lo elf64.lo $elf" target_size=64 ;;
     bfd_elf64_powerpc_vec)	tb="$tb elf64-ppc.lo elf64-gen.lo elf64.lo $elf"; target_size=64 ;;
     bfd_elf64_powerpcle_vec)	tb="$tb elf64-ppc.lo elf64-gen.lo elf64.lo $elf" target_size=64 ;;
@@ -700,6 +729,8 @@ do
     bfd_elf64_sparc_vec)	tb="$tb elf64-sparc.lo elfxx-sparc.lo elf64.lo $elf"; target_size=64 ;;
     bfd_elf64_tradbigmips_vec)	tb="$tb elf64-mips.lo elf64.lo elfxx-mips.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf64_tradlittlemips_vec) tb="$tb elf64-mips.lo elf64.lo elfxx-mips.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
+    bfd_elf64_tradbigbrownie32_vec)	tb="$tb elf64-brownie32.lo elf64.lo elfxx-brownie32.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
+    bfd_elf64_tradlittlebrownie32_vec) tb="$tb elf64-brownie32.lo elf64.lo elfxx-brownie32.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf64_x86_64_vec)	tb="$tb elf64-x86-64.lo elf64.lo $elf"; target_size=64 ;;
     bfd_mmo_vec)		tb="$tb mmo.lo" target_size=64 ;;
     bfd_powerpc_pe_vec)         tb="$tb pe-ppc.lo peigen.lo cofflink.lo" ;;
@@ -711,6 +742,9 @@ do
     ecoff_big_vec)		tb="$tb coff-mips.lo ecoff.lo ecofflink.lo" ;;
     ecoff_biglittle_vec)	tb="$tb coff-mips.lo ecoff.lo ecofflink.lo" ;;
     ecoff_little_vec)		tb="$tb coff-mips.lo ecoff.lo ecofflink.lo" ;;
+    ecoffbrownie32_big_vec)		tb="$tb coff-brownie32.lo ecoff.lo ecofflink.lo" ;;
+    ecoffbrownie32_biglittle_vec)	tb="$tb coff-brownie32.lo ecoff.lo ecofflink.lo" ;;
+    ecoffbrownie32_little_vec)		tb="$tb coff-brownie32.lo ecoff.lo ecofflink.lo" ;;
     ecoffalpha_little_vec)	tb="$tb coff-alpha.lo ecoff.lo ecofflink.lo"; target_size=64 ;;
     go32coff_vec)		tb="$tb coff-go32.lo cofflink.lo" ;;
     go32stubbedcoff_vec)	tb="$tb coff-stgo32.lo cofflink.lo" ;;
@@ -757,6 +791,8 @@ do
     mcore_pei_little_vec)	tb="$tb pei-mcore.lo peigen.lo cofflink.lo" ;;
     mipslpe_vec)		tb="$tb pe-mips.lo peigen.lo cofflink.lo" ;;
     mipslpei_vec)		tb="$tb pei-mips.lo peigen.lo cofflink.lo" ;;
+    brownie32lpe_vec)		tb="$tb pe-brownie32.lo peigen.lo cofflink.lo" ;;
+    brownie32lpei_vec)		tb="$tb pei-brownie32.lo peigen.lo cofflink.lo" ;;
     newsos3_vec)		tb="$tb newsos3.lo aout32.lo" ;;
     nlm32_alpha_vec)		tb="$tb nlm32-alpha.lo nlm32.lo nlm.lo"; target_size=64 ;;
     nlm32_i386_vec)		tb="$tb nlm32-i386.lo nlm32.lo nlm.lo" ;;
Index: bfd/cpu-brownie32.c
===================================================================
RCS file: bfd/cpu-brownie32.c
diff -N bfd/cpu-brownie32.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ bfd/cpu-brownie32.c	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,97 @@
+/* bfd back-end for brownie32 support
+   Copyright 1990, 1991, 1993, 1994, 1995, 1996, 1997, 1998, 2000, 2001,
+   2002, 2003, 2004 Free Software Foundation, Inc.
+   Written by Steve Chamberlain of Cygnus Support.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "libbfd.h"
+
+static const bfd_arch_info_type *brownie32_compatible
+  (const bfd_arch_info_type *, const bfd_arch_info_type *);
+
+/* The default routine tests bits_per_word, which is wrong on brownie32 as
+   brownie32 word size doesn't correlate with reloc size.  */
+
+static const bfd_arch_info_type *
+brownie32_compatible (const bfd_arch_info_type *a, const bfd_arch_info_type *b)
+{
+  if (a->arch != b->arch)
+    return NULL;
+
+  /* Machine compatibility is checked in
+     _bfd_brownie32_elf_merge_private_bfd_data.  */
+
+  return a;
+}
+
+#if 0  // C.Katano
+#define N(BITS_WORD, BITS_ADDR, NUMBER, PRINT, DEFAULT, NEXT)		\
+  {							\
+    BITS_WORD, /*  bits in a word */			\
+    BITS_ADDR, /* bits in an address */			\
+    8,	/* 8 bits in a byte */				\
+    bfd_arch_brownie32,					\
+    NUMBER,						\
+    "brownie32",						\
+    PRINT,						\
+    3,							\
+    DEFAULT,						\
+    brownie32_compatible,					\
+    bfd_default_scan,					\
+    NEXT,						\
+  }
+#else
+#define N(BITS_WORD, BITS_ADDR, NUMBER, PRINT, DEFAULT, NEXT)		\
+  {							\
+    BITS_WORD, /*  bits in a word */			\
+    BITS_ADDR, /* bits in an address */			\
+    8,	/* 8 bits in a byte */				\
+    bfd_arch_brownie32,					\
+    NUMBER,						\
+    "brownie32",						\
+    PRINT,						\
+    4,							\
+    DEFAULT,						\
+    brownie32_compatible,					\
+    bfd_default_scan,					\
+    NEXT,						\
+  }
+#endif
+enum
+{
+  I_brownie32_std,
+};
+
+#if 0  // C.Katano
+#define NN(index) (&arch_info_struct[(index) + 1])
+
+static const bfd_arch_info_type arch_info_struct[] =
+{
+  N (32, 32, bfd_mach_brownie32_std, "brownie32:STD ",      FALSE, NN(I_brownie32_std))
+};
+#endif
+/* The default architecture is brownie32:3000, but with a machine number of
+   zero.  This lets the linker distinguish between a default setting
+   of brownie32, and an explicit setting of brownie32:3000.  */
+
+const bfd_arch_info_type bfd_brownie32_arch =
+N (32, 32, 0, "brownie32", TRUE, 0);
Index: bfd/elf-bfd.h
===================================================================
RCS file: /home/prj/asip/cvs/gdb/bfd/elf-bfd.h,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- bfd/elf-bfd.h	31 Jul 2007 11:40:33 -0000	1.1.1.1
+++ bfd/elf-bfd.h	8 Aug 2007 08:49:54 -0000	1.2
@@ -3,6 +3,8 @@
    2002, 2003, 2004, 2005 Free Software Foundation, Inc.
    Written by Cygnus Support.
 
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
    This file is part of BFD, the Binary File Descriptor library.
 
    This program is free software; you can redistribute it and/or modify
@@ -64,7 +66,7 @@ typedef struct
   union
     {
       unsigned int hppa_arg_reloc;
-      void *mips_extr;
+      void *brownie32_extr;
       void *any;
     }
   tc_data;
@@ -584,7 +586,7 @@ struct elf_backend_data
   /* A function to determine whether a symbol is global when
      partitioning the symbol table into local and global symbols.
      This should be NULL for most targets, in which case the correct
-     thing will be done.  MIPS ELF, at least on the Irix 5, has
+     thing will be done.  BROWNIE32 ELF, at least on the Irix 5, has
      special requirements.  */
   bfd_boolean (*elf_backend_sym_is_global)
     (bfd *, asymbol *);
@@ -959,15 +961,15 @@ struct elf_backend_data
     (bfd *, asection *, bfd_byte *);
 
   /* The level of IRIX compatibility we're striving for.
-     MIPS ELF specific function.  */
-  irix_compat_t (*elf_backend_mips_irix_compat)
+     BROWNIE32 ELF specific function.  */
+  irix_compat_t (*elf_backend_brownie32_irix_compat)
     (bfd *);
 
-  reloc_howto_type *(*elf_backend_mips_rtype_to_howto)
+  reloc_howto_type *(*elf_backend_brownie32_rtype_to_howto)
     (unsigned int, bfd_boolean);
 
   /* The swapping table to use when dealing with ECOFF information.
-     Used for the MIPS ELF .mdebug section.  */
+     Used for the BROWNIE32 ELF .mdebug section.  */
   const struct ecoff_debug_swap *elf_backend_ecoff_debug_swap;
 
   /* This function implements `bfd_elf_bfd_from_remote_memory';
@@ -1025,12 +1027,12 @@ struct elf_backend_data
 
   /* This is TRUE if the linker should act like collect and gather
      global constructors and destructors by name.  This is TRUE for
-     MIPS ELF because the Irix 5 tools can not handle the .init
+     BROWNIE32 ELF because the Irix 5 tools can not handle the .init
      section.  */
   unsigned collect : 1;
 
   /* This is TRUE if the linker should ignore changes to the type of a
-     symbol.  This is TRUE for MIPS ELF because some Irix 5 objects
+     symbol.  This is TRUE for BROWNIE32 ELF because some Irix 5 objects
      record undefined functions as STT_OBJECT although the definitions
      are STT_FUNC.  */
   unsigned type_change_ok : 1;
@@ -1283,11 +1285,11 @@ struct elf_obj_tdata
   /* Used by find_nearest_line entry point.  */
   void *line_info;
 
-  /* Used by MIPS ELF find_nearest_line entry point.  The structure
+  /* Used by BROWNIE32 ELF find_nearest_line entry point.  The structure
      could be included directly in this one, but there's no point to
      wasting the memory just for the infrequently called
      find_nearest_line.  */
-  struct mips_elf_find_line *find_line_info;
+  struct brownie32_elf_find_line *find_line_info;
 
   /* A place to stash dwarf1 info for this bfd.  */
   struct dwarf1_debug *dwarf1_find_line_info;
@@ -1296,8 +1298,8 @@ struct elf_obj_tdata
   void *dwarf2_find_line_info;
 
   /* An array of stub sections indexed by symbol number, used by the
-     MIPS ELF linker.  FIXME: We should figure out some way to only
-     include this field for a MIPS ELF target.  */
+     BROWNIE32 ELF linker.  FIXME: We should figure out some way to only
+     include this field for a BROWNIE32 ELF target.  */
   asection **local_stubs;
 
   /* Used to determine if PT_GNU_EH_FRAME segment header should be
Index: bfd/elf32-brownie32.c
===================================================================
RCS file: bfd/elf32-brownie32.c
diff -N bfd/elf32-brownie32.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ bfd/elf32-brownie32.c	3 Dec 2007 08:05:42 -0000	1.2
@@ -0,0 +1,1454 @@
+/* BROWNIE32-specific support for 32-bit ELF
+   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+   2003, 2004, 2005 Free Software Foundation, Inc.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+   Most of the information added by Ian Lance Taylor, Cygnus Support,
+   <ian@cygnus.com>.
+   N32/64 ABI support added by Mark Mitchell, CodeSourcery, LLC.
+   <mark@codesourcery.com>
+   Traditional BROWNIE32 targets support added by Koundinya.K, Dansk Data
+   Elektronik & Operations Research Group. <kk@ddeorg.soft.net>
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* This file handles BROWNIE32 ELF targets.  SGI Irix 5 uses a slightly
+   different BROWNIE32 ELF from other targets.  This matters when linking.
+   This file supports both, switching at runtime.  */
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "libbfd.h"
+#include "bfdlink.h"
+#include "genlink.h"
+#include "elf-bfd.h"
+#include "elfxx-brownie32.h"
+#include "elf/brownie32.h"
+
+/* Get the ECOFF swapping routines.  */
+#include "coff/sym.h"
+#include "coff/symconst.h"
+#include "coff/internal.h"
+#include "coff/ecoff.h"
+#include "coff/brownie32.h"
+#define ECOFF_SIGNED_32
+#include "ecoffswap.h"
+
+static bfd_reloc_status_type gprel32_with_gp
+  (bfd *, asymbol *, arelent *, asection *, bfd_boolean, void *, bfd_vma);
+static bfd_reloc_status_type brownie32_elf_gprel32_reloc
+  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
+static bfd_reloc_status_type brownie3232_64bit_reloc
+  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
+static reloc_howto_type *bfd_elf32_bfd_reloc_type_lookup
+  (bfd *, bfd_reloc_code_real_type);
+static reloc_howto_type *brownie32_elf32_rtype_to_howto
+  (unsigned int, bfd_boolean);
+static void brownie32_info_to_howto_rel
+  (bfd *, arelent *, Elf_Internal_Rela *);
+static void brownie32_info_to_howto_rela
+  (bfd *, arelent *, Elf_Internal_Rela *);
+static bfd_boolean brownie32_elf_sym_is_global
+  (bfd *, asymbol *);
+static bfd_boolean brownie32_elf32_object_p
+  (bfd *);
+static bfd_boolean brownie32_elf_is_local_label_name
+  (bfd *, const char *);
+static bfd_reloc_status_type brownie32_elf_final_gp
+  (bfd *, asymbol *, bfd_boolean, char **, bfd_vma *);
+static bfd_boolean brownie32_elf_assign_gp
+  (bfd *, bfd_vma *);
+static bfd_boolean elf32_brownie32_grok_prstatus
+  (bfd *, Elf_Internal_Note *);
+static bfd_boolean elf32_brownie32_grok_psinfo
+  (bfd *, Elf_Internal_Note *);
+static irix_compat_t elf32_brownie32_irix_compat
+  (bfd *);
+
+extern const bfd_target bfd_elf32_bigbrownie32_vec;
+extern const bfd_target bfd_elf32_littlebrownie32_vec;
+
+/* Nonzero if ABFD is using the N32 ABI.  */
+#define ABI_N32_P(abfd) \
+  ((elf_elfheader (abfd)->e_flags & EF_BROWNIE32_ABI2) != 0)
+
+/* Whether we are trying to be compatible with IRIX at all.  */
+#define SGI_COMPAT(abfd) \
+  (elf32_brownie32_irix_compat (abfd) != ict_none)
+
+/* The number of local .got entries we reserve.  */
+#define BROWNIE32_RESERVED_GOTNO (2)
+
+/* In case we're on a 32-bit machine, construct a 64-bit "-1" value
+   from smaller values.  Start with zero, widen, *then* decrement.  */
+#define MINUS_ONE	(((bfd_vma)0) - 1)
+
+/* The relocation table used for SHT_REL sections.  */
+
+static reloc_howto_type elf_brownie32_howto_table_rel[] =
+{
+  /* No relocation.  */
+  HOWTO (R_BROWNIE32_NONE,		/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_NONE",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 16 bit relocation.  */
+  HOWTO (R_BROWNIE32_16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_16",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32 bit relocation.  */
+  HOWTO (R_BROWNIE32_32,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_32",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32 bit symbol relative relocation.  */
+  HOWTO (R_BROWNIE32_REL32,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_REL32",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 26 bit jump address.  */
+  HOWTO (R_BROWNIE32_26,		/* type */
+	 2,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 26,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 			/* This needs complex overflow
+				   detection, because the upper four
+				   bits must match the PC + 4.  */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_26",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0x03ffffff,		/* src_mask */
+	 0x03ffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* High 16 bits of symbol value.  */
+  HOWTO (R_BROWNIE32_HI16,		/* type */
+	 16,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_hi16_reloc, /* special_function */
+	 "R_BROWNIE32_HI16",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Low 16 bits of symbol value.  */
+  HOWTO (R_BROWNIE32_LO16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_lo16_reloc, /* special_function */
+	 "R_BROWNIE32_LO16",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* GP relative reference.  */
+  HOWTO (R_BROWNIE32_GPREL16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf32_gprel16_reloc, /* special_function */
+	 "R_BROWNIE32_GPREL16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Reference to literal section.  */
+  HOWTO (R_BROWNIE32_LITERAL,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf32_gprel16_reloc, /* special_function */
+	 "R_BROWNIE32_LITERAL",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Reference to global offset table.  */
+  HOWTO (R_BROWNIE32_GOT16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_got16_reloc, /* special_function */
+	 "R_BROWNIE32_GOT16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 16 bit PC relative reference.  */
+  HOWTO (R_BROWNIE32_PC16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_PC16",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* 16 bit call through global offset table.  */
+  HOWTO (R_BROWNIE32_CALL16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_CALL16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32 bit GP relative reference.  */
+  HOWTO (R_BROWNIE32_GPREL32,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 brownie32_elf_gprel32_reloc, /* special_function */
+	 "R_BROWNIE32_GPREL32",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* The remaining relocs are defined on Irix 5, although they are
+     not defined by the ABI.  */
+  EMPTY_HOWTO (13),
+  EMPTY_HOWTO (14),
+  EMPTY_HOWTO (15),
+
+  /* A 5 bit shift field.  */
+  HOWTO (R_BROWNIE32_SHIFT5,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 5,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 6,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_SHIFT5",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x000007c0,		/* src_mask */
+	 0x000007c0,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 6 bit shift field.  */
+  /* FIXME: This is not handled correctly; a special function is
+     needed to put the most significant bit in the right place.  */
+  HOWTO (R_BROWNIE32_SHIFT6,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 6,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 6,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_SHIFT6",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x000007c4,		/* src_mask */
+	 0x000007c4,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 64 bit relocation.  */
+  HOWTO (R_BROWNIE32_64,		/* type */
+	 0,			/* rightshift */
+	 4,			/* size (0 = byte, 1 = short, 2 = long) */
+	 64,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 brownie3232_64bit_reloc,	/* special_function */
+	 "R_BROWNIE32_64",		/* name */
+	 TRUE,			/* partial_inplace */
+	 MINUS_ONE,		/* src_mask */
+	 MINUS_ONE,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Displacement in the global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_DISP,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_GOT_DISP",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Displacement to page pointer in the global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_PAGE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_GOT_PAGE",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Offset from page pointer in the global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_OFST,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_GOT_OFST",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* High 16 bits of displacement in global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_HI16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_GOT_HI16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Low 16 bits of displacement in global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_GOT_LO16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 64 bit subtraction.  Used in the N32 ABI.  */
+  HOWTO (R_BROWNIE32_SUB,		/* type */
+	 0,			/* rightshift */
+	 4,			/* size (0 = byte, 1 = short, 2 = long) */
+	 64,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_SUB",		/* name */
+	 TRUE,			/* partial_inplace */
+	 MINUS_ONE,		/* src_mask */
+	 MINUS_ONE,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Used to cause the linker to insert and delete instructions?  */
+  EMPTY_HOWTO (R_BROWNIE32_INSERT_A),
+  EMPTY_HOWTO (R_BROWNIE32_INSERT_B),
+  EMPTY_HOWTO (R_BROWNIE32_DELETE),
+
+  /* Get the higher value of a 64 bit addend.  */
+  HOWTO (R_BROWNIE32_HIGHER,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_HIGHER",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Get the highest value of a 64 bit addend.  */
+  HOWTO (R_BROWNIE32_HIGHEST,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_HIGHEST",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* High 16 bits of displacement in global offset table.  */
+  HOWTO (R_BROWNIE32_CALL_HI16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_CALL_HI16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Low 16 bits of displacement in global offset table.  */
+  HOWTO (R_BROWNIE32_CALL_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_CALL_LO16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Section displacement.  */
+  HOWTO (R_BROWNIE32_SCN_DISP,       /* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_SCN_DISP",     /* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  EMPTY_HOWTO (R_BROWNIE32_REL16),
+  EMPTY_HOWTO (R_BROWNIE32_ADD_IMMEDIATE),
+  EMPTY_HOWTO (R_BROWNIE32_PJUMP),
+  EMPTY_HOWTO (R_BROWNIE32_RELGOT),
+
+  /* Protected jump conversion.  This is an optimization hint.  No
+     relocation is required for correctness.  */
+  HOWTO (R_BROWNIE32_JALR,	        /* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_JALR",	        /* name */
+	 FALSE,			/* partial_inplace */
+	 0x00000000,		/* src_mask */
+	 0x00000000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS GD/LD dynamic relocations.  */
+  HOWTO (R_BROWNIE32_TLS_DTPMOD32,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_DTPMOD32",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_BROWNIE32_TLS_DTPREL32,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_DTPREL32",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  EMPTY_HOWTO (R_BROWNIE32_TLS_DTPMOD64),
+  EMPTY_HOWTO (R_BROWNIE32_TLS_DTPREL64),
+
+  /* TLS general dynamic variable reference.  */
+  HOWTO (R_BROWNIE32_TLS_GD,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_GD",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS local dynamic variable reference.  */
+  HOWTO (R_BROWNIE32_TLS_LDM,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_LDM",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS local dynamic offset.  */
+  HOWTO (R_BROWNIE32_TLS_DTPREL_HI16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_DTPREL_HI16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS local dynamic offset.  */
+  HOWTO (R_BROWNIE32_TLS_DTPREL_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_DTPREL_LO16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS thread pointer offset.  */
+  HOWTO (R_BROWNIE32_TLS_GOTTPREL,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_GOTTPREL",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS IE dynamic relocations.  */
+  HOWTO (R_BROWNIE32_TLS_TPREL32,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_TPREL32",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  EMPTY_HOWTO (R_BROWNIE32_TLS_TPREL64),
+
+  /* TLS thread pointer offset.  */
+  HOWTO (R_BROWNIE32_TLS_TPREL_HI16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_TPREL_HI16", /* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS thread pointer offset.  */
+  HOWTO (R_BROWNIE32_TLS_TPREL_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_TPREL_LO16", /* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+};
+
+/* The reloc used for BFD_RELOC_CTOR when doing a 64 bit link.  This
+   is a hack to make the linker think that we need 64 bit values.  */
+static reloc_howto_type elf_brownie32_ctor64_howto =
+  HOWTO (R_BROWNIE32_64,		/* type */
+	 0,			/* rightshift */
+	 4,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 brownie3232_64bit_reloc,	/* special_function */
+	 "R_BROWNIE32_64",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE);		/* pcrel_offset */
+
+/* 16 bit offset for pc-relative branches.  */
+static reloc_howto_type elf_brownie32_gnu_rel16_s2 =
+  HOWTO (R_BROWNIE32_GNU_REL16_S2,	/* type */
+	 2,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_GNU_REL16_S2",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffff,		/* src_mask */
+	 0xffff,		/* dst_mask */
+	 TRUE);			/* pcrel_offset */
+
+/* 32 bit pc-relative.  This was a GNU extension used by embedded-PIC.
+   It was co-opted by brownie32-linux for exception-handling data.  It is no
+   longer used, but should continue to be supported by the linker for
+   backward compatibility.  (GCC stopped using it in May, 2004.)  */
+static reloc_howto_type elf_brownie32_gnu_pcrel32 =
+  HOWTO (R_BROWNIE32_PC32,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_PC32",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 TRUE);			/* pcrel_offset */
+
+/* GNU extension to record C++ vtable hierarchy */
+static reloc_howto_type elf_brownie32_gnu_vtinherit_howto =
+  HOWTO (R_BROWNIE32_GNU_VTINHERIT,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 NULL,			/* special_function */
+	 "R_BROWNIE32_GNU_VTINHERIT", /* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE);		/* pcrel_offset */
+
+/* GNU extension to record C++ vtable member usage */
+static reloc_howto_type elf_brownie32_gnu_vtentry_howto =
+  HOWTO (R_BROWNIE32_GNU_VTENTRY,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_elf_rel_vtable_reloc_fn, /* special_function */
+	 "R_BROWNIE32_GNU_VTENTRY",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE);		/* pcrel_offset */
+
+/* Set the GP value for OUTPUT_BFD.  Returns FALSE if this is a
+   dangerous relocation.  */
+
+static bfd_boolean
+brownie32_elf_assign_gp (bfd *output_bfd, bfd_vma *pgp)
+{
+  unsigned int count;
+  asymbol **sym;
+  unsigned int i;
+
+  /* If we've already figured out what GP will be, just return it.  */
+  *pgp = _bfd_get_gp_value (output_bfd);
+  if (*pgp)
+    return TRUE;
+
+  count = bfd_get_symcount (output_bfd);
+  sym = bfd_get_outsymbols (output_bfd);
+
+  /* The linker script will have created a symbol named `_gp' with the
+     appropriate value.  */
+  if (sym == NULL)
+    i = count;
+  else
+    {
+      for (i = 0; i < count; i++, sym++)
+	{
+	  register const char *name;
+
+	  name = bfd_asymbol_name (*sym);
+	  if (*name == '_' && strcmp (name, "_gp") == 0)
+	    {
+	      *pgp = bfd_asymbol_value (*sym);
+	      _bfd_set_gp_value (output_bfd, *pgp);
+	      break;
+	    }
+	}
+    }
+
+  if (i >= count)
+    {
+      /* Only get the error once.  */
+      *pgp = 4;
+      _bfd_set_gp_value (output_bfd, *pgp);
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+/* We have to figure out the gp value, so that we can adjust the
+   symbol value correctly.  We look up the symbol _gp in the output
+   BFD.  If we can't find it, we're stuck.  We cache it in the ELF
+   target data.  We don't need to adjust the symbol value for an
+   external symbol if we are producing relocatable output.  */
+
+static bfd_reloc_status_type
+brownie32_elf_final_gp (bfd *output_bfd, asymbol *symbol, bfd_boolean relocatable,
+		   char **error_message, bfd_vma *pgp)
+{
+  if (bfd_is_und_section (symbol->section)
+      && ! relocatable)
+    {
+      *pgp = 0;
+      return bfd_reloc_undefined;
+    }
+
+  *pgp = _bfd_get_gp_value (output_bfd);
+  if (*pgp == 0
+      && (! relocatable
+	  || (symbol->flags & BSF_SECTION_SYM) != 0))
+    {
+      if (relocatable)
+	{
+	  /* Make up a value.  */
+	  *pgp = symbol->section->output_section->vma + 0x4000;
+	  _bfd_set_gp_value (output_bfd, *pgp);
+	}
+      else if (!brownie32_elf_assign_gp (output_bfd, pgp))
+	{
+	  *error_message =
+	    (char *) _("GP relative relocation when _gp not defined");
+	  return bfd_reloc_dangerous;
+	}
+    }
+
+  return bfd_reloc_ok;
+}
+
+/* Do a R_BROWNIE32_GPREL16 relocation.  This is a 16 bit value which must
+   become the offset from the gp register.  This function also handles
+   R_BROWNIE32_LITERAL relocations, although those can be handled more
+   cleverly because the entries in the .lit8 and .lit4 sections can be
+   merged.  */
+
+bfd_reloc_status_type
+_bfd_brownie32_elf32_gprel16_reloc (bfd *abfd, arelent *reloc_entry,
+			       asymbol *symbol, void *data,
+			       asection *input_section, bfd *output_bfd,
+			       char **error_message)
+{
+  bfd_boolean relocatable;
+  bfd_reloc_status_type ret;
+  bfd_vma gp;
+
+  /* R_BROWNIE32_LITERAL relocations are defined for local symbols only.  */
+  if (reloc_entry->howto->type == R_BROWNIE32_LITERAL
+      && output_bfd != NULL
+      && (symbol->flags & BSF_SECTION_SYM) == 0
+      && (symbol->flags & BSF_LOCAL) != 0)
+    {
+      *error_message = (char *)
+	_("literal relocation occurs for an external symbol");
+      return bfd_reloc_outofrange;
+    }
+
+  if (output_bfd != NULL)
+    relocatable = TRUE;
+  else
+    {
+      relocatable = FALSE;
+      output_bfd = symbol->section->output_section->owner;
+    }
+
+  ret = brownie32_elf_final_gp (output_bfd, symbol, relocatable, error_message,
+			   &gp);
+  if (ret != bfd_reloc_ok)
+    return ret;
+
+  return _bfd_brownie32_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
+					input_section, relocatable,
+					data, gp);
+}
+
+/* Do a R_BROWNIE32_GPREL32 relocation.  This is a 32 bit value which must
+   become the offset from the gp register.  */
+
+static bfd_reloc_status_type
+brownie32_elf_gprel32_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
+			void *data, asection *input_section, bfd *output_bfd,
+			char **error_message)
+{
+  bfd_boolean relocatable;
+  bfd_reloc_status_type ret;
+  bfd_vma gp;
+
+  /* R_BROWNIE32_GPREL32 relocations are defined for local symbols only.  */
+  if (output_bfd != NULL
+      && (symbol->flags & BSF_SECTION_SYM) == 0
+      && (symbol->flags & BSF_LOCAL) != 0)
+    {
+      *error_message = (char *)
+	_("32bits gp relative relocation occurs for an external symbol");
+      return bfd_reloc_outofrange;
+    }
+
+  if (output_bfd != NULL)
+    relocatable = TRUE;
+  else
+    {
+      relocatable = FALSE;
+      output_bfd = symbol->section->output_section->owner;
+    }
+
+  ret = brownie32_elf_final_gp (output_bfd, symbol, relocatable,
+			   error_message, &gp);
+  if (ret != bfd_reloc_ok)
+    return ret;
+
+  return gprel32_with_gp (abfd, symbol, reloc_entry, input_section,
+			  relocatable, data, gp);
+}
+
+static bfd_reloc_status_type
+gprel32_with_gp (bfd *abfd, asymbol *symbol, arelent *reloc_entry,
+		 asection *input_section, bfd_boolean relocatable,
+		 void *data, bfd_vma gp)
+{
+  bfd_vma relocation;
+  bfd_vma val;
+
+  if (bfd_is_com_section (symbol->section))
+    relocation = 0;
+  else
+    relocation = symbol->value;
+
+  relocation += symbol->section->output_section->vma;
+  relocation += symbol->section->output_offset;
+
+  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
+    return bfd_reloc_outofrange;
+
+  /* Set val to the offset into the section or symbol.  */
+  val = reloc_entry->addend;
+
+  if (reloc_entry->howto->partial_inplace)
+    val += bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
+
+  /* Adjust val for the final section location and GP value.  If we
+     are producing relocatable output, we don't want to do this for
+     an external symbol.  */
+  if (! relocatable
+      || (symbol->flags & BSF_SECTION_SYM) != 0)
+    val += relocation - gp;
+
+  if (reloc_entry->howto->partial_inplace)
+    bfd_put_32 (abfd, val, (bfd_byte *) data + reloc_entry->address);
+  else
+    reloc_entry->addend = val;
+
+  if (relocatable)
+    reloc_entry->address += input_section->output_offset;
+
+  return bfd_reloc_ok;
+}
+
+/* Handle a 64 bit reloc in a 32 bit BROWNIE32 ELF file.  These are
+   generated when addresses are 64 bits.  The upper 32 bits are a simple
+   sign extension.  */
+
+static bfd_reloc_status_type
+brownie3232_64bit_reloc (bfd *abfd, arelent *reloc_entry,
+		    asymbol *symbol ATTRIBUTE_UNUSED,
+		    void *data, asection *input_section,
+		    bfd *output_bfd, char **error_message)
+{
+  bfd_reloc_status_type r;
+  arelent reloc32;
+  unsigned long val;
+  bfd_size_type addr;
+
+  /* Do a normal 32 bit relocation on the lower 32 bits.  */
+  reloc32 = *reloc_entry;
+  if (bfd_big_endian (abfd))
+    reloc32.address += 4;
+  reloc32.howto = &elf_brownie32_howto_table_rel[R_BROWNIE32_32];
+  r = bfd_perform_relocation (abfd, &reloc32, data, input_section,
+			      output_bfd, error_message);
+
+  /* Sign extend into the upper 32 bits.  */
+  val = bfd_get_32 (abfd, (bfd_byte *) data + reloc32.address);
+  if ((val & 0x80000000) != 0)
+    val = 0xffffffff;
+  else
+    val = 0;
+  addr = reloc_entry->address;
+  if (bfd_little_endian (abfd))
+    addr += 4;
+  bfd_put_32 (abfd, val, (bfd_byte *) data + addr);
+
+  return r;
+}
+
+/* A mapping from BFD reloc types to BROWNIE32 ELF reloc types.  */
+
+struct elf_reloc_map {
+  bfd_reloc_code_real_type bfd_val;
+  enum elf_brownie32_reloc_type elf_val;
+};
+
+static const struct elf_reloc_map brownie32_reloc_map[] =
+{
+  { BFD_RELOC_NONE, R_BROWNIE32_NONE },
+  { BFD_RELOC_16, R_BROWNIE32_16 },
+  { BFD_RELOC_32, R_BROWNIE32_32 },
+  /* There is no BFD reloc for R_BROWNIE32_REL32.  */
+  { BFD_RELOC_64, R_BROWNIE32_64 },
+  { BFD_RELOC_BROWNIE32_JMP, R_BROWNIE32_26 },
+  { BFD_RELOC_HI16_S, R_BROWNIE32_HI16 },
+  { BFD_RELOC_LO16, R_BROWNIE32_LO16 },
+  { BFD_RELOC_GPREL16, R_BROWNIE32_GPREL16 },
+  { BFD_RELOC_BROWNIE32_LITERAL, R_BROWNIE32_LITERAL },
+  { BFD_RELOC_BROWNIE32_GOT16, R_BROWNIE32_GOT16 },
+  { BFD_RELOC_16_PCREL, R_BROWNIE32_PC16 },
+  { BFD_RELOC_BROWNIE32_CALL16, R_BROWNIE32_CALL16 },
+  { BFD_RELOC_GPREL32, R_BROWNIE32_GPREL32 },
+  { BFD_RELOC_BROWNIE32_GOT_HI16, R_BROWNIE32_GOT_HI16 },
+  { BFD_RELOC_BROWNIE32_GOT_LO16, R_BROWNIE32_GOT_LO16 },
+  { BFD_RELOC_BROWNIE32_CALL_HI16, R_BROWNIE32_CALL_HI16 },
+  { BFD_RELOC_BROWNIE32_CALL_LO16, R_BROWNIE32_CALL_LO16 },
+  { BFD_RELOC_BROWNIE32_SUB, R_BROWNIE32_SUB },
+  { BFD_RELOC_BROWNIE32_GOT_PAGE, R_BROWNIE32_GOT_PAGE },
+  { BFD_RELOC_BROWNIE32_GOT_OFST, R_BROWNIE32_GOT_OFST },
+  { BFD_RELOC_BROWNIE32_GOT_DISP, R_BROWNIE32_GOT_DISP },
+  { BFD_RELOC_BROWNIE32_TLS_DTPMOD32, R_BROWNIE32_TLS_DTPMOD32 },
+  { BFD_RELOC_BROWNIE32_TLS_DTPREL32, R_BROWNIE32_TLS_DTPREL32 },
+  { BFD_RELOC_BROWNIE32_TLS_DTPMOD64, R_BROWNIE32_TLS_DTPMOD64 },
+  { BFD_RELOC_BROWNIE32_TLS_DTPREL64, R_BROWNIE32_TLS_DTPREL64 },
+  { BFD_RELOC_BROWNIE32_TLS_GD, R_BROWNIE32_TLS_GD },
+  { BFD_RELOC_BROWNIE32_TLS_LDM, R_BROWNIE32_TLS_LDM },
+  { BFD_RELOC_BROWNIE32_TLS_DTPREL_HI16, R_BROWNIE32_TLS_DTPREL_HI16 },
+  { BFD_RELOC_BROWNIE32_TLS_DTPREL_LO16, R_BROWNIE32_TLS_DTPREL_LO16 },
+  { BFD_RELOC_BROWNIE32_TLS_GOTTPREL, R_BROWNIE32_TLS_GOTTPREL },
+  { BFD_RELOC_BROWNIE32_TLS_TPREL32, R_BROWNIE32_TLS_TPREL32 },
+  { BFD_RELOC_BROWNIE32_TLS_TPREL64, R_BROWNIE32_TLS_TPREL64 },
+  { BFD_RELOC_BROWNIE32_TLS_TPREL_HI16, R_BROWNIE32_TLS_TPREL_HI16 },
+  { BFD_RELOC_BROWNIE32_TLS_TPREL_LO16, R_BROWNIE32_TLS_TPREL_LO16 }
+};
+
+/* Given a BFD reloc type, return a howto structure.  */
+
+static reloc_howto_type *
+bfd_elf32_bfd_reloc_type_lookup (bfd *abfd, bfd_reloc_code_real_type code)
+{
+  unsigned int i;
+  reloc_howto_type *howto_table = elf_brownie32_howto_table_rel;
+
+  for (i = 0; i < sizeof (brownie32_reloc_map) / sizeof (struct elf_reloc_map);
+       i++)
+    {
+      if (brownie32_reloc_map[i].bfd_val == code)
+	return &howto_table[(int) brownie32_reloc_map[i].elf_val];
+    }
+
+  switch (code)
+    {
+    default:
+      bfd_set_error (bfd_error_bad_value);
+      return NULL;
+
+    case BFD_RELOC_CTOR:
+      /* We need to handle BFD_RELOC_CTOR specially.
+	 Select the right relocation (R_BROWNIE32_32 or R_BROWNIE32_64) based on the
+	 size of addresses of the ABI.  */
+      if ((elf_elfheader (abfd)->e_flags & (E_BROWNIE32_ABI_O64
+					    | E_BROWNIE32_ABI_EABI64)) != 0)
+	return &elf_brownie32_ctor64_howto;
+      else
+	return &howto_table[(int) R_BROWNIE32_32];
+
+    case BFD_RELOC_VTABLE_INHERIT:
+      return &elf_brownie32_gnu_vtinherit_howto;
+    case BFD_RELOC_VTABLE_ENTRY:
+      return &elf_brownie32_gnu_vtentry_howto;
+    case BFD_RELOC_16_PCREL_S2:
+      return &elf_brownie32_gnu_rel16_s2;
+    case BFD_RELOC_32_PCREL:
+      return &elf_brownie32_gnu_pcrel32;
+    }
+}
+
+/* Given a BROWNIE32 Elf_Internal_Rel, fill in an arelent structure.  */
+
+static reloc_howto_type *
+brownie32_elf32_rtype_to_howto (unsigned int r_type,
+			   bfd_boolean rela_p ATTRIBUTE_UNUSED)
+{
+  switch (r_type)
+    {
+    case R_BROWNIE32_GNU_VTINHERIT:
+      return &elf_brownie32_gnu_vtinherit_howto;
+    case R_BROWNIE32_GNU_VTENTRY:
+      return &elf_brownie32_gnu_vtentry_howto;
+    case R_BROWNIE32_GNU_REL16_S2:
+      return &elf_brownie32_gnu_rel16_s2;
+    case R_BROWNIE32_PC32:
+      return &elf_brownie32_gnu_pcrel32;
+    default:
+      BFD_ASSERT (r_type < (unsigned int) R_BROWNIE32_max);
+      return &elf_brownie32_howto_table_rel[r_type];
+    }
+}
+
+/* Given a BROWNIE32 Elf_Internal_Rel, fill in an arelent structure.  */
+
+static void
+brownie32_info_to_howto_rel (bfd *abfd, arelent *cache_ptr, Elf_Internal_Rela *dst)
+{
+  unsigned int r_type;
+
+  r_type = ELF32_R_TYPE (dst->r_info);
+  cache_ptr->howto = brownie32_elf32_rtype_to_howto (r_type, FALSE);
+
+  /* The addend for a GPREL16 or LITERAL relocation comes from the GP
+     value for the object file.  We get the addend now, rather than
+     when we do the relocation, because the symbol manipulations done
+     by the linker may cause us to lose track of the input BFD.  */
+  if (((*cache_ptr->sym_ptr_ptr)->flags & BSF_SECTION_SYM) != 0
+      && (r_type == (unsigned int) R_BROWNIE32_GPREL16
+	  || r_type == (unsigned int) R_BROWNIE32_LITERAL))
+    cache_ptr->addend = elf_gp (abfd);
+}
+
+/* Given a BROWNIE32 Elf_Internal_Rela, fill in an arelent structure.  */
+
+static void
+brownie32_info_to_howto_rela (bfd *abfd, arelent *cache_ptr, Elf_Internal_Rela *dst)
+{
+  brownie32_info_to_howto_rel (abfd, cache_ptr, dst);
+
+  /* If we ever need to do any extra processing with dst->r_addend
+     (the field omitted in an Elf_Internal_Rel) we can do it here.  */
+}
+
+/* Determine whether a symbol is global for the purposes of splitting
+   the symbol table into global symbols and local symbols.  At least
+   on Irix 5, this split must be between section symbols and all other
+   symbols.  On most ELF targets the split is between static symbols
+   and externally visible symbols.  */
+
+static bfd_boolean
+brownie32_elf_sym_is_global (bfd *abfd ATTRIBUTE_UNUSED, asymbol *sym)
+{
+  if (SGI_COMPAT (abfd))
+    return (sym->flags & BSF_SECTION_SYM) == 0;
+  else
+    return ((sym->flags & (BSF_GLOBAL | BSF_WEAK)) != 0
+	    || bfd_is_und_section (bfd_get_section (sym))
+	    || bfd_is_com_section (bfd_get_section (sym)));
+}
+
+/* Set the right machine number for a BROWNIE32 ELF file.  */
+
+static bfd_boolean
+brownie32_elf32_object_p (bfd *abfd)
+{
+  unsigned long mach;
+
+  /* Irix 5 and 6 are broken.  Object file symbol tables are not always
+     sorted correctly such that local symbols precede global symbols,
+     and the sh_info field in the symbol table is not always right.  */
+  if (SGI_COMPAT (abfd))
+    elf_bad_symtab (abfd) = TRUE;
+
+  if (ABI_N32_P (abfd))
+    return FALSE;
+
+  mach = _bfd_elf_brownie32_mach (elf_elfheader (abfd)->e_flags);
+  bfd_default_set_arch_mach (abfd, bfd_arch_brownie32, mach);
+
+  return TRUE;
+}
+
+/* BROWNIE32 ELF local labels start with '$', not 'L'.  */
+
+static bfd_boolean
+brownie32_elf_is_local_label_name (bfd *abfd, const char *name)
+{
+  if (name[0] == '$')
+    return TRUE;
+
+  /* On Irix 6, the labels go back to starting with '.', so we accept
+     the generic ELF local label syntax as well.  */
+  return _bfd_elf_is_local_label_name (abfd, name);
+}
+
+/* Support for core dump NOTE sections.  */
+static bfd_boolean
+elf32_brownie32_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
+{
+  int offset;
+  unsigned int size;
+
+  switch (note->descsz)
+    {
+      default:
+	return FALSE;
+
+      case 256:		/* Linux/BROWNIE32 */
+	/* pr_cursig */
+	elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);
+
+	/* pr_pid */
+	elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);
+
+	/* pr_reg */
+	offset = 72;
+	size = 180;
+
+	break;
+    }
+
+  /* Make a ".reg/999" section.  */
+  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
+					  size, note->descpos + offset);
+}
+
+static bfd_boolean
+elf32_brownie32_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
+{
+  switch (note->descsz)
+    {
+      default:
+	return FALSE;
+
+      case 128:		/* Linux/BROWNIE32 elf_prpsinfo */
+	elf_tdata (abfd)->core_program
+	 = _bfd_elfcore_strndup (abfd, note->descdata + 32, 16);
+	elf_tdata (abfd)->core_command
+	 = _bfd_elfcore_strndup (abfd, note->descdata + 48, 80);
+    }
+
+  /* Note that for some reason, a spurious space is tacked
+     onto the end of the args in some (at least one anyway)
+     implementations, so strip it off if it exists.  */
+
+  {
+    char *command = elf_tdata (abfd)->core_command;
+    int n = strlen (command);
+
+    if (0 < n && command[n - 1] == ' ')
+      command[n - 1] = '\0';
+  }
+
+  return TRUE;
+}
+
+/* Depending on the target vector we generate some version of Irix
+   executables or "normal" BROWNIE32 ELF ABI executables.  */
+static irix_compat_t
+elf32_brownie32_irix_compat (bfd *abfd)
+{
+  if ((abfd->xvec == &bfd_elf32_bigbrownie32_vec)
+      || (abfd->xvec == &bfd_elf32_littlebrownie32_vec))
+    return ict_irix5;
+  else
+    return ict_none;
+}
+
+/* ECOFF swapping routines.  These are used when dealing with the
+   .mdebug section, which is in the ECOFF debugging format.  */
+static const struct ecoff_debug_swap brownie32_elf32_ecoff_debug_swap = {
+  /* Symbol table magic number.  */
+  magicSym,
+  /* Alignment of debugging information.  E.g., 4.  */
+  4,
+  /* Sizes of external symbolic information.  */
+  sizeof (struct hdr_ext),
+  sizeof (struct dnr_ext),
+  sizeof (struct pdr_ext),
+  sizeof (struct sym_ext),
+  sizeof (struct opt_ext),
+  sizeof (struct fdr_ext),
+  sizeof (struct rfd_ext),
+  sizeof (struct ext_ext),
+  /* Functions to swap in external symbolic data.  */
+  ecoff_swap_hdr_in,
+  ecoff_swap_dnr_in,
+  ecoff_swap_pdr_in,
+  ecoff_swap_sym_in,
+  ecoff_swap_opt_in,
+  ecoff_swap_fdr_in,
+  ecoff_swap_rfd_in,
+  ecoff_swap_ext_in,
+  _bfd_ecoff_swap_tir_in,
+  _bfd_ecoff_swap_rndx_in,
+  /* Functions to swap out external symbolic data.  */
+  ecoff_swap_hdr_out,
+  ecoff_swap_dnr_out,
+  ecoff_swap_pdr_out,
+  ecoff_swap_sym_out,
+  ecoff_swap_opt_out,
+  ecoff_swap_fdr_out,
+  ecoff_swap_rfd_out,
+  ecoff_swap_ext_out,
+  _bfd_ecoff_swap_tir_out,
+  _bfd_ecoff_swap_rndx_out,
+  /* Function to read in symbolic data.  */
+  _bfd_brownie32_elf_read_ecoff_info
+};
+
+#define ELF_ARCH			bfd_arch_brownie32
+#define ELF_MACHINE_CODE		EM_BROWNIE32
+
+#define elf_backend_collect		TRUE
+#define elf_backend_type_change_ok	TRUE
+#define elf_backend_can_gc_sections	TRUE
+#define elf_info_to_howto		brownie32_info_to_howto_rela
+#define elf_info_to_howto_rel		brownie32_info_to_howto_rel
+#define elf_backend_sym_is_global	brownie32_elf_sym_is_global
+#define elf_backend_object_p		brownie32_elf32_object_p
+#define elf_backend_symbol_processing	_bfd_brownie32_elf_symbol_processing
+#define elf_backend_section_processing	_bfd_brownie32_elf_section_processing
+#define elf_backend_section_from_shdr	_bfd_brownie32_elf_section_from_shdr
+#define elf_backend_fake_sections	_bfd_brownie32_elf_fake_sections
+#define elf_backend_section_from_bfd_section \
+					_bfd_brownie32_elf_section_from_bfd_section
+#define elf_backend_add_symbol_hook	_bfd_brownie32_elf_add_symbol_hook
+#define elf_backend_link_output_symbol_hook \
+					_bfd_brownie32_elf_link_output_symbol_hook
+#define elf_backend_create_dynamic_sections \
+					_bfd_brownie32_elf_create_dynamic_sections
+#define elf_backend_check_relocs	_bfd_brownie32_elf_check_relocs
+#define elf_backend_adjust_dynamic_symbol \
+					_bfd_brownie32_elf_adjust_dynamic_symbol
+#define elf_backend_always_size_sections \
+					_bfd_brownie32_elf_always_size_sections
+#define elf_backend_size_dynamic_sections \
+					_bfd_brownie32_elf_size_dynamic_sections
+#define elf_backend_relocate_section	_bfd_brownie32_elf_relocate_section
+#define elf_backend_finish_dynamic_symbol \
+					_bfd_brownie32_elf_finish_dynamic_symbol
+#define elf_backend_finish_dynamic_sections \
+					_bfd_brownie32_elf_finish_dynamic_sections
+#define elf_backend_final_write_processing \
+					_bfd_brownie32_elf_final_write_processing
+#define elf_backend_additional_program_headers \
+					_bfd_brownie32_elf_additional_program_headers
+#define elf_backend_modify_segment_map	_bfd_brownie32_elf_modify_segment_map
+#define elf_backend_gc_mark_hook	_bfd_brownie32_elf_gc_mark_hook
+#define elf_backend_gc_sweep_hook	_bfd_brownie32_elf_gc_sweep_hook
+#define elf_backend_copy_indirect_symbol \
+					_bfd_brownie32_elf_copy_indirect_symbol
+#define elf_backend_hide_symbol		_bfd_brownie32_elf_hide_symbol
+#define elf_backend_grok_prstatus	elf32_brownie32_grok_prstatus
+#define elf_backend_grok_psinfo		elf32_brownie32_grok_psinfo
+#define elf_backend_ecoff_debug_swap	&brownie32_elf32_ecoff_debug_swap
+
+#define elf_backend_got_header_size	(4 * BROWNIE32_RESERVED_GOTNO)
+#define elf_backend_may_use_rel_p	1
+#define elf_backend_may_use_rela_p	0
+#define elf_backend_default_use_rela_p	0
+#define elf_backend_sign_extend_vma	TRUE
+
+#define elf_backend_discard_info	_bfd_brownie32_elf_discard_info
+#define elf_backend_ignore_discarded_relocs \
+					_bfd_brownie32_elf_ignore_discarded_relocs
+#define elf_backend_brownie32_irix_compat	elf32_brownie32_irix_compat
+#define elf_backend_brownie32_rtype_to_howto	brownie32_elf32_rtype_to_howto
+#define bfd_elf32_bfd_is_local_label_name \
+					brownie32_elf_is_local_label_name
+#define bfd_elf32_find_nearest_line	_bfd_brownie32_elf_find_nearest_line
+#define bfd_elf32_find_inliner_info	_bfd_brownie32_elf_find_inliner_info
+#define bfd_elf32_new_section_hook	_bfd_brownie32_elf_new_section_hook
+#define bfd_elf32_set_section_contents	_bfd_brownie32_elf_set_section_contents
+#define bfd_elf32_bfd_get_relocated_section_contents \
+				_bfd_elf_brownie32_get_relocated_section_contents
+#define bfd_elf32_bfd_link_hash_table_create \
+					_bfd_brownie32_elf_link_hash_table_create
+#define bfd_elf32_bfd_final_link	_bfd_brownie32_elf_final_link
+#define bfd_elf32_bfd_merge_private_bfd_data \
+					_bfd_brownie32_elf_merge_private_bfd_data
+#define bfd_elf32_bfd_set_private_flags	_bfd_brownie32_elf_set_private_flags
+#define bfd_elf32_bfd_print_private_bfd_data \
+					_bfd_brownie32_elf_print_private_bfd_data
+
+/* Support for SGI-ish brownie32 targets.  */
+#define TARGET_LITTLE_SYM		bfd_elf32_littlebrownie32_vec
+#define TARGET_LITTLE_NAME		"elf32-littlebrownie32"
+#define TARGET_BIG_SYM			bfd_elf32_bigbrownie32_vec
+#define TARGET_BIG_NAME			"elf32-bigbrownie32"
+
+/* The SVR4 BROWNIE32 ABI says that this should be 0x10000, but Irix 5 uses
+   a value of 0x1000, and we are compatible.  */
+#define ELF_MAXPAGESIZE			0x1000
+#undef elf_symbol_leading_char
+#define elf_symbol_leading_char '_'
+
+#include "elf32-target.h"
+
+/* Support for traditional brownie32 targets.  */
+#undef TARGET_LITTLE_SYM
+#undef TARGET_LITTLE_NAME
+#undef TARGET_BIG_SYM
+#undef TARGET_BIG_NAME
+
+#undef ELF_MAXPAGESIZE
+
+#define TARGET_LITTLE_SYM               bfd_elf32_tradlittlebrownie32_vec
+#define TARGET_LITTLE_NAME              "elf32-tradlittlebrownie32"
+#define TARGET_BIG_SYM                  bfd_elf32_tradbigbrownie32_vec
+#define TARGET_BIG_NAME                 "elf32-tradbigbrownie32"
+
+/* The SVR4 BROWNIE32 ABI says that this should be 0x10000, and Linux uses
+   page sizes of up to that limit, so we need to respect it.  */
+#define ELF_MAXPAGESIZE			0x10000
+#define elf32_bed			elf32_tradbed
+
+/* Include the target file again for this target.  */
+#include "elf32-target.h"
Index: bfd/elf64-brownie32.c
===================================================================
RCS file: bfd/elf64-brownie32.c
diff -N bfd/elf64-brownie32.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ bfd/elf64-brownie32.c	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,2931 @@
+/* BROWNIE32-specific support for 64-bit ELF
+   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
+   Free Software Foundation, Inc.
+   Ian Lance Taylor, Cygnus Support
+   Linker support added by Mark Mitchell, CodeSourcery, LLC.
+   <mark@codesourcery.com>
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* This file supports the 64-bit BROWNIE32 ELF ABI.
+
+   The BROWNIE32 64-bit ELF ABI uses an unusual reloc format.  This file
+   overrides the usual ELF reloc handling, and handles reading and
+   writing the relocations here.  */
+
+/* TODO: Many things are unsupported, even if there is some code for it
+ .       (which was mostly stolen from elf32-brownie32.c and slightly adapted).
+ .
+ .   - Relocation handling for REL relocs is wrong in many cases and
+ .     generally untested.
+ .   - Relocation handling for RELA relocs related to GOT support are
+ .     also likely to be wrong.
+ .   - Combined relocs with RSS_* entries are unsupported.
+ .   - The whole GOT handling for NewABI is missing, some parts of
+ .     the OldABI version is still lying around and should be removed.
+ */
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "libbfd.h"
+#include "aout/ar.h"
+#include "bfdlink.h"
+#include "genlink.h"
+#include "elf-bfd.h"
+#include "elfxx-brownie32.h"
+#include "elf/brownie32.h"
+
+/* Get the ECOFF swapping routines.  The 64-bit ABI is not supposed to
+   use ECOFF.  However, we support it anyhow for an easier changeover.  */
+#include "coff/sym.h"
+#include "coff/symconst.h"
+#include "coff/internal.h"
+#include "coff/ecoff.h"
+/* The 64 bit versions of the mdebug data structures are in alpha.h.  */
+#include "coff/alpha.h"
+#define ECOFF_SIGNED_64
+#include "ecoffswap.h"
+
+static void brownie32_elf64_swap_reloc_in
+  (bfd *, const Elf64_Mips_External_Rel *, Elf64_Mips_Internal_Rela *);
+static void brownie32_elf64_swap_reloca_in
+  (bfd *, const Elf64_Mips_External_Rela *, Elf64_Mips_Internal_Rela *);
+static void brownie32_elf64_swap_reloc_out
+  (bfd *, const Elf64_Mips_Internal_Rela *, Elf64_Mips_External_Rel *);
+static void brownie32_elf64_swap_reloca_out
+  (bfd *, const Elf64_Mips_Internal_Rela *, Elf64_Mips_External_Rela *);
+static void brownie32_elf64_be_swap_reloc_in
+  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
+static void brownie32_elf64_be_swap_reloc_out
+  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
+static void brownie32_elf64_be_swap_reloca_in
+  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
+static void brownie32_elf64_be_swap_reloca_out
+  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
+static reloc_howto_type *bfd_elf64_bfd_reloc_type_lookup
+  (bfd *, bfd_reloc_code_real_type);
+static reloc_howto_type *brownie32_elf64_rtype_to_howto
+  (unsigned int, bfd_boolean);
+static void brownie32_elf64_info_to_howto_rel
+  (bfd *, arelent *, Elf_Internal_Rela *);
+static void brownie32_elf64_info_to_howto_rela
+  (bfd *, arelent *, Elf_Internal_Rela *);
+static long brownie32_elf64_get_reloc_upper_bound
+  (bfd *, asection *);
+static long brownie32_elf64_canonicalize_reloc
+  (bfd *, asection *, arelent **, asymbol **);
+static long brownie32_elf64_get_dynamic_reloc_upper_bound
+  (bfd *);
+static long brownie32_elf64_canonicalize_dynamic_reloc
+  (bfd *, arelent **, asymbol **);
+static bfd_boolean brownie32_elf64_slurp_one_reloc_table
+  (bfd *, asection *, Elf_Internal_Shdr *, bfd_size_type, arelent *,
+   asymbol **, bfd_boolean);
+static bfd_boolean brownie32_elf64_slurp_reloc_table
+  (bfd *, asection *, asymbol **, bfd_boolean);
+static void brownie32_elf64_write_relocs
+  (bfd *, asection *, void *);
+static void brownie32_elf64_write_rel
+  (bfd *, asection *, Elf_Internal_Shdr *, int *, void *);
+static void brownie32_elf64_write_rela
+  (bfd *, asection *, Elf_Internal_Shdr *, int *, void *);
+static bfd_reloc_status_type brownie32_elf64_gprel16_reloc
+  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
+static bfd_reloc_status_type brownie32_elf64_literal_reloc
+  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
+static bfd_reloc_status_type brownie32_elf64_gprel32_reloc
+  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
+static bfd_reloc_status_type brownie32_elf64_shift6_reloc
+  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
+static bfd_boolean brownie32_elf64_assign_gp
+  (bfd *, bfd_vma *);
+static bfd_reloc_status_type brownie32_elf64_final_gp
+  (bfd *, asymbol *, bfd_boolean, char **, bfd_vma *);
+static bfd_boolean brownie32_elf64_object_p
+  (bfd *);
+static irix_compat_t elf64_brownie32_irix_compat
+  (bfd *);
+static bfd_boolean elf64_brownie32_grok_prstatus
+  (bfd *, Elf_Internal_Note *);
+static bfd_boolean elf64_brownie32_grok_psinfo
+  (bfd *, Elf_Internal_Note *);
+
+extern const bfd_target bfd_elf64_bigbrownie32_vec;
+extern const bfd_target bfd_elf64_littlebrownie32_vec;
+
+/* In case we're on a 32-bit machine, construct a 64-bit "-1" value
+   from smaller values.  Start with zero, widen, *then* decrement.  */
+#define MINUS_ONE	(((bfd_vma)0) - 1)
+
+/* The number of local .got entries we reserve.  */
+#define BROWNIE32_RESERVED_GOTNO (2)
+
+/* The relocation table used for SHT_REL sections.  */
+
+static reloc_howto_type brownie32_elf64_howto_table_rel[] =
+{
+  /* No relocation.  */
+  HOWTO (R_BROWNIE32_NONE,		/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_NONE",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 16 bit relocation.  */
+  HOWTO (R_BROWNIE32_16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_16",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32 bit relocation.  */
+  HOWTO (R_BROWNIE32_32,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_32",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32 bit symbol relative relocation.  */
+  HOWTO (R_BROWNIE32_REL32,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_REL32",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 26 bit jump address.  */
+  HOWTO (R_BROWNIE32_26,		/* type */
+	 2,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 26,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+				/* This needs complex overflow
+				   detection, because the upper 36
+				   bits must match the PC + 4.  */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_26",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0x03ffffff,		/* src_mask */
+	 0x03ffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* R_BROWNIE32_HI16 and R_BROWNIE32_LO16 are unsupported for NewABI REL.
+     However, the native IRIX6 tools use them, so we try our best. */
+
+  /* High 16 bits of symbol value.  */
+  HOWTO (R_BROWNIE32_HI16,		/* type */
+	 16,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_hi16_reloc, /* special_function */
+	 "R_BROWNIE32_HI16",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Low 16 bits of symbol value.  */
+  HOWTO (R_BROWNIE32_LO16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_lo16_reloc, /* special_function */
+	 "R_BROWNIE32_LO16",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* GP relative reference.  */
+  HOWTO (R_BROWNIE32_GPREL16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 brownie32_elf64_gprel16_reloc, /* special_function */
+	 "R_BROWNIE32_GPREL16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Reference to literal section.  */
+  HOWTO (R_BROWNIE32_LITERAL,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 brownie32_elf64_literal_reloc, /* special_function */
+	 "R_BROWNIE32_LITERAL",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Reference to global offset table.  */
+  HOWTO (R_BROWNIE32_GOT16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_got16_reloc, /* special_function */
+	 "R_BROWNIE32_GOT16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 16 bit PC relative reference.  */
+  HOWTO (R_BROWNIE32_PC16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_PC16",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* 16 bit call through global offset table.  */
+  HOWTO (R_BROWNIE32_CALL16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_CALL16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32 bit GP relative reference.  */
+  HOWTO (R_BROWNIE32_GPREL32,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 brownie32_elf64_gprel32_reloc, /* special_function */
+	 "R_BROWNIE32_GPREL32",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  EMPTY_HOWTO (13),
+  EMPTY_HOWTO (14),
+  EMPTY_HOWTO (15),
+
+  /* A 5 bit shift field.  */
+  HOWTO (R_BROWNIE32_SHIFT5,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 5,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 6,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_SHIFT5",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x000007c0,		/* src_mask */
+	 0x000007c0,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 6 bit shift field.  */
+  HOWTO (R_BROWNIE32_SHIFT6,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 6,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 6,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 brownie32_elf64_shift6_reloc, /* special_function */
+	 "R_BROWNIE32_SHIFT6",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x000007c4,		/* src_mask */
+	 0x000007c4,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 64 bit relocation.  */
+  HOWTO (R_BROWNIE32_64,		/* type */
+	 0,			/* rightshift */
+	 4,			/* size (0 = byte, 1 = short, 2 = long) */
+	 64,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_64",		/* name */
+	 TRUE,			/* partial_inplace */
+	 MINUS_ONE,		/* src_mask */
+	 MINUS_ONE,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Displacement in the global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_DISP,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_GOT_DISP",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Displacement to page pointer in the global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_PAGE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_GOT_PAGE",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Offset from page pointer in the global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_OFST,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_GOT_OFST",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* High 16 bits of displacement in global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_HI16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_GOT_HI16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Low 16 bits of displacement in global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_GOT_LO16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 64 bit subtraction.  */
+  HOWTO (R_BROWNIE32_SUB,		/* type */
+	 0,			/* rightshift */
+	 4,			/* size (0 = byte, 1 = short, 2 = long) */
+	 64,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_SUB",		/* name */
+	 TRUE,			/* partial_inplace */
+	 MINUS_ONE,		/* src_mask */
+	 MINUS_ONE,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Insert the addend as an instruction.  */
+  /* FIXME: Not handled correctly.  */
+  HOWTO (R_BROWNIE32_INSERT_A,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_INSERT_A",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Insert the addend as an instruction, and change all relocations
+     to refer to the old instruction at the address.  */
+  /* FIXME: Not handled correctly.  */
+  HOWTO (R_BROWNIE32_INSERT_B,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_INSERT_B",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Delete a 32 bit instruction.  */
+  /* FIXME: Not handled correctly.  */
+  HOWTO (R_BROWNIE32_DELETE,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_DELETE",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* The BROWNIE32 ELF64 ABI Draft wants us to support these for REL relocations.
+     We don't, because
+       a) It means building the addend from a R_BROWNIE32_HIGHEST/R_BROWNIE32_HIGHER/
+	  R_BROWNIE32_HI16/R_BROWNIE32_LO16 sequence with varying ordering, using
+	  fallable heuristics.
+       b) No other NewABI toolchain actually emits such relocations.  */
+  EMPTY_HOWTO (R_BROWNIE32_HIGHER),
+  EMPTY_HOWTO (R_BROWNIE32_HIGHEST),
+
+  /* High 16 bits of displacement in global offset table.  */
+  HOWTO (R_BROWNIE32_CALL_HI16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_CALL_HI16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Low 16 bits of displacement in global offset table.  */
+  HOWTO (R_BROWNIE32_CALL_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_CALL_LO16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Section displacement, used by an associated event location section.  */
+  HOWTO (R_BROWNIE32_SCN_DISP,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_SCN_DISP",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_BROWNIE32_REL16,		/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_REL16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffff,		/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* These two are obsolete.  */
+  EMPTY_HOWTO (R_BROWNIE32_ADD_IMMEDIATE),
+  EMPTY_HOWTO (R_BROWNIE32_PJUMP),
+
+  /* Similiar to R_BROWNIE32_REL32, but used for relocations in a GOT section.
+     It must be used for multigot GOT's (and only there).  */
+  HOWTO (R_BROWNIE32_RELGOT,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_RELGOT",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Protected jump conversion.  This is an optimization hint.  No
+     relocation is required for correctness.  */
+  HOWTO (R_BROWNIE32_JALR,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_JALR",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x00000000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS relocations.  */
+  EMPTY_HOWTO (R_BROWNIE32_TLS_DTPMOD32),
+  EMPTY_HOWTO (R_BROWNIE32_TLS_DTPREL32),
+
+  HOWTO (R_BROWNIE32_TLS_DTPMOD64,	/* type */
+	 0,			/* rightshift */
+	 4,			/* size (0 = byte, 1 = short, 2 = long) */
+	 64,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_DTPMOD64",	/* name */
+	 TRUE,			/* partial_inplace */
+	 MINUS_ONE,		/* src_mask */
+	 MINUS_ONE,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_BROWNIE32_TLS_DTPREL64,	/* type */
+	 0,			/* rightshift */
+	 4,			/* size (0 = byte, 1 = short, 2 = long) */
+	 64,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_DTPREL64",	/* name */
+	 TRUE,			/* partial_inplace */
+	 MINUS_ONE,		/* src_mask */
+	 MINUS_ONE,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS general dynamic variable reference.  */
+  HOWTO (R_BROWNIE32_TLS_GD,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_GD",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS local dynamic variable reference.  */
+  HOWTO (R_BROWNIE32_TLS_LDM,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_LDM",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS local dynamic offset.  */
+  HOWTO (R_BROWNIE32_TLS_DTPREL_HI16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_DTPREL_HI16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS local dynamic offset.  */
+  HOWTO (R_BROWNIE32_TLS_DTPREL_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_DTPREL_LO16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS thread pointer offset.  */
+  HOWTO (R_BROWNIE32_TLS_GOTTPREL,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_GOTTPREL",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS IE dynamic relocations.  */
+  EMPTY_HOWTO (R_BROWNIE32_TLS_TPREL32),
+
+  HOWTO (R_BROWNIE32_TLS_TPREL64,	/* type */
+	 0,			/* rightshift */
+	 4,			/* size (0 = byte, 1 = short, 2 = long) */
+	 64,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_TPREL64",	/* name */
+	 TRUE,			/* partial_inplace */
+	 MINUS_ONE,		/* src_mask */
+	 MINUS_ONE,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS thread pointer offset.  */
+  HOWTO (R_BROWNIE32_TLS_TPREL_HI16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_TPREL_HI16", /* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS thread pointer offset.  */
+  HOWTO (R_BROWNIE32_TLS_TPREL_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_TPREL_LO16", /* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+};
+
+/* The relocation table used for SHT_RELA sections.  */
+
+static reloc_howto_type brownie32_elf64_howto_table_rela[] =
+{
+  /* No relocation.  */
+  HOWTO (R_BROWNIE32_NONE,		/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_NONE",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 16 bit relocation.  */
+  HOWTO (R_BROWNIE32_16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_16",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32 bit relocation.  */
+  HOWTO (R_BROWNIE32_32,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_32",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32 bit symbol relative relocation.  */
+  HOWTO (R_BROWNIE32_REL32,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_REL32",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 26 bit jump address.  */
+  HOWTO (R_BROWNIE32_26,		/* type */
+	 2,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 26,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+				/* This needs complex overflow
+				   detection, because the upper 36
+				   bits must match the PC + 4.  */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_26",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x03ffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* High 16 bits of symbol value.  */
+  HOWTO (R_BROWNIE32_HI16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_HI16",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Low 16 bits of symbol value.  */
+  HOWTO (R_BROWNIE32_LO16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_LO16",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* GP relative reference.  */
+  HOWTO (R_BROWNIE32_GPREL16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 brownie32_elf64_gprel16_reloc, /* special_function */
+	 "R_BROWNIE32_GPREL16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Reference to literal section.  */
+  HOWTO (R_BROWNIE32_LITERAL,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 brownie32_elf64_literal_reloc, /* special_function */
+	 "R_BROWNIE32_LITERAL",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Reference to global offset table.  */
+  HOWTO (R_BROWNIE32_GOT16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_GOT16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 16 bit PC relative reference.  */
+  HOWTO (R_BROWNIE32_PC16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_PC16",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* 16 bit call through global offset table.  */
+  HOWTO (R_BROWNIE32_CALL16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_CALL16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32 bit GP relative reference.  */
+  HOWTO (R_BROWNIE32_GPREL32,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 brownie32_elf64_gprel32_reloc, /* special_function */
+	 "R_BROWNIE32_GPREL32",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  EMPTY_HOWTO (13),
+  EMPTY_HOWTO (14),
+  EMPTY_HOWTO (15),
+
+  /* A 5 bit shift field.  */
+  HOWTO (R_BROWNIE32_SHIFT5,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 5,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 6,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_SHIFT5",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x000007c0,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 6 bit shift field.  */
+  HOWTO (R_BROWNIE32_SHIFT6,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 6,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 6,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 brownie32_elf64_shift6_reloc, /* special_function */
+	 "R_BROWNIE32_SHIFT6",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x000007c4,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 64 bit relocation.  */
+  HOWTO (R_BROWNIE32_64,		/* type */
+	 0,			/* rightshift */
+	 4,			/* size (0 = byte, 1 = short, 2 = long) */
+	 64,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_64",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 MINUS_ONE,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Displacement in the global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_DISP,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_GOT_DISP",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Displacement to page pointer in the global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_PAGE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_GOT_PAGE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Offset from page pointer in the global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_OFST,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_GOT_OFST",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* High 16 bits of displacement in global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_HI16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_GOT_HI16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Low 16 bits of displacement in global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_GOT_LO16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 64 bit subtraction.  */
+  HOWTO (R_BROWNIE32_SUB,		/* type */
+	 0,			/* rightshift */
+	 4,			/* size (0 = byte, 1 = short, 2 = long) */
+	 64,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_SUB",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 MINUS_ONE,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Insert the addend as an instruction.  */
+  /* FIXME: Not handled correctly.  */
+  HOWTO (R_BROWNIE32_INSERT_A,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_INSERT_A",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Insert the addend as an instruction, and change all relocations
+     to refer to the old instruction at the address.  */
+  /* FIXME: Not handled correctly.  */
+  HOWTO (R_BROWNIE32_INSERT_B,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_INSERT_B",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Delete a 32 bit instruction.  */
+  /* FIXME: Not handled correctly.  */
+  HOWTO (R_BROWNIE32_DELETE,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_DELETE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Get the higher value of a 64 bit addend.  */
+  HOWTO (R_BROWNIE32_HIGHER,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_HIGHER",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Get the highest value of a 64 bit addend.  */
+  HOWTO (R_BROWNIE32_HIGHEST,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_HIGHEST",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* High 16 bits of displacement in global offset table.  */
+  HOWTO (R_BROWNIE32_CALL_HI16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_CALL_HI16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Low 16 bits of displacement in global offset table.  */
+  HOWTO (R_BROWNIE32_CALL_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_CALL_LO16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Section displacement, used by an associated event location section.  */
+  HOWTO (R_BROWNIE32_SCN_DISP,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_SCN_DISP",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_BROWNIE32_REL16,		/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_REL16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* These two are obsolete.  */
+  EMPTY_HOWTO (R_BROWNIE32_ADD_IMMEDIATE),
+  EMPTY_HOWTO (R_BROWNIE32_PJUMP),
+
+  /* Similiar to R_BROWNIE32_REL32, but used for relocations in a GOT section.
+     It must be used for multigot GOT's (and only there).  */
+  HOWTO (R_BROWNIE32_RELGOT,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_RELGOT",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Protected jump conversion.  This is an optimization hint.  No
+     relocation is required for correctness.  */
+  HOWTO (R_BROWNIE32_JALR,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_JALR",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x00000000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS relocations.  */
+  EMPTY_HOWTO (R_BROWNIE32_TLS_DTPMOD32),
+  EMPTY_HOWTO (R_BROWNIE32_TLS_DTPREL32),
+  EMPTY_HOWTO (R_BROWNIE32_TLS_DTPMOD64),
+  EMPTY_HOWTO (R_BROWNIE32_TLS_DTPREL64),
+
+  /* TLS general dynamic variable reference.  */
+  HOWTO (R_BROWNIE32_TLS_GD,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_GD",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS local dynamic variable reference.  */
+  HOWTO (R_BROWNIE32_TLS_LDM,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_LDM",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS local dynamic offset.  */
+  HOWTO (R_BROWNIE32_TLS_DTPREL_HI16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_DTPREL_HI16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS local dynamic offset.  */
+  HOWTO (R_BROWNIE32_TLS_DTPREL_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_DTPREL_LO16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS thread pointer offset.  */
+  HOWTO (R_BROWNIE32_TLS_GOTTPREL,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_GOTTPREL",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  EMPTY_HOWTO (R_BROWNIE32_TLS_TPREL32),
+  EMPTY_HOWTO (R_BROWNIE32_TLS_TPREL64),
+
+  /* TLS thread pointer offset.  */
+  HOWTO (R_BROWNIE32_TLS_TPREL_HI16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_TPREL_HI16", /* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS thread pointer offset.  */
+  HOWTO (R_BROWNIE32_TLS_TPREL_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_TPREL_LO16", /* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+};
+
+/* GNU extension to record C++ vtable hierarchy */
+static reloc_howto_type elf_brownie32_gnu_vtinherit_howto =
+  HOWTO (R_BROWNIE32_GNU_VTINHERIT,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 NULL,			/* special_function */
+	 "R_BROWNIE32_GNU_VTINHERIT", /* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE);		/* pcrel_offset */
+
+/* GNU extension to record C++ vtable member usage */
+static reloc_howto_type elf_brownie32_gnu_vtentry_howto =
+  HOWTO (R_BROWNIE32_GNU_VTENTRY,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_elf_rel_vtable_reloc_fn, /* special_function */
+	 "R_BROWNIE32_GNU_VTENTRY",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE);		/* pcrel_offset */
+
+/* 16 bit offset for pc-relative branches.  */
+static reloc_howto_type elf_brownie32_gnu_rel16_s2 =
+  HOWTO (R_BROWNIE32_GNU_REL16_S2,	/* type */
+	 2,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_GNU_REL16_S2",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 TRUE);			/* pcrel_offset */
+
+/* 16 bit offset for pc-relative branches.  */
+static reloc_howto_type elf_brownie32_gnu_rela16_s2 =
+  HOWTO (R_BROWNIE32_GNU_REL16_S2,	/* type */
+	 2,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc,	/* special_function */
+	 "R_BROWNIE32_GNU_REL16_S2",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 TRUE);			/* pcrel_offset */
+
+/* Swap in a BROWNIE32 64-bit Rel reloc.  */
+
+static void
+brownie32_elf64_swap_reloc_in (bfd *abfd, const Elf64_Mips_External_Rel *src,
+			  Elf64_Mips_Internal_Rela *dst)
+{
+  dst->r_offset = H_GET_64 (abfd, src->r_offset);
+  dst->r_sym = H_GET_32 (abfd, src->r_sym);
+  dst->r_ssym = H_GET_8 (abfd, src->r_ssym);
+  dst->r_type3 = H_GET_8 (abfd, src->r_type3);
+  dst->r_type2 = H_GET_8 (abfd, src->r_type2);
+  dst->r_type = H_GET_8 (abfd, src->r_type);
+  dst->r_addend = 0;
+}
+
+/* Swap in a BROWNIE32 64-bit Rela reloc.  */
+
+static void
+brownie32_elf64_swap_reloca_in (bfd *abfd, const Elf64_Mips_External_Rela *src,
+			   Elf64_Mips_Internal_Rela *dst)
+{
+  dst->r_offset = H_GET_64 (abfd, src->r_offset);
+  dst->r_sym = H_GET_32 (abfd, src->r_sym);
+  dst->r_ssym = H_GET_8 (abfd, src->r_ssym);
+  dst->r_type3 = H_GET_8 (abfd, src->r_type3);
+  dst->r_type2 = H_GET_8 (abfd, src->r_type2);
+  dst->r_type = H_GET_8 (abfd, src->r_type);
+  dst->r_addend = H_GET_S64 (abfd, src->r_addend);
+}
+
+/* Swap out a BROWNIE32 64-bit Rel reloc.  */
+
+static void
+brownie32_elf64_swap_reloc_out (bfd *abfd, const Elf64_Mips_Internal_Rela *src,
+			   Elf64_Mips_External_Rel *dst)
+{
+  H_PUT_64 (abfd, src->r_offset, dst->r_offset);
+  H_PUT_32 (abfd, src->r_sym, dst->r_sym);
+  H_PUT_8 (abfd, src->r_ssym, dst->r_ssym);
+  H_PUT_8 (abfd, src->r_type3, dst->r_type3);
+  H_PUT_8 (abfd, src->r_type2, dst->r_type2);
+  H_PUT_8 (abfd, src->r_type, dst->r_type);
+}
+
+/* Swap out a BROWNIE32 64-bit Rela reloc.  */
+
+static void
+brownie32_elf64_swap_reloca_out (bfd *abfd, const Elf64_Mips_Internal_Rela *src,
+			    Elf64_Mips_External_Rela *dst)
+{
+  H_PUT_64 (abfd, src->r_offset, dst->r_offset);
+  H_PUT_32 (abfd, src->r_sym, dst->r_sym);
+  H_PUT_8 (abfd, src->r_ssym, dst->r_ssym);
+  H_PUT_8 (abfd, src->r_type3, dst->r_type3);
+  H_PUT_8 (abfd, src->r_type2, dst->r_type2);
+  H_PUT_8 (abfd, src->r_type, dst->r_type);
+  H_PUT_S64 (abfd, src->r_addend, dst->r_addend);
+}
+
+/* Swap in a BROWNIE32 64-bit Rel reloc.  */
+
+static void
+brownie32_elf64_be_swap_reloc_in (bfd *abfd, const bfd_byte *src,
+			     Elf_Internal_Rela *dst)
+{
+  Elf64_Mips_Internal_Rela mirel;
+
+  brownie32_elf64_swap_reloc_in (abfd,
+			    (const Elf64_Mips_External_Rel *) src,
+			    &mirel);
+
+  dst[0].r_offset = mirel.r_offset;
+  dst[0].r_info = ELF64_R_INFO (mirel.r_sym, mirel.r_type);
+  dst[0].r_addend = 0;
+  dst[1].r_offset = mirel.r_offset;
+  dst[1].r_info = ELF64_R_INFO (mirel.r_ssym, mirel.r_type2);
+  dst[1].r_addend = 0;
+  dst[2].r_offset = mirel.r_offset;
+  dst[2].r_info = ELF64_R_INFO (STN_UNDEF, mirel.r_type3);
+  dst[2].r_addend = 0;
+}
+
+/* Swap in a BROWNIE32 64-bit Rela reloc.  */
+
+static void
+brownie32_elf64_be_swap_reloca_in (bfd *abfd, const bfd_byte *src,
+			      Elf_Internal_Rela *dst)
+{
+  Elf64_Mips_Internal_Rela mirela;
+
+  brownie32_elf64_swap_reloca_in (abfd,
+			     (const Elf64_Mips_External_Rela *) src,
+			     &mirela);
+
+  dst[0].r_offset = mirela.r_offset;
+  dst[0].r_info = ELF64_R_INFO (mirela.r_sym, mirela.r_type);
+  dst[0].r_addend = mirela.r_addend;
+  dst[1].r_offset = mirela.r_offset;
+  dst[1].r_info = ELF64_R_INFO (mirela.r_ssym, mirela.r_type2);
+  dst[1].r_addend = 0;
+  dst[2].r_offset = mirela.r_offset;
+  dst[2].r_info = ELF64_R_INFO (STN_UNDEF, mirela.r_type3);
+  dst[2].r_addend = 0;
+}
+
+/* Swap out a BROWNIE32 64-bit Rel reloc.  */
+
+static void
+brownie32_elf64_be_swap_reloc_out (bfd *abfd, const Elf_Internal_Rela *src,
+			      bfd_byte *dst)
+{
+  Elf64_Mips_Internal_Rela mirel;
+
+  mirel.r_offset = src[0].r_offset;
+  BFD_ASSERT(src[0].r_offset == src[1].r_offset);
+
+  mirel.r_type = ELF64_BROWNIE32_R_TYPE (src[0].r_info);
+  mirel.r_sym = ELF64_R_SYM (src[0].r_info);
+  mirel.r_type2 = ELF64_BROWNIE32_R_TYPE (src[1].r_info);
+  mirel.r_ssym = ELF64_BROWNIE32_R_SSYM (src[1].r_info);
+  mirel.r_type3 = ELF64_BROWNIE32_R_TYPE (src[2].r_info);
+
+  brownie32_elf64_swap_reloc_out (abfd, &mirel,
+			     (Elf64_Mips_External_Rel *) dst);
+}
+
+/* Swap out a BROWNIE32 64-bit Rela reloc.  */
+
+static void
+brownie32_elf64_be_swap_reloca_out (bfd *abfd, const Elf_Internal_Rela *src,
+			       bfd_byte *dst)
+{
+  Elf64_Mips_Internal_Rela mirela;
+
+  mirela.r_offset = src[0].r_offset;
+  BFD_ASSERT(src[0].r_offset == src[1].r_offset);
+  BFD_ASSERT(src[0].r_offset == src[2].r_offset);
+
+  mirela.r_type = ELF64_BROWNIE32_R_TYPE (src[0].r_info);
+  mirela.r_sym = ELF64_R_SYM (src[0].r_info);
+  mirela.r_addend = src[0].r_addend;
+  BFD_ASSERT(src[1].r_addend == 0);
+  BFD_ASSERT(src[2].r_addend == 0);
+
+  mirela.r_type2 = ELF64_BROWNIE32_R_TYPE (src[1].r_info);
+  mirela.r_ssym = ELF64_BROWNIE32_R_SSYM (src[1].r_info);
+  mirela.r_type3 = ELF64_BROWNIE32_R_TYPE (src[2].r_info);
+
+  brownie32_elf64_swap_reloca_out (abfd, &mirela,
+			      (Elf64_Mips_External_Rela *) dst);
+}
+
+/* Set the GP value for OUTPUT_BFD.  Returns FALSE if this is a
+   dangerous relocation.  */
+
+static bfd_boolean
+brownie32_elf64_assign_gp (bfd *output_bfd, bfd_vma *pgp)
+{
+  unsigned int count;
+  asymbol **sym;
+  unsigned int i;
+
+  /* If we've already figured out what GP will be, just return it.  */
+  *pgp = _bfd_get_gp_value (output_bfd);
+  if (*pgp)
+    return TRUE;
+
+  count = bfd_get_symcount (output_bfd);
+  sym = bfd_get_outsymbols (output_bfd);
+
+  /* The linker script will have created a symbol named `_gp' with the
+     appropriate value.  */
+  if (sym == NULL)
+    i = count;
+  else
+    {
+      for (i = 0; i < count; i++, sym++)
+	{
+	  register const char *name;
+
+	  name = bfd_asymbol_name (*sym);
+	  if (*name == '_' && strcmp (name, "_gp") == 0)
+	    {
+	      *pgp = bfd_asymbol_value (*sym);
+	      _bfd_set_gp_value (output_bfd, *pgp);
+	      break;
+	    }
+	}
+    }
+
+  if (i >= count)
+    {
+      /* Only get the error once.  */
+      *pgp = 4;
+      _bfd_set_gp_value (output_bfd, *pgp);
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+/* We have to figure out the gp value, so that we can adjust the
+   symbol value correctly.  We look up the symbol _gp in the output
+   BFD.  If we can't find it, we're stuck.  We cache it in the ELF
+   target data.  We don't need to adjust the symbol value for an
+   external symbol if we are producing relocatable output.  */
+
+static bfd_reloc_status_type
+brownie32_elf64_final_gp (bfd *output_bfd, asymbol *symbol, bfd_boolean relocatable,
+		     char **error_message, bfd_vma *pgp)
+{
+  if (bfd_is_und_section (symbol->section)
+      && ! relocatable)
+    {
+      *pgp = 0;
+      return bfd_reloc_undefined;
+    }
+
+  *pgp = _bfd_get_gp_value (output_bfd);
+  if (*pgp == 0
+      && (! relocatable
+	  || (symbol->flags & BSF_SECTION_SYM) != 0))
+    {
+      if (relocatable)
+	{
+	  /* Make up a value.  */
+	  *pgp = symbol->section->output_section->vma /*+ 0x4000*/;
+	  _bfd_set_gp_value (output_bfd, *pgp);
+	}
+      else if (!brownie32_elf64_assign_gp (output_bfd, pgp))
+	{
+	  *error_message =
+	    (char *) _("GP relative relocation when _gp not defined");
+	  return bfd_reloc_dangerous;
+	}
+    }
+
+  return bfd_reloc_ok;
+}
+
+/* Do a R_BROWNIE32_GPREL16 relocation.  This is a 16 bit value which must
+   become the offset from the gp register.  */
+
+static bfd_reloc_status_type
+brownie32_elf64_gprel16_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
+			  void *data, asection *input_section, bfd *output_bfd,
+			  char **error_message)
+{
+  bfd_boolean relocatable;
+  bfd_reloc_status_type ret;
+  bfd_vma gp;
+
+  /* If we're relocating, and this is an external symbol, we don't want
+     to change anything.  */
+  if (output_bfd != NULL
+      && (symbol->flags & BSF_SECTION_SYM) == 0
+      && (symbol->flags & BSF_LOCAL) != 0)
+    {
+      reloc_entry->address += input_section->output_offset;
+      return bfd_reloc_ok;
+    }
+
+  if (output_bfd != NULL)
+    relocatable = TRUE;
+  else
+    {
+      relocatable = FALSE;
+      output_bfd = symbol->section->output_section->owner;
+    }
+
+  ret = brownie32_elf64_final_gp (output_bfd, symbol, relocatable, error_message,
+			     &gp);
+  if (ret != bfd_reloc_ok)
+    return ret;
+
+  return _bfd_brownie32_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
+					input_section, relocatable,
+					data, gp);
+}
+
+/* Do a R_BROWNIE32_LITERAL relocation.  */
+
+static bfd_reloc_status_type
+brownie32_elf64_literal_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
+			  void *data, asection *input_section, bfd *output_bfd,
+			  char **error_message)
+{
+  bfd_boolean relocatable;
+  bfd_reloc_status_type ret;
+  bfd_vma gp;
+
+  /* R_BROWNIE32_LITERAL relocations are defined for local symbols only.  */
+  if (output_bfd != NULL
+      && (symbol->flags & BSF_SECTION_SYM) == 0
+      && (symbol->flags & BSF_LOCAL) != 0)
+    {
+      *error_message = (char *)
+	_("literal relocation occurs for an external symbol");
+      return bfd_reloc_outofrange;
+    }
+
+  /* FIXME: The entries in the .lit8 and .lit4 sections should be merged.  */
+  if (output_bfd != NULL)
+    relocatable = TRUE;
+  else
+    {
+      relocatable = FALSE;
+      output_bfd = symbol->section->output_section->owner;
+    }
+
+  ret = brownie32_elf64_final_gp (output_bfd, symbol, relocatable, error_message,
+			     &gp);
+  if (ret != bfd_reloc_ok)
+    return ret;
+
+  return _bfd_brownie32_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
+					input_section, relocatable,
+					data, gp);
+}
+
+/* Do a R_BROWNIE32_GPREL32 relocation.  This is a 32 bit value which must
+   become the offset from the gp register.  */
+
+static bfd_reloc_status_type
+brownie32_elf64_gprel32_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
+			  void *data, asection *input_section, bfd *output_bfd,
+			  char **error_message)
+{
+  bfd_boolean relocatable;
+  bfd_reloc_status_type ret;
+  bfd_vma gp;
+  bfd_vma relocation;
+  bfd_vma val;
+
+  /* R_BROWNIE32_GPREL32 relocations are defined for local symbols only.  */
+  if (output_bfd != NULL
+      && (symbol->flags & BSF_SECTION_SYM) == 0
+      && (symbol->flags & BSF_LOCAL) != 0)
+    {
+      *error_message = (char *)
+	_("32bits gp relative relocation occurs for an external symbol");
+      return bfd_reloc_outofrange;
+    }
+
+  if (output_bfd != NULL)
+    relocatable = TRUE;
+  else
+    {
+      relocatable = FALSE;
+      output_bfd = symbol->section->output_section->owner;
+    }
+
+  ret = brownie32_elf64_final_gp (output_bfd, symbol, relocatable,
+			     error_message, &gp);
+  if (ret != bfd_reloc_ok)
+    return ret;
+
+  if (bfd_is_com_section (symbol->section))
+    relocation = 0;
+  else
+    relocation = symbol->value;
+
+  relocation += symbol->section->output_section->vma;
+  relocation += symbol->section->output_offset;
+
+  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
+    return bfd_reloc_outofrange;
+
+  /* Set val to the offset into the section or symbol.  */
+  val = reloc_entry->addend;
+
+  if (reloc_entry->howto->partial_inplace)
+    val += bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
+
+  /* Adjust val for the final section location and GP value.  If we
+     are producing relocatable output, we don't want to do this for
+     an external symbol.  */
+  if (! relocatable
+      || (symbol->flags & BSF_SECTION_SYM) != 0)
+    val += relocation - gp;
+
+  if (reloc_entry->howto->partial_inplace)
+    bfd_put_32 (abfd, val, (bfd_byte *) data + reloc_entry->address);
+  else
+    reloc_entry->addend = val;
+
+  if (relocatable)
+    reloc_entry->address += input_section->output_offset;
+
+  return bfd_reloc_ok;
+}
+
+/* Do a R_BROWNIE32_SHIFT6 relocation. The MSB of the shift is stored at bit 2,
+   the rest is at bits 6-10. The bitpos already got right by the howto.  */
+
+static bfd_reloc_status_type
+brownie32_elf64_shift6_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
+			 void *data, asection *input_section, bfd *output_bfd,
+			 char **error_message)
+{
+  if (reloc_entry->howto->partial_inplace)
+    {
+      reloc_entry->addend = ((reloc_entry->addend & 0x00007c0)
+			     | (reloc_entry->addend & 0x00000800) >> 9);
+    }
+
+  return _bfd_brownie32_elf_generic_reloc (abfd, reloc_entry, symbol, data,
+				      input_section, output_bfd,
+				      error_message);
+}
+
+/* A mapping from BFD reloc types to BROWNIE32 ELF reloc types.  */
+
+struct elf_reloc_map {
+  bfd_reloc_code_real_type bfd_val;
+  enum elf_brownie32_reloc_type elf_val;
+};
+
+static const struct elf_reloc_map brownie32_reloc_map[] =
+{
+  { BFD_RELOC_NONE, R_BROWNIE32_NONE },
+  { BFD_RELOC_16, R_BROWNIE32_16 },
+  { BFD_RELOC_32, R_BROWNIE32_32 },
+  /* There is no BFD reloc for R_BROWNIE32_REL32.  */
+  { BFD_RELOC_64, R_BROWNIE32_64 },
+  { BFD_RELOC_CTOR, R_BROWNIE32_64 },
+  { BFD_RELOC_16_PCREL, R_BROWNIE32_PC16 },
+  { BFD_RELOC_HI16_S, R_BROWNIE32_HI16 },
+  { BFD_RELOC_LO16, R_BROWNIE32_LO16 },
+  { BFD_RELOC_GPREL16, R_BROWNIE32_GPREL16 },
+  { BFD_RELOC_GPREL32, R_BROWNIE32_GPREL32 },
+  { BFD_RELOC_BROWNIE32_JMP, R_BROWNIE32_26 },
+  { BFD_RELOC_BROWNIE32_LITERAL, R_BROWNIE32_LITERAL },
+  { BFD_RELOC_BROWNIE32_GOT16, R_BROWNIE32_GOT16 },
+  { BFD_RELOC_BROWNIE32_CALL16, R_BROWNIE32_CALL16 },
+  { BFD_RELOC_BROWNIE32_SHIFT5, R_BROWNIE32_SHIFT5 },
+  { BFD_RELOC_BROWNIE32_SHIFT6, R_BROWNIE32_SHIFT6 },
+  { BFD_RELOC_BROWNIE32_GOT_DISP, R_BROWNIE32_GOT_DISP },
+  { BFD_RELOC_BROWNIE32_GOT_PAGE, R_BROWNIE32_GOT_PAGE },
+  { BFD_RELOC_BROWNIE32_GOT_OFST, R_BROWNIE32_GOT_OFST },
+  { BFD_RELOC_BROWNIE32_GOT_HI16, R_BROWNIE32_GOT_HI16 },
+  { BFD_RELOC_BROWNIE32_GOT_LO16, R_BROWNIE32_GOT_LO16 },
+  { BFD_RELOC_BROWNIE32_SUB, R_BROWNIE32_SUB },
+  { BFD_RELOC_BROWNIE32_INSERT_A, R_BROWNIE32_INSERT_A },
+  { BFD_RELOC_BROWNIE32_INSERT_B, R_BROWNIE32_INSERT_B },
+  { BFD_RELOC_BROWNIE32_DELETE, R_BROWNIE32_DELETE },
+  { BFD_RELOC_BROWNIE32_HIGHEST, R_BROWNIE32_HIGHEST },
+  { BFD_RELOC_BROWNIE32_HIGHER, R_BROWNIE32_HIGHER },
+  { BFD_RELOC_BROWNIE32_CALL_HI16, R_BROWNIE32_CALL_HI16 },
+  { BFD_RELOC_BROWNIE32_CALL_LO16, R_BROWNIE32_CALL_LO16 },
+  { BFD_RELOC_BROWNIE32_SCN_DISP, R_BROWNIE32_SCN_DISP },
+  { BFD_RELOC_BROWNIE32_REL16, R_BROWNIE32_REL16 },
+  /* Use of R_BROWNIE32_ADD_IMMEDIATE and R_BROWNIE32_PJUMP is deprecated.  */
+  { BFD_RELOC_BROWNIE32_RELGOT, R_BROWNIE32_RELGOT },
+  { BFD_RELOC_BROWNIE32_JALR, R_BROWNIE32_JALR },
+  { BFD_RELOC_BROWNIE32_TLS_DTPMOD32, R_BROWNIE32_TLS_DTPMOD32 },
+  { BFD_RELOC_BROWNIE32_TLS_DTPREL32, R_BROWNIE32_TLS_DTPREL32 },
+  { BFD_RELOC_BROWNIE32_TLS_DTPMOD64, R_BROWNIE32_TLS_DTPMOD64 },
+  { BFD_RELOC_BROWNIE32_TLS_DTPREL64, R_BROWNIE32_TLS_DTPREL64 },
+  { BFD_RELOC_BROWNIE32_TLS_GD, R_BROWNIE32_TLS_GD },
+  { BFD_RELOC_BROWNIE32_TLS_LDM, R_BROWNIE32_TLS_LDM },
+  { BFD_RELOC_BROWNIE32_TLS_DTPREL_HI16, R_BROWNIE32_TLS_DTPREL_HI16 },
+  { BFD_RELOC_BROWNIE32_TLS_DTPREL_LO16, R_BROWNIE32_TLS_DTPREL_LO16 },
+  { BFD_RELOC_BROWNIE32_TLS_GOTTPREL, R_BROWNIE32_TLS_GOTTPREL },
+  { BFD_RELOC_BROWNIE32_TLS_TPREL32, R_BROWNIE32_TLS_TPREL32 },
+  { BFD_RELOC_BROWNIE32_TLS_TPREL64, R_BROWNIE32_TLS_TPREL64 },
+  { BFD_RELOC_BROWNIE32_TLS_TPREL_HI16, R_BROWNIE32_TLS_TPREL_HI16 },
+  { BFD_RELOC_BROWNIE32_TLS_TPREL_LO16, R_BROWNIE32_TLS_TPREL_LO16 }
+};
+
+/* Given a BFD reloc type, return a howto structure.  */
+
+static reloc_howto_type *
+bfd_elf64_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+				 bfd_reloc_code_real_type code)
+{
+  unsigned int i;
+  /* FIXME: We default to RELA here instead of choosing the right
+     relocation variant.  */
+  reloc_howto_type *howto_table = brownie32_elf64_howto_table_rela;
+
+  for (i = 0; i < sizeof (brownie32_reloc_map) / sizeof (struct elf_reloc_map);
+       i++)
+    {
+      if (brownie32_reloc_map[i].bfd_val == code)
+	return &howto_table[(int) brownie32_reloc_map[i].elf_val];
+    }
+
+  switch (code)
+    {
+    case BFD_RELOC_VTABLE_INHERIT:
+      return &elf_brownie32_gnu_vtinherit_howto;
+    case BFD_RELOC_VTABLE_ENTRY:
+      return &elf_brownie32_gnu_vtentry_howto;
+    case BFD_RELOC_16_PCREL_S2:
+      return &elf_brownie32_gnu_rela16_s2;
+    default:
+      bfd_set_error (bfd_error_bad_value);
+      return NULL;
+    }
+}
+
+/* Given a BROWNIE32 Elf_Internal_Rel, fill in an arelent structure.  */
+
+static reloc_howto_type *
+brownie32_elf64_rtype_to_howto (unsigned int r_type, bfd_boolean rela_p)
+{
+  switch (r_type)
+    {
+    case R_BROWNIE32_GNU_VTINHERIT:
+      return &elf_brownie32_gnu_vtinherit_howto;
+    case R_BROWNIE32_GNU_VTENTRY:
+      return &elf_brownie32_gnu_vtentry_howto;
+    case R_BROWNIE32_GNU_REL16_S2:
+      if (rela_p)
+	return &elf_brownie32_gnu_rela16_s2;
+      else
+	return &elf_brownie32_gnu_rel16_s2;
+    default:
+      BFD_ASSERT (r_type < (unsigned int) R_BROWNIE32_max);
+      if (rela_p)
+	return &brownie32_elf64_howto_table_rela[r_type];
+      else
+	return &brownie32_elf64_howto_table_rel[r_type];
+      break;
+    }
+}
+
+/* Prevent relocation handling by bfd for BROWNIE32 ELF64.  */
+
+static void
+brownie32_elf64_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
+			      arelent *cache_ptr ATTRIBUTE_UNUSED,
+			      Elf_Internal_Rela *dst ATTRIBUTE_UNUSED)
+{
+  BFD_ASSERT (0);
+}
+
+static void
+brownie32_elf64_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
+			       arelent *cache_ptr ATTRIBUTE_UNUSED,
+			       Elf_Internal_Rela *dst ATTRIBUTE_UNUSED)
+{
+  BFD_ASSERT (0);
+}
+
+/* Since each entry in an SHT_REL or SHT_RELA section can represent up
+   to three relocs, we must tell the user to allocate more space.  */
+
+static long
+brownie32_elf64_get_reloc_upper_bound (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)
+{
+  return (sec->reloc_count * 3 + 1) * sizeof (arelent *);
+}
+
+static long
+brownie32_elf64_get_dynamic_reloc_upper_bound (bfd *abfd)
+{
+  return _bfd_elf_get_dynamic_reloc_upper_bound (abfd) * 3;
+}
+
+/* We must also copy more relocations than the corresponding functions
+   in elf.c would, so the two following functions are slightly
+   modified from elf.c, that multiply the external relocation count by
+   3 to obtain the internal relocation count.  */
+
+static long
+brownie32_elf64_canonicalize_reloc (bfd *abfd, sec_ptr section,
+			       arelent **relptr, asymbol **symbols)
+{
+  arelent *tblptr;
+  unsigned int i;
+  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
+
+  if (! bed->s->slurp_reloc_table (abfd, section, symbols, FALSE))
+    return -1;
+
+  tblptr = section->relocation;
+  for (i = 0; i < section->reloc_count * 3; i++)
+    *relptr++ = tblptr++;
+
+  *relptr = NULL;
+
+  return section->reloc_count * 3;
+}
+
+static long
+brownie32_elf64_canonicalize_dynamic_reloc (bfd *abfd, arelent **storage,
+				       asymbol **syms)
+{
+  bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);
+  asection *s;
+  long ret;
+
+  if (elf_dynsymtab (abfd) == 0)
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      return -1;
+    }
+
+  slurp_relocs = get_elf_backend_data (abfd)->s->slurp_reloc_table;
+  ret = 0;
+  for (s = abfd->sections; s != NULL; s = s->next)
+    {
+      if (elf_section_data (s)->this_hdr.sh_link == elf_dynsymtab (abfd)
+	  && (elf_section_data (s)->this_hdr.sh_type == SHT_REL
+	      || elf_section_data (s)->this_hdr.sh_type == SHT_RELA))
+	{
+	  arelent *p;
+	  long count, i;
+
+	  if (! (*slurp_relocs) (abfd, s, syms, TRUE))
+	    return -1;
+	  count = s->size / elf_section_data (s)->this_hdr.sh_entsize * 3;
+	  p = s->relocation;
+	  for (i = 0; i < count; i++)
+	    *storage++ = p++;
+	  ret += count;
+	}
+    }
+
+  *storage = NULL;
+
+  return ret;
+}
+
+/* Read the relocations from one reloc section.  This is mostly copied
+   from elfcode.h, except for the changes to expand one external
+   relocation to 3 internal ones.  We must unfortunately set
+   reloc_count to the number of external relocations, because a lot of
+   generic code seems to depend on this.  */
+
+static bfd_boolean
+brownie32_elf64_slurp_one_reloc_table (bfd *abfd, asection *asect,
+				  Elf_Internal_Shdr *rel_hdr,
+				  bfd_size_type reloc_count,
+				  arelent *relents, asymbol **symbols,
+				  bfd_boolean dynamic)
+{
+  void *allocated;
+  bfd_byte *native_relocs;
+  arelent *relent;
+  bfd_vma i;
+  int entsize;
+  bfd_boolean rela_p;
+
+  allocated = bfd_malloc (rel_hdr->sh_size);
+  if (allocated == NULL)
+    return FALSE;
+
+  if (bfd_seek (abfd, rel_hdr->sh_offset, SEEK_SET) != 0
+      || (bfd_bread (allocated, rel_hdr->sh_size, abfd)
+	  != rel_hdr->sh_size))
+    goto error_return;
+
+  native_relocs = allocated;
+
+  entsize = rel_hdr->sh_entsize;
+  BFD_ASSERT (entsize == sizeof (Elf64_Mips_External_Rel)
+	      || entsize == sizeof (Elf64_Mips_External_Rela));
+
+  if (entsize == sizeof (Elf64_Mips_External_Rel))
+    rela_p = FALSE;
+  else
+    rela_p = TRUE;
+
+  for (i = 0, relent = relents;
+       i < reloc_count;
+       i++, native_relocs += entsize)
+    {
+      Elf64_Mips_Internal_Rela rela;
+      bfd_boolean used_sym, used_ssym;
+      int ir;
+
+      if (entsize == sizeof (Elf64_Mips_External_Rela))
+	brownie32_elf64_swap_reloca_in (abfd,
+				   (Elf64_Mips_External_Rela *) native_relocs,
+				   &rela);
+      else
+	brownie32_elf64_swap_reloc_in (abfd,
+				  (Elf64_Mips_External_Rel *) native_relocs,
+				  &rela);
+
+      /* Each entry represents exactly three actual relocations.  */
+
+      used_sym = FALSE;
+      used_ssym = FALSE;
+      for (ir = 0; ir < 3; ir++)
+	{
+	  enum elf_brownie32_reloc_type type;
+
+	  switch (ir)
+	    {
+	    default:
+	      abort ();
+	    case 0:
+	      type = (enum elf_brownie32_reloc_type) rela.r_type;
+	      break;
+	    case 1:
+	      type = (enum elf_brownie32_reloc_type) rela.r_type2;
+	      break;
+	    case 2:
+	      type = (enum elf_brownie32_reloc_type) rela.r_type3;
+	      break;
+	    }
+
+	  /* Some types require symbols, whereas some do not.  */
+	  switch (type)
+	    {
+	    case R_BROWNIE32_NONE:
+	    case R_BROWNIE32_LITERAL:
+	    case R_BROWNIE32_INSERT_A:
+	    case R_BROWNIE32_INSERT_B:
+	    case R_BROWNIE32_DELETE:
+	      relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
+	      break;
+
+	    default:
+	      if (! used_sym)
+		{
+		  if (rela.r_sym == 0)
+		    relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
+		  else
+		    {
+		      asymbol **ps, *s;
+
+		      ps = symbols + rela.r_sym - 1;
+		      s = *ps;
+		      if ((s->flags & BSF_SECTION_SYM) == 0)
+			relent->sym_ptr_ptr = ps;
+		      else
+			relent->sym_ptr_ptr = s->section->symbol_ptr_ptr;
+		    }
+
+		  used_sym = TRUE;
+		}
+	      else if (! used_ssym)
+		{
+		  switch (rela.r_ssym)
+		    {
+		    case RSS_UNDEF:
+		      relent->sym_ptr_ptr =
+			bfd_abs_section_ptr->symbol_ptr_ptr;
+		      break;
+
+		    case RSS_GP:
+		    case RSS_GP0:
+		    case RSS_LOC:
+		      /* FIXME: I think these need to be handled using
+			 special howto structures.  */
+		      BFD_ASSERT (0);
+		      break;
+
+		    default:
+		      BFD_ASSERT (0);
+		      break;
+		    }
+
+		  used_ssym = TRUE;
+		}
+	      else
+		relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
+
+	      break;
+	    }
+
+	  /* The address of an ELF reloc is section relative for an
+	     object file, and absolute for an executable file or
+	     shared library.  The address of a BFD reloc is always
+	     section relative.  */
+	  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0 || dynamic)
+	    relent->address = rela.r_offset;
+	  else
+	    relent->address = rela.r_offset - asect->vma;
+
+	  relent->addend = rela.r_addend;
+
+	  relent->howto = brownie32_elf64_rtype_to_howto (type, rela_p);
+
+	  ++relent;
+	}
+    }
+
+  asect->reloc_count += (relent - relents) / 3;
+
+  if (allocated != NULL)
+    free (allocated);
+
+  return TRUE;
+
+ error_return:
+  if (allocated != NULL)
+    free (allocated);
+  return FALSE;
+}
+
+/* Read the relocations.  On Irix 6, there can be two reloc sections
+   associated with a single data section.  This is copied from
+   elfcode.h as well, with changes as small as accounting for 3
+   internal relocs per external reloc and resetting reloc_count to
+   zero before processing the relocs of a section.  */
+
+static bfd_boolean
+brownie32_elf64_slurp_reloc_table (bfd *abfd, asection *asect,
+			      asymbol **symbols, bfd_boolean dynamic)
+{
+  struct bfd_elf_section_data * const d = elf_section_data (asect);
+  Elf_Internal_Shdr *rel_hdr;
+  Elf_Internal_Shdr *rel_hdr2;
+  bfd_size_type reloc_count;
+  bfd_size_type reloc_count2;
+  arelent *relents;
+  bfd_size_type amt;
+
+  if (asect->relocation != NULL)
+    return TRUE;
+
+  if (! dynamic)
+    {
+      if ((asect->flags & SEC_RELOC) == 0
+	  || asect->reloc_count == 0)
+	return TRUE;
+
+      rel_hdr = &d->rel_hdr;
+      reloc_count = NUM_SHDR_ENTRIES (rel_hdr);
+      rel_hdr2 = d->rel_hdr2;
+      reloc_count2 = (rel_hdr2 ? NUM_SHDR_ENTRIES (rel_hdr2) : 0);
+
+      BFD_ASSERT (asect->reloc_count == reloc_count + reloc_count2);
+      BFD_ASSERT (asect->rel_filepos == rel_hdr->sh_offset
+		  || (rel_hdr2 && asect->rel_filepos == rel_hdr2->sh_offset));
+
+    }
+  else
+    {
+      /* Note that ASECT->RELOC_COUNT tends not to be accurate in this
+	 case because relocations against this section may use the
+	 dynamic symbol table, and in that case bfd_section_from_shdr
+	 in elf.c does not update the RELOC_COUNT.  */
+      if (asect->size == 0)
+	return TRUE;
+
+      rel_hdr = &d->this_hdr;
+      reloc_count = NUM_SHDR_ENTRIES (rel_hdr);
+      rel_hdr2 = NULL;
+      reloc_count2 = 0;
+    }
+
+  /* Allocate space for 3 arelent structures for each Rel structure.  */
+  amt = (reloc_count + reloc_count2) * 3 * sizeof (arelent);
+  relents = bfd_alloc (abfd, amt);
+  if (relents == NULL)
+    return FALSE;
+
+  /* The slurp_one_reloc_table routine increments reloc_count.  */
+  asect->reloc_count = 0;
+
+  if (! brownie32_elf64_slurp_one_reloc_table (abfd, asect,
+					  rel_hdr, reloc_count,
+					  relents,
+					  symbols, dynamic))
+    return FALSE;
+  if (d->rel_hdr2 != NULL)
+    {
+      if (! brownie32_elf64_slurp_one_reloc_table (abfd, asect,
+					      rel_hdr2, reloc_count2,
+					      relents + reloc_count * 3,
+					      symbols, dynamic))
+	return FALSE;
+    }
+
+  asect->relocation = relents;
+  return TRUE;
+}
+
+/* Write out the relocations.  */
+
+static void
+brownie32_elf64_write_relocs (bfd *abfd, asection *sec, void *data)
+{
+  bfd_boolean *failedp = data;
+  int count;
+  Elf_Internal_Shdr *rel_hdr;
+  unsigned int idx;
+
+  /* If we have already failed, don't do anything.  */
+  if (*failedp)
+    return;
+
+  if ((sec->flags & SEC_RELOC) == 0)
+    return;
+
+  /* The linker backend writes the relocs out itself, and sets the
+     reloc_count field to zero to inhibit writing them here.  Also,
+     sometimes the SEC_RELOC flag gets set even when there aren't any
+     relocs.  */
+  if (sec->reloc_count == 0)
+    return;
+
+  /* We can combine up to three relocs that refer to the same address
+     if the latter relocs have no associated symbol.  */
+  count = 0;
+  for (idx = 0; idx < sec->reloc_count; idx++)
+    {
+      bfd_vma addr;
+      unsigned int i;
+
+      ++count;
+
+      addr = sec->orelocation[idx]->address;
+      for (i = 0; i < 2; i++)
+	{
+	  arelent *r;
+
+	  if (idx + 1 >= sec->reloc_count)
+	    break;
+	  r = sec->orelocation[idx + 1];
+	  if (r->address != addr
+	      || ! bfd_is_abs_section ((*r->sym_ptr_ptr)->section)
+	      || (*r->sym_ptr_ptr)->value != 0)
+	    break;
+
+	  /* We can merge the reloc at IDX + 1 with the reloc at IDX.  */
+
+	  ++idx;
+	}
+    }
+
+  rel_hdr = &elf_section_data (sec)->rel_hdr;
+
+  /* Do the actual relocation.  */
+
+  if (rel_hdr->sh_entsize == sizeof(Elf64_Mips_External_Rel))
+    brownie32_elf64_write_rel (abfd, sec, rel_hdr, &count, data);
+  else if (rel_hdr->sh_entsize == sizeof(Elf64_Mips_External_Rela))
+    brownie32_elf64_write_rela (abfd, sec, rel_hdr, &count, data);
+  else
+    BFD_ASSERT (0);
+}
+
+static void
+brownie32_elf64_write_rel (bfd *abfd, asection *sec,
+		      Elf_Internal_Shdr *rel_hdr,
+		      int *count, void *data)
+{
+  bfd_boolean *failedp = data;
+  Elf64_Mips_External_Rel *ext_rel;
+  unsigned int idx;
+  asymbol *last_sym = 0;
+  int last_sym_idx = 0;
+
+  rel_hdr->sh_size = rel_hdr->sh_entsize * *count;
+  rel_hdr->contents = bfd_alloc (abfd, rel_hdr->sh_size);
+  if (rel_hdr->contents == NULL)
+    {
+      *failedp = TRUE;
+      return;
+    }
+
+  ext_rel = (Elf64_Mips_External_Rel *) rel_hdr->contents;
+  for (idx = 0; idx < sec->reloc_count; idx++, ext_rel++)
+    {
+      arelent *ptr;
+      Elf64_Mips_Internal_Rela int_rel;
+      asymbol *sym;
+      int n;
+      unsigned int i;
+
+      ptr = sec->orelocation[idx];
+
+      /* The address of an ELF reloc is section relative for an object
+	 file, and absolute for an executable file or shared library.
+	 The address of a BFD reloc is always section relative.  */
+      if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)
+	int_rel.r_offset = ptr->address;
+      else
+	int_rel.r_offset = ptr->address + sec->vma;
+
+      sym = *ptr->sym_ptr_ptr;
+      if (sym == last_sym)
+	n = last_sym_idx;
+      else if (bfd_is_abs_section (sym->section) && sym->value == 0)
+	n = STN_UNDEF;
+      else
+	{
+	  last_sym = sym;
+	  n = _bfd_elf_symbol_from_bfd_symbol (abfd, &sym);
+	  if (n < 0)
+	    {
+	      *failedp = TRUE;
+	      return;
+	    }
+	  last_sym_idx = n;
+	}
+
+      int_rel.r_sym = n;
+      int_rel.r_ssym = RSS_UNDEF;
+
+      if ((*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec
+	  && ! _bfd_elf_validate_reloc (abfd, ptr))
+	{
+	  *failedp = TRUE;
+	  return;
+	}
+
+      int_rel.r_type = ptr->howto->type;
+      int_rel.r_type2 = (int) R_BROWNIE32_NONE;
+      int_rel.r_type3 = (int) R_BROWNIE32_NONE;
+
+      for (i = 0; i < 2; i++)
+	{
+	  arelent *r;
+
+	  if (idx + 1 >= sec->reloc_count)
+	    break;
+	  r = sec->orelocation[idx + 1];
+	  if (r->address != ptr->address
+	      || ! bfd_is_abs_section ((*r->sym_ptr_ptr)->section)
+	      || (*r->sym_ptr_ptr)->value != 0)
+	    break;
+
+	  /* We can merge the reloc at IDX + 1 with the reloc at IDX.  */
+
+	  if (i == 0)
+	    int_rel.r_type2 = r->howto->type;
+	  else
+	    int_rel.r_type3 = r->howto->type;
+
+	  ++idx;
+	}
+
+      brownie32_elf64_swap_reloc_out (abfd, &int_rel, ext_rel);
+    }
+
+  BFD_ASSERT (ext_rel - (Elf64_Mips_External_Rel *) rel_hdr->contents
+	      == *count);
+}
+
+static void
+brownie32_elf64_write_rela (bfd *abfd, asection *sec,
+		       Elf_Internal_Shdr *rela_hdr,
+		       int *count, void *data)
+{
+  bfd_boolean *failedp = data;
+  Elf64_Mips_External_Rela *ext_rela;
+  unsigned int idx;
+  asymbol *last_sym = 0;
+  int last_sym_idx = 0;
+
+  rela_hdr->sh_size = rela_hdr->sh_entsize * *count;
+  rela_hdr->contents = bfd_alloc (abfd, rela_hdr->sh_size);
+  if (rela_hdr->contents == NULL)
+    {
+      *failedp = TRUE;
+      return;
+    }
+
+  ext_rela = (Elf64_Mips_External_Rela *) rela_hdr->contents;
+  for (idx = 0; idx < sec->reloc_count; idx++, ext_rela++)
+    {
+      arelent *ptr;
+      Elf64_Mips_Internal_Rela int_rela;
+      asymbol *sym;
+      int n;
+      unsigned int i;
+
+      ptr = sec->orelocation[idx];
+
+      /* The address of an ELF reloc is section relative for an object
+	 file, and absolute for an executable file or shared library.
+	 The address of a BFD reloc is always section relative.  */
+      if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)
+	int_rela.r_offset = ptr->address;
+      else
+	int_rela.r_offset = ptr->address + sec->vma;
+
+      sym = *ptr->sym_ptr_ptr;
+      if (sym == last_sym)
+	n = last_sym_idx;
+      else if (bfd_is_abs_section (sym->section) && sym->value == 0)
+	n = STN_UNDEF;
+      else
+	{
+	  last_sym = sym;
+	  n = _bfd_elf_symbol_from_bfd_symbol (abfd, &sym);
+	  if (n < 0)
+	    {
+	      *failedp = TRUE;
+	      return;
+	    }
+	  last_sym_idx = n;
+	}
+
+      int_rela.r_sym = n;
+      int_rela.r_addend = ptr->addend;
+      int_rela.r_ssym = RSS_UNDEF;
+
+      if ((*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec
+	  && ! _bfd_elf_validate_reloc (abfd, ptr))
+	{
+	  *failedp = TRUE;
+	  return;
+	}
+
+      int_rela.r_type = ptr->howto->type;
+      int_rela.r_type2 = (int) R_BROWNIE32_NONE;
+      int_rela.r_type3 = (int) R_BROWNIE32_NONE;
+
+      for (i = 0; i < 2; i++)
+	{
+	  arelent *r;
+
+	  if (idx + 1 >= sec->reloc_count)
+	    break;
+	  r = sec->orelocation[idx + 1];
+	  if (r->address != ptr->address
+	      || ! bfd_is_abs_section ((*r->sym_ptr_ptr)->section)
+	      || (*r->sym_ptr_ptr)->value != 0)
+	    break;
+
+	  /* We can merge the reloc at IDX + 1 with the reloc at IDX.  */
+
+	  if (i == 0)
+	    int_rela.r_type2 = r->howto->type;
+	  else
+	    int_rela.r_type3 = r->howto->type;
+
+	  ++idx;
+	}
+
+      brownie32_elf64_swap_reloca_out (abfd, &int_rela, ext_rela);
+    }
+
+  BFD_ASSERT (ext_rela - (Elf64_Mips_External_Rela *) rela_hdr->contents
+	      == *count);
+}
+
+/* Set the right machine number for a BROWNIE32 ELF file.  */
+
+static bfd_boolean
+brownie32_elf64_object_p (bfd *abfd)
+{
+  unsigned long mach;
+
+  /* Irix 6 is broken.  Object file symbol tables are not always
+     sorted correctly such that local symbols precede global symbols,
+     and the sh_info field in the symbol table is not always right.  */
+  if (elf64_brownie32_irix_compat (abfd) != ict_none)
+    elf_bad_symtab (abfd) = TRUE;
+
+  mach = _bfd_elf_brownie32_mach (elf_elfheader (abfd)->e_flags);
+  bfd_default_set_arch_mach (abfd, bfd_arch_brownie32, mach);
+  return TRUE;
+}
+
+/* Depending on the target vector we generate some version of Irix
+   executables or "normal" BROWNIE32 ELF ABI executables.  */
+static irix_compat_t
+elf64_brownie32_irix_compat (bfd *abfd)
+{
+  if ((abfd->xvec == &bfd_elf64_bigbrownie32_vec)
+      || (abfd->xvec == &bfd_elf64_littlebrownie32_vec))
+    return ict_irix6;
+  else
+    return ict_none;
+}
+
+/* Support for core dump NOTE sections.  */
+static bfd_boolean
+elf64_brownie32_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
+{
+  int offset;
+  unsigned int size;
+
+  switch (note->descsz)
+    {
+      default:
+	return FALSE;
+
+      case 480:		/* Linux/BROWNIE32 - N64 kernel */
+	/* pr_cursig */
+	elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);
+
+	/* pr_pid */
+	elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 32);
+
+	/* pr_reg */
+	offset = 112;
+	size = 360;
+
+	break;
+    }
+
+  /* Make a ".reg/999" section.  */
+  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
+					  size, note->descpos + offset);
+}
+
+static bfd_boolean
+elf64_brownie32_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
+{
+  switch (note->descsz)
+    {
+      default:
+	return FALSE;
+
+      case 136:		/* Linux/BROWNIE32 - N64 kernel elf_prpsinfo */
+	elf_tdata (abfd)->core_program
+	 = _bfd_elfcore_strndup (abfd, note->descdata + 40, 16);
+	elf_tdata (abfd)->core_command
+	 = _bfd_elfcore_strndup (abfd, note->descdata + 56, 80);
+    }
+
+  /* Note that for some reason, a spurious space is tacked
+     onto the end of the args in some (at least one anyway)
+     implementations, so strip it off if it exists.  */
+
+  {
+    char *command = elf_tdata (abfd)->core_command;
+    int n = strlen (command);
+
+    if (0 < n && command[n - 1] == ' ')
+      command[n - 1] = '\0';
+  }
+
+  return TRUE;
+}
+
+/* ECOFF swapping routines.  These are used when dealing with the
+   .mdebug section, which is in the ECOFF debugging format.  */
+static const struct ecoff_debug_swap brownie32_elf64_ecoff_debug_swap =
+{
+  /* Symbol table magic number.  */
+  magicSym2,
+  /* Alignment of debugging information.  E.g., 4.  */
+  8,
+  /* Sizes of external symbolic information.  */
+  sizeof (struct hdr_ext),
+  sizeof (struct dnr_ext),
+  sizeof (struct pdr_ext),
+  sizeof (struct sym_ext),
+  sizeof (struct opt_ext),
+  sizeof (struct fdr_ext),
+  sizeof (struct rfd_ext),
+  sizeof (struct ext_ext),
+  /* Functions to swap in external symbolic data.  */
+  ecoff_swap_hdr_in,
+  ecoff_swap_dnr_in,
+  ecoff_swap_pdr_in,
+  ecoff_swap_sym_in,
+  ecoff_swap_opt_in,
+  ecoff_swap_fdr_in,
+  ecoff_swap_rfd_in,
+  ecoff_swap_ext_in,
+  _bfd_ecoff_swap_tir_in,
+  _bfd_ecoff_swap_rndx_in,
+  /* Functions to swap out external symbolic data.  */
+  ecoff_swap_hdr_out,
+  ecoff_swap_dnr_out,
+  ecoff_swap_pdr_out,
+  ecoff_swap_sym_out,
+  ecoff_swap_opt_out,
+  ecoff_swap_fdr_out,
+  ecoff_swap_rfd_out,
+  ecoff_swap_ext_out,
+  _bfd_ecoff_swap_tir_out,
+  _bfd_ecoff_swap_rndx_out,
+  /* Function to read in symbolic data.  */
+  _bfd_brownie32_elf_read_ecoff_info
+};
+
+/* Relocations in the 64 bit BROWNIE32 ELF ABI are more complex than in
+   standard ELF.  This structure is used to redirect the relocation
+   handling routines.  */
+
+const struct elf_size_info brownie32_elf64_size_info =
+{
+  sizeof (Elf64_External_Ehdr),
+  sizeof (Elf64_External_Phdr),
+  sizeof (Elf64_External_Shdr),
+  sizeof (Elf64_Mips_External_Rel),
+  sizeof (Elf64_Mips_External_Rela),
+  sizeof (Elf64_External_Sym),
+  sizeof (Elf64_External_Dyn),
+  sizeof (Elf_External_Note),
+  4,		/* hash-table entry size */
+  3,		/* internal relocations per external relocations */
+  64,		/* arch_size */
+  3,		/* log_file_align */
+  ELFCLASS64,
+  EV_CURRENT,
+  bfd_elf64_write_out_phdrs,
+  bfd_elf64_write_shdrs_and_ehdr,
+  brownie32_elf64_write_relocs,
+  bfd_elf64_swap_symbol_in,
+  bfd_elf64_swap_symbol_out,
+  brownie32_elf64_slurp_reloc_table,
+  bfd_elf64_slurp_symbol_table,
+  bfd_elf64_swap_dyn_in,
+  bfd_elf64_swap_dyn_out,
+  brownie32_elf64_be_swap_reloc_in,
+  brownie32_elf64_be_swap_reloc_out,
+  brownie32_elf64_be_swap_reloca_in,
+  brownie32_elf64_be_swap_reloca_out
+};
+
+#define ELF_ARCH			bfd_arch_brownie32
+#define ELF_MACHINE_CODE		EM_BROWNIE32
+
+#define elf_backend_collect		TRUE
+#define elf_backend_type_change_ok	TRUE
+#define elf_backend_can_gc_sections	TRUE
+#define elf_info_to_howto		brownie32_elf64_info_to_howto_rela
+#define elf_info_to_howto_rel		brownie32_elf64_info_to_howto_rel
+#define elf_backend_object_p		brownie32_elf64_object_p
+#define elf_backend_symbol_processing	_bfd_brownie32_elf_symbol_processing
+#define elf_backend_section_processing	_bfd_brownie32_elf_section_processing
+#define elf_backend_section_from_shdr	_bfd_brownie32_elf_section_from_shdr
+#define elf_backend_fake_sections	_bfd_brownie32_elf_fake_sections
+#define elf_backend_section_from_bfd_section \
+				_bfd_brownie32_elf_section_from_bfd_section
+#define elf_backend_add_symbol_hook	_bfd_brownie32_elf_add_symbol_hook
+#define elf_backend_link_output_symbol_hook \
+				_bfd_brownie32_elf_link_output_symbol_hook
+#define elf_backend_create_dynamic_sections \
+				_bfd_brownie32_elf_create_dynamic_sections
+#define elf_backend_check_relocs	_bfd_brownie32_elf_check_relocs
+#define elf_backend_adjust_dynamic_symbol \
+				_bfd_brownie32_elf_adjust_dynamic_symbol
+#define elf_backend_always_size_sections \
+				_bfd_brownie32_elf_always_size_sections
+#define elf_backend_size_dynamic_sections \
+				_bfd_brownie32_elf_size_dynamic_sections
+#define elf_backend_relocate_section    _bfd_brownie32_elf_relocate_section
+#define elf_backend_finish_dynamic_symbol \
+				_bfd_brownie32_elf_finish_dynamic_symbol
+#define elf_backend_finish_dynamic_sections \
+				_bfd_brownie32_elf_finish_dynamic_sections
+#define elf_backend_final_write_processing \
+				_bfd_brownie32_elf_final_write_processing
+#define elf_backend_additional_program_headers \
+				_bfd_brownie32_elf_additional_program_headers
+#define elf_backend_modify_segment_map	_bfd_brownie32_elf_modify_segment_map
+#define elf_backend_gc_mark_hook	_bfd_brownie32_elf_gc_mark_hook
+#define elf_backend_gc_sweep_hook	_bfd_brownie32_elf_gc_sweep_hook
+#define elf_backend_copy_indirect_symbol \
+					_bfd_brownie32_elf_copy_indirect_symbol
+#define elf_backend_hide_symbol		_bfd_brownie32_elf_hide_symbol
+#define elf_backend_ignore_discarded_relocs \
+					_bfd_brownie32_elf_ignore_discarded_relocs
+#define elf_backend_brownie32_irix_compat	elf64_brownie32_irix_compat
+#define elf_backend_brownie32_rtype_to_howto	brownie32_elf64_rtype_to_howto
+#define elf_backend_ecoff_debug_swap	&brownie32_elf64_ecoff_debug_swap
+#define elf_backend_size_info		brownie32_elf64_size_info
+
+#define elf_backend_grok_prstatus	elf64_brownie32_grok_prstatus
+#define elf_backend_grok_psinfo		elf64_brownie32_grok_psinfo
+
+#define elf_backend_got_header_size	(4 * BROWNIE32_RESERVED_GOTNO)
+
+/* BROWNIE32 ELF64 can use a mixture of REL and RELA, but some Relocations
+   work better/work only in RELA, so we default to this.  */
+#define elf_backend_may_use_rel_p	1
+#define elf_backend_may_use_rela_p	1
+#define elf_backend_default_use_rela_p	1
+
+#define elf_backend_write_section	_bfd_brownie32_elf_write_section
+
+/* We don't set bfd_elf64_bfd_is_local_label_name because the 32-bit
+   BROWNIE32-specific function only applies to IRIX5, which had no 64-bit
+   ABI.  */
+#define bfd_elf64_find_nearest_line	_bfd_brownie32_elf_find_nearest_line
+#define bfd_elf64_find_inliner_info	_bfd_brownie32_elf_find_inliner_info
+#define bfd_elf64_new_section_hook	_bfd_brownie32_elf_new_section_hook
+#define bfd_elf64_set_section_contents	_bfd_brownie32_elf_set_section_contents
+#define bfd_elf64_bfd_get_relocated_section_contents \
+				_bfd_elf_brownie32_get_relocated_section_contents
+#define bfd_elf64_bfd_link_hash_table_create \
+				_bfd_brownie32_elf_link_hash_table_create
+#define bfd_elf64_bfd_final_link	_bfd_brownie32_elf_final_link
+#define bfd_elf64_bfd_merge_private_bfd_data \
+				_bfd_brownie32_elf_merge_private_bfd_data
+#define bfd_elf64_bfd_set_private_flags	_bfd_brownie32_elf_set_private_flags
+#define bfd_elf64_bfd_print_private_bfd_data \
+				_bfd_brownie32_elf_print_private_bfd_data
+
+#define bfd_elf64_get_reloc_upper_bound brownie32_elf64_get_reloc_upper_bound
+#define bfd_elf64_canonicalize_reloc brownie32_elf64_canonicalize_reloc
+#define bfd_elf64_get_dynamic_reloc_upper_bound brownie32_elf64_get_dynamic_reloc_upper_bound
+#define bfd_elf64_canonicalize_dynamic_reloc brownie32_elf64_canonicalize_dynamic_reloc
+#define bfd_elf64_bfd_relax_section     _bfd_brownie32_relax_section
+
+/* BROWNIE32 ELF64 archive functions.  */
+#define bfd_elf64_archive_functions
+extern bfd_boolean bfd_elf64_archive_slurp_armap
+  (bfd *);
+extern bfd_boolean bfd_elf64_archive_write_armap
+  (bfd *, unsigned int, struct orl *, unsigned int, int);
+#define bfd_elf64_archive_slurp_extended_name_table \
+			_bfd_archive_coff_slurp_extended_name_table
+#define bfd_elf64_archive_construct_extended_name_table \
+			_bfd_archive_coff_construct_extended_name_table
+#define bfd_elf64_archive_truncate_arname \
+			_bfd_archive_coff_truncate_arname
+#define bfd_elf64_archive_read_ar_hdr	_bfd_archive_coff_read_ar_hdr
+#define bfd_elf64_archive_openr_next_archived_file \
+			_bfd_archive_coff_openr_next_archived_file
+#define bfd_elf64_archive_get_elt_at_index \
+			_bfd_archive_coff_get_elt_at_index
+#define bfd_elf64_archive_generic_stat_arch_elt \
+			_bfd_archive_coff_generic_stat_arch_elt
+#define bfd_elf64_archive_update_armap_timestamp \
+			_bfd_archive_coff_update_armap_timestamp
+
+/* The SGI style (n)64 NewABI.  */
+#define TARGET_LITTLE_SYM		bfd_elf64_littlebrownie32_vec
+#define TARGET_LITTLE_NAME		"elf64-littlebrownie32"
+#define TARGET_BIG_SYM			bfd_elf64_bigbrownie32_vec
+#define TARGET_BIG_NAME			"elf64-bigbrownie32"
+
+/* The SVR4 BROWNIE32 ABI says that this should be 0x10000, but Irix 5 uses
+   a value of 0x1000, and we are compatible.
+   FIXME: How does this affect NewABI?  */
+#define ELF_MAXPAGESIZE			0x1000
+
+#include "elf64-target.h"
+
+/* The SYSV-style 'traditional' (n)64 NewABI.  */
+#undef TARGET_LITTLE_SYM
+#undef TARGET_LITTLE_NAME
+#undef TARGET_BIG_SYM
+#undef TARGET_BIG_NAME
+
+#undef ELF_MAXPAGESIZE
+
+#define TARGET_LITTLE_SYM		bfd_elf64_tradlittlebrownie32_vec
+#define TARGET_LITTLE_NAME		"elf64-tradlittlebrownie32"
+#define TARGET_BIG_SYM			bfd_elf64_tradbigbrownie32_vec
+#define TARGET_BIG_NAME			"elf64-tradbigbrownie32"
+
+/* The SVR4 BROWNIE32 ABI says that this should be 0x10000, and Linux uses
+   page sizes of up to that limit, so we need to respect it.  */
+#define ELF_MAXPAGESIZE			0x10000
+#define elf64_bed			elf64_tradbed
+
+/* Include the target file again for this target.  */
+#include "elf64-target.h"
Index: bfd/elfn32-brownie32.c
===================================================================
RCS file: bfd/elfn32-brownie32.c
diff -N bfd/elfn32-brownie32.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ bfd/elfn32-brownie32.c	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,2171 @@
+/* BROWNIE32-specific support for 32-bit ELF
+   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+   2003, 2004, 2005 Free Software Foundation, Inc.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+   Most of the information added by Ian Lance Taylor, Cygnus Support,
+   <ian@cygnus.com>.
+   N32/64 ABI support added by Mark Mitchell, CodeSourcery, LLC.
+   <mark@codesourcery.com>
+   Traditional BROWNIE32 targets support added by Koundinya.K, Dansk Data
+   Elektronik & Operations Research Group. <kk@ddeorg.soft.net>
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* This file handles BROWNIE32 ELF targets.  SGI Irix 5 uses a slightly
+   different BROWNIE32 ELF from other targets.  This matters when linking.
+   This file supports both, switching at runtime.  */
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "libbfd.h"
+#include "bfdlink.h"
+#include "genlink.h"
+#include "elf-bfd.h"
+#include "elfxx-brownie32.h"
+#include "elf/brownie32.h"
+
+/* Get the ECOFF swapping routines.  */
+#include "coff/sym.h"
+#include "coff/symconst.h"
+#include "coff/internal.h"
+#include "coff/ecoff.h"
+#include "coff/brownie32.h"
+#define ECOFF_SIGNED_32
+#include "ecoffswap.h"
+
+static bfd_boolean brownie32_elf_assign_gp
+  (bfd *, bfd_vma *);
+static bfd_reloc_status_type brownie32_elf_final_gp
+  (bfd *, asymbol *, bfd_boolean, char **, bfd_vma *);
+static bfd_reloc_status_type brownie32_elf_gprel16_reloc
+  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
+static bfd_reloc_status_type brownie32_elf_literal_reloc
+  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
+static bfd_reloc_status_type brownie32_elf_gprel32_reloc
+  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
+static bfd_reloc_status_type gprel32_with_gp
+  (bfd *, asymbol *, arelent *, asection *, bfd_boolean, void *, bfd_vma);
+static bfd_reloc_status_type brownie32_elf_shift6_reloc
+  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
+static reloc_howto_type *bfd_elf32_bfd_reloc_type_lookup
+  (bfd *, bfd_reloc_code_real_type);
+static reloc_howto_type *brownie32_elf_n32_rtype_to_howto
+  (unsigned int, bfd_boolean);
+static void brownie32_info_to_howto_rel
+  (bfd *, arelent *, Elf_Internal_Rela *);
+static void brownie32_info_to_howto_rela
+  (bfd *, arelent *, Elf_Internal_Rela *);
+static bfd_boolean brownie32_elf_sym_is_global
+  (bfd *, asymbol *);
+static bfd_boolean brownie32_elf_n32_object_p
+  (bfd *);
+static bfd_boolean elf32_brownie32_grok_prstatus
+  (bfd *, Elf_Internal_Note *);
+static bfd_boolean elf32_brownie32_grok_psinfo
+  (bfd *, Elf_Internal_Note *);
+static irix_compat_t elf_n32_brownie32_irix_compat
+  (bfd *);
+
+extern const bfd_target bfd_elf32_nbigbrownie32_vec;
+extern const bfd_target bfd_elf32_nlittlebrownie32_vec;
+
+/* Nonzero if ABFD is using the N32 ABI.  */
+#define ABI_N32_P(abfd) \
+  ((elf_elfheader (abfd)->e_flags & EF_BROWNIE32_ABI2) != 0)
+
+/* Whether we are trying to be compatible with IRIX at all.  */
+#define SGI_COMPAT(abfd) \
+  (elf_n32_brownie32_irix_compat (abfd) != ict_none)
+
+/* The number of local .got entries we reserve.  */
+#define BROWNIE32_RESERVED_GOTNO (2)
+
+/* In case we're on a 32-bit machine, construct a 64-bit "-1" value
+   from smaller values.  Start with zero, widen, *then* decrement.  */
+#define MINUS_ONE	(((bfd_vma)0) - 1)
+
+/* The relocation table used for SHT_REL sections.  */
+
+static reloc_howto_type elf_brownie32_howto_table_rel[] =
+{
+  /* No relocation.  */
+  HOWTO (R_BROWNIE32_NONE,		/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_NONE",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 16 bit relocation.  */
+  HOWTO (R_BROWNIE32_16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_16",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32 bit relocation.  */
+  HOWTO (R_BROWNIE32_32,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_32",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32 bit symbol relative relocation.  */
+  HOWTO (R_BROWNIE32_REL32,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_REL32",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 26 bit jump address.  */
+  HOWTO (R_BROWNIE32_26,		/* type */
+	 2,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 26,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 			/* This needs complex overflow
+				   detection, because the upper four
+				   bits must match the PC + 4.  */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_26",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0x03ffffff,		/* src_mask */
+	 0x03ffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* R_BROWNIE32_HI16 and R_BROWNIE32_LO16 are unsupported for NewABI REL.
+     However, the native IRIX6 tools use them, so we try our best. */
+
+  /* High 16 bits of symbol value.  */
+  HOWTO (R_BROWNIE32_HI16,		/* type */
+	 16,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_hi16_reloc, /* special_function */
+	 "R_BROWNIE32_HI16",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Low 16 bits of symbol value.  */
+  HOWTO (R_BROWNIE32_LO16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_lo16_reloc, /* special_function */
+	 "R_BROWNIE32_LO16",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* GP relative reference.  */
+  HOWTO (R_BROWNIE32_GPREL16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 brownie32_elf_gprel16_reloc, /* special_function */
+	 "R_BROWNIE32_GPREL16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Reference to literal section.  */
+  HOWTO (R_BROWNIE32_LITERAL,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 brownie32_elf_literal_reloc, /* special_function */
+	 "R_BROWNIE32_LITERAL",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Reference to global offset table.  */
+  HOWTO (R_BROWNIE32_GOT16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_got16_reloc, /* special_function */
+	 "R_BROWNIE32_GOT16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 16 bit PC relative reference.  */
+  HOWTO (R_BROWNIE32_PC16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_PC16",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* 16 bit call through global offset table.  */
+  HOWTO (R_BROWNIE32_CALL16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_CALL16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32 bit GP relative reference.  */
+  HOWTO (R_BROWNIE32_GPREL32,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 brownie32_elf_gprel32_reloc, /* special_function */
+	 "R_BROWNIE32_GPREL32",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* The remaining relocs are defined on Irix 5, although they are
+     not defined by the ABI.  */
+  EMPTY_HOWTO (13),
+  EMPTY_HOWTO (14),
+  EMPTY_HOWTO (15),
+
+  /* A 5 bit shift field.  */
+  HOWTO (R_BROWNIE32_SHIFT5,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 5,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 6,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_SHIFT5",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x000007c0,		/* src_mask */
+	 0x000007c0,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 6 bit shift field.  */
+  HOWTO (R_BROWNIE32_SHIFT6,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 6,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 6,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 brownie32_elf_shift6_reloc,	/* special_function */
+	 "R_BROWNIE32_SHIFT6",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x000007c4,		/* src_mask */
+	 0x000007c4,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 64 bit relocation.  */
+  HOWTO (R_BROWNIE32_64,		/* type */
+	 0,			/* rightshift */
+	 4,			/* size (0 = byte, 1 = short, 2 = long) */
+	 64,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_64",		/* name */
+	 TRUE,			/* partial_inplace */
+	 MINUS_ONE,		/* src_mask */
+	 MINUS_ONE,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Displacement in the global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_DISP,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_GOT_DISP",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Displacement to page pointer in the global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_PAGE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_GOT_PAGE",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Offset from page pointer in the global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_OFST,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_GOT_OFST",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* High 16 bits of displacement in global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_HI16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_GOT_HI16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Low 16 bits of displacement in global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_GOT_LO16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 64 bit subtraction.  */
+  HOWTO (R_BROWNIE32_SUB,		/* type */
+	 0,			/* rightshift */
+	 4,			/* size (0 = byte, 1 = short, 2 = long) */
+	 64,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_SUB",		/* name */
+	 TRUE,			/* partial_inplace */
+	 MINUS_ONE,		/* src_mask */
+	 MINUS_ONE,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Insert the addend as an instruction.  */
+  /* FIXME: Not handled correctly.  */
+  HOWTO (R_BROWNIE32_INSERT_A,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_INSERT_A",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Insert the addend as an instruction, and change all relocations
+     to refer to the old instruction at the address.  */
+  /* FIXME: Not handled correctly.  */
+  HOWTO (R_BROWNIE32_INSERT_B,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_INSERT_B",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Delete a 32 bit instruction.  */
+  /* FIXME: Not handled correctly.  */
+  HOWTO (R_BROWNIE32_DELETE,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_DELETE",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* The BROWNIE32 ELF64 ABI Draft wants us to support these for REL relocations.
+     We don't, because
+       a) It means building the addend from a R_BROWNIE32_HIGHEST/R_BROWNIE32_HIGHER/
+	  R_BROWNIE32_HI16/R_BROWNIE32_LO16 sequence with varying ordering, using
+	  fallable heuristics.
+       b) No other NewABI toolchain actually emits such relocations.  */
+  EMPTY_HOWTO (R_BROWNIE32_HIGHER),
+  EMPTY_HOWTO (R_BROWNIE32_HIGHEST),
+
+  /* High 16 bits of displacement in global offset table.  */
+  HOWTO (R_BROWNIE32_CALL_HI16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_CALL_HI16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Low 16 bits of displacement in global offset table.  */
+  HOWTO (R_BROWNIE32_CALL_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_CALL_LO16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Section displacement.  */
+  HOWTO (R_BROWNIE32_SCN_DISP,       /* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_SCN_DISP",     /* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_BROWNIE32_REL16,		/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_REL16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffff,		/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* These two are obsolete.  */
+  EMPTY_HOWTO (R_BROWNIE32_ADD_IMMEDIATE),
+  EMPTY_HOWTO (R_BROWNIE32_PJUMP),
+
+  /* Similiar to R_BROWNIE32_REL32, but used for relocations in a GOT section.
+     It must be used for multigot GOT's (and only there).  */
+  HOWTO (R_BROWNIE32_RELGOT,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_RELGOT",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Protected jump conversion.  This is an optimization hint.  No
+     relocation is required for correctness.  */
+  HOWTO (R_BROWNIE32_JALR,	        /* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_JALR",	        /* name */
+	 FALSE,			/* partial_inplace */
+	 0x00000000,		/* src_mask */
+	 0x00000000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS GD/LD dynamic relocations.  */
+  HOWTO (R_BROWNIE32_TLS_DTPMOD32,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_DTPMOD32",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_BROWNIE32_TLS_DTPREL32,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_DTPREL32",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  EMPTY_HOWTO (R_BROWNIE32_TLS_DTPMOD64),
+  EMPTY_HOWTO (R_BROWNIE32_TLS_DTPREL64),
+
+  /* TLS general dynamic variable reference.  */
+  HOWTO (R_BROWNIE32_TLS_GD,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_GD",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS local dynamic variable reference.  */
+  HOWTO (R_BROWNIE32_TLS_LDM,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_LDM",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS local dynamic offset.  */
+  HOWTO (R_BROWNIE32_TLS_DTPREL_HI16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_DTPREL_HI16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS local dynamic offset.  */
+  HOWTO (R_BROWNIE32_TLS_DTPREL_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_DTPREL_LO16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS thread pointer offset.  */
+  HOWTO (R_BROWNIE32_TLS_GOTTPREL,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_GOTTPREL",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS IE dynamic relocations.  */
+  HOWTO (R_BROWNIE32_TLS_TPREL32,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_TPREL32",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  EMPTY_HOWTO (R_BROWNIE32_TLS_TPREL64),
+
+  /* TLS thread pointer offset.  */
+  HOWTO (R_BROWNIE32_TLS_TPREL_HI16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_TPREL_HI16", /* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS thread pointer offset.  */
+  HOWTO (R_BROWNIE32_TLS_TPREL_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_TPREL_LO16", /* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+};
+
+/* The relocation table used for SHT_RELA sections.  */
+
+static reloc_howto_type elf_brownie32_howto_table_rela[] =
+{
+  /* No relocation.  */
+  HOWTO (R_BROWNIE32_NONE,		/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_NONE",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 16 bit relocation.  */
+  HOWTO (R_BROWNIE32_16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_16",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32 bit relocation.  */
+  HOWTO (R_BROWNIE32_32,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_32",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32 bit symbol relative relocation.  */
+  HOWTO (R_BROWNIE32_REL32,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_REL32",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 26 bit jump address.  */
+  HOWTO (R_BROWNIE32_26,		/* type */
+	 2,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 26,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+				/* This needs complex overflow
+				   detection, because the upper 36
+				   bits must match the PC + 4.  */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_26",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x03ffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* High 16 bits of symbol value.  */
+  HOWTO (R_BROWNIE32_HI16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_HI16",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Low 16 bits of symbol value.  */
+  HOWTO (R_BROWNIE32_LO16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_LO16",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* GP relative reference.  */
+  HOWTO (R_BROWNIE32_GPREL16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 brownie32_elf_gprel16_reloc, /* special_function */
+	 "R_BROWNIE32_GPREL16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Reference to literal section.  */
+  HOWTO (R_BROWNIE32_LITERAL,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 brownie32_elf_literal_reloc, /* special_function */
+	 "R_BROWNIE32_LITERAL",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Reference to global offset table.  */
+  HOWTO (R_BROWNIE32_GOT16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_GOT16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 16 bit PC relative reference.  */
+  HOWTO (R_BROWNIE32_PC16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_PC16",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* 16 bit call through global offset table.  */
+  HOWTO (R_BROWNIE32_CALL16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_CALL16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32 bit GP relative reference.  */
+  HOWTO (R_BROWNIE32_GPREL32,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 brownie32_elf_gprel32_reloc, /* special_function */
+	 "R_BROWNIE32_GPREL32",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  EMPTY_HOWTO (13),
+  EMPTY_HOWTO (14),
+  EMPTY_HOWTO (15),
+
+  /* A 5 bit shift field.  */
+  HOWTO (R_BROWNIE32_SHIFT5,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 5,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 6,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_SHIFT5",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x000007c0,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 6 bit shift field.  */
+  HOWTO (R_BROWNIE32_SHIFT6,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 6,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 6,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 brownie32_elf_shift6_reloc,	/* special_function */
+	 "R_BROWNIE32_SHIFT6",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x000007c4,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 64 bit relocation.  */
+  HOWTO (R_BROWNIE32_64,		/* type */
+	 0,			/* rightshift */
+	 4,			/* size (0 = byte, 1 = short, 2 = long) */
+	 64,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_64",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 MINUS_ONE,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Displacement in the global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_DISP,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_GOT_DISP",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Displacement to page pointer in the global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_PAGE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_GOT_PAGE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Offset from page pointer in the global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_OFST,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_GOT_OFST",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* High 16 bits of displacement in global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_HI16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_GOT_HI16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Low 16 bits of displacement in global offset table.  */
+  HOWTO (R_BROWNIE32_GOT_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_GOT_LO16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 64 bit subtraction.  */
+  HOWTO (R_BROWNIE32_SUB,		/* type */
+	 0,			/* rightshift */
+	 4,			/* size (0 = byte, 1 = short, 2 = long) */
+	 64,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_SUB",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 MINUS_ONE,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Insert the addend as an instruction.  */
+  /* FIXME: Not handled correctly.  */
+  HOWTO (R_BROWNIE32_INSERT_A,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_INSERT_A",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Insert the addend as an instruction, and change all relocations
+     to refer to the old instruction at the address.  */
+  /* FIXME: Not handled correctly.  */
+  HOWTO (R_BROWNIE32_INSERT_B,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_INSERT_B",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Delete a 32 bit instruction.  */
+  /* FIXME: Not handled correctly.  */
+  HOWTO (R_BROWNIE32_DELETE,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_DELETE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Get the higher value of a 64 bit addend.  */
+  HOWTO (R_BROWNIE32_HIGHER,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_HIGHER",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Get the highest value of a 64 bit addend.  */
+  HOWTO (R_BROWNIE32_HIGHEST,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_HIGHEST",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* High 16 bits of displacement in global offset table.  */
+  HOWTO (R_BROWNIE32_CALL_HI16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_CALL_HI16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Low 16 bits of displacement in global offset table.  */
+  HOWTO (R_BROWNIE32_CALL_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_CALL_LO16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Section displacement, used by an associated event location section.  */
+  HOWTO (R_BROWNIE32_SCN_DISP,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_SCN_DISP",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 16 bit relocation.  */
+  HOWTO (R_BROWNIE32_REL16,		/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_REL16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* These two are obsolete.  */
+  EMPTY_HOWTO (R_BROWNIE32_ADD_IMMEDIATE),
+  EMPTY_HOWTO (R_BROWNIE32_PJUMP),
+
+  /* Similiar to R_BROWNIE32_REL32, but used for relocations in a GOT section.
+     It must be used for multigot GOT's (and only there).  */
+  HOWTO (R_BROWNIE32_RELGOT,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_RELGOT",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Protected jump conversion.  This is an optimization hint.  No
+     relocation is required for correctness.  */
+  HOWTO (R_BROWNIE32_JALR,	        /* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_JALR",	        /* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS GD/LD dynamic relocations.  */
+  HOWTO (R_BROWNIE32_TLS_DTPMOD32,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_DTPMOD32",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_BROWNIE32_TLS_DTPREL32,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_DTPREL32",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  EMPTY_HOWTO (R_BROWNIE32_TLS_DTPMOD64),
+  EMPTY_HOWTO (R_BROWNIE32_TLS_DTPREL64),
+
+  /* TLS general dynamic variable reference.  */
+  HOWTO (R_BROWNIE32_TLS_GD,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_GD",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS local dynamic variable reference.  */
+  HOWTO (R_BROWNIE32_TLS_LDM,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_LDM",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS local dynamic offset.  */
+  HOWTO (R_BROWNIE32_TLS_DTPREL_HI16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_DTPREL_HI16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS local dynamic offset.  */
+  HOWTO (R_BROWNIE32_TLS_DTPREL_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_DTPREL_LO16",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS thread pointer offset.  */
+  HOWTO (R_BROWNIE32_TLS_GOTTPREL,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_GOTTPREL",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS IE dynamic relocations.  */
+  HOWTO (R_BROWNIE32_TLS_TPREL32,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_TPREL32",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  EMPTY_HOWTO (R_BROWNIE32_TLS_TPREL64),
+
+  /* TLS thread pointer offset.  */
+  HOWTO (R_BROWNIE32_TLS_TPREL_HI16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_TPREL_HI16", /* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* TLS thread pointer offset.  */
+  HOWTO (R_BROWNIE32_TLS_TPREL_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_TLS_TPREL_LO16", /* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+};
+
+/* GNU extension to record C++ vtable hierarchy */
+static reloc_howto_type elf_brownie32_gnu_vtinherit_howto =
+  HOWTO (R_BROWNIE32_GNU_VTINHERIT,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 NULL,			/* special_function */
+	 "R_BROWNIE32_GNU_VTINHERIT", /* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE);		/* pcrel_offset */
+
+/* GNU extension to record C++ vtable member usage */
+static reloc_howto_type elf_brownie32_gnu_vtentry_howto =
+  HOWTO (R_BROWNIE32_GNU_VTENTRY,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_elf_rel_vtable_reloc_fn, /* special_function */
+	 "R_BROWNIE32_GNU_VTENTRY",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE);		/* pcrel_offset */
+
+/* 16 bit offset for pc-relative branches.  */
+static reloc_howto_type elf_brownie32_gnu_rel16_s2 =
+  HOWTO (R_BROWNIE32_GNU_REL16_S2,	/* type */
+	 2,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_GNU_REL16_S2",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 TRUE);			/* pcrel_offset */
+
+/* 16 bit offset for pc-relative branches.  */
+static reloc_howto_type elf_brownie32_gnu_rela16_s2 =
+  HOWTO (R_BROWNIE32_GNU_REL16_S2,	/* type */
+	 2,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 _bfd_brownie32_elf_generic_reloc, /* special_function */
+	 "R_BROWNIE32_GNU_REL16_S2",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 TRUE);			/* pcrel_offset */
+
+/* Set the GP value for OUTPUT_BFD.  Returns FALSE if this is a
+   dangerous relocation.  */
+
+static bfd_boolean
+brownie32_elf_assign_gp (bfd *output_bfd, bfd_vma *pgp)
+{
+  unsigned int count;
+  asymbol **sym;
+  unsigned int i;
+
+  /* If we've already figured out what GP will be, just return it.  */
+  *pgp = _bfd_get_gp_value (output_bfd);
+  if (*pgp)
+    return TRUE;
+
+  count = bfd_get_symcount (output_bfd);
+  sym = bfd_get_outsymbols (output_bfd);
+
+  /* The linker script will have created a symbol named `_gp' with the
+     appropriate value.  */
+  if (sym == NULL)
+    i = count;
+  else
+    {
+      for (i = 0; i < count; i++, sym++)
+	{
+	  register const char *name;
+
+	  name = bfd_asymbol_name (*sym);
+	  if (*name == '_' && strcmp (name, "_gp") == 0)
+	    {
+	      *pgp = bfd_asymbol_value (*sym);
+	      _bfd_set_gp_value (output_bfd, *pgp);
+	      break;
+	    }
+	}
+    }
+
+  if (i >= count)
+    {
+      /* Only get the error once.  */
+      *pgp = 4;
+      _bfd_set_gp_value (output_bfd, *pgp);
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+/* We have to figure out the gp value, so that we can adjust the
+   symbol value correctly.  We look up the symbol _gp in the output
+   BFD.  If we can't find it, we're stuck.  We cache it in the ELF
+   target data.  We don't need to adjust the symbol value for an
+   external symbol if we are producing relocatable output.  */
+
+static bfd_reloc_status_type
+brownie32_elf_final_gp (bfd *output_bfd, asymbol *symbol, bfd_boolean relocatable,
+		   char **error_message, bfd_vma *pgp)
+{
+  if (bfd_is_und_section (symbol->section)
+      && ! relocatable)
+    {
+      *pgp = 0;
+      return bfd_reloc_undefined;
+    }
+
+  *pgp = _bfd_get_gp_value (output_bfd);
+  if (*pgp == 0
+      && (! relocatable
+	  || (symbol->flags & BSF_SECTION_SYM) != 0))
+    {
+      if (relocatable)
+	{
+	  /* Make up a value.  */
+	  *pgp = symbol->section->output_section->vma /*+ 0x4000*/;
+	  _bfd_set_gp_value (output_bfd, *pgp);
+	}
+      else if (!brownie32_elf_assign_gp (output_bfd, pgp))
+	{
+	  *error_message =
+	    (char *) _("GP relative relocation when _gp not defined");
+	  return bfd_reloc_dangerous;
+	}
+    }
+
+  return bfd_reloc_ok;
+}
+
+/* Do a R_BROWNIE32_GPREL16 relocation.  This is a 16 bit value which must
+   become the offset from the gp register.  */
+
+static bfd_reloc_status_type
+brownie32_elf_gprel16_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
+			asymbol *symbol, void *data ATTRIBUTE_UNUSED,
+			asection *input_section, bfd *output_bfd,
+			char **error_message ATTRIBUTE_UNUSED)
+{
+  bfd_boolean relocatable;
+  bfd_reloc_status_type ret;
+  bfd_vma gp;
+
+  if (output_bfd != NULL)
+    relocatable = TRUE;
+  else
+    {
+      relocatable = FALSE;
+      output_bfd = symbol->section->output_section->owner;
+    }
+
+  ret = brownie32_elf_final_gp (output_bfd, symbol, relocatable, error_message,
+			   &gp);
+  if (ret != bfd_reloc_ok)
+    return ret;
+
+  return _bfd_brownie32_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
+					input_section, relocatable,
+					data, gp);
+}
+
+/* Do a R_BROWNIE32_LITERAL relocation.  */
+
+static bfd_reloc_status_type
+brownie32_elf_literal_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
+			void *data, asection *input_section, bfd *output_bfd,
+			char **error_message)
+{
+  bfd_boolean relocatable;
+  bfd_reloc_status_type ret;
+  bfd_vma gp;
+
+  /* R_BROWNIE32_LITERAL relocations are defined for local symbols only.  */
+  if (output_bfd != NULL
+      && (symbol->flags & BSF_SECTION_SYM) == 0
+      && (symbol->flags & BSF_LOCAL) != 0)
+    {
+      *error_message = (char *)
+	_("literal relocation occurs for an external symbol");
+      return bfd_reloc_outofrange;
+    }
+
+  /* FIXME: The entries in the .lit8 and .lit4 sections should be merged.  */
+  if (output_bfd != NULL)
+    relocatable = TRUE;
+  else
+    {
+      relocatable = FALSE;
+      output_bfd = symbol->section->output_section->owner;
+    }
+
+  ret = brownie32_elf_final_gp (output_bfd, symbol, relocatable, error_message,
+			   &gp);
+  if (ret != bfd_reloc_ok)
+    return ret;
+
+  return _bfd_brownie32_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
+					input_section, relocatable,
+					data, gp);
+}
+
+/* Do a R_BROWNIE32_GPREL32 relocation.  This is a 32 bit value which must
+   become the offset from the gp register.  */
+
+static bfd_reloc_status_type
+brownie32_elf_gprel32_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
+			void *data, asection *input_section, bfd *output_bfd,
+			char **error_message)
+{
+  bfd_boolean relocatable;
+  bfd_reloc_status_type ret;
+  bfd_vma gp;
+
+  /* R_BROWNIE32_GPREL32 relocations are defined for local symbols only.  */
+  if (output_bfd != NULL
+      && (symbol->flags & BSF_SECTION_SYM) == 0
+      && (symbol->flags & BSF_LOCAL) != 0)
+    {
+      *error_message = (char *)
+	_("32bits gp relative relocation occurs for an external symbol");
+      return bfd_reloc_outofrange;
+    }
+
+  if (output_bfd != NULL)
+    {
+      relocatable = TRUE;
+      gp = _bfd_get_gp_value (output_bfd);
+    }
+  else
+    {
+      relocatable = FALSE;
+      output_bfd = symbol->section->output_section->owner;
+
+      ret = brownie32_elf_final_gp (output_bfd, symbol, relocatable,
+			       error_message, &gp);
+      if (ret != bfd_reloc_ok)
+	return ret;
+    }
+
+  return gprel32_with_gp (abfd, symbol, reloc_entry, input_section,
+			  relocatable, data, gp);
+}
+
+static bfd_reloc_status_type
+gprel32_with_gp (bfd *abfd, asymbol *symbol, arelent *reloc_entry,
+		 asection *input_section, bfd_boolean relocatable,
+		 void *data, bfd_vma gp)
+{
+  bfd_vma relocation;
+  unsigned long val;
+
+  if (bfd_is_com_section (symbol->section))
+    relocation = 0;
+  else
+    relocation = symbol->value;
+
+  relocation += symbol->section->output_section->vma;
+  relocation += symbol->section->output_offset;
+
+  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
+    return bfd_reloc_outofrange;
+
+  if (reloc_entry->howto->src_mask == 0)
+    val = 0;
+  else
+    val = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
+
+  /* Set val to the offset into the section or symbol.  */
+  val += reloc_entry->addend;
+
+  /* Adjust val for the final section location and GP value.  If we
+     are producing relocatable output, we don't want to do this for
+     an external symbol.  */
+  if (! relocatable
+      || (symbol->flags & BSF_SECTION_SYM) != 0)
+    val += relocation - gp;
+
+  bfd_put_32 (abfd, val, (bfd_byte *) data + reloc_entry->address);
+
+  if (relocatable)
+    reloc_entry->address += input_section->output_offset;
+
+  return bfd_reloc_ok;
+}
+
+/* Do a R_BROWNIE32_SHIFT6 relocation. The MSB of the shift is stored at bit 2,
+   the rest is at bits 6-10. The bitpos already got right by the howto.  */
+
+static bfd_reloc_status_type
+brownie32_elf_shift6_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
+		       void *data, asection *input_section, bfd *output_bfd,
+		       char **error_message)
+{
+  if (reloc_entry->howto->partial_inplace)
+    {
+      reloc_entry->addend = ((reloc_entry->addend & 0x00007c0)
+			     | (reloc_entry->addend & 0x00000800) >> 9);
+    }
+
+  return _bfd_brownie32_elf_generic_reloc (abfd, reloc_entry, symbol, data,
+				      input_section, output_bfd,
+				      error_message);
+}
+
+
+/* A mapping from BFD reloc types to BROWNIE32 ELF reloc types.  */
+
+struct elf_reloc_map {
+  bfd_reloc_code_real_type bfd_val;
+  enum elf_brownie32_reloc_type elf_val;
+};
+
+static const struct elf_reloc_map brownie32_reloc_map[] =
+{
+  { BFD_RELOC_NONE, R_BROWNIE32_NONE },
+  { BFD_RELOC_16, R_BROWNIE32_16 },
+  { BFD_RELOC_32, R_BROWNIE32_32 },
+  /* There is no BFD reloc for R_BROWNIE32_REL32.  */
+  { BFD_RELOC_CTOR, R_BROWNIE32_32 },
+  { BFD_RELOC_64, R_BROWNIE32_64 },
+  { BFD_RELOC_16_PCREL, R_BROWNIE32_PC16 },
+  { BFD_RELOC_HI16_S, R_BROWNIE32_HI16 },
+  { BFD_RELOC_LO16, R_BROWNIE32_LO16 },
+  { BFD_RELOC_GPREL16, R_BROWNIE32_GPREL16 },
+  { BFD_RELOC_GPREL32, R_BROWNIE32_GPREL32 },
+  { BFD_RELOC_BROWNIE32_JMP, R_BROWNIE32_26 },
+  { BFD_RELOC_BROWNIE32_LITERAL, R_BROWNIE32_LITERAL },
+  { BFD_RELOC_BROWNIE32_GOT16, R_BROWNIE32_GOT16 },
+  { BFD_RELOC_BROWNIE32_CALL16, R_BROWNIE32_CALL16 },
+  { BFD_RELOC_BROWNIE32_SHIFT5, R_BROWNIE32_SHIFT5 },
+  { BFD_RELOC_BROWNIE32_SHIFT6, R_BROWNIE32_SHIFT6 },
+  { BFD_RELOC_BROWNIE32_GOT_DISP, R_BROWNIE32_GOT_DISP },
+  { BFD_RELOC_BROWNIE32_GOT_PAGE, R_BROWNIE32_GOT_PAGE },
+  { BFD_RELOC_BROWNIE32_GOT_OFST, R_BROWNIE32_GOT_OFST },
+  { BFD_RELOC_BROWNIE32_GOT_HI16, R_BROWNIE32_GOT_HI16 },
+  { BFD_RELOC_BROWNIE32_GOT_LO16, R_BROWNIE32_GOT_LO16 },
+  { BFD_RELOC_BROWNIE32_SUB, R_BROWNIE32_SUB },
+  { BFD_RELOC_BROWNIE32_INSERT_A, R_BROWNIE32_INSERT_A },
+  { BFD_RELOC_BROWNIE32_INSERT_B, R_BROWNIE32_INSERT_B },
+  { BFD_RELOC_BROWNIE32_DELETE, R_BROWNIE32_DELETE },
+  { BFD_RELOC_BROWNIE32_HIGHEST, R_BROWNIE32_HIGHEST },
+  { BFD_RELOC_BROWNIE32_HIGHER, R_BROWNIE32_HIGHER },
+  { BFD_RELOC_BROWNIE32_CALL_HI16, R_BROWNIE32_CALL_HI16 },
+  { BFD_RELOC_BROWNIE32_CALL_LO16, R_BROWNIE32_CALL_LO16 },
+  { BFD_RELOC_BROWNIE32_SCN_DISP, R_BROWNIE32_SCN_DISP },
+  { BFD_RELOC_BROWNIE32_REL16, R_BROWNIE32_REL16 },
+  /* Use of R_BROWNIE32_ADD_IMMEDIATE and R_BROWNIE32_PJUMP is deprecated.  */
+  { BFD_RELOC_BROWNIE32_RELGOT, R_BROWNIE32_RELGOT },
+  { BFD_RELOC_BROWNIE32_JALR, R_BROWNIE32_JALR },
+  { BFD_RELOC_BROWNIE32_TLS_DTPMOD32, R_BROWNIE32_TLS_DTPMOD32 },
+  { BFD_RELOC_BROWNIE32_TLS_DTPREL32, R_BROWNIE32_TLS_DTPREL32 },
+  { BFD_RELOC_BROWNIE32_TLS_DTPMOD64, R_BROWNIE32_TLS_DTPMOD64 },
+  { BFD_RELOC_BROWNIE32_TLS_DTPREL64, R_BROWNIE32_TLS_DTPREL64 },
+  { BFD_RELOC_BROWNIE32_TLS_GD, R_BROWNIE32_TLS_GD },
+  { BFD_RELOC_BROWNIE32_TLS_LDM, R_BROWNIE32_TLS_LDM },
+  { BFD_RELOC_BROWNIE32_TLS_DTPREL_HI16, R_BROWNIE32_TLS_DTPREL_HI16 },
+  { BFD_RELOC_BROWNIE32_TLS_DTPREL_LO16, R_BROWNIE32_TLS_DTPREL_LO16 },
+  { BFD_RELOC_BROWNIE32_TLS_GOTTPREL, R_BROWNIE32_TLS_GOTTPREL },
+  { BFD_RELOC_BROWNIE32_TLS_TPREL32, R_BROWNIE32_TLS_TPREL32 },
+  { BFD_RELOC_BROWNIE32_TLS_TPREL64, R_BROWNIE32_TLS_TPREL64 },
+  { BFD_RELOC_BROWNIE32_TLS_TPREL_HI16, R_BROWNIE32_TLS_TPREL_HI16 },
+  { BFD_RELOC_BROWNIE32_TLS_TPREL_LO16, R_BROWNIE32_TLS_TPREL_LO16 }
+};
+
+
+/* Given a BFD reloc type, return a howto structure.  */
+
+static reloc_howto_type *
+bfd_elf32_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+				 bfd_reloc_code_real_type code)
+{
+  unsigned int i;
+  /* FIXME: We default to RELA here instead of choosing the right
+     relocation variant.  */
+  reloc_howto_type *howto_table = elf_brownie32_howto_table_rela;
+
+  for (i = 0; i < sizeof (brownie32_reloc_map) / sizeof (struct elf_reloc_map);
+       i++)
+    {
+      if (brownie32_reloc_map[i].bfd_val == code)
+	return &howto_table[(int) brownie32_reloc_map[i].elf_val];
+    }
+
+  switch (code)
+    {
+    case BFD_RELOC_VTABLE_INHERIT:
+      return &elf_brownie32_gnu_vtinherit_howto;
+    case BFD_RELOC_VTABLE_ENTRY:
+      return &elf_brownie32_gnu_vtentry_howto;
+    case BFD_RELOC_16_PCREL_S2:
+      return &elf_brownie32_gnu_rela16_s2;
+    default:
+      bfd_set_error (bfd_error_bad_value);
+      return NULL;
+    }
+}
+
+/* Given a BROWNIE32 Elf_Internal_Rel, fill in an arelent structure.  */
+
+static reloc_howto_type *
+brownie32_elf_n32_rtype_to_howto (unsigned int r_type, bfd_boolean rela_p)
+{
+  switch (r_type)
+    {
+    case R_BROWNIE32_GNU_VTINHERIT:
+      return &elf_brownie32_gnu_vtinherit_howto;
+    case R_BROWNIE32_GNU_VTENTRY:
+      return &elf_brownie32_gnu_vtentry_howto;
+    case R_BROWNIE32_GNU_REL16_S2:
+      if (rela_p)
+	return &elf_brownie32_gnu_rela16_s2;
+      else
+	return &elf_brownie32_gnu_rel16_s2;
+    default:
+      BFD_ASSERT (r_type < (unsigned int) R_BROWNIE32_max);
+      if (rela_p)
+	return &elf_brownie32_howto_table_rela[r_type];
+      else
+	return &elf_brownie32_howto_table_rel[r_type];
+      break;
+    }
+}
+
+/* Given a BROWNIE32 Elf_Internal_Rel, fill in an arelent structure.  */
+
+static void
+brownie32_info_to_howto_rel (bfd *abfd, arelent *cache_ptr, Elf_Internal_Rela *dst)
+{
+  unsigned int r_type;
+
+  r_type = ELF32_R_TYPE (dst->r_info);
+  cache_ptr->howto = brownie32_elf_n32_rtype_to_howto (r_type, FALSE);
+
+  /* The addend for a GPREL16 or LITERAL relocation comes from the GP
+     value for the object file.  We get the addend now, rather than
+     when we do the relocation, because the symbol manipulations done
+     by the linker may cause us to lose track of the input BFD.  */
+  if (((*cache_ptr->sym_ptr_ptr)->flags & BSF_SECTION_SYM) != 0
+      && (r_type == (unsigned int) R_BROWNIE32_GPREL16
+	  || r_type == (unsigned int) R_BROWNIE32_LITERAL))
+    cache_ptr->addend = elf_gp (abfd);
+}
+
+/* Given a BROWNIE32 Elf_Internal_Rela, fill in an arelent structure.  */
+
+static void
+brownie32_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
+			 arelent *cache_ptr, Elf_Internal_Rela *dst)
+{
+  unsigned int r_type;
+
+  r_type = ELF32_R_TYPE (dst->r_info);
+  cache_ptr->howto = brownie32_elf_n32_rtype_to_howto (r_type, TRUE);
+  cache_ptr->addend = dst->r_addend;
+}
+
+/* Determine whether a symbol is global for the purposes of splitting
+   the symbol table into global symbols and local symbols.  At least
+   on Irix 5, this split must be between section symbols and all other
+   symbols.  On most ELF targets the split is between static symbols
+   and externally visible symbols.  */
+
+static bfd_boolean
+brownie32_elf_sym_is_global (bfd *abfd ATTRIBUTE_UNUSED, asymbol *sym)
+{
+  if (SGI_COMPAT (abfd))
+    return (sym->flags & BSF_SECTION_SYM) == 0;
+  else
+    return ((sym->flags & (BSF_GLOBAL | BSF_WEAK)) != 0
+	    || bfd_is_und_section (bfd_get_section (sym))
+	    || bfd_is_com_section (bfd_get_section (sym)));
+}
+
+/* Set the right machine number for a BROWNIE32 ELF file.  */
+
+static bfd_boolean
+brownie32_elf_n32_object_p (bfd *abfd)
+{
+  unsigned long mach;
+
+  /* Irix 5 and 6 are broken.  Object file symbol tables are not always
+     sorted correctly such that local symbols precede global symbols,
+     and the sh_info field in the symbol table is not always right.  */
+  if (SGI_COMPAT (abfd))
+    elf_bad_symtab (abfd) = TRUE;
+
+  mach = _bfd_elf_brownie32_mach (elf_elfheader (abfd)->e_flags);
+  bfd_default_set_arch_mach (abfd, bfd_arch_brownie32, mach);
+
+  if (! ABI_N32_P(abfd))
+    return FALSE;
+
+  return TRUE;
+}
+
+/* Support for core dump NOTE sections.  */
+static bfd_boolean
+elf32_brownie32_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
+{
+  int offset;
+  unsigned int size;
+
+  switch (note->descsz)
+    {
+      default:
+	return FALSE;
+
+      case 440:		/* Linux/BROWNIE32 N32 */
+	/* pr_cursig */
+	elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);
+
+	/* pr_pid */
+	elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);
+
+	/* pr_reg */
+	offset = 72;
+	size = 360;
+
+	break;
+    }
+
+  /* Make a ".reg/999" section.  */
+  return _bfd_elfcore_make_pseudosection (abfd, ".reg", size,
+					  note->descpos + offset);
+}
+
+static bfd_boolean
+elf32_brownie32_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
+{
+  switch (note->descsz)
+    {
+      default:
+	return FALSE;
+
+      case 128:		/* Linux/BROWNIE32 elf_prpsinfo */
+	elf_tdata (abfd)->core_program
+	 = _bfd_elfcore_strndup (abfd, note->descdata + 32, 16);
+	elf_tdata (abfd)->core_command
+	 = _bfd_elfcore_strndup (abfd, note->descdata + 48, 80);
+    }
+
+  /* Note that for some reason, a spurious space is tacked
+     onto the end of the args in some (at least one anyway)
+     implementations, so strip it off if it exists.  */
+
+  {
+    char *command = elf_tdata (abfd)->core_command;
+    int n = strlen (command);
+
+    if (0 < n && command[n - 1] == ' ')
+      command[n - 1] = '\0';
+  }
+
+  return TRUE;
+}
+
+/* Depending on the target vector we generate some version of Irix
+   executables or "normal" BROWNIE32 ELF ABI executables.  */
+static irix_compat_t
+elf_n32_brownie32_irix_compat (bfd *abfd)
+{
+  if ((abfd->xvec == &bfd_elf32_nbigbrownie32_vec)
+      || (abfd->xvec == &bfd_elf32_nlittlebrownie32_vec))
+    return ict_irix6;
+  else
+    return ict_none;
+}
+
+/* ECOFF swapping routines.  These are used when dealing with the
+   .mdebug section, which is in the ECOFF debugging format.  */
+static const struct ecoff_debug_swap brownie32_elf32_ecoff_debug_swap = {
+  /* Symbol table magic number.  */
+  magicSym,
+  /* Alignment of debugging information.  E.g., 4.  */
+  4,
+  /* Sizes of external symbolic information.  */
+  sizeof (struct hdr_ext),
+  sizeof (struct dnr_ext),
+  sizeof (struct pdr_ext),
+  sizeof (struct sym_ext),
+  sizeof (struct opt_ext),
+  sizeof (struct fdr_ext),
+  sizeof (struct rfd_ext),
+  sizeof (struct ext_ext),
+  /* Functions to swap in external symbolic data.  */
+  ecoff_swap_hdr_in,
+  ecoff_swap_dnr_in,
+  ecoff_swap_pdr_in,
+  ecoff_swap_sym_in,
+  ecoff_swap_opt_in,
+  ecoff_swap_fdr_in,
+  ecoff_swap_rfd_in,
+  ecoff_swap_ext_in,
+  _bfd_ecoff_swap_tir_in,
+  _bfd_ecoff_swap_rndx_in,
+  /* Functions to swap out external symbolic data.  */
+  ecoff_swap_hdr_out,
+  ecoff_swap_dnr_out,
+  ecoff_swap_pdr_out,
+  ecoff_swap_sym_out,
+  ecoff_swap_opt_out,
+  ecoff_swap_fdr_out,
+  ecoff_swap_rfd_out,
+  ecoff_swap_ext_out,
+  _bfd_ecoff_swap_tir_out,
+  _bfd_ecoff_swap_rndx_out,
+  /* Function to read in symbolic data.  */
+  _bfd_brownie32_elf_read_ecoff_info
+};
+
+#define ELF_ARCH			bfd_arch_brownie32
+#define ELF_MACHINE_CODE		EM_BROWNIE32
+
+#define elf_backend_collect		TRUE
+#define elf_backend_type_change_ok	TRUE
+#define elf_backend_can_gc_sections	TRUE
+#define elf_info_to_howto		brownie32_info_to_howto_rela
+#define elf_info_to_howto_rel		brownie32_info_to_howto_rel
+#define elf_backend_sym_is_global	brownie32_elf_sym_is_global
+#define elf_backend_object_p		brownie32_elf_n32_object_p
+#define elf_backend_symbol_processing	_bfd_brownie32_elf_symbol_processing
+#define elf_backend_section_processing	_bfd_brownie32_elf_section_processing
+#define elf_backend_section_from_shdr	_bfd_brownie32_elf_section_from_shdr
+#define elf_backend_fake_sections	_bfd_brownie32_elf_fake_sections
+#define elf_backend_section_from_bfd_section \
+					_bfd_brownie32_elf_section_from_bfd_section
+#define elf_backend_add_symbol_hook	_bfd_brownie32_elf_add_symbol_hook
+#define elf_backend_link_output_symbol_hook \
+					_bfd_brownie32_elf_link_output_symbol_hook
+#define elf_backend_create_dynamic_sections \
+					_bfd_brownie32_elf_create_dynamic_sections
+#define elf_backend_check_relocs	_bfd_brownie32_elf_check_relocs
+#define elf_backend_adjust_dynamic_symbol \
+					_bfd_brownie32_elf_adjust_dynamic_symbol
+#define elf_backend_always_size_sections \
+					_bfd_brownie32_elf_always_size_sections
+#define elf_backend_size_dynamic_sections \
+					_bfd_brownie32_elf_size_dynamic_sections
+#define elf_backend_relocate_section	_bfd_brownie32_elf_relocate_section
+#define elf_backend_finish_dynamic_symbol \
+					_bfd_brownie32_elf_finish_dynamic_symbol
+#define elf_backend_finish_dynamic_sections \
+					_bfd_brownie32_elf_finish_dynamic_sections
+#define elf_backend_final_write_processing \
+					_bfd_brownie32_elf_final_write_processing
+#define elf_backend_additional_program_headers \
+					_bfd_brownie32_elf_additional_program_headers
+#define elf_backend_modify_segment_map	_bfd_brownie32_elf_modify_segment_map
+#define elf_backend_gc_mark_hook	_bfd_brownie32_elf_gc_mark_hook
+#define elf_backend_gc_sweep_hook	_bfd_brownie32_elf_gc_sweep_hook
+#define elf_backend_copy_indirect_symbol \
+					_bfd_brownie32_elf_copy_indirect_symbol
+#define elf_backend_hide_symbol		_bfd_brownie32_elf_hide_symbol
+#define elf_backend_grok_prstatus	elf32_brownie32_grok_prstatus
+#define elf_backend_grok_psinfo		elf32_brownie32_grok_psinfo
+#define elf_backend_ecoff_debug_swap	&brownie32_elf32_ecoff_debug_swap
+
+#define elf_backend_got_header_size	(4 * BROWNIE32_RESERVED_GOTNO)
+
+/* BROWNIE32 n32 ELF can use a mixture of REL and RELA, but some Relocations
+   work better/work only in RELA, so we default to this.  */
+#define elf_backend_may_use_rel_p	1
+#define elf_backend_may_use_rela_p	1
+#define elf_backend_default_use_rela_p	1
+#define elf_backend_sign_extend_vma	TRUE
+
+#define elf_backend_discard_info	_bfd_brownie32_elf_discard_info
+#define elf_backend_ignore_discarded_relocs \
+					_bfd_brownie32_elf_ignore_discarded_relocs
+#define elf_backend_write_section	_bfd_brownie32_elf_write_section
+#define elf_backend_brownie32_irix_compat	elf_n32_brownie32_irix_compat
+#define elf_backend_brownie32_rtype_to_howto	brownie32_elf_n32_rtype_to_howto
+#define bfd_elf32_find_nearest_line	_bfd_brownie32_elf_find_nearest_line
+#define bfd_elf32_find_inliner_info	_bfd_brownie32_elf_find_inliner_info
+#define bfd_elf32_new_section_hook	_bfd_brownie32_elf_new_section_hook
+#define bfd_elf32_set_section_contents	_bfd_brownie32_elf_set_section_contents
+#define bfd_elf32_bfd_get_relocated_section_contents \
+				_bfd_elf_brownie32_get_relocated_section_contents
+#define bfd_elf32_bfd_link_hash_table_create \
+					_bfd_brownie32_elf_link_hash_table_create
+#define bfd_elf32_bfd_final_link	_bfd_brownie32_elf_final_link
+#define bfd_elf32_bfd_merge_private_bfd_data \
+					_bfd_brownie32_elf_merge_private_bfd_data
+#define bfd_elf32_bfd_set_private_flags	_bfd_brownie32_elf_set_private_flags
+#define bfd_elf32_bfd_print_private_bfd_data \
+					_bfd_brownie32_elf_print_private_bfd_data
+#define bfd_elf32_bfd_relax_section     _bfd_brownie32_relax_section
+
+/* Support for SGI-ish brownie32 targets using n32 ABI.  */
+
+#define TARGET_LITTLE_SYM               bfd_elf32_nlittlebrownie32_vec
+#define TARGET_LITTLE_NAME              "elf32-nlittlebrownie32"
+#define TARGET_BIG_SYM                  bfd_elf32_nbigbrownie32_vec
+#define TARGET_BIG_NAME                 "elf32-nbigbrownie32"
+
+/* The SVR4 BROWNIE32 ABI says that this should be 0x10000, but Irix 5 uses
+   a value of 0x1000, and we are compatible.
+   FIXME: How does this affect NewABI?  */
+#define ELF_MAXPAGESIZE			0x1000
+
+#include "elf32-target.h"
+
+/* Support for traditional brownie32 targets using n32 ABI.  */
+#undef TARGET_LITTLE_SYM
+#undef TARGET_LITTLE_NAME
+#undef TARGET_BIG_SYM
+#undef TARGET_BIG_NAME
+
+#undef ELF_MAXPAGESIZE
+
+#define TARGET_LITTLE_SYM               bfd_elf32_ntradlittlebrownie32_vec
+#define TARGET_LITTLE_NAME              "elf32-ntradlittlebrownie32"
+#define TARGET_BIG_SYM                  bfd_elf32_ntradbigbrownie32_vec
+#define TARGET_BIG_NAME                 "elf32-ntradbigbrownie32"
+
+/* The SVR4 BROWNIE32 ABI says that this should be 0x10000, and Linux uses
+   page sizes of up to that limit, so we need to respect it.  */
+#define ELF_MAXPAGESIZE			0x10000
+#define elf32_bed			elf32_tradbed
+
+/* Include the target file again for this target.  */
+#include "elf32-target.h"
Index: bfd/elfxx-brownie32.c
===================================================================
RCS file: bfd/elfxx-brownie32.c
diff -N bfd/elfxx-brownie32.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ bfd/elfxx-brownie32.c	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,9775 @@
+/* BROWNIE32-specific support for ELF
+   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+   2003, 2004, 2005 Free Software Foundation, Inc.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+   Most of the information added by Ian Lance Taylor, Cygnus Support,
+   <ian@cygnus.com>.
+   N32/64 ABI support added by Mark Mitchell, CodeSourcery, LLC.
+   <mark@codesourcery.com>
+   Traditional BROWNIE32 targets support added by Koundinya.K, Dansk Data
+   Elektronik & Operations Research Group. <kk@ddeorg.soft.net>
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* This file handles functionality common to the different BROWNIE32 ABI's.  */
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "libbfd.h"
+#include "libiberty.h"
+#include "elf-bfd.h"
+#include "elfxx-brownie32.h"
+#include "elf/brownie32.h"
+
+/* Get the ECOFF swapping routines.  */
+#include "coff/sym.h"
+#include "coff/symconst.h"
+#include "coff/ecoff.h"
+#include "coff/brownie32.h"
+
+#include "hashtab.h"
+
+/* This structure is used to hold .got entries while estimating got
+   sizes.  */
+struct brownie32_got_entry
+{
+  /* The input bfd in which the symbol is defined.  */
+  bfd *abfd;
+  /* The index of the symbol, as stored in the relocation r_info, if
+     we have a local symbol; -1 otherwise.  */
+  long symndx;
+  union
+  {
+    /* If abfd == NULL, an address that must be stored in the got.  */
+    bfd_vma address;
+    /* If abfd != NULL && symndx != -1, the addend of the relocation
+       that should be added to the symbol value.  */
+    bfd_vma addend;
+    /* If abfd != NULL && symndx == -1, the hash table entry
+       corresponding to a global symbol in the got (or, local, if
+       h->forced_local).  */
+    struct brownie32_elf_link_hash_entry *h;
+  } d;
+
+  /* The TLS types included in this GOT entry (specifically, GD and
+     IE).  The GD and IE flags can be added as we encounter new
+     relocations.  LDM can also be set; it will always be alone, not
+     combined with any GD or IE flags.  An LDM GOT entry will be
+     a local symbol entry with r_symndx == 0.  */
+  unsigned char tls_type;
+
+  /* The offset from the beginning of the .got section to the entry
+     corresponding to this symbol+addend.  If it's a global symbol
+     whose offset is yet to be decided, it's going to be -1.  */
+  long gotidx;
+};
+
+/* This structure is used to hold .got information when linking.  */
+
+struct brownie32_got_info
+{
+  /* The global symbol in the GOT with the lowest index in the dynamic
+     symbol table.  */
+  struct elf_link_hash_entry *global_gotsym;
+  /* The number of global .got entries.  */
+  unsigned int global_gotno;
+  /* The number of .got slots used for TLS.  */
+  unsigned int tls_gotno;
+  /* The first unused TLS .got entry.  Used only during
+     brownie32_elf_initialize_tls_index.  */
+  unsigned int tls_assigned_gotno;
+  /* The number of local .got entries.  */
+  unsigned int local_gotno;
+  /* The number of local .got entries we have used.  */
+  unsigned int assigned_gotno;
+  /* A hash table holding members of the got.  */
+  struct htab *got_entries;
+  /* A hash table mapping input bfds to other brownie32_got_info.  NULL
+     unless multi-got was necessary.  */
+  struct htab *bfd2got;
+  /* In multi-got links, a pointer to the next got (err, rather, most
+     of the time, it points to the previous got).  */
+  struct brownie32_got_info *next;
+  /* This is the GOT index of the TLS LDM entry for the GOT, MINUS_ONE
+     for none, or MINUS_TWO for not yet assigned.  This is needed
+     because a single-GOT link may have multiple hash table entries
+     for the LDM.  It does not get initialized in multi-GOT mode.  */
+  bfd_vma tls_ldm_offset;
+};
+
+/* Map an input bfd to a got in a multi-got link.  */
+
+struct brownie32_elf_bfd2got_hash {
+  bfd *bfd;
+  struct brownie32_got_info *g;
+};
+
+/* Structure passed when traversing the bfd2got hash table, used to
+   create and merge bfd's gots.  */
+
+struct brownie32_elf_got_per_bfd_arg
+{
+  /* A hashtable that maps bfds to gots.  */
+  htab_t bfd2got;
+  /* The output bfd.  */
+  bfd *obfd;
+  /* The link information.  */
+  struct bfd_link_info *info;
+  /* A pointer to the primary got, i.e., the one that's going to get
+     the implicit relocations from DT_BROWNIE32_LOCAL_GOTNO and
+     DT_BROWNIE32_GOTSYM.  */
+  struct brownie32_got_info *primary;
+  /* A non-primary got we're trying to merge with other input bfd's
+     gots.  */
+  struct brownie32_got_info *current;
+  /* The maximum number of got entries that can be addressed with a
+     16-bit offset.  */
+  unsigned int max_count;
+  /* The number of local and global entries in the primary got.  */
+  unsigned int primary_count;
+  /* The number of local and global entries in the current got.  */
+  unsigned int current_count;
+  /* The total number of global entries which will live in the
+     primary got and be automatically relocated.  This includes
+     those not referenced by the primary GOT but included in
+     the "master" GOT.  */
+  unsigned int global_count;
+};
+
+/* Another structure used to pass arguments for got entries traversal.  */
+
+struct brownie32_elf_set_global_got_offset_arg
+{
+  struct brownie32_got_info *g;
+  int value;
+  unsigned int needed_relocs;
+  struct bfd_link_info *info;
+};
+
+/* A structure used to count TLS relocations or GOT entries, for GOT
+   entry or ELF symbol table traversal.  */
+
+struct brownie32_elf_count_tls_arg
+{
+  struct bfd_link_info *info;
+  unsigned int needed;
+};
+
+struct _brownie32_elf_section_data
+{
+  struct bfd_elf_section_data elf;
+  union
+  {
+    struct brownie32_got_info *got_info;
+    bfd_byte *tdata;
+  } u;
+};
+
+#define brownie32_elf_section_data(sec) \
+  ((struct _brownie32_elf_section_data *) elf_section_data (sec))
+
+/* This structure is passed to brownie32_elf_sort_hash_table_f when sorting
+   the dynamic symbols.  */
+
+struct brownie32_elf_hash_sort_data
+{
+  /* The symbol in the global GOT with the lowest dynamic symbol table
+     index.  */
+  struct elf_link_hash_entry *low;
+  /* The least dynamic symbol table index corresponding to a non-TLS
+     symbol with a GOT entry.  */
+  long min_got_dynindx;
+  /* The greatest dynamic symbol table index corresponding to a symbol
+     with a GOT entry that is not referenced (e.g., a dynamic symbol
+     with dynamic relocations pointing to it from non-primary GOTs).  */
+  long max_unref_got_dynindx;
+  /* The greatest dynamic symbol table index not corresponding to a
+     symbol without a GOT entry.  */
+  long max_non_got_dynindx;
+};
+
+/* The BROWNIE32 ELF linker needs additional information for each symbol in
+   the global hash table.  */
+
+struct brownie32_elf_link_hash_entry
+{
+  struct elf_link_hash_entry root;
+
+  /* External symbol information.  */
+  EXTR esym;
+
+  /* Number of R_BROWNIE32_32, R_BROWNIE32_REL32, or R_BROWNIE32_64 relocs against
+     this symbol.  */
+  unsigned int possibly_dynamic_relocs;
+
+  /* If the R_BROWNIE32_32, R_BROWNIE32_REL32, or R_BROWNIE32_64 reloc is against
+     a readonly section.  */
+  bfd_boolean readonly_reloc;
+
+  /* We must not create a stub for a symbol that has relocations
+     related to taking the function's address, i.e. any but
+     R_BROWNIE32_CALL*16 ones -- see "BROWNIE32 ABI Supplement, 3rd Edition",
+     p. 4-20.  */
+  bfd_boolean no_fn_stub;
+
+  /* If there is a stub that 32 bit functions should use to call this
+     16 bit function, this points to the section containing the stub.  */
+  asection *fn_stub;
+
+  /* Whether we need the fn_stub; this is set if this symbol appears
+     in any relocs other than a 16 bit call.  */
+  bfd_boolean need_fn_stub;
+
+  /* If there is a stub that 16 bit functions should use to call this
+     32 bit function, this points to the section containing the stub.  */
+  asection *call_stub;
+
+  /* This is like the call_stub field, but it is used if the function
+     being called returns a floating point value.  */
+  asection *call_fp_stub;
+
+  /* Are we forced local?  This will only be set if we have converted
+     the initial global GOT entry to a local GOT entry.  */
+  bfd_boolean forced_local;
+
+#define GOT_NORMAL	0
+#define GOT_TLS_GD	1
+#define GOT_TLS_LDM	2
+#define GOT_TLS_IE	4
+#define GOT_TLS_OFFSET_DONE    0x40
+#define GOT_TLS_DONE    0x80
+  unsigned char tls_type;
+  /* This is only used in single-GOT mode; in multi-GOT mode there
+     is one brownie32_got_entry per GOT entry, so the offset is stored
+     there.  In single-GOT mode there may be many brownie32_got_entry
+     structures all referring to the same GOT slot.  It might be
+     possible to use root.got.offset instead, but that field is
+     overloaded already.  */
+  bfd_vma tls_got_offset;
+};
+
+/* BROWNIE32 ELF linker hash table.  */
+
+struct brownie32_elf_link_hash_table
+{
+  struct elf_link_hash_table root;
+#if 0
+  /* We no longer use this.  */
+  /* String section indices for the dynamic section symbols.  */
+  bfd_size_type dynsym_sec_strindex[SIZEOF_BROWNIE32_DYNSYM_SECNAMES];
+#endif
+  /* The number of .rtproc entries.  */
+  bfd_size_type procedure_count;
+  /* The size of the .compact_rel section (if SGI_COMPAT).  */
+  bfd_size_type compact_rel_size;
+  /* This flag indicates that the value of DT_BROWNIE32_RLD_MAP dynamic
+     entry is set to the address of __rld_obj_head as in IRIX5.  */
+  bfd_boolean use_rld_obj_head;
+  /* This is the value of the __rld_map or __rld_obj_head symbol.  */
+  bfd_vma rld_value;
+  /* This is set if we see any brownie3216 stub sections.  */
+  bfd_boolean brownie3216_stubs_seen;
+};
+
+#define TLS_RELOC_P(r_type) \
+  (r_type == R_BROWNIE32_TLS_DTPMOD32		\
+   || r_type == R_BROWNIE32_TLS_DTPMOD64		\
+   || r_type == R_BROWNIE32_TLS_DTPREL32		\
+   || r_type == R_BROWNIE32_TLS_DTPREL64		\
+   || r_type == R_BROWNIE32_TLS_GD			\
+   || r_type == R_BROWNIE32_TLS_LDM			\
+   || r_type == R_BROWNIE32_TLS_DTPREL_HI16		\
+   || r_type == R_BROWNIE32_TLS_DTPREL_LO16		\
+   || r_type == R_BROWNIE32_TLS_GOTTPREL		\
+   || r_type == R_BROWNIE32_TLS_TPREL32		\
+   || r_type == R_BROWNIE32_TLS_TPREL64		\
+   || r_type == R_BROWNIE32_TLS_TPREL_HI16		\
+   || r_type == R_BROWNIE32_TLS_TPREL_LO16)
+
+/* Structure used to pass information to brownie32_elf_output_extsym.  */
+
+struct extsym_info
+{
+  bfd *abfd;
+  struct bfd_link_info *info;
+  struct ecoff_debug_info *debug;
+  const struct ecoff_debug_swap *swap;
+  bfd_boolean failed;
+};
+
+/* The names of the runtime procedure table symbols used on IRIX5.  */
+
+static const char * const brownie32_elf_dynsym_rtproc_names[] =
+{
+  "_procedure_table",
+  "_procedure_string_table",
+  "_procedure_table_size",
+  NULL
+};
+
+/* These structures are used to generate the .compact_rel section on
+   IRIX5.  */
+
+typedef struct
+{
+  unsigned long id1;		/* Always one?  */
+  unsigned long num;		/* Number of compact relocation entries.  */
+  unsigned long id2;		/* Always two?  */
+  unsigned long offset;		/* The file offset of the first relocation.  */
+  unsigned long reserved0;	/* Zero?  */
+  unsigned long reserved1;	/* Zero?  */
+} Elf32_compact_rel;
+
+typedef struct
+{
+  bfd_byte id1[4];
+  bfd_byte num[4];
+  bfd_byte id2[4];
+  bfd_byte offset[4];
+  bfd_byte reserved0[4];
+  bfd_byte reserved1[4];
+} Elf32_External_compact_rel;
+
+typedef struct
+{
+  unsigned int ctype : 1;	/* 1: long 0: short format. See below.  */
+  unsigned int rtype : 4;	/* Relocation types. See below.  */
+  unsigned int dist2to : 8;
+  unsigned int relvaddr : 19;	/* (VADDR - vaddr of the previous entry)/ 4 */
+  unsigned long konst;		/* KONST field. See below.  */
+  unsigned long vaddr;		/* VADDR to be relocated.  */
+} Elf32_crinfo;
+
+typedef struct
+{
+  unsigned int ctype : 1;	/* 1: long 0: short format. See below.  */
+  unsigned int rtype : 4;	/* Relocation types. See below.  */
+  unsigned int dist2to : 8;
+  unsigned int relvaddr : 19;	/* (VADDR - vaddr of the previous entry)/ 4 */
+  unsigned long konst;		/* KONST field. See below.  */
+} Elf32_crinfo2;
+
+typedef struct
+{
+  bfd_byte info[4];
+  bfd_byte konst[4];
+  bfd_byte vaddr[4];
+} Elf32_External_crinfo;
+
+typedef struct
+{
+  bfd_byte info[4];
+  bfd_byte konst[4];
+} Elf32_External_crinfo2;
+
+/* These are the constants used to swap the bitfields in a crinfo.  */
+
+#define CRINFO_CTYPE (0x1)
+#define CRINFO_CTYPE_SH (31)
+#define CRINFO_RTYPE (0xf)
+#define CRINFO_RTYPE_SH (27)
+#define CRINFO_DIST2TO (0xff)
+#define CRINFO_DIST2TO_SH (19)
+#define CRINFO_RELVADDR (0x7ffff)
+#define CRINFO_RELVADDR_SH (0)
+
+/* A compact relocation info has long (3 words) or short (2 words)
+   formats.  A short format doesn't have VADDR field and relvaddr
+   fields contains ((VADDR - vaddr of the previous entry) >> 2).  */
+#define CRF_BROWNIE32_LONG			1
+#define CRF_BROWNIE32_SHORT			0
+
+/* There are 4 types of compact relocation at least. The value KONST
+   has different meaning for each type:
+
+   (type)		(konst)
+   CT_BROWNIE32_REL32	Address in data
+   CT_BROWNIE32_WORD		Address in word (XXX)
+   CT_BROWNIE32_GPHI_LO	GP - vaddr
+   CT_BROWNIE32_JMPAD	Address to jump
+   */
+
+#define CRT_BROWNIE32_REL32			0xa
+#define CRT_BROWNIE32_WORD			0xb
+#define CRT_BROWNIE32_GPHI_LO		0xc
+#define CRT_BROWNIE32_JMPAD			0xd
+
+#define brownie32_elf_set_cr_format(x,format)	((x).ctype = (format))
+#define brownie32_elf_set_cr_type(x,type)		((x).rtype = (type))
+#define brownie32_elf_set_cr_dist2to(x,v)		((x).dist2to = (v))
+#define brownie32_elf_set_cr_relvaddr(x,d)		((x).relvaddr = (d)<<2)
+
+/* The structure of the runtime procedure descriptor created by the
+   loader for use by the static exception system.  */
+
+typedef struct runtime_pdr {
+	bfd_vma	adr;		/* Memory address of start of procedure.  */
+	long	regmask;	/* Save register mask.  */
+	long	regoffset;	/* Save register offset.  */
+	long	fregmask;	/* Save floating point register mask.  */
+	long	fregoffset;	/* Save floating point register offset.  */
+	long	frameoffset;	/* Frame size.  */
+	short	framereg;	/* Frame pointer register.  */
+	short	pcreg;		/* Offset or reg of return pc.  */
+	long	irpss;		/* Index into the runtime string table.  */
+	long	reserved;
+	struct exception_info *exception_info;/* Pointer to exception array.  */
+} RPDR, *pRPDR;
+#define cbRPDR sizeof (RPDR)
+#define rpdNil ((pRPDR) 0)
+
+static struct brownie32_got_entry *brownie32_elf_create_local_got_entry
+  (bfd *, bfd *, struct brownie32_got_info *, asection *, bfd_vma, unsigned long,
+   struct brownie32_elf_link_hash_entry *, int);
+static bfd_boolean brownie32_elf_sort_hash_table_f
+  (struct brownie32_elf_link_hash_entry *, void *);
+static bfd_vma brownie32_elf_high
+  (bfd_vma);
+static bfd_boolean brownie32_elf_stub_section_p
+  (bfd *, asection *);
+static bfd_boolean brownie32_elf_create_dynamic_relocation
+  (bfd *, struct bfd_link_info *, const Elf_Internal_Rela *,
+   struct brownie32_elf_link_hash_entry *, asection *, bfd_vma,
+   bfd_vma *, asection *);
+static hashval_t brownie32_elf_got_entry_hash
+  (const void *);
+static bfd_vma brownie32_elf_adjust_gp
+  (bfd *, struct brownie32_got_info *, bfd *);
+static struct brownie32_got_info *brownie32_elf_got_for_ibfd
+  (struct brownie32_got_info *, bfd *);
+
+/* This will be used when we sort the dynamic relocation records.  */
+static bfd *reldyn_sorting_bfd;
+
+/* Nonzero if ABFD is using the N32 ABI.  */
+
+#define ABI_N32_P(abfd) \
+  ((elf_elfheader (abfd)->e_flags & EF_BROWNIE32_ABI2) != 0)
+
+/* Nonzero if ABFD is using the N64 ABI.  */
+#define ABI_64_P(abfd) \
+  (get_elf_backend_data (abfd)->s->elfclass == ELFCLASS64)
+
+/* Nonzero if ABFD is using NewABI conventions.  */
+#define NEWABI_P(abfd) (ABI_N32_P (abfd) || ABI_64_P (abfd))
+
+/* The IRIX compatibility level we are striving for.  */
+#define IRIX_COMPAT(abfd) \
+  (get_elf_backend_data (abfd)->elf_backend_brownie32_irix_compat (abfd))
+
+/* Whether we are trying to be compatible with IRIX at all.  */
+#define SGI_COMPAT(abfd) \
+  (IRIX_COMPAT (abfd) != ict_none)
+
+/* The name of the options section.  */
+#define BROWNIE32_ELF_OPTIONS_SECTION_NAME(abfd) \
+  (NEWABI_P (abfd) ? ".BROWNIE32.options" : ".options")
+
+/* True if NAME is the recognized name of any SHT_BROWNIE32_OPTIONS section.
+   Some IRIX system files do not use BROWNIE32_ELF_OPTIONS_SECTION_NAME.  */
+#define BROWNIE32_ELF_OPTIONS_SECTION_NAME_P(NAME) \
+  (strcmp (NAME, ".BROWNIE32.options") == 0 || strcmp (NAME, ".options") == 0)
+
+/* The name of the stub section.  */
+#define BROWNIE32_ELF_STUB_SECTION_NAME(abfd) ".BROWNIE32.stubs"
+
+/* The size of an external REL relocation.  */
+#define BROWNIE32_ELF_REL_SIZE(abfd) \
+  (get_elf_backend_data (abfd)->s->sizeof_rel)
+
+/* The size of an external dynamic table entry.  */
+#define BROWNIE32_ELF_DYN_SIZE(abfd) \
+  (get_elf_backend_data (abfd)->s->sizeof_dyn)
+
+/* The size of a GOT entry.  */
+#define BROWNIE32_ELF_GOT_SIZE(abfd) \
+  (get_elf_backend_data (abfd)->s->arch_size / 8)
+
+/* The size of a symbol-table entry.  */
+#define BROWNIE32_ELF_SYM_SIZE(abfd) \
+  (get_elf_backend_data (abfd)->s->sizeof_sym)
+
+/* The default alignment for sections, as a power of two.  */
+#define BROWNIE32_ELF_LOG_FILE_ALIGN(abfd)				\
+  (get_elf_backend_data (abfd)->s->log_file_align)
+
+/* Get word-sized data.  */
+#define BROWNIE32_ELF_GET_WORD(abfd, ptr) \
+  (ABI_64_P (abfd) ? bfd_get_64 (abfd, ptr) : bfd_get_32 (abfd, ptr))
+
+/* Put out word-sized data.  */
+#define BROWNIE32_ELF_PUT_WORD(abfd, val, ptr)	\
+  (ABI_64_P (abfd) 				\
+   ? bfd_put_64 (abfd, val, ptr) 		\
+   : bfd_put_32 (abfd, val, ptr))
+
+/* Add a dynamic symbol table-entry.  */
+#define BROWNIE32_ELF_ADD_DYNAMIC_ENTRY(info, tag, val)	\
+  _bfd_elf_add_dynamic_entry (info, tag, val)
+
+#define BROWNIE32_ELF_RTYPE_TO_HOWTO(abfd, rtype, rela)			\
+  (get_elf_backend_data (abfd)->elf_backend_brownie32_rtype_to_howto (rtype, rela))
+
+/* Determine whether the internal relocation of index REL_IDX is REL
+   (zero) or RELA (non-zero).  The assumption is that, if there are
+   two relocation sections for this section, one of them is REL and
+   the other is RELA.  If the index of the relocation we're testing is
+   in range for the first relocation section, check that the external
+   relocation size is that for RELA.  It is also assumed that, if
+   rel_idx is not in range for the first section, and this first
+   section contains REL relocs, then the relocation is in the second
+   section, that is RELA.  */
+#define BROWNIE32_RELOC_RELA_P(abfd, sec, rel_idx)				\
+  ((NUM_SHDR_ENTRIES (&elf_section_data (sec)->rel_hdr)			\
+    * get_elf_backend_data (abfd)->s->int_rels_per_ext_rel		\
+    > (bfd_vma)(rel_idx))						\
+   == (elf_section_data (sec)->rel_hdr.sh_entsize			\
+       == (ABI_64_P (abfd) ? sizeof (Elf64_External_Rela)		\
+	   : sizeof (Elf32_External_Rela))))
+
+/* In case we're on a 32-bit machine, construct a 64-bit "-1" value
+   from smaller values.  Start with zero, widen, *then* decrement.  */
+#define MINUS_ONE	(((bfd_vma)0) - 1)
+#define MINUS_TWO	(((bfd_vma)0) - 2)
+
+/* The number of local .got entries we reserve.  */
+#define BROWNIE32_RESERVED_GOTNO (2)
+
+/* The offset of $gp from the beginning of the .got section.  */
+#define ELF_BROWNIE32_GP_OFFSET(abfd) (0x7ff0)
+
+/* The maximum size of the GOT for it to be addressable using 16-bit
+   offsets from $gp.  */
+#define BROWNIE32_ELF_GOT_MAX_SIZE(abfd) (ELF_BROWNIE32_GP_OFFSET(abfd) + 0x7fff)
+
+/* Instructions which appear in a stub.  */
+#define STUB_LW(abfd)						\
+  ((ABI_64_P (abfd)  						\
+    ? 0xdf998010		/* ld t9,0x8010(gp) */		\
+    : 0x8f998010))              /* lw t9,0x8010(gp) */
+#define STUB_MOVE(abfd)                                         \
+   ((ABI_64_P (abfd)						\
+     ? 0x03e0782d		/* daddu t7,ra */		\
+     : 0x03e07821))		/* addu t7,ra */
+#define STUB_JALR 0x0320f809	/* jalr t9,ra */
+#define STUB_LI16(abfd)                                         \
+  ((ABI_64_P (abfd)						\
+   ? 0x64180000			/* daddiu t8,zero,0 */		\
+   : 0x24180000))		/* addiu t8,zero,0 */
+#define BROWNIE32_FUNCTION_STUB_SIZE (16)
+
+/* The name of the dynamic interpreter.  This is put in the .interp
+   section.  */
+
+#define ELF_DYNAMIC_INTERPRETER(abfd) 		\
+   (ABI_N32_P (abfd) ? "/usr/lib32/libc.so.1" 	\
+    : ABI_64_P (abfd) ? "/usr/lib64/libc.so.1" 	\
+    : "/usr/lib/libc.so.1")
+
+#ifdef BFD64
+#define MNAME(bfd,pre,pos) \
+  (ABI_64_P (bfd) ? CONCAT4 (pre,64,_,pos) : CONCAT4 (pre,32,_,pos))
+#define ELF_R_SYM(bfd, i)					\
+  (ABI_64_P (bfd) ? ELF64_R_SYM (i) : ELF32_R_SYM (i))
+#define ELF_R_TYPE(bfd, i)					\
+  (ABI_64_P (bfd) ? ELF64_BROWNIE32_R_TYPE (i) : ELF32_R_TYPE (i))
+#define ELF_R_INFO(bfd, s, t)					\
+  (ABI_64_P (bfd) ? ELF64_R_INFO (s, t) : ELF32_R_INFO (s, t))
+#else
+#define MNAME(bfd,pre,pos) CONCAT4 (pre,32,_,pos)
+#define ELF_R_SYM(bfd, i)					\
+  (ELF32_R_SYM (i))
+#define ELF_R_TYPE(bfd, i)					\
+  (ELF32_R_TYPE (i))
+#define ELF_R_INFO(bfd, s, t)					\
+  (ELF32_R_INFO (s, t))
+#endif
+
+  /* The brownie3216 compiler uses a couple of special sections to handle
+     floating point arguments.
+
+     Section names that look like .brownie3216.fn.FNNAME contain stubs that
+     copy floating point arguments from the fp regs to the gp regs and
+     then jump to FNNAME.  If any 32 bit function calls FNNAME, the
+     call should be redirected to the stub instead.  If no 32 bit
+     function calls FNNAME, the stub should be discarded.  We need to
+     consider any reference to the function, not just a call, because
+     if the address of the function is taken we will need the stub,
+     since the address might be passed to a 32 bit function.
+
+     Section names that look like .brownie3216.call.FNNAME contain stubs
+     that copy floating point arguments from the gp regs to the fp
+     regs and then jump to FNNAME.  If FNNAME is a 32 bit function,
+     then any 16 bit function that calls FNNAME should be redirected
+     to the stub instead.  If FNNAME is not a 32 bit function, the
+     stub should be discarded.
+
+     .brownie3216.call.fp.FNNAME sections are similar, but contain stubs
+     which call FNNAME and then copy the return value from the fp regs
+     to the gp regs.  These stubs store the return value in $18 while
+     calling FNNAME; any function which might call one of these stubs
+     must arrange to save $18 around the call.  (This case is not
+     needed for 32 bit functions that call 16 bit functions, because
+     16 bit functions always return floating point values in both
+     $f0/$f1 and $2/$3.)
+
+     Note that in all cases FNNAME might be defined statically.
+     Therefore, FNNAME is not used literally.  Instead, the relocation
+     information will indicate which symbol the section is for.
+
+     We record any stubs that we find in the symbol table.  */
+
+#define FN_STUB ".brownie3216.fn."
+#define CALL_STUB ".brownie3216.call."
+#define CALL_FP_STUB ".brownie3216.call.fp."
+
+/* Look up an entry in a BROWNIE32 ELF linker hash table.  */
+
+#define brownie32_elf_link_hash_lookup(table, string, create, copy, follow)	\
+  ((struct brownie32_elf_link_hash_entry *)					\
+   elf_link_hash_lookup (&(table)->root, (string), (create),		\
+			 (copy), (follow)))
+
+/* Traverse a BROWNIE32 ELF linker hash table.  */
+
+#define brownie32_elf_link_hash_traverse(table, func, info)			\
+  (elf_link_hash_traverse						\
+   (&(table)->root,							\
+    (bfd_boolean (*) (struct elf_link_hash_entry *, void *)) (func),	\
+    (info)))
+
+/* Get the BROWNIE32 ELF linker hash table from a link_info structure.  */
+
+#define brownie32_elf_hash_table(p) \
+  ((struct brownie32_elf_link_hash_table *) ((p)->hash))
+
+/* Find the base offsets for thread-local storage in this object,
+   for GD/LD and IE/LE respectively.  */
+
+#define TP_OFFSET 0x7000
+#define DTP_OFFSET 0x8000
+
+static bfd_vma
+dtprel_base (struct bfd_link_info *info)
+{
+  /* If tls_sec is NULL, we should have signalled an error already.  */
+  if (elf_hash_table (info)->tls_sec == NULL)
+    return 0;
+  return elf_hash_table (info)->tls_sec->vma + DTP_OFFSET;
+}
+
+static bfd_vma
+tprel_base (struct bfd_link_info *info)
+{
+  /* If tls_sec is NULL, we should have signalled an error already.  */
+  if (elf_hash_table (info)->tls_sec == NULL)
+    return 0;
+  return elf_hash_table (info)->tls_sec->vma + TP_OFFSET;
+}
+
+/* Create an entry in a BROWNIE32 ELF linker hash table.  */
+
+static struct bfd_hash_entry *
+brownie32_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
+			    struct bfd_hash_table *table, const char *string)
+{
+  struct brownie32_elf_link_hash_entry *ret =
+    (struct brownie32_elf_link_hash_entry *) entry;
+
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (ret == NULL)
+    ret = bfd_hash_allocate (table, sizeof (struct brownie32_elf_link_hash_entry));
+  if (ret == NULL)
+    return (struct bfd_hash_entry *) ret;
+
+  /* Call the allocation method of the superclass.  */
+  ret = ((struct brownie32_elf_link_hash_entry *)
+	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
+				     table, string));
+  if (ret != NULL)
+    {
+      /* Set local fields.  */
+      memset (&ret->esym, 0, sizeof (EXTR));
+      /* We use -2 as a marker to indicate that the information has
+	 not been set.  -1 means there is no associated ifd.  */
+      ret->esym.ifd = -2;
+      ret->possibly_dynamic_relocs = 0;
+      ret->readonly_reloc = FALSE;
+      ret->no_fn_stub = FALSE;
+      ret->fn_stub = NULL;
+      ret->need_fn_stub = FALSE;
+      ret->call_stub = NULL;
+      ret->call_fp_stub = NULL;
+      ret->forced_local = FALSE;
+      ret->tls_type = GOT_NORMAL;
+    }
+
+  return (struct bfd_hash_entry *) ret;
+}
+
+bfd_boolean
+_bfd_brownie32_elf_new_section_hook (bfd *abfd, asection *sec)
+{
+  struct _brownie32_elf_section_data *sdata;
+  bfd_size_type amt = sizeof (*sdata);
+
+  sdata = bfd_zalloc (abfd, amt);
+  if (sdata == NULL)
+    return FALSE;
+  sec->used_by_bfd = sdata;
+
+  return _bfd_elf_new_section_hook (abfd, sec);
+}
+
+/* Read ECOFF debugging information from a .mdebug section into a
+   ecoff_debug_info structure.  */
+
+bfd_boolean
+_bfd_brownie32_elf_read_ecoff_info (bfd *abfd, asection *section,
+			       struct ecoff_debug_info *debug)
+{
+  HDRR *symhdr;
+  const struct ecoff_debug_swap *swap;
+  char *ext_hdr;
+
+  swap = get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;
+  memset (debug, 0, sizeof (*debug));
+
+  ext_hdr = bfd_malloc (swap->external_hdr_size);
+  if (ext_hdr == NULL && swap->external_hdr_size != 0)
+    goto error_return;
+
+  if (! bfd_get_section_contents (abfd, section, ext_hdr, 0,
+				  swap->external_hdr_size))
+    goto error_return;
+
+  symhdr = &debug->symbolic_header;
+  (*swap->swap_hdr_in) (abfd, ext_hdr, symhdr);
+
+  /* The symbolic header contains absolute file offsets and sizes to
+     read.  */
+#define READ(ptr, offset, count, size, type)				\
+  if (symhdr->count == 0)						\
+    debug->ptr = NULL;							\
+  else									\
+    {									\
+      bfd_size_type amt = (bfd_size_type) size * symhdr->count;		\
+      debug->ptr = bfd_malloc (amt);					\
+      if (debug->ptr == NULL)						\
+	goto error_return;						\
+      if (bfd_seek (abfd, symhdr->offset, SEEK_SET) != 0		\
+	  || bfd_bread (debug->ptr, amt, abfd) != amt)			\
+	goto error_return;						\
+    }
+
+  READ (line, cbLineOffset, cbLine, sizeof (unsigned char), unsigned char *);
+  READ (external_dnr, cbDnOffset, idnMax, swap->external_dnr_size, void *);
+  READ (external_pdr, cbPdOffset, ipdMax, swap->external_pdr_size, void *);
+  READ (external_sym, cbSymOffset, isymMax, swap->external_sym_size, void *);
+  READ (external_opt, cbOptOffset, ioptMax, swap->external_opt_size, void *);
+  READ (external_aux, cbAuxOffset, iauxMax, sizeof (union aux_ext),
+	union aux_ext *);
+  READ (ss, cbSsOffset, issMax, sizeof (char), char *);
+  READ (ssext, cbSsExtOffset, issExtMax, sizeof (char), char *);
+  READ (external_fdr, cbFdOffset, ifdMax, swap->external_fdr_size, void *);
+  READ (external_rfd, cbRfdOffset, crfd, swap->external_rfd_size, void *);
+  READ (external_ext, cbExtOffset, iextMax, swap->external_ext_size, void *);
+#undef READ
+
+  debug->fdr = NULL;
+
+  return TRUE;
+
+ error_return:
+  if (ext_hdr != NULL)
+    free (ext_hdr);
+  if (debug->line != NULL)
+    free (debug->line);
+  if (debug->external_dnr != NULL)
+    free (debug->external_dnr);
+  if (debug->external_pdr != NULL)
+    free (debug->external_pdr);
+  if (debug->external_sym != NULL)
+    free (debug->external_sym);
+  if (debug->external_opt != NULL)
+    free (debug->external_opt);
+  if (debug->external_aux != NULL)
+    free (debug->external_aux);
+  if (debug->ss != NULL)
+    free (debug->ss);
+  if (debug->ssext != NULL)
+    free (debug->ssext);
+  if (debug->external_fdr != NULL)
+    free (debug->external_fdr);
+  if (debug->external_rfd != NULL)
+    free (debug->external_rfd);
+  if (debug->external_ext != NULL)
+    free (debug->external_ext);
+  return FALSE;
+}
+
+/* Swap RPDR (runtime procedure table entry) for output.  */
+
+static void
+ecoff_swap_rpdr_out (bfd *abfd, const RPDR *in, struct rpdr_ext *ex)
+{
+  H_PUT_S32 (abfd, in->adr, ex->p_adr);
+  H_PUT_32 (abfd, in->regmask, ex->p_regmask);
+  H_PUT_32 (abfd, in->regoffset, ex->p_regoffset);
+  H_PUT_32 (abfd, in->fregmask, ex->p_fregmask);
+  H_PUT_32 (abfd, in->fregoffset, ex->p_fregoffset);
+  H_PUT_32 (abfd, in->frameoffset, ex->p_frameoffset);
+
+  H_PUT_16 (abfd, in->framereg, ex->p_framereg);
+  H_PUT_16 (abfd, in->pcreg, ex->p_pcreg);
+
+  H_PUT_32 (abfd, in->irpss, ex->p_irpss);
+}
+
+/* Create a runtime procedure table from the .mdebug section.  */
+
+static bfd_boolean
+brownie32_elf_create_procedure_table (void *handle, bfd *abfd,
+				 struct bfd_link_info *info, asection *s,
+				 struct ecoff_debug_info *debug)
+{
+  const struct ecoff_debug_swap *swap;
+  HDRR *hdr = &debug->symbolic_header;
+  RPDR *rpdr, *rp;
+  struct rpdr_ext *erp;
+  void *rtproc;
+  struct pdr_ext *epdr;
+  struct sym_ext *esym;
+  char *ss, **sv;
+  char *str;
+  bfd_size_type size;
+  bfd_size_type count;
+  unsigned long sindex;
+  unsigned long i;
+  PDR pdr;
+  SYMR sym;
+  const char *no_name_func = _("static procedure (no name)");
+
+  epdr = NULL;
+  rpdr = NULL;
+  esym = NULL;
+  ss = NULL;
+  sv = NULL;
+
+  swap = get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;
+
+  sindex = strlen (no_name_func) + 1;
+  count = hdr->ipdMax;
+  if (count > 0)
+    {
+      size = swap->external_pdr_size;
+
+      epdr = bfd_malloc (size * count);
+      if (epdr == NULL)
+	goto error_return;
+
+      if (! _bfd_ecoff_get_accumulated_pdr (handle, (bfd_byte *) epdr))
+	goto error_return;
+
+      size = sizeof (RPDR);
+      rp = rpdr = bfd_malloc (size * count);
+      if (rpdr == NULL)
+	goto error_return;
+
+      size = sizeof (char *);
+      sv = bfd_malloc (size * count);
+      if (sv == NULL)
+	goto error_return;
+
+      count = hdr->isymMax;
+      size = swap->external_sym_size;
+      esym = bfd_malloc (size * count);
+      if (esym == NULL)
+	goto error_return;
+
+      if (! _bfd_ecoff_get_accumulated_sym (handle, (bfd_byte *) esym))
+	goto error_return;
+
+      count = hdr->issMax;
+      ss = bfd_malloc (count);
+      if (ss == NULL)
+	goto error_return;
+      if (! _bfd_ecoff_get_accumulated_ss (handle, (bfd_byte *) ss))
+	goto error_return;
+
+      count = hdr->ipdMax;
+      for (i = 0; i < (unsigned long) count; i++, rp++)
+	{
+	  (*swap->swap_pdr_in) (abfd, epdr + i, &pdr);
+	  (*swap->swap_sym_in) (abfd, &esym[pdr.isym], &sym);
+	  rp->adr = sym.value;
+	  rp->regmask = pdr.regmask;
+	  rp->regoffset = pdr.regoffset;
+	  rp->fregmask = pdr.fregmask;
+	  rp->fregoffset = pdr.fregoffset;
+	  rp->frameoffset = pdr.frameoffset;
+	  rp->framereg = pdr.framereg;
+	  rp->pcreg = pdr.pcreg;
+	  rp->irpss = sindex;
+	  sv[i] = ss + sym.iss;
+	  sindex += strlen (sv[i]) + 1;
+	}
+    }
+
+  size = sizeof (struct rpdr_ext) * (count + 2) + sindex;
+  size = BFD_ALIGN (size, 16);
+  rtproc = bfd_alloc (abfd, size);
+  if (rtproc == NULL)
+    {
+      brownie32_elf_hash_table (info)->procedure_count = 0;
+      goto error_return;
+    }
+
+  brownie32_elf_hash_table (info)->procedure_count = count + 2;
+
+  erp = rtproc;
+  memset (erp, 0, sizeof (struct rpdr_ext));
+  erp++;
+  str = (char *) rtproc + sizeof (struct rpdr_ext) * (count + 2);
+  strcpy (str, no_name_func);
+  str += strlen (no_name_func) + 1;
+  for (i = 0; i < count; i++)
+    {
+      ecoff_swap_rpdr_out (abfd, rpdr + i, erp + i);
+      strcpy (str, sv[i]);
+      str += strlen (sv[i]) + 1;
+    }
+  H_PUT_S32 (abfd, -1, (erp + count)->p_adr);
+
+  /* Set the size and contents of .rtproc section.  */
+  s->size = size;
+  s->contents = rtproc;
+
+  /* Skip this section later on (I don't think this currently
+     matters, but someday it might).  */
+  s->map_head.link_order = NULL;
+
+  if (epdr != NULL)
+    free (epdr);
+  if (rpdr != NULL)
+    free (rpdr);
+  if (esym != NULL)
+    free (esym);
+  if (ss != NULL)
+    free (ss);
+  if (sv != NULL)
+    free (sv);
+
+  return TRUE;
+
+ error_return:
+  if (epdr != NULL)
+    free (epdr);
+  if (rpdr != NULL)
+    free (rpdr);
+  if (esym != NULL)
+    free (esym);
+  if (ss != NULL)
+    free (ss);
+  if (sv != NULL)
+    free (sv);
+  return FALSE;
+}
+
+/* Check the brownie3216 stubs for a particular symbol, and see if we can
+   discard them.  */
+
+static bfd_boolean
+brownie32_elf_check_brownie3216_stubs (struct brownie32_elf_link_hash_entry *h,
+			     void *data ATTRIBUTE_UNUSED)
+{
+  if (h->root.root.type == bfd_link_hash_warning)
+    h = (struct brownie32_elf_link_hash_entry *) h->root.root.u.i.link;
+
+  if (h->fn_stub != NULL
+      && ! h->need_fn_stub)
+    {
+      /* We don't need the fn_stub; the only references to this symbol
+         are 16 bit calls.  Clobber the size to 0 to prevent it from
+         being included in the link.  */
+      h->fn_stub->size = 0;
+      h->fn_stub->flags &= ~SEC_RELOC;
+      h->fn_stub->reloc_count = 0;
+      h->fn_stub->flags |= SEC_EXCLUDE;
+    }
+
+  if (h->call_stub != NULL
+      && h->root.other == STO_BROWNIE3216)
+    {
+      /* We don't need the call_stub; this is a 16 bit function, so
+         calls from other 16 bit functions are OK.  Clobber the size
+         to 0 to prevent it from being included in the link.  */
+      h->call_stub->size = 0;
+      h->call_stub->flags &= ~SEC_RELOC;
+      h->call_stub->reloc_count = 0;
+      h->call_stub->flags |= SEC_EXCLUDE;
+    }
+
+  if (h->call_fp_stub != NULL
+      && h->root.other == STO_BROWNIE3216)
+    {
+      /* We don't need the call_stub; this is a 16 bit function, so
+         calls from other 16 bit functions are OK.  Clobber the size
+         to 0 to prevent it from being included in the link.  */
+      h->call_fp_stub->size = 0;
+      h->call_fp_stub->flags &= ~SEC_RELOC;
+      h->call_fp_stub->reloc_count = 0;
+      h->call_fp_stub->flags |= SEC_EXCLUDE;
+    }
+
+  return TRUE;
+}
+
+/* R_BROWNIE3216_26 is used for the brownie3216 jal and jalx instructions.
+   Most brownie3216 instructions are 16 bits, but these instructions
+   are 32 bits.
+
+   The format of these instructions is:
+
+   +--------------+--------------------------------+
+   |     JALX     | X|   Imm 20:16  |   Imm 25:21  |
+   +--------------+--------------------------------+
+   |                Immediate  15:0                |
+   +-----------------------------------------------+
+
+   JALX is the 5-bit value 00011.  X is 0 for jal, 1 for jalx.
+   Note that the immediate value in the first word is swapped.
+
+   When producing a relocatable object file, R_BROWNIE3216_26 is
+   handled mostly like R_BROWNIE32_26.  In particular, the addend is
+   stored as a straight 26-bit value in a 32-bit instruction.
+   (gas makes life simpler for itself by never adjusting a
+   R_BROWNIE3216_26 reloc to be against a section, so the addend is
+   always zero).  However, the 32 bit instruction is stored as 2
+   16-bit values, rather than a single 32-bit value.  In a
+   big-endian file, the result is the same; in a little-endian
+   file, the two 16-bit halves of the 32 bit value are swapped.
+   This is so that a disassembler can recognize the jal
+   instruction.
+
+   When doing a final link, R_BROWNIE3216_26 is treated as a 32 bit
+   instruction stored as two 16-bit values.  The addend A is the
+   contents of the targ26 field.  The calculation is the same as
+   R_BROWNIE32_26.  When storing the calculated value, reorder the
+   immediate value as shown above, and don't forget to store the
+   value as two 16-bit values.
+
+   To put it in BROWNIE32 ABI terms, the relocation field is T-targ26-16,
+   defined as
+
+   big-endian:
+   +--------+----------------------+
+   |        |                      |
+   |        |    targ26-16         |
+   |31    26|25                   0|
+   +--------+----------------------+
+
+   little-endian:
+   +----------+------+-------------+
+   |          |      |             |
+   |  sub1    |      |     sub2    |
+   |0        9|10  15|16         31|
+   +----------+--------------------+
+   where targ26-16 is sub1 followed by sub2 (i.e., the addend field A is
+   ((sub1 << 16) | sub2)).
+
+   When producing a relocatable object file, the calculation is
+   (((A < 2) | ((P + 4) & 0xf0000000) + S) >> 2)
+   When producing a fully linked file, the calculation is
+   let R = (((A < 2) | ((P + 4) & 0xf0000000) + S) >> 2)
+   ((R & 0x1f0000) << 5) | ((R & 0x3e00000) >> 5) | (R & 0xffff)
+
+   R_BROWNIE3216_GPREL is used for GP-relative addressing in brownie3216
+   mode.  A typical instruction will have a format like this:
+
+   +--------------+--------------------------------+
+   |    EXTEND    |     Imm 10:5    |   Imm 15:11  |
+   +--------------+--------------------------------+
+   |    Major     |   rx   |   ry   |   Imm  4:0   |
+   +--------------+--------------------------------+
+
+   EXTEND is the five bit value 11110.  Major is the instruction
+   opcode.
+
+   This is handled exactly like R_BROWNIE32_GPREL16, except that the
+   addend is retrieved and stored as shown in this diagram; that
+   is, the Imm fields above replace the V-rel16 field.
+
+   All we need to do here is shuffle the bits appropriately.  As
+   above, the two 16-bit halves must be swapped on a
+   little-endian system.
+
+   R_BROWNIE3216_HI16 and R_BROWNIE3216_LO16 are used in brownie3216 mode to
+   access data when neither GP-relative nor PC-relative addressing
+   can be used.  They are handled like R_BROWNIE32_HI16 and R_BROWNIE32_LO16,
+   except that the addend is retrieved and stored as shown above
+   for R_BROWNIE3216_GPREL.
+  */
+void
+_bfd_brownie3216_elf_reloc_unshuffle (bfd *abfd, int r_type,
+				 bfd_boolean jal_shuffle, bfd_byte *data)
+{
+  bfd_vma extend, insn, val;
+
+  if (r_type != R_BROWNIE3216_26 && r_type != R_BROWNIE3216_GPREL
+      && r_type != R_BROWNIE3216_HI16 && r_type != R_BROWNIE3216_LO16)
+    return;
+
+  /* Pick up the brownie3216 extend instruction and the real instruction.  */
+  extend = bfd_get_16 (abfd, data);
+  insn = bfd_get_16 (abfd, data + 2);
+  if (r_type == R_BROWNIE3216_26)
+    {
+      if (jal_shuffle)
+	val = ((extend & 0xfc00) << 16) | ((extend & 0x3e0) << 11)
+	      | ((extend & 0x1f) << 21) | insn;
+      else
+	val = extend << 16 | insn;
+    }
+  else
+    val = ((extend & 0xf800) << 16) | ((insn & 0xffe0) << 11)
+	  | ((extend & 0x1f) << 11) | (extend & 0x7e0) | (insn & 0x1f);
+  bfd_put_32 (abfd, val, data);
+}
+
+void
+_bfd_brownie3216_elf_reloc_shuffle (bfd *abfd, int r_type,
+			       bfd_boolean jal_shuffle, bfd_byte *data)
+{
+  bfd_vma extend, insn, val;
+
+  if (r_type != R_BROWNIE3216_26 && r_type != R_BROWNIE3216_GPREL
+      && r_type != R_BROWNIE3216_HI16 && r_type != R_BROWNIE3216_LO16)
+    return;
+
+  val = bfd_get_32 (abfd, data);
+  if (r_type == R_BROWNIE3216_26)
+    {
+      if (jal_shuffle)
+	{
+	  insn = val & 0xffff;
+	  extend = ((val >> 16) & 0xfc00) | ((val >> 11) & 0x3e0)
+		   | ((val >> 21) & 0x1f);
+	}
+      else
+	{
+	  insn = val & 0xffff;
+	  extend = val >> 16;
+	}
+    }
+  else
+    {
+      insn = ((val >> 11) & 0xffe0) | (val & 0x1f);
+      extend = ((val >> 16) & 0xf800) | ((val >> 11) & 0x1f) | (val & 0x7e0);
+    }
+  bfd_put_16 (abfd, insn, data + 2);
+  bfd_put_16 (abfd, extend, data);
+}
+
+bfd_reloc_status_type
+_bfd_brownie32_elf_gprel16_with_gp (bfd *abfd, asymbol *symbol,
+			       arelent *reloc_entry, asection *input_section,
+			       bfd_boolean relocatable, void *data, bfd_vma gp)
+{
+  bfd_vma relocation;
+  bfd_signed_vma val;
+  bfd_reloc_status_type status;
+
+  if (bfd_is_com_section (symbol->section))
+    relocation = 0;
+  else
+    relocation = symbol->value;
+
+  relocation += symbol->section->output_section->vma;
+  relocation += symbol->section->output_offset;
+
+  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
+    return bfd_reloc_outofrange;
+
+  /* Set val to the offset into the section or symbol.  */
+  val = reloc_entry->addend;
+
+  _bfd_brownie32_elf_sign_extend (val, 16);
+
+  /* Adjust val for the final section location and GP value.  If we
+     are producing relocatable output, we don't want to do this for
+     an external symbol.  */
+  if (! relocatable
+      || (symbol->flags & BSF_SECTION_SYM) != 0)
+    val += relocation - gp;
+
+  if (reloc_entry->howto->partial_inplace)
+    {
+      status = _bfd_relocate_contents (reloc_entry->howto, abfd, val,
+				       (bfd_byte *) data
+				       + reloc_entry->address);
+      if (status != bfd_reloc_ok)
+	return status;
+    }
+  else
+    reloc_entry->addend = val;
+
+  if (relocatable)
+    reloc_entry->address += input_section->output_offset;
+
+  return bfd_reloc_ok;
+}
+
+/* Used to store a REL high-part relocation such as R_BROWNIE32_HI16 or
+   R_BROWNIE32_GOT16.  REL is the relocation, INPUT_SECTION is the section
+   that contains the relocation field and DATA points to the start of
+   INPUT_SECTION.  */
+
+struct brownie32_hi16
+{
+  struct brownie32_hi16 *next;
+  bfd_byte *data;
+  asection *input_section;
+  arelent rel;
+};
+
+/* FIXME: This should not be a static variable.  */
+
+static struct brownie32_hi16 *brownie32_hi16_list;
+
+/* A howto special_function for REL *HI16 relocations.  We can only
+   calculate the correct value once we've seen the partnering
+   *LO16 relocation, so just save the information for later.
+
+   The ABI requires that the *LO16 immediately follow the *HI16.
+   However, as a GNU extension, we permit an arbitrary number of
+   *HI16s to be associated with a single *LO16.  This significantly
+   simplies the relocation handling in gcc.  */
+
+bfd_reloc_status_type
+_bfd_brownie32_elf_hi16_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
+			  asymbol *symbol ATTRIBUTE_UNUSED, void *data,
+			  asection *input_section, bfd *output_bfd,
+			  char **error_message ATTRIBUTE_UNUSED)
+{
+  struct brownie32_hi16 *n;
+
+  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
+    return bfd_reloc_outofrange;
+
+  n = bfd_malloc (sizeof *n);
+  if (n == NULL)
+    return bfd_reloc_outofrange;
+
+  n->next = brownie32_hi16_list;
+  n->data = data;
+  n->input_section = input_section;
+  n->rel = *reloc_entry;
+  brownie32_hi16_list = n;
+
+  if (output_bfd != NULL)
+    reloc_entry->address += input_section->output_offset;
+
+  return bfd_reloc_ok;
+}
+
+/* A howto special_function for REL R_BROWNIE32_GOT16 relocations.  This is just
+   like any other 16-bit relocation when applied to global symbols, but is
+   treated in the same as R_BROWNIE32_HI16 when applied to local symbols.  */
+
+bfd_reloc_status_type
+_bfd_brownie32_elf_got16_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
+			   void *data, asection *input_section,
+			   bfd *output_bfd, char **error_message)
+{
+  if ((symbol->flags & (BSF_GLOBAL | BSF_WEAK)) != 0
+      || bfd_is_und_section (bfd_get_section (symbol))
+      || bfd_is_com_section (bfd_get_section (symbol)))
+    /* The relocation is against a global symbol.  */
+    return _bfd_brownie32_elf_generic_reloc (abfd, reloc_entry, symbol, data,
+					input_section, output_bfd,
+					error_message);
+
+  return _bfd_brownie32_elf_hi16_reloc (abfd, reloc_entry, symbol, data,
+				   input_section, output_bfd, error_message);
+}
+
+/* A howto special_function for REL *LO16 relocations.  The *LO16 itself
+   is a straightforward 16 bit inplace relocation, but we must deal with
+   any partnering high-part relocations as well.  */
+
+bfd_reloc_status_type
+_bfd_brownie32_elf_lo16_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
+			  void *data, asection *input_section,
+			  bfd *output_bfd, char **error_message)
+{
+  bfd_vma vallo;
+  bfd_byte *location = (bfd_byte *) data + reloc_entry->address;
+
+  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
+    return bfd_reloc_outofrange;
+
+  _bfd_brownie3216_elf_reloc_unshuffle (abfd, reloc_entry->howto->type, FALSE,
+				   location);
+  vallo = bfd_get_32 (abfd, location);
+  _bfd_brownie3216_elf_reloc_shuffle (abfd, reloc_entry->howto->type, FALSE,
+				 location);
+
+  while (brownie32_hi16_list != NULL)
+    {
+      bfd_reloc_status_type ret;
+      struct brownie32_hi16 *hi;
+
+      hi = brownie32_hi16_list;
+
+      /* R_BROWNIE32_GOT16 relocations are something of a special case.  We
+	 want to install the addend in the same way as for a R_BROWNIE32_HI16
+	 relocation (with a rightshift of 16).  However, since GOT16
+	 relocations can also be used with global symbols, their howto
+	 has a rightshift of 0.  */
+      if (hi->rel.howto->type == R_BROWNIE32_GOT16)
+	hi->rel.howto = BROWNIE32_ELF_RTYPE_TO_HOWTO (abfd, R_BROWNIE32_HI16, FALSE);
+
+      /* VALLO is a signed 16-bit number.  Bias it by 0x8000 so that any
+	 carry or borrow will induce a change of +1 or -1 in the high part.  */
+      hi->rel.addend += (vallo + 0x8000) & 0xffff;
+
+      ret = _bfd_brownie32_elf_generic_reloc (abfd, &hi->rel, symbol, hi->data,
+					 hi->input_section, output_bfd,
+					 error_message);
+      if (ret != bfd_reloc_ok)
+	return ret;
+
+      brownie32_hi16_list = hi->next;
+      free (hi);
+    }
+
+  return _bfd_brownie32_elf_generic_reloc (abfd, reloc_entry, symbol, data,
+				      input_section, output_bfd,
+				      error_message);
+}
+
+/* A generic howto special_function.  This calculates and installs the
+   relocation itself, thus avoiding the oft-discussed problems in
+   bfd_perform_relocation and bfd_install_relocation.  */
+
+bfd_reloc_status_type
+_bfd_brownie32_elf_generic_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
+			     asymbol *symbol, void *data ATTRIBUTE_UNUSED,
+			     asection *input_section, bfd *output_bfd,
+			     char **error_message ATTRIBUTE_UNUSED)
+{
+  bfd_signed_vma val;
+  bfd_reloc_status_type status;
+  bfd_boolean relocatable;
+
+  relocatable = (output_bfd != NULL);
+
+  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
+    return bfd_reloc_outofrange;
+
+  /* Build up the field adjustment in VAL.  */
+  val = 0;
+  if (!relocatable || (symbol->flags & BSF_SECTION_SYM) != 0)
+    {
+      /* Either we're calculating the final field value or we have a
+	 relocation against a section symbol.  Add in the section's
+	 offset or address.  */
+      val += symbol->section->output_section->vma;
+      val += symbol->section->output_offset;
+    }
+
+  if (!relocatable)
+    {
+      /* We're calculating the final field value.  Add in the symbol's value
+	 and, if pc-relative, subtract the address of the field itself.  */
+      val += symbol->value;
+      if (reloc_entry->howto->pc_relative)
+	{
+	  val -= input_section->output_section->vma;
+	  val -= input_section->output_offset;
+	  val -= reloc_entry->address;
+	}
+    }
+
+  /* VAL is now the final adjustment.  If we're keeping this relocation
+     in the output file, and if the relocation uses a separate addend,
+     we just need to add VAL to that addend.  Otherwise we need to add
+     VAL to the relocation field itself.  */
+  if (relocatable && !reloc_entry->howto->partial_inplace)
+    reloc_entry->addend += val;
+  else
+    {
+      bfd_byte *location = (bfd_byte *) data + reloc_entry->address;
+
+      /* Add in the separate addend, if any.  */
+      val += reloc_entry->addend;
+
+      /* Add VAL to the relocation field.  */
+      _bfd_brownie3216_elf_reloc_unshuffle (abfd, reloc_entry->howto->type, FALSE,
+				       location);
+      status = _bfd_relocate_contents (reloc_entry->howto, abfd, val,
+				       location);
+      _bfd_brownie3216_elf_reloc_shuffle (abfd, reloc_entry->howto->type, FALSE,
+				     location);
+
+      if (status != bfd_reloc_ok)
+	return status;
+    }
+
+  if (relocatable)
+    reloc_entry->address += input_section->output_offset;
+
+  return bfd_reloc_ok;
+}
+
+/* Swap an entry in a .gptab section.  Note that these routines rely
+   on the equivalence of the two elements of the union.  */
+
+static void
+bfd_brownie32_elf32_swap_gptab_in (bfd *abfd, const Elf32_External_gptab *ex,
+			      Elf32_gptab *in)
+{
+  in->gt_entry.gt_g_value = H_GET_32 (abfd, ex->gt_entry.gt_g_value);
+  in->gt_entry.gt_bytes = H_GET_32 (abfd, ex->gt_entry.gt_bytes);
+}
+
+static void
+bfd_brownie32_elf32_swap_gptab_out (bfd *abfd, const Elf32_gptab *in,
+			       Elf32_External_gptab *ex)
+{
+  H_PUT_32 (abfd, in->gt_entry.gt_g_value, ex->gt_entry.gt_g_value);
+  H_PUT_32 (abfd, in->gt_entry.gt_bytes, ex->gt_entry.gt_bytes);
+}
+
+static void
+bfd_elf32_swap_compact_rel_out (bfd *abfd, const Elf32_compact_rel *in,
+				Elf32_External_compact_rel *ex)
+{
+  H_PUT_32 (abfd, in->id1, ex->id1);
+  H_PUT_32 (abfd, in->num, ex->num);
+  H_PUT_32 (abfd, in->id2, ex->id2);
+  H_PUT_32 (abfd, in->offset, ex->offset);
+  H_PUT_32 (abfd, in->reserved0, ex->reserved0);
+  H_PUT_32 (abfd, in->reserved1, ex->reserved1);
+}
+
+static void
+bfd_elf32_swap_crinfo_out (bfd *abfd, const Elf32_crinfo *in,
+			   Elf32_External_crinfo *ex)
+{
+  unsigned long l;
+
+  l = (((in->ctype & CRINFO_CTYPE) << CRINFO_CTYPE_SH)
+       | ((in->rtype & CRINFO_RTYPE) << CRINFO_RTYPE_SH)
+       | ((in->dist2to & CRINFO_DIST2TO) << CRINFO_DIST2TO_SH)
+       | ((in->relvaddr & CRINFO_RELVADDR) << CRINFO_RELVADDR_SH));
+  H_PUT_32 (abfd, l, ex->info);
+  H_PUT_32 (abfd, in->konst, ex->konst);
+  H_PUT_32 (abfd, in->vaddr, ex->vaddr);
+}
+
+/* A .reginfo section holds a single Elf32_RegInfo structure.  These
+   routines swap this structure in and out.  They are used outside of
+   BFD, so they are globally visible.  */
+
+void
+bfd_brownie32_elf32_swap_reginfo_in (bfd *abfd, const Elf32_External_RegInfo *ex,
+				Elf32_RegInfo *in)
+{
+  in->ri_gprmask = H_GET_32 (abfd, ex->ri_gprmask);
+  in->ri_cprmask[0] = H_GET_32 (abfd, ex->ri_cprmask[0]);
+  in->ri_cprmask[1] = H_GET_32 (abfd, ex->ri_cprmask[1]);
+  in->ri_cprmask[2] = H_GET_32 (abfd, ex->ri_cprmask[2]);
+  in->ri_cprmask[3] = H_GET_32 (abfd, ex->ri_cprmask[3]);
+  in->ri_gp_value = H_GET_32 (abfd, ex->ri_gp_value);
+}
+
+void
+bfd_brownie32_elf32_swap_reginfo_out (bfd *abfd, const Elf32_RegInfo *in,
+				 Elf32_External_RegInfo *ex)
+{
+  H_PUT_32 (abfd, in->ri_gprmask, ex->ri_gprmask);
+  H_PUT_32 (abfd, in->ri_cprmask[0], ex->ri_cprmask[0]);
+  H_PUT_32 (abfd, in->ri_cprmask[1], ex->ri_cprmask[1]);
+  H_PUT_32 (abfd, in->ri_cprmask[2], ex->ri_cprmask[2]);
+  H_PUT_32 (abfd, in->ri_cprmask[3], ex->ri_cprmask[3]);
+  H_PUT_32 (abfd, in->ri_gp_value, ex->ri_gp_value);
+}
+
+/* In the 64 bit ABI, the .BROWNIE32.options section holds register
+   information in an Elf64_Reginfo structure.  These routines swap
+   them in and out.  They are globally visible because they are used
+   outside of BFD.  These routines are here so that gas can call them
+   without worrying about whether the 64 bit ABI has been included.  */
+
+void
+bfd_brownie32_elf64_swap_reginfo_in (bfd *abfd, const Elf64_External_RegInfo *ex,
+				Elf64_Internal_RegInfo *in)
+{
+  in->ri_gprmask = H_GET_32 (abfd, ex->ri_gprmask);
+  in->ri_pad = H_GET_32 (abfd, ex->ri_pad);
+  in->ri_cprmask[0] = H_GET_32 (abfd, ex->ri_cprmask[0]);
+  in->ri_cprmask[1] = H_GET_32 (abfd, ex->ri_cprmask[1]);
+  in->ri_cprmask[2] = H_GET_32 (abfd, ex->ri_cprmask[2]);
+  in->ri_cprmask[3] = H_GET_32 (abfd, ex->ri_cprmask[3]);
+  in->ri_gp_value = H_GET_64 (abfd, ex->ri_gp_value);
+}
+
+void
+bfd_brownie32_elf64_swap_reginfo_out (bfd *abfd, const Elf64_Internal_RegInfo *in,
+				 Elf64_External_RegInfo *ex)
+{
+  H_PUT_32 (abfd, in->ri_gprmask, ex->ri_gprmask);
+  H_PUT_32 (abfd, in->ri_pad, ex->ri_pad);
+  H_PUT_32 (abfd, in->ri_cprmask[0], ex->ri_cprmask[0]);
+  H_PUT_32 (abfd, in->ri_cprmask[1], ex->ri_cprmask[1]);
+  H_PUT_32 (abfd, in->ri_cprmask[2], ex->ri_cprmask[2]);
+  H_PUT_32 (abfd, in->ri_cprmask[3], ex->ri_cprmask[3]);
+  H_PUT_64 (abfd, in->ri_gp_value, ex->ri_gp_value);
+}
+
+/* Swap in an options header.  */
+
+void
+bfd_brownie32_elf_swap_options_in (bfd *abfd, const Elf_External_Options *ex,
+			      Elf_Internal_Options *in)
+{
+  in->kind = H_GET_8 (abfd, ex->kind);
+  in->size = H_GET_8 (abfd, ex->size);
+  in->section = H_GET_16 (abfd, ex->section);
+  in->info = H_GET_32 (abfd, ex->info);
+}
+
+/* Swap out an options header.  */
+
+void
+bfd_brownie32_elf_swap_options_out (bfd *abfd, const Elf_Internal_Options *in,
+			       Elf_External_Options *ex)
+{
+  H_PUT_8 (abfd, in->kind, ex->kind);
+  H_PUT_8 (abfd, in->size, ex->size);
+  H_PUT_16 (abfd, in->section, ex->section);
+  H_PUT_32 (abfd, in->info, ex->info);
+}
+
+/* This function is called via qsort() to sort the dynamic relocation
+   entries by increasing r_symndx value.  */
+
+static int
+sort_dynamic_relocs (const void *arg1, const void *arg2)
+{
+  Elf_Internal_Rela int_reloc1;
+  Elf_Internal_Rela int_reloc2;
+
+  bfd_elf32_swap_reloc_in (reldyn_sorting_bfd, arg1, &int_reloc1);
+  bfd_elf32_swap_reloc_in (reldyn_sorting_bfd, arg2, &int_reloc2);
+
+  return ELF32_R_SYM (int_reloc1.r_info) - ELF32_R_SYM (int_reloc2.r_info);
+}
+
+/* Like sort_dynamic_relocs, but used for elf64 relocations.  */
+
+static int
+sort_dynamic_relocs_64 (const void *arg1 ATTRIBUTE_UNUSED,
+			const void *arg2 ATTRIBUTE_UNUSED)
+{
+#ifdef BFD64
+  Elf_Internal_Rela int_reloc1[3];
+  Elf_Internal_Rela int_reloc2[3];
+
+  (*get_elf_backend_data (reldyn_sorting_bfd)->s->swap_reloc_in)
+    (reldyn_sorting_bfd, arg1, int_reloc1);
+  (*get_elf_backend_data (reldyn_sorting_bfd)->s->swap_reloc_in)
+    (reldyn_sorting_bfd, arg2, int_reloc2);
+
+  return (ELF64_R_SYM (int_reloc1[0].r_info)
+	  - ELF64_R_SYM (int_reloc2[0].r_info));
+#else
+  abort ();
+#endif
+}
+
+
+/* This routine is used to write out ECOFF debugging external symbol
+   information.  It is called via brownie32_elf_link_hash_traverse.  The
+   ECOFF external symbol information must match the ELF external
+   symbol information.  Unfortunately, at this point we don't know
+   whether a symbol is required by reloc information, so the two
+   tables may wind up being different.  We must sort out the external
+   symbol information before we can set the final size of the .mdebug
+   section, and we must set the size of the .mdebug section before we
+   can relocate any sections, and we can't know which symbols are
+   required by relocation until we relocate the sections.
+   Fortunately, it is relatively unlikely that any symbol will be
+   stripped but required by a reloc.  In particular, it can not happen
+   when generating a final executable.  */
+
+static bfd_boolean
+brownie32_elf_output_extsym (struct brownie32_elf_link_hash_entry *h, void *data)
+{
+  struct extsym_info *einfo = data;
+  bfd_boolean strip;
+  asection *sec, *output_section;
+
+  if (h->root.root.type == bfd_link_hash_warning)
+    h = (struct brownie32_elf_link_hash_entry *) h->root.root.u.i.link;
+
+  if (h->root.indx == -2)
+    strip = FALSE;
+  else if ((h->root.def_dynamic
+	    || h->root.ref_dynamic
+	    || h->root.type == bfd_link_hash_new)
+	   && !h->root.def_regular
+	   && !h->root.ref_regular)
+    strip = TRUE;
+  else if (einfo->info->strip == strip_all
+	   || (einfo->info->strip == strip_some
+	       && bfd_hash_lookup (einfo->info->keep_hash,
+				   h->root.root.root.string,
+				   FALSE, FALSE) == NULL))
+    strip = TRUE;
+  else
+    strip = FALSE;
+
+  if (strip)
+    return TRUE;
+
+  if (h->esym.ifd == -2)
+    {
+      h->esym.jmptbl = 0;
+      h->esym.cobol_main = 0;
+      h->esym.weakext = 0;
+      h->esym.reserved = 0;
+      h->esym.ifd = ifdNil;
+      h->esym.asym.value = 0;
+      h->esym.asym.st = stGlobal;
+
+      if (h->root.root.type == bfd_link_hash_undefined
+	  || h->root.root.type == bfd_link_hash_undefweak)
+	{
+	  const char *name;
+
+	  /* Use undefined class.  Also, set class and type for some
+             special symbols.  */
+	  name = h->root.root.root.string;
+	  if (strcmp (name, brownie32_elf_dynsym_rtproc_names[0]) == 0
+	      || strcmp (name, brownie32_elf_dynsym_rtproc_names[1]) == 0)
+	    {
+	      h->esym.asym.sc = scData;
+	      h->esym.asym.st = stLabel;
+	      h->esym.asym.value = 0;
+	    }
+	  else if (strcmp (name, brownie32_elf_dynsym_rtproc_names[2]) == 0)
+	    {
+	      h->esym.asym.sc = scAbs;
+	      h->esym.asym.st = stLabel;
+	      h->esym.asym.value =
+		brownie32_elf_hash_table (einfo->info)->procedure_count;
+	    }
+	  else if (strcmp (name, "_gp_disp") == 0 && ! NEWABI_P (einfo->abfd))
+	    {
+	      h->esym.asym.sc = scAbs;
+	      h->esym.asym.st = stLabel;
+	      h->esym.asym.value = elf_gp (einfo->abfd);
+	    }
+	  else
+	    h->esym.asym.sc = scUndefined;
+	}
+      else if (h->root.root.type != bfd_link_hash_defined
+	  && h->root.root.type != bfd_link_hash_defweak)
+	h->esym.asym.sc = scAbs;
+      else
+	{
+	  const char *name;
+
+	  sec = h->root.root.u.def.section;
+	  output_section = sec->output_section;
+
+	  /* When making a shared library and symbol h is the one from
+	     the another shared library, OUTPUT_SECTION may be null.  */
+	  if (output_section == NULL)
+	    h->esym.asym.sc = scUndefined;
+	  else
+	    {
+	      name = bfd_section_name (output_section->owner, output_section);
+
+	      if (strcmp (name, ".text") == 0)
+		h->esym.asym.sc = scText;
+	      else if (strcmp (name, ".data") == 0)
+		h->esym.asym.sc = scData;
+	      else if (strcmp (name, ".sdata") == 0)
+		h->esym.asym.sc = scSData;
+	      else if (strcmp (name, ".rodata") == 0
+		       || strcmp (name, ".rdata") == 0)
+		h->esym.asym.sc = scRData;
+	      else if (strcmp (name, ".bss") == 0)
+		h->esym.asym.sc = scBss;
+	      else if (strcmp (name, ".sbss") == 0)
+		h->esym.asym.sc = scSBss;
+	      else if (strcmp (name, ".init") == 0)
+		h->esym.asym.sc = scInit;
+	      else if (strcmp (name, ".fini") == 0)
+		h->esym.asym.sc = scFini;
+	      else
+		h->esym.asym.sc = scAbs;
+	    }
+	}
+
+      h->esym.asym.reserved = 0;
+      h->esym.asym.index = indexNil;
+    }
+
+  if (h->root.root.type == bfd_link_hash_common)
+    h->esym.asym.value = h->root.root.u.c.size;
+  else if (h->root.root.type == bfd_link_hash_defined
+	   || h->root.root.type == bfd_link_hash_defweak)
+    {
+      if (h->esym.asym.sc == scCommon)
+	h->esym.asym.sc = scBss;
+      else if (h->esym.asym.sc == scSCommon)
+	h->esym.asym.sc = scSBss;
+
+      sec = h->root.root.u.def.section;
+      output_section = sec->output_section;
+      if (output_section != NULL)
+	h->esym.asym.value = (h->root.root.u.def.value
+			      + sec->output_offset
+			      + output_section->vma);
+      else
+	h->esym.asym.value = 0;
+    }
+  else if (h->root.needs_plt)
+    {
+      struct brownie32_elf_link_hash_entry *hd = h;
+      bfd_boolean no_fn_stub = h->no_fn_stub;
+
+      while (hd->root.root.type == bfd_link_hash_indirect)
+	{
+	  hd = (struct brownie32_elf_link_hash_entry *)h->root.root.u.i.link;
+	  no_fn_stub = no_fn_stub || hd->no_fn_stub;
+	}
+
+      if (!no_fn_stub)
+	{
+	  /* Set type and value for a symbol with a function stub.  */
+	  h->esym.asym.st = stProc;
+	  sec = hd->root.root.u.def.section;
+	  if (sec == NULL)
+	    h->esym.asym.value = 0;
+	  else
+	    {
+	      output_section = sec->output_section;
+	      if (output_section != NULL)
+		h->esym.asym.value = (hd->root.plt.offset
+				      + sec->output_offset
+				      + output_section->vma);
+	      else
+		h->esym.asym.value = 0;
+	    }
+	}
+    }
+
+  if (! bfd_ecoff_debug_one_external (einfo->abfd, einfo->debug, einfo->swap,
+				      h->root.root.root.string,
+				      &h->esym))
+    {
+      einfo->failed = TRUE;
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+/* A comparison routine used to sort .gptab entries.  */
+
+static int
+gptab_compare (const void *p1, const void *p2)
+{
+  const Elf32_gptab *a1 = p1;
+  const Elf32_gptab *a2 = p2;
+
+  return a1->gt_entry.gt_g_value - a2->gt_entry.gt_g_value;
+}
+
+/* Functions to manage the got entry hash table.  */
+
+/* Use all 64 bits of a bfd_vma for the computation of a 32-bit
+   hash number.  */
+
+static INLINE hashval_t
+brownie32_elf_hash_bfd_vma (bfd_vma addr)
+{
+#ifdef BFD64
+  return addr + (addr >> 32);
+#else
+  return addr;
+#endif
+}
+
+/* got_entries only match if they're identical, except for gotidx, so
+   use all fields to compute the hash, and compare the appropriate
+   union members.  */
+
+static hashval_t
+brownie32_elf_got_entry_hash (const void *entry_)
+{
+  const struct brownie32_got_entry *entry = (struct brownie32_got_entry *)entry_;
+
+  return entry->symndx
+    + ((entry->tls_type & GOT_TLS_LDM) << 17)
+    + (! entry->abfd ? brownie32_elf_hash_bfd_vma (entry->d.address)
+       : entry->abfd->id
+         + (entry->symndx >= 0 ? brownie32_elf_hash_bfd_vma (entry->d.addend)
+	    : entry->d.h->root.root.root.hash));
+}
+
+static int
+brownie32_elf_got_entry_eq (const void *entry1, const void *entry2)
+{
+  const struct brownie32_got_entry *e1 = (struct brownie32_got_entry *)entry1;
+  const struct brownie32_got_entry *e2 = (struct brownie32_got_entry *)entry2;
+
+  /* An LDM entry can only match another LDM entry.  */
+  if ((e1->tls_type ^ e2->tls_type) & GOT_TLS_LDM)
+    return 0;
+
+  return e1->abfd == e2->abfd && e1->symndx == e2->symndx
+    && (! e1->abfd ? e1->d.address == e2->d.address
+	: e1->symndx >= 0 ? e1->d.addend == e2->d.addend
+	: e1->d.h == e2->d.h);
+}
+
+/* multi_got_entries are still a match in the case of global objects,
+   even if the input bfd in which they're referenced differs, so the
+   hash computation and compare functions are adjusted
+   accordingly.  */
+
+static hashval_t
+brownie32_elf_multi_got_entry_hash (const void *entry_)
+{
+  const struct brownie32_got_entry *entry = (struct brownie32_got_entry *)entry_;
+
+  return entry->symndx
+    + (! entry->abfd
+       ? brownie32_elf_hash_bfd_vma (entry->d.address)
+       : entry->symndx >= 0
+       ? ((entry->tls_type & GOT_TLS_LDM)
+	  ? (GOT_TLS_LDM << 17)
+	  : (entry->abfd->id
+	     + brownie32_elf_hash_bfd_vma (entry->d.addend)))
+       : entry->d.h->root.root.root.hash);
+}
+
+static int
+brownie32_elf_multi_got_entry_eq (const void *entry1, const void *entry2)
+{
+  const struct brownie32_got_entry *e1 = (struct brownie32_got_entry *)entry1;
+  const struct brownie32_got_entry *e2 = (struct brownie32_got_entry *)entry2;
+
+  /* Any two LDM entries match.  */
+  if (e1->tls_type & e2->tls_type & GOT_TLS_LDM)
+    return 1;
+
+  /* Nothing else matches an LDM entry.  */
+  if ((e1->tls_type ^ e2->tls_type) & GOT_TLS_LDM)
+    return 0;
+
+  return e1->symndx == e2->symndx
+    && (e1->symndx >= 0 ? e1->abfd == e2->abfd && e1->d.addend == e2->d.addend
+	: e1->abfd == NULL || e2->abfd == NULL
+	? e1->abfd == e2->abfd && e1->d.address == e2->d.address
+	: e1->d.h == e2->d.h);
+}
+
+/* Returns the dynamic relocation section for DYNOBJ.  */
+
+static asection *
+brownie32_elf_rel_dyn_section (bfd *dynobj, bfd_boolean create_p)
+{
+  static const char dname[] = ".rel.dyn";
+  asection *sreloc;
+
+  sreloc = bfd_get_section_by_name (dynobj, dname);
+  if (sreloc == NULL && create_p)
+    {
+      sreloc = bfd_make_section_with_flags (dynobj, dname,
+					    (SEC_ALLOC
+					     | SEC_LOAD
+					     | SEC_HAS_CONTENTS
+					     | SEC_IN_MEMORY
+					     | SEC_LINKER_CREATED
+					     | SEC_READONLY));
+      if (sreloc == NULL
+	  || ! bfd_set_section_alignment (dynobj, sreloc,
+					  BROWNIE32_ELF_LOG_FILE_ALIGN (dynobj)))
+	return NULL;
+    }
+  return sreloc;
+}
+
+/* Returns the GOT section for ABFD.  */
+
+static asection *
+brownie32_elf_got_section (bfd *abfd, bfd_boolean maybe_excluded)
+{
+  asection *sgot = bfd_get_section_by_name (abfd, ".got");
+  if (sgot == NULL
+      || (! maybe_excluded && (sgot->flags & SEC_EXCLUDE) != 0))
+    return NULL;
+  return sgot;
+}
+
+/* Returns the GOT information associated with the link indicated by
+   INFO.  If SGOTP is non-NULL, it is filled in with the GOT
+   section.  */
+
+static struct brownie32_got_info *
+brownie32_elf_got_info (bfd *abfd, asection **sgotp)
+{
+  asection *sgot;
+  struct brownie32_got_info *g;
+
+  sgot = brownie32_elf_got_section (abfd, TRUE);
+  BFD_ASSERT (sgot != NULL);
+  BFD_ASSERT (brownie32_elf_section_data (sgot) != NULL);
+  g = brownie32_elf_section_data (sgot)->u.got_info;
+  BFD_ASSERT (g != NULL);
+
+  if (sgotp)
+    *sgotp = (sgot->flags & SEC_EXCLUDE) == 0 ? sgot : NULL;
+
+  return g;
+}
+
+/* Count the number of relocations needed for a TLS GOT entry, with
+   access types from TLS_TYPE, and symbol H (or a local symbol if H
+   is NULL).  */
+
+static int
+brownie32_tls_got_relocs (struct bfd_link_info *info, unsigned char tls_type,
+		     struct elf_link_hash_entry *h)
+{
+  int indx = 0;
+  int ret = 0;
+  bfd_boolean need_relocs = FALSE;
+  bfd_boolean dyn = elf_hash_table (info)->dynamic_sections_created;
+
+  if (h && WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
+      && (!info->shared || !SYMBOL_REFERENCES_LOCAL (info, h)))
+    indx = h->dynindx;
+
+  if ((info->shared || indx != 0)
+      && (h == NULL
+	  || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
+	  || h->root.type != bfd_link_hash_undefweak))
+    need_relocs = TRUE;
+
+  if (!need_relocs)
+    return FALSE;
+
+  if (tls_type & GOT_TLS_GD)
+    {
+      ret++;
+      if (indx != 0)
+	ret++;
+    }
+
+  if (tls_type & GOT_TLS_IE)
+    ret++;
+
+  if ((tls_type & GOT_TLS_LDM) && info->shared)
+    ret++;
+
+  return ret;
+}
+
+/* Count the number of TLS relocations required for the GOT entry in
+   ARG1, if it describes a local symbol.  */
+
+static int
+brownie32_elf_count_local_tls_relocs (void **arg1, void *arg2)
+{
+  struct brownie32_got_entry *entry = * (struct brownie32_got_entry **) arg1;
+  struct brownie32_elf_count_tls_arg *arg = arg2;
+
+  if (entry->abfd != NULL && entry->symndx != -1)
+    arg->needed += brownie32_tls_got_relocs (arg->info, entry->tls_type, NULL);
+
+  return 1;
+}
+
+/* Count the number of TLS GOT entries required for the global (or
+   forced-local) symbol in ARG1.  */
+
+static int
+brownie32_elf_count_global_tls_entries (void *arg1, void *arg2)
+{
+  struct brownie32_elf_link_hash_entry *hm
+    = (struct brownie32_elf_link_hash_entry *) arg1;
+  struct brownie32_elf_count_tls_arg *arg = arg2;
+
+  if (hm->tls_type & GOT_TLS_GD)
+    arg->needed += 2;
+  if (hm->tls_type & GOT_TLS_IE)
+    arg->needed += 1;
+
+  return 1;
+}
+
+/* Count the number of TLS relocations required for the global (or
+   forced-local) symbol in ARG1.  */
+
+static int
+brownie32_elf_count_global_tls_relocs (void *arg1, void *arg2)
+{
+  struct brownie32_elf_link_hash_entry *hm
+    = (struct brownie32_elf_link_hash_entry *) arg1;
+  struct brownie32_elf_count_tls_arg *arg = arg2;
+
+  arg->needed += brownie32_tls_got_relocs (arg->info, hm->tls_type, &hm->root);
+
+  return 1;
+}
+
+/* Output a simple dynamic relocation into SRELOC.  */
+
+static void
+brownie32_elf_output_dynamic_relocation (bfd *output_bfd,
+				    asection *sreloc,
+				    unsigned long indx,
+				    int r_type,
+				    bfd_vma offset)
+{
+  Elf_Internal_Rela rel[3];
+
+  memset (rel, 0, sizeof (rel));
+
+  rel[0].r_info = ELF_R_INFO (output_bfd, indx, r_type);
+  rel[0].r_offset = rel[1].r_offset = rel[2].r_offset = offset;
+
+  if (ABI_64_P (output_bfd))
+    {
+      (*get_elf_backend_data (output_bfd)->s->swap_reloc_out)
+	(output_bfd, &rel[0],
+	 (sreloc->contents
+	  + sreloc->reloc_count * sizeof (Elf64_Mips_External_Rel)));
+    }
+  else
+    bfd_elf32_swap_reloc_out
+      (output_bfd, &rel[0],
+       (sreloc->contents
+	+ sreloc->reloc_count * sizeof (Elf32_External_Rel)));
+  ++sreloc->reloc_count;
+}
+
+/* Initialize a set of TLS GOT entries for one symbol.  */
+
+static void
+brownie32_elf_initialize_tls_slots (bfd *abfd, bfd_vma got_offset,
+			       unsigned char *tls_type_p,
+			       struct bfd_link_info *info,
+			       struct brownie32_elf_link_hash_entry *h,
+			       bfd_vma value)
+{
+  int indx;
+  asection *sreloc, *sgot;
+  bfd_vma offset, offset2;
+  bfd *dynobj;
+  bfd_boolean need_relocs = FALSE;
+
+  dynobj = elf_hash_table (info)->dynobj;
+  sgot = brownie32_elf_got_section (dynobj, FALSE);
+
+  indx = 0;
+  if (h != NULL)
+    {
+      bfd_boolean dyn = elf_hash_table (info)->dynamic_sections_created;
+
+      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, &h->root)
+	  && (!info->shared || !SYMBOL_REFERENCES_LOCAL (info, &h->root)))
+	indx = h->root.dynindx;
+    }
+
+  if (*tls_type_p & GOT_TLS_DONE)
+    return;
+
+  if ((info->shared || indx != 0)
+      && (h == NULL
+	  || ELF_ST_VISIBILITY (h->root.other) == STV_DEFAULT
+	  || h->root.type != bfd_link_hash_undefweak))
+    need_relocs = TRUE;
+
+  /* MINUS_ONE means the symbol is not defined in this object.  It may not
+     be defined at all; assume that the value doesn't matter in that
+     case.  Otherwise complain if we would use the value.  */
+  BFD_ASSERT (value != MINUS_ONE || (indx != 0 && need_relocs)
+	      || h->root.root.type == bfd_link_hash_undefweak);
+
+  /* Emit necessary relocations.  */
+  sreloc = brownie32_elf_rel_dyn_section (dynobj, FALSE);
+
+  /* General Dynamic.  */
+  if (*tls_type_p & GOT_TLS_GD)
+    {
+      offset = got_offset;
+      offset2 = offset + BROWNIE32_ELF_GOT_SIZE (abfd);
+
+      if (need_relocs)
+	{
+	  brownie32_elf_output_dynamic_relocation
+	    (abfd, sreloc, indx,
+	     ABI_64_P (abfd) ? R_BROWNIE32_TLS_DTPMOD64 : R_BROWNIE32_TLS_DTPMOD32,
+	     sgot->output_offset + sgot->output_section->vma + offset);
+
+	  if (indx)
+	    brownie32_elf_output_dynamic_relocation
+	      (abfd, sreloc, indx,
+	       ABI_64_P (abfd) ? R_BROWNIE32_TLS_DTPREL64 : R_BROWNIE32_TLS_DTPREL32,
+	       sgot->output_offset + sgot->output_section->vma + offset2);
+	  else
+	    BROWNIE32_ELF_PUT_WORD (abfd, value - dtprel_base (info),
+			       sgot->contents + offset2);
+	}
+      else
+	{
+	  BROWNIE32_ELF_PUT_WORD (abfd, 1,
+			     sgot->contents + offset);
+	  BROWNIE32_ELF_PUT_WORD (abfd, value - dtprel_base (info),
+			     sgot->contents + offset2);
+	}
+
+      got_offset += 2 * BROWNIE32_ELF_GOT_SIZE (abfd);
+    }
+
+  /* Initial Exec model.  */
+  if (*tls_type_p & GOT_TLS_IE)
+    {
+      offset = got_offset;
+
+      if (need_relocs)
+	{
+	  if (indx == 0)
+	    BROWNIE32_ELF_PUT_WORD (abfd, value - elf_hash_table (info)->tls_sec->vma,
+			       sgot->contents + offset);
+	  else
+	    BROWNIE32_ELF_PUT_WORD (abfd, 0,
+			       sgot->contents + offset);
+
+	  brownie32_elf_output_dynamic_relocation
+	    (abfd, sreloc, indx,
+	     ABI_64_P (abfd) ? R_BROWNIE32_TLS_TPREL64 : R_BROWNIE32_TLS_TPREL32,
+	     sgot->output_offset + sgot->output_section->vma + offset);
+	}
+      else
+	BROWNIE32_ELF_PUT_WORD (abfd, value - tprel_base (info),
+			   sgot->contents + offset);
+    }
+
+  if (*tls_type_p & GOT_TLS_LDM)
+    {
+      /* The initial offset is zero, and the LD offsets will include the
+	 bias by DTP_OFFSET.  */
+      BROWNIE32_ELF_PUT_WORD (abfd, 0,
+			 sgot->contents + got_offset
+			 + BROWNIE32_ELF_GOT_SIZE (abfd));
+
+      if (!info->shared)
+	BROWNIE32_ELF_PUT_WORD (abfd, 1,
+			   sgot->contents + got_offset);
+      else
+	brownie32_elf_output_dynamic_relocation
+	  (abfd, sreloc, indx,
+	   ABI_64_P (abfd) ? R_BROWNIE32_TLS_DTPMOD64 : R_BROWNIE32_TLS_DTPMOD32,
+	   sgot->output_offset + sgot->output_section->vma + got_offset);
+    }
+
+  *tls_type_p |= GOT_TLS_DONE;
+}
+
+/* Return the GOT index to use for a relocation of type R_TYPE against
+   a symbol accessed using TLS_TYPE models.  The GOT entries for this
+   symbol in this GOT start at GOT_INDEX.  This function initializes the
+   GOT entries and corresponding relocations.  */
+
+static bfd_vma
+brownie32_tls_got_index (bfd *abfd, bfd_vma got_index, unsigned char *tls_type,
+		    int r_type, struct bfd_link_info *info,
+		    struct brownie32_elf_link_hash_entry *h, bfd_vma symbol)
+{
+  BFD_ASSERT (r_type == R_BROWNIE32_TLS_GOTTPREL || r_type == R_BROWNIE32_TLS_GD
+	      || r_type == R_BROWNIE32_TLS_LDM);
+
+  brownie32_elf_initialize_tls_slots (abfd, got_index, tls_type, info, h, symbol);
+
+  if (r_type == R_BROWNIE32_TLS_GOTTPREL)
+    {
+      BFD_ASSERT (*tls_type & GOT_TLS_IE);
+      if (*tls_type & GOT_TLS_GD)
+	return got_index + 2 * BROWNIE32_ELF_GOT_SIZE (abfd);
+      else
+	return got_index;
+    }
+
+  if (r_type == R_BROWNIE32_TLS_GD)
+    {
+      BFD_ASSERT (*tls_type & GOT_TLS_GD);
+      return got_index;
+    }
+
+  if (r_type == R_BROWNIE32_TLS_LDM)
+    {
+      BFD_ASSERT (*tls_type & GOT_TLS_LDM);
+      return got_index;
+    }
+
+  return got_index;
+}
+
+/* Returns the GOT offset at which the indicated address can be found.
+   If there is not yet a GOT entry for this value, create one.  If
+   R_SYMNDX refers to a TLS symbol, create a TLS GOT entry instead.
+   Returns -1 if no satisfactory GOT offset can be found.  */
+
+static bfd_vma
+brownie32_elf_local_got_index (bfd *abfd, bfd *ibfd, struct bfd_link_info *info,
+			  bfd_vma value, unsigned long r_symndx,
+			  struct brownie32_elf_link_hash_entry *h, int r_type)
+{
+  asection *sgot;
+  struct brownie32_got_info *g;
+  struct brownie32_got_entry *entry;
+
+  g = brownie32_elf_got_info (elf_hash_table (info)->dynobj, &sgot);
+
+  entry = brownie32_elf_create_local_got_entry (abfd, ibfd, g, sgot, value,
+					   r_symndx, h, r_type);
+  if (!entry)
+    return MINUS_ONE;
+
+  if (TLS_RELOC_P (r_type))
+    return brownie32_tls_got_index (abfd, entry->gotidx, &entry->tls_type, r_type,
+			       info, h, value);
+  else
+    return entry->gotidx;
+}
+
+/* Returns the GOT index for the global symbol indicated by H.  */
+
+static bfd_vma
+brownie32_elf_global_got_index (bfd *abfd, bfd *ibfd, struct elf_link_hash_entry *h,
+			   int r_type, struct bfd_link_info *info)
+{
+  bfd_vma index;
+  asection *sgot;
+  struct brownie32_got_info *g, *gg;
+  long global_got_dynindx = 0;
+
+  gg = g = brownie32_elf_got_info (abfd, &sgot);
+  if (g->bfd2got && ibfd)
+    {
+      struct brownie32_got_entry e, *p;
+
+      BFD_ASSERT (h->dynindx >= 0);
+
+      g = brownie32_elf_got_for_ibfd (g, ibfd);
+      if (g->next != gg || TLS_RELOC_P (r_type))
+	{
+	  e.abfd = ibfd;
+	  e.symndx = -1;
+	  e.d.h = (struct brownie32_elf_link_hash_entry *)h;
+	  e.tls_type = 0;
+
+	  p = htab_find (g->got_entries, &e);
+
+	  BFD_ASSERT (p->gotidx > 0);
+
+	  if (TLS_RELOC_P (r_type))
+	    {
+	      bfd_vma value = MINUS_ONE;
+	      if ((h->root.type == bfd_link_hash_defined
+		   || h->root.type == bfd_link_hash_defweak)
+		  && h->root.u.def.section->output_section)
+		value = (h->root.u.def.value
+			 + h->root.u.def.section->output_offset
+			 + h->root.u.def.section->output_section->vma);
+
+	      return brownie32_tls_got_index (abfd, p->gotidx, &p->tls_type, r_type,
+					 info, e.d.h, value);
+	    }
+	  else
+	    return p->gotidx;
+	}
+    }
+
+  if (gg->global_gotsym != NULL)
+    global_got_dynindx = gg->global_gotsym->dynindx;
+
+  if (TLS_RELOC_P (r_type))
+    {
+      struct brownie32_elf_link_hash_entry *hm
+	= (struct brownie32_elf_link_hash_entry *) h;
+      bfd_vma value = MINUS_ONE;
+
+      if ((h->root.type == bfd_link_hash_defined
+	   || h->root.type == bfd_link_hash_defweak)
+	  && h->root.u.def.section->output_section)
+	value = (h->root.u.def.value
+		 + h->root.u.def.section->output_offset
+		 + h->root.u.def.section->output_section->vma);
+
+      index = brownie32_tls_got_index (abfd, hm->tls_got_offset, &hm->tls_type,
+				  r_type, info, hm, value);
+    }
+  else
+    {
+      /* Once we determine the global GOT entry with the lowest dynamic
+	 symbol table index, we must put all dynamic symbols with greater
+	 indices into the GOT.  That makes it easy to calculate the GOT
+	 offset.  */
+      BFD_ASSERT (h->dynindx >= global_got_dynindx);
+      index = ((h->dynindx - global_got_dynindx + g->local_gotno)
+	       * BROWNIE32_ELF_GOT_SIZE (abfd));
+    }
+  BFD_ASSERT (index < sgot->size);
+
+  return index;
+}
+
+/* Find a GOT entry that is within 32KB of the VALUE.  These entries
+   are supposed to be placed at small offsets in the GOT, i.e.,
+   within 32KB of GP.  Return the index into the GOT for this page,
+   and store the offset from this entry to the desired address in
+   OFFSETP, if it is non-NULL.  */
+
+static bfd_vma
+brownie32_elf_got_page (bfd *abfd, bfd *ibfd, struct bfd_link_info *info,
+		   bfd_vma value, bfd_vma *offsetp)
+{
+  asection *sgot;
+  struct brownie32_got_info *g;
+  bfd_vma index;
+  struct brownie32_got_entry *entry;
+
+  g = brownie32_elf_got_info (elf_hash_table (info)->dynobj, &sgot);
+
+  entry = brownie32_elf_create_local_got_entry (abfd, ibfd, g, sgot,
+					   (value + 0x8000)
+					   & (~(bfd_vma)0xffff), 0,
+					   NULL, R_BROWNIE32_GOT_PAGE);
+
+  if (!entry)
+    return MINUS_ONE;
+
+  index = entry->gotidx;
+
+  if (offsetp)
+    *offsetp = value - entry->d.address;
+
+  return index;
+}
+
+/* Find a GOT entry whose higher-order 16 bits are the same as those
+   for value.  Return the index into the GOT for this entry.  */
+
+static bfd_vma
+brownie32_elf_got16_entry (bfd *abfd, bfd *ibfd, struct bfd_link_info *info,
+		      bfd_vma value, bfd_boolean external)
+{
+  asection *sgot;
+  struct brownie32_got_info *g;
+  struct brownie32_got_entry *entry;
+
+  if (! external)
+    {
+      /* Although the ABI says that it is "the high-order 16 bits" that we
+	 want, it is really the %high value.  The complete value is
+	 calculated with a `addiu' of a LO16 relocation, just as with a
+	 HI16/LO16 pair.  */
+      value = brownie32_elf_high (value) << 16;
+    }
+
+  g = brownie32_elf_got_info (elf_hash_table (info)->dynobj, &sgot);
+
+  entry = brownie32_elf_create_local_got_entry (abfd, ibfd, g, sgot, value, 0, NULL,
+					   R_BROWNIE32_GOT16);
+  if (entry)
+    return entry->gotidx;
+  else
+    return MINUS_ONE;
+}
+
+/* Returns the offset for the entry at the INDEXth position
+   in the GOT.  */
+
+static bfd_vma
+brownie32_elf_got_offset_from_index (bfd *dynobj, bfd *output_bfd,
+				bfd *input_bfd, bfd_vma index)
+{
+  asection *sgot;
+  bfd_vma gp;
+  struct brownie32_got_info *g;
+
+  g = brownie32_elf_got_info (dynobj, &sgot);
+  gp = _bfd_get_gp_value (output_bfd)
+    + brownie32_elf_adjust_gp (output_bfd, g, input_bfd);
+
+  return sgot->output_section->vma + sgot->output_offset + index - gp;
+}
+
+/* Create a local GOT entry for VALUE.  Return the index of the entry,
+   or -1 if it could not be created.  If R_SYMNDX refers to a TLS symbol,
+   create a TLS entry instead.  */
+
+static struct brownie32_got_entry *
+brownie32_elf_create_local_got_entry (bfd *abfd, bfd *ibfd,
+				 struct brownie32_got_info *gg,
+				 asection *sgot, bfd_vma value,
+				 unsigned long r_symndx,
+				 struct brownie32_elf_link_hash_entry *h,
+				 int r_type)
+{
+  struct brownie32_got_entry entry, **loc;
+  struct brownie32_got_info *g;
+
+  entry.abfd = NULL;
+  entry.symndx = -1;
+  entry.d.address = value;
+  entry.tls_type = 0;
+
+  g = brownie32_elf_got_for_ibfd (gg, ibfd);
+  if (g == NULL)
+    {
+      g = brownie32_elf_got_for_ibfd (gg, abfd);
+      BFD_ASSERT (g != NULL);
+    }
+
+  /* We might have a symbol, H, if it has been forced local.  Use the
+     global entry then.  It doesn't matter whether an entry is local
+     or global for TLS, since the dynamic linker does not
+     automatically relocate TLS GOT entries.  */
+  BFD_ASSERT (h == NULL || h->root.forced_local);
+  if (TLS_RELOC_P (r_type))
+    {
+      struct brownie32_got_entry *p;
+
+      entry.abfd = ibfd;
+      if (r_type == R_BROWNIE32_TLS_LDM)
+	{
+	  entry.tls_type = GOT_TLS_LDM;
+	  entry.symndx = 0;
+	  entry.d.addend = 0;
+	}
+      else if (h == NULL)
+	{
+	  entry.symndx = r_symndx;
+	  entry.d.addend = 0;
+	}
+      else
+	entry.d.h = h;
+
+      p = (struct brownie32_got_entry *)
+	htab_find (g->got_entries, &entry);
+
+      BFD_ASSERT (p);
+      return p;
+    }
+
+  loc = (struct brownie32_got_entry **) htab_find_slot (g->got_entries, &entry,
+						   INSERT);
+  if (*loc)
+    return *loc;
+
+  entry.gotidx = BROWNIE32_ELF_GOT_SIZE (abfd) * g->assigned_gotno++;
+  entry.tls_type = 0;
+
+  *loc = (struct brownie32_got_entry *)bfd_alloc (abfd, sizeof entry);
+
+  if (! *loc)
+    return NULL;
+
+  memcpy (*loc, &entry, sizeof entry);
+
+  if (g->assigned_gotno >= g->local_gotno)
+    {
+      (*loc)->gotidx = -1;
+      /* We didn't allocate enough space in the GOT.  */
+      (*_bfd_error_handler)
+	(_("not enough GOT space for local GOT entries"));
+      bfd_set_error (bfd_error_bad_value);
+      return NULL;
+    }
+
+  BROWNIE32_ELF_PUT_WORD (abfd, value,
+		     (sgot->contents + entry.gotidx));
+
+  return *loc;
+}
+
+/* Sort the dynamic symbol table so that symbols that need GOT entries
+   appear towards the end.  This reduces the amount of GOT space
+   required.  MAX_LOCAL is used to set the number of local symbols
+   known to be in the dynamic symbol table.  During
+   _bfd_brownie32_elf_size_dynamic_sections, this value is 1.  Afterward, the
+   section symbols are added and the count is higher.  */
+
+static bfd_boolean
+brownie32_elf_sort_hash_table (struct bfd_link_info *info, unsigned long max_local)
+{
+  struct brownie32_elf_hash_sort_data hsd;
+  struct brownie32_got_info *g;
+  bfd *dynobj;
+
+  dynobj = elf_hash_table (info)->dynobj;
+
+  g = brownie32_elf_got_info (dynobj, NULL);
+
+  hsd.low = NULL;
+  hsd.max_unref_got_dynindx =
+  hsd.min_got_dynindx = elf_hash_table (info)->dynsymcount
+    /* In the multi-got case, assigned_gotno of the master got_info
+       indicate the number of entries that aren't referenced in the
+       primary GOT, but that must have entries because there are
+       dynamic relocations that reference it.  Since they aren't
+       referenced, we move them to the end of the GOT, so that they
+       don't prevent other entries that are referenced from getting
+       too large offsets.  */
+    - (g->next ? g->assigned_gotno : 0);
+  hsd.max_non_got_dynindx = max_local;
+  brownie32_elf_link_hash_traverse (((struct brownie32_elf_link_hash_table *)
+				elf_hash_table (info)),
+			       brownie32_elf_sort_hash_table_f,
+			       &hsd);
+
+  /* There should have been enough room in the symbol table to
+     accommodate both the GOT and non-GOT symbols.  */
+  BFD_ASSERT (hsd.max_non_got_dynindx <= hsd.min_got_dynindx);
+  BFD_ASSERT ((unsigned long)hsd.max_unref_got_dynindx
+	      <= elf_hash_table (info)->dynsymcount);
+
+  /* Now we know which dynamic symbol has the lowest dynamic symbol
+     table index in the GOT.  */
+  g->global_gotsym = hsd.low;
+
+  return TRUE;
+}
+
+/* If H needs a GOT entry, assign it the highest available dynamic
+   index.  Otherwise, assign it the lowest available dynamic
+   index.  */
+
+static bfd_boolean
+brownie32_elf_sort_hash_table_f (struct brownie32_elf_link_hash_entry *h, void *data)
+{
+  struct brownie32_elf_hash_sort_data *hsd = data;
+
+  if (h->root.root.type == bfd_link_hash_warning)
+    h = (struct brownie32_elf_link_hash_entry *) h->root.root.u.i.link;
+
+  /* Symbols without dynamic symbol table entries aren't interesting
+     at all.  */
+  if (h->root.dynindx == -1)
+    return TRUE;
+
+  /* Global symbols that need GOT entries that are not explicitly
+     referenced are marked with got offset 2.  Those that are
+     referenced get a 1, and those that don't need GOT entries get
+     -1.  */
+  if (h->root.got.offset == 2)
+    {
+      BFD_ASSERT (h->tls_type == GOT_NORMAL);
+
+      if (hsd->max_unref_got_dynindx == hsd->min_got_dynindx)
+	hsd->low = (struct elf_link_hash_entry *) h;
+      h->root.dynindx = hsd->max_unref_got_dynindx++;
+    }
+  else if (h->root.got.offset != 1)
+    h->root.dynindx = hsd->max_non_got_dynindx++;
+  else
+    {
+      BFD_ASSERT (h->tls_type == GOT_NORMAL);
+
+      h->root.dynindx = --hsd->min_got_dynindx;
+      hsd->low = (struct elf_link_hash_entry *) h;
+    }
+
+  return TRUE;
+}
+
+/* If H is a symbol that needs a global GOT entry, but has a dynamic
+   symbol table index lower than any we've seen to date, record it for
+   posterity.  */
+
+static bfd_boolean
+brownie32_elf_record_global_got_symbol (struct elf_link_hash_entry *h,
+				   bfd *abfd, struct bfd_link_info *info,
+				   struct brownie32_got_info *g,
+				   unsigned char tls_flag)
+{
+  struct brownie32_got_entry entry, **loc;
+
+  /* A global symbol in the GOT must also be in the dynamic symbol
+     table.  */
+  if (h->dynindx == -1)
+    {
+      switch (ELF_ST_VISIBILITY (h->other))
+	{
+	case STV_INTERNAL:
+	case STV_HIDDEN:
+	  _bfd_brownie32_elf_hide_symbol (info, h, TRUE);
+	  break;
+	}
+      if (!bfd_elf_link_record_dynamic_symbol (info, h))
+	return FALSE;
+    }
+
+  entry.abfd = abfd;
+  entry.symndx = -1;
+  entry.d.h = (struct brownie32_elf_link_hash_entry *) h;
+  entry.tls_type = 0;
+
+  loc = (struct brownie32_got_entry **) htab_find_slot (g->got_entries, &entry,
+						   INSERT);
+
+  /* If we've already marked this entry as needing GOT space, we don't
+     need to do it again.  */
+  if (*loc)
+    {
+      (*loc)->tls_type |= tls_flag;
+      return TRUE;
+    }
+
+  *loc = (struct brownie32_got_entry *)bfd_alloc (abfd, sizeof entry);
+
+  if (! *loc)
+    return FALSE;
+
+  entry.gotidx = -1;
+  entry.tls_type = tls_flag;
+
+  memcpy (*loc, &entry, sizeof entry);
+
+  if (h->got.offset != MINUS_ONE)
+    return TRUE;
+
+  /* By setting this to a value other than -1, we are indicating that
+     there needs to be a GOT entry for H.  Avoid using zero, as the
+     generic ELF copy_indirect_symbol tests for <= 0.  */
+  if (tls_flag == 0)
+    h->got.offset = 1;
+
+  return TRUE;
+}
+
+/* Reserve space in G for a GOT entry containing the value of symbol
+   SYMNDX in input bfd ABDF, plus ADDEND.  */
+
+static bfd_boolean
+brownie32_elf_record_local_got_symbol (bfd *abfd, long symndx, bfd_vma addend,
+				  struct brownie32_got_info *g,
+				  unsigned char tls_flag)
+{
+  struct brownie32_got_entry entry, **loc;
+
+  entry.abfd = abfd;
+  entry.symndx = symndx;
+  entry.d.addend = addend;
+  entry.tls_type = tls_flag;
+  loc = (struct brownie32_got_entry **)
+    htab_find_slot (g->got_entries, &entry, INSERT);
+
+  if (*loc)
+    {
+      if (tls_flag == GOT_TLS_GD && !((*loc)->tls_type & GOT_TLS_GD))
+	{
+	  g->tls_gotno += 2;
+	  (*loc)->tls_type |= tls_flag;
+	}
+      else if (tls_flag == GOT_TLS_IE && !((*loc)->tls_type & GOT_TLS_IE))
+	{
+	  g->tls_gotno += 1;
+	  (*loc)->tls_type |= tls_flag;
+	}
+      return TRUE;
+    }
+
+  if (tls_flag != 0)
+    {
+      entry.gotidx = -1;
+      entry.tls_type = tls_flag;
+      if (tls_flag == GOT_TLS_IE)
+	g->tls_gotno += 1;
+      else if (tls_flag == GOT_TLS_GD)
+	g->tls_gotno += 2;
+      else if (g->tls_ldm_offset == MINUS_ONE)
+	{
+	  g->tls_ldm_offset = MINUS_TWO;
+	  g->tls_gotno += 2;
+	}
+    }
+  else
+    {
+      entry.gotidx = g->local_gotno++;
+      entry.tls_type = 0;
+    }
+
+  *loc = (struct brownie32_got_entry *)bfd_alloc (abfd, sizeof entry);
+
+  if (! *loc)
+    return FALSE;
+
+  memcpy (*loc, &entry, sizeof entry);
+
+  return TRUE;
+}
+
+/* Compute the hash value of the bfd in a bfd2got hash entry.  */
+
+static hashval_t
+brownie32_elf_bfd2got_entry_hash (const void *entry_)
+{
+  const struct brownie32_elf_bfd2got_hash *entry
+    = (struct brownie32_elf_bfd2got_hash *)entry_;
+
+  return entry->bfd->id;
+}
+
+/* Check whether two hash entries have the same bfd.  */
+
+static int
+brownie32_elf_bfd2got_entry_eq (const void *entry1, const void *entry2)
+{
+  const struct brownie32_elf_bfd2got_hash *e1
+    = (const struct brownie32_elf_bfd2got_hash *)entry1;
+  const struct brownie32_elf_bfd2got_hash *e2
+    = (const struct brownie32_elf_bfd2got_hash *)entry2;
+
+  return e1->bfd == e2->bfd;
+}
+
+/* In a multi-got link, determine the GOT to be used for IBDF.  G must
+   be the master GOT data.  */
+
+static struct brownie32_got_info *
+brownie32_elf_got_for_ibfd (struct brownie32_got_info *g, bfd *ibfd)
+{
+  struct brownie32_elf_bfd2got_hash e, *p;
+
+  if (! g->bfd2got)
+    return g;
+
+  e.bfd = ibfd;
+  p = htab_find (g->bfd2got, &e);
+  return p ? p->g : NULL;
+}
+
+/* Create one separate got for each bfd that has entries in the global
+   got, such that we can tell how many local and global entries each
+   bfd requires.  */
+
+static int
+brownie32_elf_make_got_per_bfd (void **entryp, void *p)
+{
+  struct brownie32_got_entry *entry = (struct brownie32_got_entry *)*entryp;
+  struct brownie32_elf_got_per_bfd_arg *arg = (struct brownie32_elf_got_per_bfd_arg *)p;
+  htab_t bfd2got = arg->bfd2got;
+  struct brownie32_got_info *g;
+  struct brownie32_elf_bfd2got_hash bfdgot_entry, *bfdgot;
+  void **bfdgotp;
+
+  /* Find the got_info for this GOT entry's input bfd.  Create one if
+     none exists.  */
+  bfdgot_entry.bfd = entry->abfd;
+  bfdgotp = htab_find_slot (bfd2got, &bfdgot_entry, INSERT);
+  bfdgot = (struct brownie32_elf_bfd2got_hash *)*bfdgotp;
+
+  if (bfdgot != NULL)
+    g = bfdgot->g;
+  else
+    {
+      bfdgot = (struct brownie32_elf_bfd2got_hash *)bfd_alloc
+	(arg->obfd, sizeof (struct brownie32_elf_bfd2got_hash));
+
+      if (bfdgot == NULL)
+	{
+	  arg->obfd = 0;
+	  return 0;
+	}
+
+      *bfdgotp = bfdgot;
+
+      bfdgot->bfd = entry->abfd;
+      bfdgot->g = g = (struct brownie32_got_info *)
+	bfd_alloc (arg->obfd, sizeof (struct brownie32_got_info));
+      if (g == NULL)
+	{
+	  arg->obfd = 0;
+	  return 0;
+	}
+
+      g->global_gotsym = NULL;
+      g->global_gotno = 0;
+      g->local_gotno = 0;
+      g->assigned_gotno = -1;
+      g->tls_gotno = 0;
+      g->tls_assigned_gotno = 0;
+      g->tls_ldm_offset = MINUS_ONE;
+      g->got_entries = htab_try_create (1, brownie32_elf_multi_got_entry_hash,
+					brownie32_elf_multi_got_entry_eq, NULL);
+      if (g->got_entries == NULL)
+	{
+	  arg->obfd = 0;
+	  return 0;
+	}
+
+      g->bfd2got = NULL;
+      g->next = NULL;
+    }
+
+  /* Insert the GOT entry in the bfd's got entry hash table.  */
+  entryp = htab_find_slot (g->got_entries, entry, INSERT);
+  if (*entryp != NULL)
+    return 1;
+
+  *entryp = entry;
+
+  if (entry->tls_type)
+    {
+      if (entry->tls_type & (GOT_TLS_GD | GOT_TLS_LDM))
+	g->tls_gotno += 2;
+      if (entry->tls_type & GOT_TLS_IE)
+	g->tls_gotno += 1;
+    }
+  else if (entry->symndx >= 0 || entry->d.h->forced_local)
+    ++g->local_gotno;
+  else
+    ++g->global_gotno;
+
+  return 1;
+}
+
+/* Attempt to merge gots of different input bfds.  Try to use as much
+   as possible of the primary got, since it doesn't require explicit
+   dynamic relocations, but don't use bfds that would reference global
+   symbols out of the addressable range.  Failing the primary got,
+   attempt to merge with the current got, or finish the current got
+   and then make make the new got current.  */
+
+static int
+brownie32_elf_merge_gots (void **bfd2got_, void *p)
+{
+  struct brownie32_elf_bfd2got_hash *bfd2got
+    = (struct brownie32_elf_bfd2got_hash *)*bfd2got_;
+  struct brownie32_elf_got_per_bfd_arg *arg = (struct brownie32_elf_got_per_bfd_arg *)p;
+  unsigned int lcount = bfd2got->g->local_gotno;
+  unsigned int gcount = bfd2got->g->global_gotno;
+  unsigned int tcount = bfd2got->g->tls_gotno;
+  unsigned int maxcnt = arg->max_count;
+  bfd_boolean too_many_for_tls = FALSE;
+
+  /* We place TLS GOT entries after both locals and globals.  The globals
+     for the primary GOT may overflow the normal GOT size limit, so be
+     sure not to merge a GOT which requires TLS with the primary GOT in that
+     case.  This doesn't affect non-primary GOTs.  */
+  if (tcount > 0)
+    {
+      unsigned int primary_total = lcount + tcount + arg->global_count;
+      if (primary_total * BROWNIE32_ELF_GOT_SIZE (bfd2got->bfd)
+	   >= BROWNIE32_ELF_GOT_MAX_SIZE (bfd2got->bfd))
+	too_many_for_tls = TRUE;
+    }
+
+  /* If we don't have a primary GOT and this is not too big, use it as
+     a starting point for the primary GOT.  */
+  if (! arg->primary && lcount + gcount + tcount <= maxcnt
+      && ! too_many_for_tls)
+    {
+      arg->primary = bfd2got->g;
+      arg->primary_count = lcount + gcount;
+    }
+  /* If it looks like we can merge this bfd's entries with those of
+     the primary, merge them.  The heuristics is conservative, but we
+     don't have to squeeze it too hard.  */
+  else if (arg->primary && ! too_many_for_tls
+	   && (arg->primary_count + lcount + gcount + tcount) <= maxcnt)
+    {
+      struct brownie32_got_info *g = bfd2got->g;
+      int old_lcount = arg->primary->local_gotno;
+      int old_gcount = arg->primary->global_gotno;
+      int old_tcount = arg->primary->tls_gotno;
+
+      bfd2got->g = arg->primary;
+
+      htab_traverse (g->got_entries,
+		     brownie32_elf_make_got_per_bfd,
+		     arg);
+      if (arg->obfd == NULL)
+	return 0;
+
+      htab_delete (g->got_entries);
+      /* We don't have to worry about releasing memory of the actual
+	 got entries, since they're all in the master got_entries hash
+	 table anyway.  */
+
+      BFD_ASSERT (old_lcount + lcount >= arg->primary->local_gotno);
+      BFD_ASSERT (old_gcount + gcount >= arg->primary->global_gotno);
+      BFD_ASSERT (old_tcount + tcount >= arg->primary->tls_gotno);
+
+      arg->primary_count = arg->primary->local_gotno
+	+ arg->primary->global_gotno + arg->primary->tls_gotno;
+    }
+  /* If we can merge with the last-created got, do it.  */
+  else if (arg->current
+	   && arg->current_count + lcount + gcount + tcount <= maxcnt)
+    {
+      struct brownie32_got_info *g = bfd2got->g;
+      int old_lcount = arg->current->local_gotno;
+      int old_gcount = arg->current->global_gotno;
+      int old_tcount = arg->current->tls_gotno;
+
+      bfd2got->g = arg->current;
+
+      htab_traverse (g->got_entries,
+		     brownie32_elf_make_got_per_bfd,
+		     arg);
+      if (arg->obfd == NULL)
+	return 0;
+
+      htab_delete (g->got_entries);
+
+      BFD_ASSERT (old_lcount + lcount >= arg->current->local_gotno);
+      BFD_ASSERT (old_gcount + gcount >= arg->current->global_gotno);
+      BFD_ASSERT (old_tcount + tcount >= arg->current->tls_gotno);
+
+      arg->current_count = arg->current->local_gotno
+	+ arg->current->global_gotno + arg->current->tls_gotno;
+    }
+  /* Well, we couldn't merge, so create a new GOT.  Don't check if it
+     fits; if it turns out that it doesn't, we'll get relocation
+     overflows anyway.  */
+  else
+    {
+      bfd2got->g->next = arg->current;
+      arg->current = bfd2got->g;
+
+      arg->current_count = lcount + gcount + 2 * tcount;
+    }
+
+  return 1;
+}
+
+/* Set the TLS GOT index for the GOT entry in ENTRYP.  */
+
+static int
+brownie32_elf_initialize_tls_index (void **entryp, void *p)
+{
+  struct brownie32_got_entry *entry = (struct brownie32_got_entry *)*entryp;
+  struct brownie32_got_info *g = p;
+
+  /* We're only interested in TLS symbols.  */
+  if (entry->tls_type == 0)
+    return 1;
+
+  if (entry->symndx == -1)
+    {
+      /* There may be multiple brownie32_got_entry structs for a global variable
+	 if there is just one GOT.  Just do this once.  */
+      if (g->next == NULL)
+	{
+	  if (entry->d.h->tls_type & GOT_TLS_OFFSET_DONE)
+	    return 1;
+	  entry->d.h->tls_type |= GOT_TLS_OFFSET_DONE;
+	}
+    }
+  else if (entry->tls_type & GOT_TLS_LDM)
+    {
+      /* Similarly, there may be multiple structs for the LDM entry.  */
+      if (g->tls_ldm_offset != MINUS_TWO && g->tls_ldm_offset != MINUS_ONE)
+	{
+	  entry->gotidx = g->tls_ldm_offset;
+	  return 1;
+	}
+    }
+
+  /* Initialize the GOT offset.  */
+  entry->gotidx = BROWNIE32_ELF_GOT_SIZE (entry->abfd) * (long) g->tls_assigned_gotno;
+  if (g->next == NULL && entry->symndx == -1)
+    entry->d.h->tls_got_offset = entry->gotidx;
+
+  if (entry->tls_type & (GOT_TLS_GD | GOT_TLS_LDM))
+    g->tls_assigned_gotno += 2;
+  if (entry->tls_type & GOT_TLS_IE)
+    g->tls_assigned_gotno += 1;
+
+  if (entry->tls_type & GOT_TLS_LDM)
+    g->tls_ldm_offset = entry->gotidx;
+
+  return 1;
+}
+
+/* If passed a NULL brownie32_got_info in the argument, set the marker used
+   to tell whether a global symbol needs a got entry (in the primary
+   got) to the given VALUE.
+
+   If passed a pointer G to a brownie32_got_info in the argument (it must
+   not be the primary GOT), compute the offset from the beginning of
+   the (primary) GOT section to the entry in G corresponding to the
+   global symbol.  G's assigned_gotno must contain the index of the
+   first available global GOT entry in G.  VALUE must contain the size
+   of a GOT entry in bytes.  For each global GOT entry that requires a
+   dynamic relocation, NEEDED_RELOCS is incremented, and the symbol is
+   marked as not eligible for lazy resolution through a function
+   stub.  */
+static int
+brownie32_elf_set_global_got_offset (void **entryp, void *p)
+{
+  struct brownie32_got_entry *entry = (struct brownie32_got_entry *)*entryp;
+  struct brownie32_elf_set_global_got_offset_arg *arg
+    = (struct brownie32_elf_set_global_got_offset_arg *)p;
+  struct brownie32_got_info *g = arg->g;
+
+  if (g && entry->tls_type != GOT_NORMAL)
+    arg->needed_relocs +=
+      brownie32_tls_got_relocs (arg->info, entry->tls_type,
+			   entry->symndx == -1 ? &entry->d.h->root : NULL);
+
+  if (entry->abfd != NULL && entry->symndx == -1
+      && entry->d.h->root.dynindx != -1
+      && entry->d.h->tls_type == GOT_NORMAL)
+    {
+      if (g)
+	{
+	  BFD_ASSERT (g->global_gotsym == NULL);
+
+	  entry->gotidx = arg->value * (long) g->assigned_gotno++;
+	  if (arg->info->shared
+	      || (elf_hash_table (arg->info)->dynamic_sections_created
+		  && entry->d.h->root.def_dynamic
+		  && !entry->d.h->root.def_regular))
+	    ++arg->needed_relocs;
+	}
+      else
+	entry->d.h->root.got.offset = arg->value;
+    }
+
+  return 1;
+}
+
+/* Mark any global symbols referenced in the GOT we are iterating over
+   as inelligible for lazy resolution stubs.  */
+static int
+brownie32_elf_set_no_stub (void **entryp, void *p ATTRIBUTE_UNUSED)
+{
+  struct brownie32_got_entry *entry = (struct brownie32_got_entry *)*entryp;
+
+  if (entry->abfd != NULL
+      && entry->symndx == -1
+      && entry->d.h->root.dynindx != -1)
+    entry->d.h->no_fn_stub = TRUE;
+
+  return 1;
+}
+
+/* Follow indirect and warning hash entries so that each got entry
+   points to the final symbol definition.  P must point to a pointer
+   to the hash table we're traversing.  Since this traversal may
+   modify the hash table, we set this pointer to NULL to indicate
+   we've made a potentially-destructive change to the hash table, so
+   the traversal must be restarted.  */
+static int
+brownie32_elf_resolve_final_got_entry (void **entryp, void *p)
+{
+  struct brownie32_got_entry *entry = (struct brownie32_got_entry *)*entryp;
+  htab_t got_entries = *(htab_t *)p;
+
+  if (entry->abfd != NULL && entry->symndx == -1)
+    {
+      struct brownie32_elf_link_hash_entry *h = entry->d.h;
+
+      while (h->root.root.type == bfd_link_hash_indirect
+ 	     || h->root.root.type == bfd_link_hash_warning)
+	h = (struct brownie32_elf_link_hash_entry *) h->root.root.u.i.link;
+
+      if (entry->d.h == h)
+	return 1;
+
+      entry->d.h = h;
+
+      /* If we can't find this entry with the new bfd hash, re-insert
+	 it, and get the traversal restarted.  */
+      if (! htab_find (got_entries, entry))
+	{
+	  htab_clear_slot (got_entries, entryp);
+	  entryp = htab_find_slot (got_entries, entry, INSERT);
+	  if (! *entryp)
+	    *entryp = entry;
+	  /* Abort the traversal, since the whole table may have
+	     moved, and leave it up to the parent to restart the
+	     process.  */
+	  *(htab_t *)p = NULL;
+	  return 0;
+	}
+      /* We might want to decrement the global_gotno count, but it's
+	 either too early or too late for that at this point.  */
+    }
+
+  return 1;
+}
+
+/* Turn indirect got entries in a got_entries table into their final
+   locations.  */
+static void
+brownie32_elf_resolve_final_got_entries (struct brownie32_got_info *g)
+{
+  htab_t got_entries;
+
+  do
+    {
+      got_entries = g->got_entries;
+
+      htab_traverse (got_entries,
+		     brownie32_elf_resolve_final_got_entry,
+		     &got_entries);
+    }
+  while (got_entries == NULL);
+}
+
+/* Return the offset of an input bfd IBFD's GOT from the beginning of
+   the primary GOT.  */
+static bfd_vma
+brownie32_elf_adjust_gp (bfd *abfd, struct brownie32_got_info *g, bfd *ibfd)
+{
+  if (g->bfd2got == NULL)
+    return 0;
+
+  g = brownie32_elf_got_for_ibfd (g, ibfd);
+  if (! g)
+    return 0;
+
+  BFD_ASSERT (g->next);
+
+  g = g->next;
+
+  return (g->local_gotno + g->global_gotno + g->tls_gotno)
+    * BROWNIE32_ELF_GOT_SIZE (abfd);
+}
+
+/* Turn a single GOT that is too big for 16-bit addressing into
+   a sequence of GOTs, each one 16-bit addressable.  */
+
+static bfd_boolean
+brownie32_elf_multi_got (bfd *abfd, struct bfd_link_info *info,
+		    struct brownie32_got_info *g, asection *got,
+		    bfd_size_type pages)
+{
+  struct brownie32_elf_got_per_bfd_arg got_per_bfd_arg;
+  struct brownie32_elf_set_global_got_offset_arg set_got_offset_arg;
+  struct brownie32_got_info *gg;
+  unsigned int assign;
+
+  g->bfd2got = htab_try_create (1, brownie32_elf_bfd2got_entry_hash,
+				brownie32_elf_bfd2got_entry_eq, NULL);
+  if (g->bfd2got == NULL)
+    return FALSE;
+
+  got_per_bfd_arg.bfd2got = g->bfd2got;
+  got_per_bfd_arg.obfd = abfd;
+  got_per_bfd_arg.info = info;
+
+  /* Count how many GOT entries each input bfd requires, creating a
+     map from bfd to got info while at that.  */
+  htab_traverse (g->got_entries, brownie32_elf_make_got_per_bfd, &got_per_bfd_arg);
+  if (got_per_bfd_arg.obfd == NULL)
+    return FALSE;
+
+  got_per_bfd_arg.current = NULL;
+  got_per_bfd_arg.primary = NULL;
+  /* Taking out PAGES entries is a worst-case estimate.  We could
+     compute the maximum number of pages that each separate input bfd
+     uses, but it's probably not worth it.  */
+  got_per_bfd_arg.max_count = ((BROWNIE32_ELF_GOT_MAX_SIZE (abfd)
+				/ BROWNIE32_ELF_GOT_SIZE (abfd))
+			       - BROWNIE32_RESERVED_GOTNO - pages);
+  /* The number of globals that will be included in the primary GOT.
+     See the calls to brownie32_elf_set_global_got_offset below for more
+     information.  */
+  got_per_bfd_arg.global_count = g->global_gotno;
+
+  /* Try to merge the GOTs of input bfds together, as long as they
+     don't seem to exceed the maximum GOT size, choosing one of them
+     to be the primary GOT.  */
+  htab_traverse (g->bfd2got, brownie32_elf_merge_gots, &got_per_bfd_arg);
+  if (got_per_bfd_arg.obfd == NULL)
+    return FALSE;
+
+  /* If we do not find any suitable primary GOT, create an empty one.  */
+  if (got_per_bfd_arg.primary == NULL)
+    {
+      g->next = (struct brownie32_got_info *)
+	bfd_alloc (abfd, sizeof (struct brownie32_got_info));
+      if (g->next == NULL)
+	return FALSE;
+
+      g->next->global_gotsym = NULL;
+      g->next->global_gotno = 0;
+      g->next->local_gotno = 0;
+      g->next->tls_gotno = 0;
+      g->next->assigned_gotno = 0;
+      g->next->tls_assigned_gotno = 0;
+      g->next->tls_ldm_offset = MINUS_ONE;
+      g->next->got_entries = htab_try_create (1, brownie32_elf_multi_got_entry_hash,
+					      brownie32_elf_multi_got_entry_eq,
+					      NULL);
+      if (g->next->got_entries == NULL)
+	return FALSE;
+      g->next->bfd2got = NULL;
+    }
+  else
+    g->next = got_per_bfd_arg.primary;
+  g->next->next = got_per_bfd_arg.current;
+
+  /* GG is now the master GOT, and G is the primary GOT.  */
+  gg = g;
+  g = g->next;
+
+  /* Map the output bfd to the primary got.  That's what we're going
+     to use for bfds that use GOT16 or GOT_PAGE relocations that we
+     didn't mark in check_relocs, and we want a quick way to find it.
+     We can't just use gg->next because we're going to reverse the
+     list.  */
+  {
+    struct brownie32_elf_bfd2got_hash *bfdgot;
+    void **bfdgotp;
+
+    bfdgot = (struct brownie32_elf_bfd2got_hash *)bfd_alloc
+      (abfd, sizeof (struct brownie32_elf_bfd2got_hash));
+
+    if (bfdgot == NULL)
+      return FALSE;
+
+    bfdgot->bfd = abfd;
+    bfdgot->g = g;
+    bfdgotp = htab_find_slot (gg->bfd2got, bfdgot, INSERT);
+
+    BFD_ASSERT (*bfdgotp == NULL);
+    *bfdgotp = bfdgot;
+  }
+
+  /* The IRIX dynamic linker requires every symbol that is referenced
+     in a dynamic relocation to be present in the primary GOT, so
+     arrange for them to appear after those that are actually
+     referenced.
+
+     GNU/Linux could very well do without it, but it would slow down
+     the dynamic linker, since it would have to resolve every dynamic
+     symbol referenced in other GOTs more than once, without help from
+     the cache.  Also, knowing that every external symbol has a GOT
+     helps speed up the resolution of local symbols too, so GNU/Linux
+     follows IRIX's practice.
+
+     The number 2 is used by brownie32_elf_sort_hash_table_f to count
+     global GOT symbols that are unreferenced in the primary GOT, with
+     an initial dynamic index computed from gg->assigned_gotno, where
+     the number of unreferenced global entries in the primary GOT is
+     preserved.  */
+  if (1)
+    {
+      gg->assigned_gotno = gg->global_gotno - g->global_gotno;
+      g->global_gotno = gg->global_gotno;
+      set_got_offset_arg.value = 2;
+    }
+  else
+    {
+      /* This could be used for dynamic linkers that don't optimize
+	 symbol resolution while applying relocations so as to use
+	 primary GOT entries or assuming the symbol is locally-defined.
+	 With this code, we assign lower dynamic indices to global
+	 symbols that are not referenced in the primary GOT, so that
+	 their entries can be omitted.  */
+      gg->assigned_gotno = 0;
+      set_got_offset_arg.value = -1;
+    }
+
+  /* Reorder dynamic symbols as described above (which behavior
+     depends on the setting of VALUE).  */
+  set_got_offset_arg.g = NULL;
+  htab_traverse (gg->got_entries, brownie32_elf_set_global_got_offset,
+		 &set_got_offset_arg);
+  set_got_offset_arg.value = 1;
+  htab_traverse (g->got_entries, brownie32_elf_set_global_got_offset,
+		 &set_got_offset_arg);
+  if (! brownie32_elf_sort_hash_table (info, 1))
+    return FALSE;
+
+  /* Now go through the GOTs assigning them offset ranges.
+     [assigned_gotno, local_gotno[ will be set to the range of local
+     entries in each GOT.  We can then compute the end of a GOT by
+     adding local_gotno to global_gotno.  We reverse the list and make
+     it circular since then we'll be able to quickly compute the
+     beginning of a GOT, by computing the end of its predecessor.  To
+     avoid special cases for the primary GOT, while still preserving
+     assertions that are valid for both single- and multi-got links,
+     we arrange for the main got struct to have the right number of
+     global entries, but set its local_gotno such that the initial
+     offset of the primary GOT is zero.  Remember that the primary GOT
+     will become the last item in the circular linked list, so it
+     points back to the master GOT.  */
+  gg->local_gotno = -g->global_gotno;
+  gg->global_gotno = g->global_gotno;
+  gg->tls_gotno = 0;
+  assign = 0;
+  gg->next = gg;
+
+  do
+    {
+      struct brownie32_got_info *gn;
+
+      assign += BROWNIE32_RESERVED_GOTNO;
+      g->assigned_gotno = assign;
+      g->local_gotno += assign + pages;
+      assign = g->local_gotno + g->global_gotno + g->tls_gotno;
+
+      /* Set up any TLS entries.  We always place the TLS entries after
+	 all non-TLS entries.  */
+      g->tls_assigned_gotno = g->local_gotno + g->global_gotno;
+      htab_traverse (g->got_entries, brownie32_elf_initialize_tls_index, g);
+
+      /* Take g out of the direct list, and push it onto the reversed
+	 list that gg points to.  */
+      gn = g->next;
+      g->next = gg->next;
+      gg->next = g;
+      g = gn;
+
+      /* Mark global symbols in every non-primary GOT as ineligible for
+	 stubs.  */
+      if (g)
+	htab_traverse (g->got_entries, brownie32_elf_set_no_stub, NULL);
+    }
+  while (g);
+
+  got->size = (gg->next->local_gotno
+		    + gg->next->global_gotno
+		    + gg->next->tls_gotno) * BROWNIE32_ELF_GOT_SIZE (abfd);
+
+  return TRUE;
+}
+
+
+/* Returns the first relocation of type r_type found, beginning with
+   RELOCATION.  RELEND is one-past-the-end of the relocation table.  */
+
+static const Elf_Internal_Rela *
+brownie32_elf_next_relocation (bfd *abfd ATTRIBUTE_UNUSED, unsigned int r_type,
+			  const Elf_Internal_Rela *relocation,
+			  const Elf_Internal_Rela *relend)
+{
+  while (relocation < relend)
+    {
+      if (ELF_R_TYPE (abfd, relocation->r_info) == r_type)
+	return relocation;
+
+      ++relocation;
+    }
+
+  /* We didn't find it.  */
+  bfd_set_error (bfd_error_bad_value);
+  return NULL;
+}
+
+/* Return whether a relocation is against a local symbol.  */
+
+static bfd_boolean
+brownie32_elf_local_relocation_p (bfd *input_bfd,
+			     const Elf_Internal_Rela *relocation,
+			     asection **local_sections,
+			     bfd_boolean check_forced)
+{
+  unsigned long r_symndx;
+  Elf_Internal_Shdr *symtab_hdr;
+  struct brownie32_elf_link_hash_entry *h;
+  size_t extsymoff;
+
+  r_symndx = ELF_R_SYM (input_bfd, relocation->r_info);
+  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+  extsymoff = (elf_bad_symtab (input_bfd)) ? 0 : symtab_hdr->sh_info;
+
+  if (r_symndx < extsymoff)
+    return TRUE;
+  if (elf_bad_symtab (input_bfd) && local_sections[r_symndx] != NULL)
+    return TRUE;
+
+  if (check_forced)
+    {
+      /* Look up the hash table to check whether the symbol
+ 	 was forced local.  */
+      h = (struct brownie32_elf_link_hash_entry *)
+	elf_sym_hashes (input_bfd) [r_symndx - extsymoff];
+      /* Find the real hash-table entry for this symbol.  */
+      while (h->root.root.type == bfd_link_hash_indirect
+ 	     || h->root.root.type == bfd_link_hash_warning)
+	h = (struct brownie32_elf_link_hash_entry *) h->root.root.u.i.link;
+      if (h->root.forced_local)
+	return TRUE;
+    }
+
+  return FALSE;
+}
+
+/* Sign-extend VALUE, which has the indicated number of BITS.  */
+
+bfd_vma
+_bfd_brownie32_elf_sign_extend (bfd_vma value, int bits)
+{
+  if (value & ((bfd_vma) 1 << (bits - 1)))
+    /* VALUE is negative.  */
+    value |= ((bfd_vma) - 1) << bits;
+
+  return value;
+}
+
+/* Return non-zero if the indicated VALUE has overflowed the maximum
+   range expressible by a signed number with the indicated number of
+   BITS.  */
+
+static bfd_boolean
+brownie32_elf_overflow_p (bfd_vma value, int bits)
+{
+  bfd_signed_vma svalue = (bfd_signed_vma) value;
+
+  if (svalue > (1 << (bits - 1)) - 1)
+    /* The value is too big.  */
+    return TRUE;
+  else if (svalue < -(1 << (bits - 1)))
+    /* The value is too small.  */
+    return TRUE;
+
+  /* All is well.  */
+  return FALSE;
+}
+
+/* Calculate the %high function.  */
+
+static bfd_vma
+brownie32_elf_high (bfd_vma value)
+{
+  return ((value + (bfd_vma) 0x8000) >> 16) & 0xffff;
+}
+
+/* Calculate the %higher function.  */
+
+static bfd_vma
+brownie32_elf_higher (bfd_vma value ATTRIBUTE_UNUSED)
+{
+#ifdef BFD64
+  return ((value + (bfd_vma) 0x80008000) >> 32) & 0xffff;
+#else
+  abort ();
+  return MINUS_ONE;
+#endif
+}
+
+/* Calculate the %highest function.  */
+
+static bfd_vma
+brownie32_elf_highest (bfd_vma value ATTRIBUTE_UNUSED)
+{
+#ifdef BFD64
+  return ((value + (((bfd_vma) 0x8000 << 32) | 0x80008000)) >> 48) & 0xffff;
+#else
+  abort ();
+  return MINUS_ONE;
+#endif
+}
+
+/* Create the .compact_rel section.  */
+
+static bfd_boolean
+brownie32_elf_create_compact_rel_section
+  (bfd *abfd, struct bfd_link_info *info ATTRIBUTE_UNUSED)
+{
+  flagword flags;
+  register asection *s;
+
+  if (bfd_get_section_by_name (abfd, ".compact_rel") == NULL)
+    {
+      flags = (SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED
+	       | SEC_READONLY);
+
+      s = bfd_make_section_with_flags (abfd, ".compact_rel", flags);
+      if (s == NULL
+	  || ! bfd_set_section_alignment (abfd, s,
+					  BROWNIE32_ELF_LOG_FILE_ALIGN (abfd)))
+	return FALSE;
+
+      s->size = sizeof (Elf32_External_compact_rel);
+    }
+
+  return TRUE;
+}
+
+/* Create the .got section to hold the global offset table.  */
+
+static bfd_boolean
+brownie32_elf_create_got_section (bfd *abfd, struct bfd_link_info *info,
+			     bfd_boolean maybe_exclude)
+{
+  flagword flags;
+  register asection *s;
+  struct elf_link_hash_entry *h;
+  struct bfd_link_hash_entry *bh;
+  struct brownie32_got_info *g;
+  bfd_size_type amt;
+
+  /* This function may be called more than once.  */
+  s = brownie32_elf_got_section (abfd, TRUE);
+  if (s)
+    {
+      if (! maybe_exclude)
+	s->flags &= ~SEC_EXCLUDE;
+      return TRUE;
+    }
+
+  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
+	   | SEC_LINKER_CREATED);
+
+  if (maybe_exclude)
+    flags |= SEC_EXCLUDE;
+
+  /* We have to use an alignment of 2**4 here because this is hardcoded
+     in the function stub generation and in the linker script.  */
+  s = bfd_make_section_with_flags (abfd, ".got", flags);
+  if (s == NULL
+      || ! bfd_set_section_alignment (abfd, s, 4))
+    return FALSE;
+
+  /* Define the symbol _GLOBAL_OFFSET_TABLE_.  We don't do this in the
+     linker script because we don't want to define the symbol if we
+     are not creating a global offset table.  */
+  bh = NULL;
+  if (! (_bfd_generic_link_add_one_symbol
+	 (info, abfd, "_GLOBAL_OFFSET_TABLE_", BSF_GLOBAL, s,
+	  0, NULL, FALSE, get_elf_backend_data (abfd)->collect, &bh)))
+    return FALSE;
+
+  h = (struct elf_link_hash_entry *) bh;
+  h->non_elf = 0;
+  h->def_regular = 1;
+  h->type = STT_OBJECT;
+
+  if (info->shared
+      && ! bfd_elf_link_record_dynamic_symbol (info, h))
+    return FALSE;
+
+  amt = sizeof (struct brownie32_got_info);
+  g = bfd_alloc (abfd, amt);
+  if (g == NULL)
+    return FALSE;
+  g->global_gotsym = NULL;
+  g->global_gotno = 0;
+  g->tls_gotno = 0;
+  g->local_gotno = BROWNIE32_RESERVED_GOTNO;
+  g->assigned_gotno = BROWNIE32_RESERVED_GOTNO;
+  g->bfd2got = NULL;
+  g->next = NULL;
+  g->tls_ldm_offset = MINUS_ONE;
+  g->got_entries = htab_try_create (1, brownie32_elf_got_entry_hash,
+				    brownie32_elf_got_entry_eq, NULL);
+  if (g->got_entries == NULL)
+    return FALSE;
+  brownie32_elf_section_data (s)->u.got_info = g;
+  brownie32_elf_section_data (s)->elf.this_hdr.sh_flags
+    |= SHF_ALLOC | SHF_WRITE | SHF_BROWNIE32_GPREL;
+
+  return TRUE;
+}
+
+/* Calculate the value produced by the RELOCATION (which comes from
+   the INPUT_BFD).  The ADDEND is the addend to use for this
+   RELOCATION; RELOCATION->R_ADDEND is ignored.
+
+   The result of the relocation calculation is stored in VALUEP.
+   REQUIRE_JALXP indicates whether or not the opcode used with this
+   relocation must be JALX.
+
+   This function returns bfd_reloc_continue if the caller need take no
+   further action regarding this relocation, bfd_reloc_notsupported if
+   something goes dramatically wrong, bfd_reloc_overflow if an
+   overflow occurs, and bfd_reloc_ok to indicate success.  */
+
+static bfd_reloc_status_type
+brownie32_elf_calculate_relocation (bfd *abfd, bfd *input_bfd,
+			       asection *input_section,
+			       struct bfd_link_info *info,
+			       const Elf_Internal_Rela *relocation,
+			       bfd_vma addend, reloc_howto_type *howto,
+			       Elf_Internal_Sym *local_syms,
+			       asection **local_sections, bfd_vma *valuep,
+			       const char **namep, bfd_boolean *require_jalxp,
+			       bfd_boolean save_addend)
+{
+  /* The eventual value we will return.  */
+  bfd_vma value;
+  /* The address of the symbol against which the relocation is
+     occurring.  */
+  bfd_vma symbol = 0;
+  /* The final GP value to be used for the relocatable, executable, or
+     shared object file being produced.  */
+  bfd_vma gp = MINUS_ONE;
+  /* The place (section offset or address) of the storage unit being
+     relocated.  */
+  bfd_vma p;
+  /* The value of GP used to create the relocatable object.  */
+  bfd_vma gp0 = MINUS_ONE;
+  /* The offset into the global offset table at which the address of
+     the relocation entry symbol, adjusted by the addend, resides
+     during execution.  */
+  bfd_vma g = MINUS_ONE;
+  /* The section in which the symbol referenced by the relocation is
+     located.  */
+  asection *sec = NULL;
+  struct brownie32_elf_link_hash_entry *h = NULL;
+  /* TRUE if the symbol referred to by this relocation is a local
+     symbol.  */
+  bfd_boolean local_p, was_local_p;
+  /* TRUE if the symbol referred to by this relocation is "_gp_disp".  */
+  bfd_boolean gp_disp_p = FALSE;
+  /* TRUE if the symbol referred to by this relocation is
+     "__gnu_local_gp".  */
+  bfd_boolean gnu_local_gp_p = FALSE;
+  Elf_Internal_Shdr *symtab_hdr;
+  size_t extsymoff;
+  unsigned long r_symndx;
+  int r_type;
+  /* TRUE if overflow occurred during the calculation of the
+     relocation value.  */
+  bfd_boolean overflowed_p;
+  /* TRUE if this relocation refers to a BROWNIE3216 function.  */
+  bfd_boolean target_is_16_bit_code_p = FALSE;
+
+  /* Parse the relocation.  */
+  r_symndx = ELF_R_SYM (input_bfd, relocation->r_info);
+  r_type = ELF_R_TYPE (input_bfd, relocation->r_info);
+  p = (input_section->output_section->vma
+       + input_section->output_offset
+       + relocation->r_offset);
+
+  /* Assume that there will be no overflow.  */
+  overflowed_p = FALSE;
+
+  /* Figure out whether or not the symbol is local, and get the offset
+     used in the array of hash table entries.  */
+  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+  local_p = brownie32_elf_local_relocation_p (input_bfd, relocation,
+					 local_sections, FALSE);
+  was_local_p = local_p;
+  if (! elf_bad_symtab (input_bfd))
+    extsymoff = symtab_hdr->sh_info;
+  else
+    {
+      /* The symbol table does not follow the rule that local symbols
+	 must come before globals.  */
+      extsymoff = 0;
+    }
+
+  /* Figure out the value of the symbol.  */
+  if (local_p)
+    {
+      Elf_Internal_Sym *sym;
+
+      sym = local_syms + r_symndx;
+      sec = local_sections[r_symndx];
+
+      symbol = sec->output_section->vma + sec->output_offset;
+      if (ELF_ST_TYPE (sym->st_info) != STT_SECTION
+	  || (sec->flags & SEC_MERGE))
+	symbol += sym->st_value;
+      if ((sec->flags & SEC_MERGE)
+	  && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
+	{
+	  addend = _bfd_elf_rel_local_sym (abfd, sym, &sec, addend);
+	  addend -= symbol;
+	  addend += sec->output_section->vma + sec->output_offset;
+	}
+
+      /* BROWNIE3216 text labels should be treated as odd.  */
+      if (sym->st_other == STO_BROWNIE3216)
+	++symbol;
+
+      /* Record the name of this symbol, for our caller.  */
+      *namep = bfd_elf_string_from_elf_section (input_bfd,
+						symtab_hdr->sh_link,
+						sym->st_name);
+      if (*namep == '\0')
+	*namep = bfd_section_name (input_bfd, sec);
+
+      target_is_16_bit_code_p = (sym->st_other == STO_BROWNIE3216);
+    }
+  else
+    {
+      /* ??? Could we use RELOC_FOR_GLOBAL_SYMBOL here ?  */
+
+      /* For global symbols we look up the symbol in the hash-table.  */
+      h = ((struct brownie32_elf_link_hash_entry *)
+	   elf_sym_hashes (input_bfd) [r_symndx - extsymoff]);
+      /* Find the real hash-table entry for this symbol.  */
+      while (h->root.root.type == bfd_link_hash_indirect
+	     || h->root.root.type == bfd_link_hash_warning)
+	h = (struct brownie32_elf_link_hash_entry *) h->root.root.u.i.link;
+
+      /* Record the name of this symbol, for our caller.  */
+      *namep = h->root.root.root.string;
+
+      /* See if this is the special _gp_disp symbol.  Note that such a
+	 symbol must always be a global symbol.  */
+      if (strcmp (*namep, "_gp_disp") == 0
+	  && ! NEWABI_P (input_bfd))
+	{
+	  /* Relocations against _gp_disp are permitted only with
+	     R_BROWNIE32_HI16 and R_BROWNIE32_LO16 relocations.  */
+	  if (r_type != R_BROWNIE32_HI16 && r_type != R_BROWNIE32_LO16
+	      && r_type != R_BROWNIE3216_HI16 && r_type != R_BROWNIE3216_LO16)
+	    return bfd_reloc_notsupported;
+
+	  gp_disp_p = TRUE;
+	}
+      /* See if this is the special _gp symbol.  Note that such a
+	 symbol must always be a global symbol.  */
+      else if (strcmp (*namep, "__gnu_local_gp") == 0)
+	gnu_local_gp_p = TRUE;
+
+
+      /* If this symbol is defined, calculate its address.  Note that
+	 _gp_disp is a magic symbol, always implicitly defined by the
+	 linker, so it's inappropriate to check to see whether or not
+	 its defined.  */
+      else if ((h->root.root.type == bfd_link_hash_defined
+		|| h->root.root.type == bfd_link_hash_defweak)
+	       && h->root.root.u.def.section)
+	{
+	  sec = h->root.root.u.def.section;
+	  if (sec->output_section)
+	    symbol = (h->root.root.u.def.value
+		      + sec->output_section->vma
+		      + sec->output_offset);
+	  else
+	    symbol = h->root.root.u.def.value;
+	}
+      else if (h->root.root.type == bfd_link_hash_undefweak)
+	/* We allow relocations against undefined weak symbols, giving
+	   it the value zero, so that you can undefined weak functions
+	   and check to see if they exist by looking at their
+	   addresses.  */
+	symbol = 0;
+      else if (info->unresolved_syms_in_objects == RM_IGNORE
+	       && ELF_ST_VISIBILITY (h->root.other) == STV_DEFAULT)
+	symbol = 0;
+      else if (strcmp (*namep, SGI_COMPAT (input_bfd)
+		       ? "_DYNAMIC_LINK" : "_DYNAMIC_LINKING") == 0)
+	{
+	  /* If this is a dynamic link, we should have created a
+	     _DYNAMIC_LINK symbol or _DYNAMIC_LINKING(for normal brownie32) symbol
+	     in in _bfd_brownie32_elf_create_dynamic_sections.
+	     Otherwise, we should define the symbol with a value of 0.
+	     FIXME: It should probably get into the symbol table
+	     somehow as well.  */
+	  BFD_ASSERT (! info->shared);
+	  BFD_ASSERT (bfd_get_section_by_name (abfd, ".dynamic") == NULL);
+	  symbol = 0;
+	}
+      else
+	{
+	  if (! ((*info->callbacks->undefined_symbol)
+		 (info, h->root.root.root.string, input_bfd,
+		  input_section, relocation->r_offset,
+		  (info->unresolved_syms_in_objects == RM_GENERATE_ERROR)
+		   || ELF_ST_VISIBILITY (h->root.other))))
+	    return bfd_reloc_undefined;
+	  symbol = 0;
+	}
+
+      target_is_16_bit_code_p = (h->root.other == STO_BROWNIE3216);
+    }
+
+  /* If this is a 32- or 64-bit call to a 16-bit function with a stub, we
+     need to redirect the call to the stub, unless we're already *in*
+     a stub.  */
+  if (r_type != R_BROWNIE3216_26 && !info->relocatable
+      && ((h != NULL && h->fn_stub != NULL)
+	  || (local_p && elf_tdata (input_bfd)->local_stubs != NULL
+	      && elf_tdata (input_bfd)->local_stubs[r_symndx] != NULL))
+      && !brownie32_elf_stub_section_p (input_bfd, input_section))
+    {
+      /* This is a 32- or 64-bit call to a 16-bit function.  We should
+	 have already noticed that we were going to need the
+	 stub.  */
+      if (local_p)
+	sec = elf_tdata (input_bfd)->local_stubs[r_symndx];
+      else
+	{
+	  BFD_ASSERT (h->need_fn_stub);
+	  sec = h->fn_stub;
+	}
+
+      symbol = sec->output_section->vma + sec->output_offset;
+    }
+  /* If this is a 16-bit call to a 32- or 64-bit function with a stub, we
+     need to redirect the call to the stub.  */
+  else if (r_type == R_BROWNIE3216_26 && !info->relocatable
+	   && h != NULL
+	   && (h->call_stub != NULL || h->call_fp_stub != NULL)
+	   && !target_is_16_bit_code_p)
+    {
+      /* If both call_stub and call_fp_stub are defined, we can figure
+	 out which one to use by seeing which one appears in the input
+	 file.  */
+      if (h->call_stub != NULL && h->call_fp_stub != NULL)
+	{
+	  asection *o;
+
+	  sec = NULL;
+	  for (o = input_bfd->sections; o != NULL; o = o->next)
+	    {
+	      if (strncmp (bfd_get_section_name (input_bfd, o),
+			   CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0)
+		{
+		  sec = h->call_fp_stub;
+		  break;
+		}
+	    }
+	  if (sec == NULL)
+	    sec = h->call_stub;
+	}
+      else if (h->call_stub != NULL)
+	sec = h->call_stub;
+      else
+	sec = h->call_fp_stub;
+
+      BFD_ASSERT (sec->size > 0);
+      symbol = sec->output_section->vma + sec->output_offset;
+    }
+
+  /* Calls from 16-bit code to 32-bit code and vice versa require the
+     special jalx instruction.  */
+  *require_jalxp = (!info->relocatable
+                    && (((r_type == R_BROWNIE3216_26) && !target_is_16_bit_code_p)
+                        || ((r_type == R_BROWNIE32_26) && target_is_16_bit_code_p)));
+
+  local_p = brownie32_elf_local_relocation_p (input_bfd, relocation,
+					 local_sections, TRUE);
+
+  /* If we haven't already determined the GOT offset, or the GP value,
+     and we're going to need it, get it now.  */
+  switch (r_type)
+    {
+    case R_BROWNIE32_GOT_PAGE:
+    case R_BROWNIE32_GOT_OFST:
+      /* We need to decay to GOT_DISP/addend if the symbol doesn't
+	 bind locally.  */
+      local_p = local_p || _bfd_elf_symbol_refs_local_p (&h->root, info, 1);
+      if (local_p || r_type == R_BROWNIE32_GOT_OFST)
+	break;
+      /* Fall through.  */
+
+    case R_BROWNIE32_CALL16:
+    case R_BROWNIE32_GOT16:
+    case R_BROWNIE32_GOT_DISP:
+    case R_BROWNIE32_GOT_HI16:
+    case R_BROWNIE32_CALL_HI16:
+    case R_BROWNIE32_GOT_LO16:
+    case R_BROWNIE32_CALL_LO16:
+    case R_BROWNIE32_TLS_GD:
+    case R_BROWNIE32_TLS_GOTTPREL:
+    case R_BROWNIE32_TLS_LDM:
+      /* Find the index into the GOT where this value is located.  */
+      if (r_type == R_BROWNIE32_TLS_LDM)
+	{
+	  g = brownie32_elf_local_got_index (abfd, input_bfd, info, 0, 0, NULL,
+					r_type);
+	  if (g == MINUS_ONE)
+	    return bfd_reloc_outofrange;
+	}
+      else if (!local_p)
+	{
+	  /* GOT_PAGE may take a non-zero addend, that is ignored in a
+	     GOT_PAGE relocation that decays to GOT_DISP because the
+	     symbol turns out to be global.  The addend is then added
+	     as GOT_OFST.  */
+	  BFD_ASSERT (addend == 0 || r_type == R_BROWNIE32_GOT_PAGE);
+	  g = brownie32_elf_global_got_index (elf_hash_table (info)->dynobj,
+					 input_bfd,
+					 (struct elf_link_hash_entry *) h,
+					 r_type, info);
+	  if (h->tls_type == GOT_NORMAL
+	      && (! elf_hash_table(info)->dynamic_sections_created
+		  || (info->shared
+		      && (info->symbolic || h->root.dynindx == -1)
+		      && h->root.def_regular)))
+	    {
+	      /* This is a static link or a -Bsymbolic link.  The
+		 symbol is defined locally, or was forced to be local.
+		 We must initialize this entry in the GOT.  */
+	      bfd *tmpbfd = elf_hash_table (info)->dynobj;
+	      asection *sgot = brownie32_elf_got_section (tmpbfd, FALSE);
+	      BROWNIE32_ELF_PUT_WORD (tmpbfd, symbol, sgot->contents + g);
+	    }
+	}
+      else if (r_type == R_BROWNIE32_GOT16 || r_type == R_BROWNIE32_CALL16)
+	/* There's no need to create a local GOT entry here; the
+	   calculation for a local GOT16 entry does not involve G.  */
+	break;
+      else
+	{
+	  g = brownie32_elf_local_got_index (abfd, input_bfd,
+					info, symbol + addend, r_symndx, h,
+					r_type);
+	  if (g == MINUS_ONE)
+	    return bfd_reloc_outofrange;
+	}
+
+      /* Convert GOT indices to actual offsets.  */
+      g = brownie32_elf_got_offset_from_index (elf_hash_table (info)->dynobj,
+					  abfd, input_bfd, g);
+      break;
+
+    case R_BROWNIE32_HI16:
+    case R_BROWNIE32_LO16:
+    case R_BROWNIE32_GPREL16:
+    case R_BROWNIE32_GPREL32:
+    case R_BROWNIE32_LITERAL:
+    case R_BROWNIE3216_HI16:
+    case R_BROWNIE3216_LO16:
+    case R_BROWNIE3216_GPREL:
+      gp0 = _bfd_get_gp_value (input_bfd);
+      gp = _bfd_get_gp_value (abfd);
+      if (elf_hash_table (info)->dynobj)
+	gp += brownie32_elf_adjust_gp (abfd,
+				  brownie32_elf_got_info
+				  (elf_hash_table (info)->dynobj, NULL),
+				  input_bfd);
+      break;
+
+    default:
+      break;
+    }
+
+  if (gnu_local_gp_p)
+    symbol = gp;
+  
+  /* Figure out what kind of relocation is being performed.  */
+  switch (r_type)
+    {
+    case R_BROWNIE32_NONE:
+      return bfd_reloc_continue;
+
+    case R_BROWNIE32_16:
+      value = symbol + _bfd_brownie32_elf_sign_extend (addend, 16);
+      overflowed_p = brownie32_elf_overflow_p (value, 16);
+      break;
+
+    case R_BROWNIE32_32:
+    case R_BROWNIE32_REL32:
+    case R_BROWNIE32_64:
+      if ((info->shared
+	   || (elf_hash_table (info)->dynamic_sections_created
+	       && h != NULL
+	       && h->root.def_dynamic
+	       && !h->root.def_regular))
+	  && r_symndx != 0
+	  && (input_section->flags & SEC_ALLOC) != 0)
+	{
+	  /* If we're creating a shared library, or this relocation is
+	     against a symbol in a shared library, then we can't know
+	     where the symbol will end up.  So, we create a relocation
+	     record in the output, and leave the job up to the dynamic
+	     linker.  */
+	  value = addend;
+	  if (!brownie32_elf_create_dynamic_relocation (abfd,
+						   info,
+						   relocation,
+						   h,
+						   sec,
+						   symbol,
+						   &value,
+						   input_section))
+	    return bfd_reloc_undefined;
+	}
+      else
+	{
+	  if (r_type != R_BROWNIE32_REL32)
+	    value = symbol + addend;
+	  else
+	    value = addend;
+	}
+      value &= howto->dst_mask;
+      break;
+
+    case R_BROWNIE32_PC32:
+      value = symbol + addend - p;
+      value &= howto->dst_mask;
+      break;
+
+    case R_BROWNIE32_GNU_REL16_S2:
+      value = symbol + _bfd_brownie32_elf_sign_extend (addend, 18) - p;
+      overflowed_p = brownie32_elf_overflow_p (value, 18);
+      value = (value >> 2) & howto->dst_mask;
+      break;
+
+    case R_BROWNIE3216_26:
+      /* The calculation for R_BROWNIE3216_26 is just the same as for an
+	 R_BROWNIE32_26.  It's only the storage of the relocated field into
+	 the output file that's different.  That's handled in
+	 brownie32_elf_perform_relocation.  So, we just fall through to the
+	 R_BROWNIE32_26 case here.  */
+    case R_BROWNIE32_26:
+      if (local_p)
+	value = ((addend | ((p + 4) & 0xf0000000)) + symbol) >> 2;
+      else
+	{
+	  value = (_bfd_brownie32_elf_sign_extend (addend, 28) + symbol) >> 2;
+	  if (h->root.root.type != bfd_link_hash_undefweak)
+	    overflowed_p = (value >> 26) != ((p + 4) >> 28);
+	}
+      value &= howto->dst_mask;
+      break;
+
+    case R_BROWNIE32_TLS_DTPREL_HI16:
+      value = (brownie32_elf_high (addend + symbol - dtprel_base (info))
+	       & howto->dst_mask);
+      break;
+
+    case R_BROWNIE32_TLS_DTPREL_LO16:
+      value = (symbol + addend - dtprel_base (info)) & howto->dst_mask;
+      break;
+
+    case R_BROWNIE32_TLS_TPREL_HI16:
+      value = (brownie32_elf_high (addend + symbol - tprel_base (info))
+	       & howto->dst_mask);
+      break;
+
+    case R_BROWNIE32_TLS_TPREL_LO16:
+      value = (symbol + addend - tprel_base (info)) & howto->dst_mask;
+      break;
+
+    case R_BROWNIE32_HI16:
+    case R_BROWNIE3216_HI16:
+      if (!gp_disp_p)
+	{
+	  value = brownie32_elf_high (addend + symbol);
+	  value &= howto->dst_mask;
+	}
+      else
+	{
+	  /* For BROWNIE3216 ABI code we generate this sequence
+	        0: li      $v0,%hi(_gp_disp)
+	        4: addiupc $v1,%lo(_gp_disp)
+	        8: sll     $v0,16
+	       12: addu    $v0,$v1
+	       14: move    $gp,$v0
+	     So the offsets of hi and lo relocs are the same, but the
+	     $pc is four higher than $t9 would be, so reduce
+	     both reloc addends by 4. */
+	  if (r_type == R_BROWNIE3216_HI16)
+	    value = brownie32_elf_high (addend + gp - p - 4);
+	  else
+	    value = brownie32_elf_high (addend + gp - p);
+	  overflowed_p = brownie32_elf_overflow_p (value, 16);
+	}
+      break;
+
+    case R_BROWNIE32_LO16:
+    case R_BROWNIE3216_LO16:
+      if (!gp_disp_p)
+	value = (symbol + addend) & howto->dst_mask;
+      else
+	{
+	  /* See the comment for R_BROWNIE3216_HI16 above for the reason
+	     for this conditional.  */
+	  if (r_type == R_BROWNIE3216_LO16)
+	    value = addend + gp - p;
+	  else
+	    value = addend + gp - p + 4;
+	  /* The BROWNIE32 ABI requires checking the R_BROWNIE32_LO16 relocation
+	     for overflow.  But, on, say, IRIX5, relocations against
+	     _gp_disp are normally generated from the .cpload
+	     pseudo-op.  It generates code that normally looks like
+	     this:
+
+	       lui    $gp,%hi(_gp_disp)
+	       addiu  $gp,$gp,%lo(_gp_disp)
+	       addu   $gp,$gp,$t9
+
+	     Here $t9 holds the address of the function being called,
+	     as required by the BROWNIE32 ELF ABI.  The R_BROWNIE32_LO16
+	     relocation can easily overflow in this situation, but the
+	     R_BROWNIE32_HI16 relocation will handle the overflow.
+	     Therefore, we consider this a bug in the BROWNIE32 ABI, and do
+	     not check for overflow here.  */
+	}
+      break;
+
+    case R_BROWNIE32_LITERAL:
+      /* Because we don't merge literal sections, we can handle this
+	 just like R_BROWNIE32_GPREL16.  In the long run, we should merge
+	 shared literals, and then we will need to additional work
+	 here.  */
+
+      /* Fall through.  */
+
+    case R_BROWNIE3216_GPREL:
+      /* The R_BROWNIE3216_GPREL performs the same calculation as
+	 R_BROWNIE32_GPREL16, but stores the relocated bits in a different
+	 order.  We don't need to do anything special here; the
+	 differences are handled in brownie32_elf_perform_relocation.  */
+    case R_BROWNIE32_GPREL16:
+      /* Only sign-extend the addend if it was extracted from the
+	 instruction.  If the addend was separate, leave it alone,
+	 otherwise we may lose significant bits.  */
+      if (howto->partial_inplace)
+	addend = _bfd_brownie32_elf_sign_extend (addend, 16);
+      value = symbol + addend - gp;
+      /* If the symbol was local, any earlier relocatable links will
+	 have adjusted its addend with the gp offset, so compensate
+	 for that now.  Don't do it for symbols forced local in this
+	 link, though, since they won't have had the gp offset applied
+	 to them before.  */
+      if (was_local_p)
+	value += gp0;
+      overflowed_p = brownie32_elf_overflow_p (value, 16);
+      break;
+
+    case R_BROWNIE32_GOT16:
+    case R_BROWNIE32_CALL16:
+      if (local_p)
+	{
+	  bfd_boolean forced;
+
+	  /* The special case is when the symbol is forced to be local.  We
+	     need the full address in the GOT since no R_BROWNIE32_LO16 relocation
+	     follows.  */
+	  forced = ! brownie32_elf_local_relocation_p (input_bfd, relocation,
+						  local_sections, FALSE);
+	  value = brownie32_elf_got16_entry (abfd, input_bfd, info,
+					symbol + addend, forced);
+	  if (value == MINUS_ONE)
+	    return bfd_reloc_outofrange;
+	  value
+	    = brownie32_elf_got_offset_from_index (elf_hash_table (info)->dynobj,
+					      abfd, input_bfd, value);
+	  overflowed_p = brownie32_elf_overflow_p (value, 16);
+	  break;
+	}
+
+      /* Fall through.  */
+
+    case R_BROWNIE32_TLS_GD:
+    case R_BROWNIE32_TLS_GOTTPREL:
+    case R_BROWNIE32_TLS_LDM:
+    case R_BROWNIE32_GOT_DISP:
+    got_disp:
+      value = g;
+      overflowed_p = brownie32_elf_overflow_p (value, 16);
+      break;
+
+    case R_BROWNIE32_GPREL32:
+      value = (addend + symbol + gp0 - gp);
+      if (!save_addend)
+	value &= howto->dst_mask;
+      break;
+
+    case R_BROWNIE32_PC16:
+      value = _bfd_brownie32_elf_sign_extend (addend, 16) + symbol - p;
+      overflowed_p = brownie32_elf_overflow_p (value, 16);
+      break;
+
+    case R_BROWNIE32_GOT_HI16:
+    case R_BROWNIE32_CALL_HI16:
+      /* We're allowed to handle these two relocations identically.
+	 The dynamic linker is allowed to handle the CALL relocations
+	 differently by creating a lazy evaluation stub.  */
+      value = g;
+      value = brownie32_elf_high (value);
+      value &= howto->dst_mask;
+      break;
+
+    case R_BROWNIE32_GOT_LO16:
+    case R_BROWNIE32_CALL_LO16:
+      value = g & howto->dst_mask;
+      break;
+
+    case R_BROWNIE32_GOT_PAGE:
+      /* GOT_PAGE relocations that reference non-local symbols decay
+	 to GOT_DISP.  The corresponding GOT_OFST relocation decays to
+	 0.  */
+      if (! local_p)
+	goto got_disp;
+      value = brownie32_elf_got_page (abfd, input_bfd, info, symbol + addend, NULL);
+      if (value == MINUS_ONE)
+	return bfd_reloc_outofrange;
+      value = brownie32_elf_got_offset_from_index (elf_hash_table (info)->dynobj,
+					      abfd, input_bfd, value);
+      overflowed_p = brownie32_elf_overflow_p (value, 16);
+      break;
+
+    case R_BROWNIE32_GOT_OFST:
+      if (local_p)
+	brownie32_elf_got_page (abfd, input_bfd, info, symbol + addend, &value);
+      else
+	value = addend;
+      overflowed_p = brownie32_elf_overflow_p (value, 16);
+      break;
+
+    case R_BROWNIE32_SUB:
+      value = symbol - addend;
+      value &= howto->dst_mask;
+      break;
+
+    case R_BROWNIE32_HIGHER:
+      value = brownie32_elf_higher (addend + symbol);
+      value &= howto->dst_mask;
+      break;
+
+    case R_BROWNIE32_HIGHEST:
+      value = brownie32_elf_highest (addend + symbol);
+      value &= howto->dst_mask;
+      break;
+
+    case R_BROWNIE32_SCN_DISP:
+      value = symbol + addend - sec->output_offset;
+      value &= howto->dst_mask;
+      break;
+
+    case R_BROWNIE32_JALR:
+      /* This relocation is only a hint.  In some cases, we optimize
+	 it into a bal instruction.  But we don't try to optimize
+	 branches to the PLT; that will wind up wasting time.  */
+      if (h != NULL && h->root.plt.offset != (bfd_vma) -1)
+	return bfd_reloc_continue;
+      value = symbol + addend;
+      break;
+
+    case R_BROWNIE32_PJUMP:
+    case R_BROWNIE32_GNU_VTINHERIT:
+    case R_BROWNIE32_GNU_VTENTRY:
+      /* We don't do anything with these at present.  */
+      return bfd_reloc_continue;
+
+    default:
+      /* An unrecognized relocation type.  */
+      return bfd_reloc_notsupported;
+    }
+
+  /* Store the VALUE for our caller.  */
+  *valuep = value;
+  return overflowed_p ? bfd_reloc_overflow : bfd_reloc_ok;
+}
+
+/* Obtain the field relocated by RELOCATION.  */
+
+static bfd_vma
+brownie32_elf_obtain_contents (reloc_howto_type *howto,
+			  const Elf_Internal_Rela *relocation,
+			  bfd *input_bfd, bfd_byte *contents)
+{
+  bfd_vma x;
+  bfd_byte *location = contents + relocation->r_offset;
+
+  /* Obtain the bytes.  */
+  x = bfd_get ((8 * bfd_get_reloc_size (howto)), input_bfd, location);
+
+  return x;
+}
+
+/* It has been determined that the result of the RELOCATION is the
+   VALUE.  Use HOWTO to place VALUE into the output file at the
+   appropriate position.  The SECTION is the section to which the
+   relocation applies.  If REQUIRE_JALX is TRUE, then the opcode used
+   for the relocation must be either JAL or JALX, and it is
+   unconditionally converted to JALX.
+
+   Returns FALSE if anything goes wrong.  */
+
+static bfd_boolean
+brownie32_elf_perform_relocation (struct bfd_link_info *info,
+			     reloc_howto_type *howto,
+			     const Elf_Internal_Rela *relocation,
+			     bfd_vma value, bfd *input_bfd,
+			     asection *input_section, bfd_byte *contents,
+			     bfd_boolean require_jalx)
+{
+  bfd_vma x;
+  bfd_byte *location;
+  int r_type = ELF_R_TYPE (input_bfd, relocation->r_info);
+
+  /* Figure out where the relocation is occurring.  */
+  location = contents + relocation->r_offset;
+
+  _bfd_brownie3216_elf_reloc_unshuffle (input_bfd, r_type, FALSE, location);
+
+  /* Obtain the current value.  */
+  x = brownie32_elf_obtain_contents (howto, relocation, input_bfd, contents);
+
+  /* Clear the field we are setting.  */
+  x &= ~howto->dst_mask;
+
+  /* Set the field.  */
+  x |= (value & howto->dst_mask);
+
+  /* If required, turn JAL into JALX.  */
+  if (require_jalx)
+    {
+      bfd_boolean ok;
+      bfd_vma opcode = x >> 26;
+      bfd_vma jalx_opcode;
+
+      /* Check to see if the opcode is already JAL or JALX.  */
+      if (r_type == R_BROWNIE3216_26)
+	{
+	  ok = ((opcode == 0x6) || (opcode == 0x7));
+	  jalx_opcode = 0x7;
+	}
+      else
+	{
+	  ok = ((opcode == 0x3) || (opcode == 0x1d));
+	  jalx_opcode = 0x1d;
+	}
+
+      /* If the opcode is not JAL or JALX, there's a problem.  */
+      if (!ok)
+	{
+	  (*_bfd_error_handler)
+	    (_("%B: %A+0x%lx: jump to stub routine which is not jal"),
+	     input_bfd,
+	     input_section,
+	     (unsigned long) relocation->r_offset);
+	  bfd_set_error (bfd_error_bad_value);
+	  return FALSE;
+	}
+
+      /* Make this the JALX opcode.  */
+      x = (x & ~(0x3f << 26)) | (jalx_opcode << 26);
+    }
+
+  /* Put the value into the output.  */
+  bfd_put (8 * bfd_get_reloc_size (howto), input_bfd, x, location);
+
+  _bfd_brownie3216_elf_reloc_shuffle(input_bfd, r_type, !info->relocatable,
+				location);
+
+  return TRUE;
+}
+
+/* Returns TRUE if SECTION is a BROWNIE3216 stub section.  */
+
+static bfd_boolean
+brownie32_elf_stub_section_p (bfd *abfd ATTRIBUTE_UNUSED, asection *section)
+{
+  const char *name = bfd_get_section_name (abfd, section);
+
+  return (strncmp (name, FN_STUB, sizeof FN_STUB - 1) == 0
+	  || strncmp (name, CALL_STUB, sizeof CALL_STUB - 1) == 0
+	  || strncmp (name, CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0);
+}
+
+/* Add room for N relocations to the .rel.dyn section in ABFD.  */
+
+static void
+brownie32_elf_allocate_dynamic_relocations (bfd *abfd, unsigned int n)
+{
+  asection *s;
+
+  s = brownie32_elf_rel_dyn_section (abfd, FALSE);
+  BFD_ASSERT (s != NULL);
+
+  if (s->size == 0)
+    {
+      /* Make room for a null element.  */
+      s->size += BROWNIE32_ELF_REL_SIZE (abfd);
+      ++s->reloc_count;
+    }
+  s->size += n * BROWNIE32_ELF_REL_SIZE (abfd);
+}
+
+/* Create a rel.dyn relocation for the dynamic linker to resolve.  REL
+   is the original relocation, which is now being transformed into a
+   dynamic relocation.  The ADDENDP is adjusted if necessary; the
+   caller should store the result in place of the original addend.  */
+
+static bfd_boolean
+brownie32_elf_create_dynamic_relocation (bfd *output_bfd,
+				    struct bfd_link_info *info,
+				    const Elf_Internal_Rela *rel,
+				    struct brownie32_elf_link_hash_entry *h,
+				    asection *sec, bfd_vma symbol,
+				    bfd_vma *addendp, asection *input_section)
+{
+  Elf_Internal_Rela outrel[3];
+  asection *sreloc;
+  bfd *dynobj;
+  int r_type;
+  long indx;
+  bfd_boolean defined_p;
+
+  r_type = ELF_R_TYPE (output_bfd, rel->r_info);
+  dynobj = elf_hash_table (info)->dynobj;
+  sreloc = brownie32_elf_rel_dyn_section (dynobj, FALSE);
+  BFD_ASSERT (sreloc != NULL);
+  BFD_ASSERT (sreloc->contents != NULL);
+  BFD_ASSERT (sreloc->reloc_count * BROWNIE32_ELF_REL_SIZE (output_bfd)
+	      < sreloc->size);
+
+  outrel[0].r_offset =
+    _bfd_elf_section_offset (output_bfd, info, input_section, rel[0].r_offset);
+  outrel[1].r_offset =
+    _bfd_elf_section_offset (output_bfd, info, input_section, rel[1].r_offset);
+  outrel[2].r_offset =
+    _bfd_elf_section_offset (output_bfd, info, input_section, rel[2].r_offset);
+
+  if (outrel[0].r_offset == MINUS_ONE)
+    /* The relocation field has been deleted.  */
+    return TRUE;
+
+  if (outrel[0].r_offset == MINUS_TWO)
+    {
+      /* The relocation field has been converted into a relative value of
+	 some sort.  Functions like _bfd_elf_write_section_eh_frame expect
+	 the field to be fully relocated, so add in the symbol's value.  */
+      *addendp += symbol;
+      return TRUE;
+    }
+
+  /* We must now calculate the dynamic symbol table index to use
+     in the relocation.  */
+  if (h != NULL
+      && (! info->symbolic || !h->root.def_regular)
+      /* h->root.dynindx may be -1 if this symbol was marked to
+	 become local.  */
+      && h->root.dynindx != -1)
+    {
+      indx = h->root.dynindx;
+      if (SGI_COMPAT (output_bfd))
+	defined_p = h->root.def_regular;
+      else
+	/* ??? glibc's ld.so just adds the final GOT entry to the
+	   relocation field.  It therefore treats relocs against
+	   defined symbols in the same way as relocs against
+	   undefined symbols.  */
+	defined_p = FALSE;
+    }
+  else
+    {
+      if (sec != NULL && bfd_is_abs_section (sec))
+	indx = 0;
+      else if (sec == NULL || sec->owner == NULL)
+	{
+	  bfd_set_error (bfd_error_bad_value);
+	  return FALSE;
+	}
+      else
+	{
+	  indx = elf_section_data (sec->output_section)->dynindx;
+	  if (indx == 0)
+	    abort ();
+	}
+
+      /* Instead of generating a relocation using the section
+	 symbol, we may as well make it a fully relative
+	 relocation.  We want to avoid generating relocations to
+	 local symbols because we used to generate them
+	 incorrectly, without adding the original symbol value,
+	 which is mandated by the ABI for section symbols.  In
+	 order to give dynamic loaders and applications time to
+	 phase out the incorrect use, we refrain from emitting
+	 section-relative relocations.  It's not like they're
+	 useful, after all.  This should be a bit more efficient
+	 as well.  */
+      /* ??? Although this behavior is compatible with glibc's ld.so,
+	 the ABI says that relocations against STN_UNDEF should have
+	 a symbol value of 0.  Irix rld honors this, so relocations
+	 against STN_UNDEF have no effect.  */
+      if (!SGI_COMPAT (output_bfd))
+	indx = 0;
+      defined_p = TRUE;
+    }
+
+  /* If the relocation was previously an absolute relocation and
+     this symbol will not be referred to by the relocation, we must
+     adjust it by the value we give it in the dynamic symbol table.
+     Otherwise leave the job up to the dynamic linker.  */
+  if (defined_p && r_type != R_BROWNIE32_REL32)
+    *addendp += symbol;
+
+  /* The relocation is always an REL32 relocation because we don't
+     know where the shared library will wind up at load-time.  */
+  outrel[0].r_info = ELF_R_INFO (output_bfd, (unsigned long) indx,
+				 R_BROWNIE32_REL32);
+  /* For strict adherence to the ABI specification, we should
+     generate a R_BROWNIE32_64 relocation record by itself before the
+     _REL32/_64 record as well, such that the addend is read in as
+     a 64-bit value (REL32 is a 32-bit relocation, after all).
+     However, since none of the existing ELF64 BROWNIE32 dynamic
+     loaders seems to care, we don't waste space with these
+     artificial relocations.  If this turns out to not be true,
+     brownie32_elf_allocate_dynamic_relocation() should be tweaked so
+     as to make room for a pair of dynamic relocations per
+     invocation if ABI_64_P, and here we should generate an
+     additional relocation record with R_BROWNIE32_64 by itself for a
+     NULL symbol before this relocation record.  */
+  outrel[1].r_info = ELF_R_INFO (output_bfd, 0,
+				 ABI_64_P (output_bfd)
+				 ? R_BROWNIE32_64
+				 : R_BROWNIE32_NONE);
+  outrel[2].r_info = ELF_R_INFO (output_bfd, 0, R_BROWNIE32_NONE);
+
+  /* Adjust the output offset of the relocation to reference the
+     correct location in the output file.  */
+  outrel[0].r_offset += (input_section->output_section->vma
+			 + input_section->output_offset);
+  outrel[1].r_offset += (input_section->output_section->vma
+			 + input_section->output_offset);
+  outrel[2].r_offset += (input_section->output_section->vma
+			 + input_section->output_offset);
+
+  /* Put the relocation back out.  We have to use the special
+     relocation outputter in the 64-bit case since the 64-bit
+     relocation format is non-standard.  */
+  if (ABI_64_P (output_bfd))
+    {
+      (*get_elf_backend_data (output_bfd)->s->swap_reloc_out)
+	(output_bfd, &outrel[0],
+	 (sreloc->contents
+	  + sreloc->reloc_count * sizeof (Elf64_Mips_External_Rel)));
+    }
+  else
+    bfd_elf32_swap_reloc_out
+      (output_bfd, &outrel[0],
+       (sreloc->contents + sreloc->reloc_count * sizeof (Elf32_External_Rel)));
+
+  /* We've now added another relocation.  */
+  ++sreloc->reloc_count;
+
+  /* Make sure the output section is writable.  The dynamic linker
+     will be writing to it.  */
+  elf_section_data (input_section->output_section)->this_hdr.sh_flags
+    |= SHF_WRITE;
+
+  /* On IRIX5, make an entry of compact relocation info.  */
+  if (IRIX_COMPAT (output_bfd) == ict_irix5)
+    {
+      asection *scpt = bfd_get_section_by_name (dynobj, ".compact_rel");
+      bfd_byte *cr;
+
+      if (scpt)
+	{
+	  Elf32_crinfo cptrel;
+
+	  brownie32_elf_set_cr_format (cptrel, CRF_BROWNIE32_LONG);
+	  cptrel.vaddr = (rel->r_offset
+			  + input_section->output_section->vma
+			  + input_section->output_offset);
+	  if (r_type == R_BROWNIE32_REL32)
+	    brownie32_elf_set_cr_type (cptrel, CRT_BROWNIE32_REL32);
+	  else
+	    brownie32_elf_set_cr_type (cptrel, CRT_BROWNIE32_WORD);
+	  brownie32_elf_set_cr_dist2to (cptrel, 0);
+	  cptrel.konst = *addendp;
+
+	  cr = (scpt->contents
+		+ sizeof (Elf32_External_compact_rel));
+	  brownie32_elf_set_cr_relvaddr (cptrel, 0);
+	  bfd_elf32_swap_crinfo_out (output_bfd, &cptrel,
+				     ((Elf32_External_crinfo *) cr
+				      + scpt->reloc_count));
+	  ++scpt->reloc_count;
+	}
+    }
+
+  return TRUE;
+}
+
+/* Return the MACH for a BROWNIE32 e_flags value.  */
+
+unsigned long
+_bfd_elf_brownie32_mach (flagword flags)
+{
+    switch (flags & EF_BROWNIE32_ARCH)
+	{
+	default:
+	case E_BROWNIE32_ARCH_1:
+	  return bfd_mach_brownie32_std;
+	  break;
+    }
+
+  return 0;
+}
+
+/* Return printable name for ABI.  */
+
+static INLINE char *
+elf_brownie32_abi_name (bfd *abfd)
+{
+  flagword flags;
+
+  flags = elf_elfheader (abfd)->e_flags;
+  switch (flags & EF_BROWNIE32_ABI)
+    {
+    case 0:
+      if (ABI_N32_P (abfd))
+	return "N32";
+      else if (ABI_64_P (abfd))
+	return "64";
+      else
+	return "none";
+    case E_BROWNIE32_ABI_O32:
+      return "O32";
+    case E_BROWNIE32_ABI_O64:
+      return "O64";
+    case E_BROWNIE32_ABI_EABI32:
+      return "EABI32";
+    case E_BROWNIE32_ABI_EABI64:
+      return "EABI64";
+    default:
+      return "unknown abi";
+    }
+}
+
+/* BROWNIE32 ELF uses two common sections.  One is the usual one, and the
+   other is for small objects.  All the small objects are kept
+   together, and then referenced via the gp pointer, which yields
+   faster assembler code.  This is what we use for the small common
+   section.  This approach is copied from ecoff.c.  */
+static asection brownie32_elf_scom_section;
+static asymbol brownie32_elf_scom_symbol;
+static asymbol *brownie32_elf_scom_symbol_ptr;
+
+/* BROWNIE32 ELF also uses an acommon section, which represents an
+   allocated common symbol which may be overridden by a
+   definition in a shared library.  */
+static asection brownie32_elf_acom_section;
+static asymbol brownie32_elf_acom_symbol;
+static asymbol *brownie32_elf_acom_symbol_ptr;
+
+/* Handle the special BROWNIE32 section numbers that a symbol may use.
+   This is used for both the 32-bit and the 64-bit ABI.  */
+
+void
+_bfd_brownie32_elf_symbol_processing (bfd *abfd, asymbol *asym)
+{
+  elf_symbol_type *elfsym;
+
+  elfsym = (elf_symbol_type *) asym;
+  switch (elfsym->internal_elf_sym.st_shndx)
+    {
+    case SHN_BROWNIE32_ACOMMON:
+      /* This section is used in a dynamically linked executable file.
+	 It is an allocated common section.  The dynamic linker can
+	 either resolve these symbols to something in a shared
+	 library, or it can just leave them here.  For our purposes,
+	 we can consider these symbols to be in a new section.  */
+      if (brownie32_elf_acom_section.name == NULL)
+	{
+	  /* Initialize the acommon section.  */
+	  brownie32_elf_acom_section.name = ".acommon";
+	  brownie32_elf_acom_section.flags = SEC_ALLOC;
+	  brownie32_elf_acom_section.output_section = &brownie32_elf_acom_section;
+	  brownie32_elf_acom_section.symbol = &brownie32_elf_acom_symbol;
+	  brownie32_elf_acom_section.symbol_ptr_ptr = &brownie32_elf_acom_symbol_ptr;
+	  brownie32_elf_acom_symbol.name = ".acommon";
+	  brownie32_elf_acom_symbol.flags = BSF_SECTION_SYM;
+	  brownie32_elf_acom_symbol.section = &brownie32_elf_acom_section;
+	  brownie32_elf_acom_symbol_ptr = &brownie32_elf_acom_symbol;
+	}
+      asym->section = &brownie32_elf_acom_section;
+      break;
+
+    case SHN_COMMON:
+      /* Common symbols less than the GP size are automatically
+	 treated as SHN_BROWNIE32_SCOMMON symbols on IRIX5.  */
+      if (asym->value > elf_gp_size (abfd)
+	  || IRIX_COMPAT (abfd) == ict_irix6)
+	break;
+      /* Fall through.  */
+    case SHN_BROWNIE32_SCOMMON:
+      if (brownie32_elf_scom_section.name == NULL)
+	{
+	  /* Initialize the small common section.  */
+	  brownie32_elf_scom_section.name = ".scommon";
+	  brownie32_elf_scom_section.flags = SEC_IS_COMMON;
+	  brownie32_elf_scom_section.output_section = &brownie32_elf_scom_section;
+	  brownie32_elf_scom_section.symbol = &brownie32_elf_scom_symbol;
+	  brownie32_elf_scom_section.symbol_ptr_ptr = &brownie32_elf_scom_symbol_ptr;
+	  brownie32_elf_scom_symbol.name = ".scommon";
+	  brownie32_elf_scom_symbol.flags = BSF_SECTION_SYM;
+	  brownie32_elf_scom_symbol.section = &brownie32_elf_scom_section;
+	  brownie32_elf_scom_symbol_ptr = &brownie32_elf_scom_symbol;
+	}
+      asym->section = &brownie32_elf_scom_section;
+      asym->value = elfsym->internal_elf_sym.st_size;
+      break;
+
+    case SHN_BROWNIE32_SUNDEFINED:
+      asym->section = bfd_und_section_ptr;
+      break;
+
+    case SHN_BROWNIE32_TEXT:
+      {
+	asection *section = bfd_get_section_by_name (abfd, ".text");
+
+	BFD_ASSERT (SGI_COMPAT (abfd));
+	if (section != NULL)
+	  {
+	    asym->section = section;
+	    /* BROWNIE32_TEXT is a bit special, the address is not an offset
+	       to the base of the .text section.  So substract the section
+	       base address to make it an offset.  */
+	    asym->value -= section->vma;
+	  }
+      }
+      break;
+
+    case SHN_BROWNIE32_DATA:
+      {
+	asection *section = bfd_get_section_by_name (abfd, ".data");
+
+	BFD_ASSERT (SGI_COMPAT (abfd));
+	if (section != NULL)
+	  {
+	    asym->section = section;
+	    /* BROWNIE32_DATA is a bit special, the address is not an offset
+	       to the base of the .data section.  So substract the section
+	       base address to make it an offset.  */
+	    asym->value -= section->vma;
+	  }
+      }
+      break;
+    }
+}
+
+/* Implement elf_backend_eh_frame_address_size.  This differs from
+   the default in the way it handles EABI64.
+
+   EABI64 was originally specified as an LP64 ABI, and that is what
+   -mabi=eabi normally gives on a 64-bit target.  However, gcc has
+   historically accepted the combination of -mabi=eabi and -mlong32,
+   and this ILP32 variation has become semi-official over time.
+   Both forms use elf32 and have pointer-sized FDE addresses.
+
+   If an EABI object was generated by GCC 4.0 or above, it will have
+   an empty .gcc_compiled_longXX section, where XX is the size of longs
+   in bits.  Unfortunately, ILP32 objects generated by earlier compilers
+   have no special marking to distinguish them from LP64 objects.
+
+   We don't want users of the official LP64 ABI to be punished for the
+   existence of the ILP32 variant, but at the same time, we don't want
+   to mistakenly interpret pre-4.0 ILP32 objects as being LP64 objects.
+   We therefore take the following approach:
+
+      - If ABFD contains a .gcc_compiled_longXX section, use it to
+        determine the pointer size.
+
+      - Otherwise check the type of the first relocation.  Assume that
+        the LP64 ABI is being used if the relocation is of type R_BROWNIE32_64.
+
+      - Otherwise punt.
+
+   The second check is enough to detect LP64 objects generated by pre-4.0
+   compilers because, in the kind of output generated by those compilers,
+   the first relocation will be associated with either a CIE personality
+   routine or an FDE start address.  Furthermore, the compilers never
+   used a special (non-pointer) encoding for this ABI.
+
+   Checking the relocation type should also be safe because there is no
+   reason to use R_BROWNIE32_64 in an ILP32 object.  Pre-4.0 compilers never
+   did so.  */
+
+unsigned int
+_bfd_brownie32_elf_eh_frame_address_size (bfd *abfd, asection *sec)
+{
+  if (elf_elfheader (abfd)->e_ident[EI_CLASS] == ELFCLASS64)
+    return 8;
+  if ((elf_elfheader (abfd)->e_flags & EF_BROWNIE32_ABI) == E_BROWNIE32_ABI_EABI64)
+    {
+      bfd_boolean long32_p, long64_p;
+
+      long32_p = bfd_get_section_by_name (abfd, ".gcc_compiled_long32") != 0;
+      long64_p = bfd_get_section_by_name (abfd, ".gcc_compiled_long64") != 0;
+      if (long32_p && long64_p)
+	return 0;
+      if (long32_p)
+	return 4;
+      if (long64_p)
+	return 8;
+
+      if (sec->reloc_count > 0
+	  && elf_section_data (sec)->relocs != NULL
+	  && (ELF32_R_TYPE (elf_section_data (sec)->relocs[0].r_info)
+	      == R_BROWNIE32_64))
+	return 8;
+
+      return 0;
+    }
+  return 4;
+}
+
+/* There appears to be a bug in the BROWNIE32pro linker that causes GOT_DISP
+   relocations against two unnamed section symbols to resolve to the
+   same address.  For example, if we have code like:
+
+	lw	$4,%got_disp(.data)($gp)
+	lw	$25,%got_disp(.text)($gp)
+	jalr	$25
+
+   then the linker will resolve both relocations to .data and the program
+   will jump there rather than to .text.
+
+   We can work around this problem by giving names to local section symbols.
+   This is also what the BROWNIE32pro tools do.  */
+
+bfd_boolean
+_bfd_brownie32_elf_name_local_section_symbols (bfd *abfd)
+{
+  return SGI_COMPAT (abfd);
+}
+
+/* Work over a section just before writing it out.  This routine is
+   used by both the 32-bit and the 64-bit ABI.  FIXME: We recognize
+   sections that need the SHF_BROWNIE32_GPREL flag by name; there has to be
+   a better way.  */
+
+bfd_boolean
+_bfd_brownie32_elf_section_processing (bfd *abfd, Elf_Internal_Shdr *hdr)
+{
+  if (hdr->sh_type == SHT_BROWNIE32_REGINFO
+      && hdr->sh_size > 0)
+    {
+      bfd_byte buf[4];
+
+      BFD_ASSERT (hdr->sh_size == sizeof (Elf32_External_RegInfo));
+      BFD_ASSERT (hdr->contents == NULL);
+
+      if (bfd_seek (abfd,
+		    hdr->sh_offset + sizeof (Elf32_External_RegInfo) - 4,
+		    SEEK_SET) != 0)
+	return FALSE;
+      H_PUT_32 (abfd, elf_gp (abfd), buf);
+      if (bfd_bwrite (buf, 4, abfd) != 4)
+	return FALSE;
+    }
+
+  if (hdr->sh_type == SHT_BROWNIE32_OPTIONS
+      && hdr->bfd_section != NULL
+      && brownie32_elf_section_data (hdr->bfd_section) != NULL
+      && brownie32_elf_section_data (hdr->bfd_section)->u.tdata != NULL)
+    {
+      bfd_byte *contents, *l, *lend;
+
+      /* We stored the section contents in the tdata field in the
+	 set_section_contents routine.  We save the section contents
+	 so that we don't have to read them again.
+	 At this point we know that elf_gp is set, so we can look
+	 through the section contents to see if there is an
+	 ODK_REGINFO structure.  */
+
+      contents = brownie32_elf_section_data (hdr->bfd_section)->u.tdata;
+      l = contents;
+      lend = contents + hdr->sh_size;
+      while (l + sizeof (Elf_External_Options) <= lend)
+	{
+	  Elf_Internal_Options intopt;
+
+	  bfd_brownie32_elf_swap_options_in (abfd, (Elf_External_Options *) l,
+					&intopt);
+	  if (intopt.size < sizeof (Elf_External_Options))
+	    {
+	      (*_bfd_error_handler)
+		(_("%B: Warning: bad `%s' option size %u smaller than its header"),
+		abfd, BROWNIE32_ELF_OPTIONS_SECTION_NAME (abfd), intopt.size);
+	      break;
+	    }
+	  if (ABI_64_P (abfd) && intopt.kind == ODK_REGINFO)
+	    {
+	      bfd_byte buf[8];
+
+	      if (bfd_seek (abfd,
+			    (hdr->sh_offset
+			     + (l - contents)
+			     + sizeof (Elf_External_Options)
+			     + (sizeof (Elf64_External_RegInfo) - 8)),
+			     SEEK_SET) != 0)
+		return FALSE;
+	      H_PUT_64 (abfd, elf_gp (abfd), buf);
+	      if (bfd_bwrite (buf, 8, abfd) != 8)
+		return FALSE;
+	    }
+	  else if (intopt.kind == ODK_REGINFO)
+	    {
+	      bfd_byte buf[4];
+
+	      if (bfd_seek (abfd,
+			    (hdr->sh_offset
+			     + (l - contents)
+			     + sizeof (Elf_External_Options)
+			     + (sizeof (Elf32_External_RegInfo) - 4)),
+			    SEEK_SET) != 0)
+		return FALSE;
+	      H_PUT_32 (abfd, elf_gp (abfd), buf);
+	      if (bfd_bwrite (buf, 4, abfd) != 4)
+		return FALSE;
+	    }
+	  l += intopt.size;
+	}
+    }
+
+  if (hdr->bfd_section != NULL)
+    {
+      const char *name = bfd_get_section_name (abfd, hdr->bfd_section);
+
+      if (strcmp (name, ".sdata") == 0
+	  || strcmp (name, ".lit8") == 0
+	  || strcmp (name, ".lit4") == 0)
+	{
+	  hdr->sh_flags |= SHF_ALLOC | SHF_WRITE | SHF_BROWNIE32_GPREL;
+	  hdr->sh_type = SHT_PROGBITS;
+	}
+      else if (strcmp (name, ".sbss") == 0)
+	{
+	  hdr->sh_flags |= SHF_ALLOC | SHF_WRITE | SHF_BROWNIE32_GPREL;
+	  hdr->sh_type = SHT_NOBITS;
+	}
+      else if (strcmp (name, ".srdata") == 0)
+	{
+	  hdr->sh_flags |= SHF_ALLOC | SHF_BROWNIE32_GPREL;
+	  hdr->sh_type = SHT_PROGBITS;
+	}
+      else if (strcmp (name, ".compact_rel") == 0)
+	{
+	  hdr->sh_flags = 0;
+	  hdr->sh_type = SHT_PROGBITS;
+	}
+      else if (strcmp (name, ".rtproc") == 0)
+	{
+	  if (hdr->sh_addralign != 0 && hdr->sh_entsize == 0)
+	    {
+	      unsigned int adjust;
+
+	      adjust = hdr->sh_size % hdr->sh_addralign;
+	      if (adjust != 0)
+		hdr->sh_size += hdr->sh_addralign - adjust;
+	    }
+	}
+    }
+
+  return TRUE;
+}
+
+/* Handle a BROWNIE32 specific section when reading an object file.  This
+   is called when elfcode.h finds a section with an unknown type.
+   This routine supports both the 32-bit and 64-bit ELF ABI.
+
+   FIXME: We need to handle the SHF_BROWNIE32_GPREL flag, but I'm not sure
+   how to.  */
+
+bfd_boolean
+_bfd_brownie32_elf_section_from_shdr (bfd *abfd,
+				 Elf_Internal_Shdr *hdr,
+				 const char *name,
+				 int shindex)
+{
+  flagword flags = 0;
+
+  /* There ought to be a place to keep ELF backend specific flags, but
+     at the moment there isn't one.  We just keep track of the
+     sections by their name, instead.  Fortunately, the ABI gives
+     suggested names for all the BROWNIE32 specific sections, so we will
+     probably get away with this.  */
+  switch (hdr->sh_type)
+    {
+    case SHT_BROWNIE32_LIBLIST:
+      if (strcmp (name, ".liblist") != 0)
+	return FALSE;
+      break;
+    case SHT_BROWNIE32_MSYM:
+      if (strcmp (name, ".msym") != 0)
+	return FALSE;
+      break;
+    case SHT_BROWNIE32_CONFLICT:
+      if (strcmp (name, ".conflict") != 0)
+	return FALSE;
+      break;
+    case SHT_BROWNIE32_GPTAB:
+      if (strncmp (name, ".gptab.", sizeof ".gptab." - 1) != 0)
+	return FALSE;
+      break;
+    case SHT_BROWNIE32_UCODE:
+      if (strcmp (name, ".ucode") != 0)
+	return FALSE;
+      break;
+    case SHT_BROWNIE32_DEBUG:
+      if (strcmp (name, ".mdebug") != 0)
+	return FALSE;
+      flags = SEC_DEBUGGING;
+      break;
+    case SHT_BROWNIE32_REGINFO:
+      if (strcmp (name, ".reginfo") != 0
+	  || hdr->sh_size != sizeof (Elf32_External_RegInfo))
+	return FALSE;
+      flags = (SEC_LINK_ONCE | SEC_LINK_DUPLICATES_SAME_SIZE);
+      break;
+    case SHT_BROWNIE32_IFACE:
+      if (strcmp (name, ".BROWNIE32.interfaces") != 0)
+	return FALSE;
+      break;
+    case SHT_BROWNIE32_CONTENT:
+      if (strncmp (name, ".BROWNIE32.content", sizeof ".BROWNIE32.content" - 1) != 0)
+	return FALSE;
+      break;
+    case SHT_BROWNIE32_OPTIONS:
+      if (!BROWNIE32_ELF_OPTIONS_SECTION_NAME_P (name))
+	return FALSE;
+      break;
+    case SHT_BROWNIE32_DWARF:
+      if (strncmp (name, ".debug_", sizeof ".debug_" - 1) != 0)
+	return FALSE;
+      break;
+    case SHT_BROWNIE32_SYMBOL_LIB:
+      if (strcmp (name, ".BROWNIE32.symlib") != 0)
+	return FALSE;
+      break;
+    case SHT_BROWNIE32_EVENTS:
+      if (strncmp (name, ".BROWNIE32.events", sizeof ".BROWNIE32.events" - 1) != 0
+	  && strncmp (name, ".BROWNIE32.post_rel",
+		      sizeof ".BROWNIE32.post_rel" - 1) != 0)
+	return FALSE;
+      break;
+    default:
+      break;
+    }
+
+  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex))
+    return FALSE;
+
+  if (flags)
+    {
+      if (! bfd_set_section_flags (abfd, hdr->bfd_section,
+				   (bfd_get_section_flags (abfd,
+							   hdr->bfd_section)
+				    | flags)))
+	return FALSE;
+    }
+
+  /* FIXME: We should record sh_info for a .gptab section.  */
+
+  /* For a .reginfo section, set the gp value in the tdata information
+     from the contents of this section.  We need the gp value while
+     processing relocs, so we just get it now.  The .reginfo section
+     is not used in the 64-bit BROWNIE32 ELF ABI.  */
+  if (hdr->sh_type == SHT_BROWNIE32_REGINFO)
+    {
+      Elf32_External_RegInfo ext;
+      Elf32_RegInfo s;
+
+      if (! bfd_get_section_contents (abfd, hdr->bfd_section,
+				      &ext, 0, sizeof ext))
+	return FALSE;
+      bfd_brownie32_elf32_swap_reginfo_in (abfd, &ext, &s);
+      elf_gp (abfd) = s.ri_gp_value;
+    }
+
+  /* For a SHT_BROWNIE32_OPTIONS section, look for a ODK_REGINFO entry, and
+     set the gp value based on what we find.  We may see both
+     SHT_BROWNIE32_REGINFO and SHT_BROWNIE32_OPTIONS/ODK_REGINFO; in that case,
+     they should agree.  */
+  if (hdr->sh_type == SHT_BROWNIE32_OPTIONS)
+    {
+      bfd_byte *contents, *l, *lend;
+
+      contents = bfd_malloc (hdr->sh_size);
+      if (contents == NULL)
+	return FALSE;
+      if (! bfd_get_section_contents (abfd, hdr->bfd_section, contents,
+				      0, hdr->sh_size))
+	{
+	  free (contents);
+	  return FALSE;
+	}
+      l = contents;
+      lend = contents + hdr->sh_size;
+      while (l + sizeof (Elf_External_Options) <= lend)
+	{
+	  Elf_Internal_Options intopt;
+
+	  bfd_brownie32_elf_swap_options_in (abfd, (Elf_External_Options *) l,
+					&intopt);
+	  if (intopt.size < sizeof (Elf_External_Options))
+	    {
+	      (*_bfd_error_handler)
+		(_("%B: Warning: bad `%s' option size %u smaller than its header"),
+		abfd, BROWNIE32_ELF_OPTIONS_SECTION_NAME (abfd), intopt.size);
+	      break;
+	    }
+	  if (ABI_64_P (abfd) && intopt.kind == ODK_REGINFO)
+	    {
+	      Elf64_Internal_RegInfo intreg;
+
+	      bfd_brownie32_elf64_swap_reginfo_in
+		(abfd,
+		 ((Elf64_External_RegInfo *)
+		  (l + sizeof (Elf_External_Options))),
+		 &intreg);
+	      elf_gp (abfd) = intreg.ri_gp_value;
+	    }
+	  else if (intopt.kind == ODK_REGINFO)
+	    {
+	      Elf32_RegInfo intreg;
+
+	      bfd_brownie32_elf32_swap_reginfo_in
+		(abfd,
+		 ((Elf32_External_RegInfo *)
+		  (l + sizeof (Elf_External_Options))),
+		 &intreg);
+	      elf_gp (abfd) = intreg.ri_gp_value;
+	    }
+	  l += intopt.size;
+	}
+      free (contents);
+    }
+
+  return TRUE;
+}
+
+/* Set the correct type for a BROWNIE32 ELF section.  We do this by the
+   section name, which is a hack, but ought to work.  This routine is
+   used by both the 32-bit and the 64-bit ABI.  */
+
+bfd_boolean
+_bfd_brownie32_elf_fake_sections (bfd *abfd, Elf_Internal_Shdr *hdr, asection *sec)
+{
+  register const char *name;
+  unsigned int sh_type;
+
+  name = bfd_get_section_name (abfd, sec);
+  sh_type = hdr->sh_type;
+
+  if (strcmp (name, ".liblist") == 0)
+    {
+      hdr->sh_type = SHT_BROWNIE32_LIBLIST;
+      hdr->sh_info = sec->size / sizeof (Elf32_Lib);
+      /* The sh_link field is set in final_write_processing.  */
+    }
+  else if (strcmp (name, ".conflict") == 0)
+    hdr->sh_type = SHT_BROWNIE32_CONFLICT;
+  else if (strncmp (name, ".gptab.", sizeof ".gptab." - 1) == 0)
+    {
+      hdr->sh_type = SHT_BROWNIE32_GPTAB;
+      hdr->sh_entsize = sizeof (Elf32_External_gptab);
+      /* The sh_info field is set in final_write_processing.  */
+    }
+  else if (strcmp (name, ".ucode") == 0)
+    hdr->sh_type = SHT_BROWNIE32_UCODE;
+  else if (strcmp (name, ".mdebug") == 0)
+    {
+      hdr->sh_type = SHT_BROWNIE32_DEBUG;
+      /* In a shared object on IRIX 5.3, the .mdebug section has an
+         entsize of 0.  FIXME: Does this matter?  */
+      if (SGI_COMPAT (abfd) && (abfd->flags & DYNAMIC) != 0)
+	hdr->sh_entsize = 0;
+      else
+	hdr->sh_entsize = 1;
+    }
+  else if (strcmp (name, ".reginfo") == 0)
+    {
+      hdr->sh_type = SHT_BROWNIE32_REGINFO;
+      /* In a shared object on IRIX 5.3, the .reginfo section has an
+         entsize of 0x18.  FIXME: Does this matter?  */
+      if (SGI_COMPAT (abfd))
+	{
+	  if ((abfd->flags & DYNAMIC) != 0)
+	    hdr->sh_entsize = sizeof (Elf32_External_RegInfo);
+	  else
+	    hdr->sh_entsize = 1;
+	}
+      else
+	hdr->sh_entsize = sizeof (Elf32_External_RegInfo);
+    }
+  else if (SGI_COMPAT (abfd)
+	   && (strcmp (name, ".hash") == 0
+	       || strcmp (name, ".dynamic") == 0
+	       || strcmp (name, ".dynstr") == 0))
+    {
+      if (SGI_COMPAT (abfd))
+	hdr->sh_entsize = 0;
+#if 0
+      /* This isn't how the IRIX6 linker behaves.  */
+      hdr->sh_info = SIZEOF_BROWNIE32_DYNSYM_SECNAMES;
+#endif
+    }
+  else if (strcmp (name, ".got") == 0
+	   || strcmp (name, ".srdata") == 0
+	   || strcmp (name, ".sdata") == 0
+	   || strcmp (name, ".sbss") == 0
+	   || strcmp (name, ".lit4") == 0
+	   || strcmp (name, ".lit8") == 0)
+    hdr->sh_flags |= SHF_BROWNIE32_GPREL;
+  else if (strcmp (name, ".BROWNIE32.interfaces") == 0)
+    {
+      hdr->sh_type = SHT_BROWNIE32_IFACE;
+      hdr->sh_flags |= SHF_BROWNIE32_NOSTRIP;
+    }
+  else if (strncmp (name, ".BROWNIE32.content", strlen (".BROWNIE32.content")) == 0)
+    {
+      hdr->sh_type = SHT_BROWNIE32_CONTENT;
+      hdr->sh_flags |= SHF_BROWNIE32_NOSTRIP;
+      /* The sh_info field is set in final_write_processing.  */
+    }
+  else if (BROWNIE32_ELF_OPTIONS_SECTION_NAME_P (name))
+    {
+      hdr->sh_type = SHT_BROWNIE32_OPTIONS;
+      hdr->sh_entsize = 1;
+      hdr->sh_flags |= SHF_BROWNIE32_NOSTRIP;
+    }
+  else if (strncmp (name, ".debug_", sizeof ".debug_" - 1) == 0)
+    hdr->sh_type = SHT_BROWNIE32_DWARF;
+  else if (strcmp (name, ".BROWNIE32.symlib") == 0)
+    {
+      hdr->sh_type = SHT_BROWNIE32_SYMBOL_LIB;
+      /* The sh_link and sh_info fields are set in
+         final_write_processing.  */
+    }
+  else if (strncmp (name, ".BROWNIE32.events", sizeof ".BROWNIE32.events" - 1) == 0
+	   || strncmp (name, ".BROWNIE32.post_rel",
+		       sizeof ".BROWNIE32.post_rel" - 1) == 0)
+    {
+      hdr->sh_type = SHT_BROWNIE32_EVENTS;
+      hdr->sh_flags |= SHF_BROWNIE32_NOSTRIP;
+      /* The sh_link field is set in final_write_processing.  */
+    }
+  else if (strcmp (name, ".msym") == 0)
+    {
+      hdr->sh_type = SHT_BROWNIE32_MSYM;
+      hdr->sh_flags |= SHF_ALLOC;
+      hdr->sh_entsize = 8;
+    }
+
+  /* In the unlikely event a special section is empty it has to lose its
+     special meaning.  This may happen e.g. when using `strip' with the
+     "--only-keep-debug" option.  */
+  if (sec->size > 0 && !(sec->flags & SEC_HAS_CONTENTS))
+    hdr->sh_type = sh_type;
+
+  /* The generic elf_fake_sections will set up REL_HDR using the default
+   kind of relocations.  We used to set up a second header for the
+   non-default kind of relocations here, but only NewABI would use
+   these, and the IRIX ld doesn't like resulting empty RELA sections.
+   Thus we create those header only on demand now.  */
+
+  return TRUE;
+}
+
+/* Given a BFD section, try to locate the corresponding ELF section
+   index.  This is used by both the 32-bit and the 64-bit ABI.
+   Actually, it's not clear to me that the 64-bit ABI supports these,
+   but for non-PIC objects we will certainly want support for at least
+   the .scommon section.  */
+
+bfd_boolean
+_bfd_brownie32_elf_section_from_bfd_section (bfd *abfd ATTRIBUTE_UNUSED,
+					asection *sec, int *retval)
+{
+  if (strcmp (bfd_get_section_name (abfd, sec), ".scommon") == 0)
+    {
+      *retval = SHN_BROWNIE32_SCOMMON;
+      return TRUE;
+    }
+  if (strcmp (bfd_get_section_name (abfd, sec), ".acommon") == 0)
+    {
+      *retval = SHN_BROWNIE32_ACOMMON;
+      return TRUE;
+    }
+  return FALSE;
+}
+
+/* Hook called by the linker routine which adds symbols from an object
+   file.  We must handle the special BROWNIE32 section numbers here.  */
+
+bfd_boolean
+_bfd_brownie32_elf_add_symbol_hook (bfd *abfd, struct bfd_link_info *info,
+			       Elf_Internal_Sym *sym, const char **namep,
+			       flagword *flagsp ATTRIBUTE_UNUSED,
+			       asection **secp, bfd_vma *valp)
+{
+  if (SGI_COMPAT (abfd)
+      && (abfd->flags & DYNAMIC) != 0
+      && strcmp (*namep, "_rld_new_interface") == 0)
+    {
+      /* Skip IRIX5 rld entry name.  */
+      *namep = NULL;
+      return TRUE;
+    }
+
+  /* Shared objects may have a dynamic symbol '_gp_disp' defined as
+     a SECTION *ABS*.  This causes ld to think it can resolve _gp_disp
+     by setting a DT_NEEDED for the shared object.  Since _gp_disp is
+     a magic symbol resolved by the linker, we ignore this bogus definition
+     of _gp_disp.  New ABI objects do not suffer from this problem so this
+     is not done for them. */
+  if (!NEWABI_P(abfd)
+      && (sym->st_shndx == SHN_ABS)
+      && (strcmp (*namep, "_gp_disp") == 0))
+    {
+      *namep = NULL;
+      return TRUE;
+    }
+
+  switch (sym->st_shndx)
+    {
+    case SHN_COMMON:
+      /* Common symbols less than the GP size are automatically
+	 treated as SHN_BROWNIE32_SCOMMON symbols.  */
+      if (sym->st_size > elf_gp_size (abfd)
+	  || IRIX_COMPAT (abfd) == ict_irix6)
+	break;
+      /* Fall through.  */
+    case SHN_BROWNIE32_SCOMMON:
+      *secp = bfd_make_section_old_way (abfd, ".scommon");
+      (*secp)->flags |= SEC_IS_COMMON;
+      *valp = sym->st_size;
+      break;
+
+    case SHN_BROWNIE32_TEXT:
+      /* This section is used in a shared object.  */
+      if (elf_tdata (abfd)->elf_text_section == NULL)
+	{
+	  asymbol *elf_text_symbol;
+	  asection *elf_text_section;
+	  bfd_size_type amt = sizeof (asection);
+
+	  elf_text_section = bfd_zalloc (abfd, amt);
+	  if (elf_text_section == NULL)
+	    return FALSE;
+
+	  amt = sizeof (asymbol);
+	  elf_text_symbol = bfd_zalloc (abfd, amt);
+	  if (elf_text_symbol == NULL)
+	    return FALSE;
+
+	  /* Initialize the section.  */
+
+	  elf_tdata (abfd)->elf_text_section = elf_text_section;
+	  elf_tdata (abfd)->elf_text_symbol = elf_text_symbol;
+
+	  elf_text_section->symbol = elf_text_symbol;
+	  elf_text_section->symbol_ptr_ptr = &elf_tdata (abfd)->elf_text_symbol;
+
+	  elf_text_section->name = ".text";
+	  elf_text_section->flags = SEC_NO_FLAGS;
+	  elf_text_section->output_section = NULL;
+	  elf_text_section->owner = abfd;
+	  elf_text_symbol->name = ".text";
+	  elf_text_symbol->flags = BSF_SECTION_SYM | BSF_DYNAMIC;
+	  elf_text_symbol->section = elf_text_section;
+	}
+      /* This code used to do *secp = bfd_und_section_ptr if
+         info->shared.  I don't know why, and that doesn't make sense,
+         so I took it out.  */
+      *secp = elf_tdata (abfd)->elf_text_section;
+      break;
+
+    case SHN_BROWNIE32_ACOMMON:
+      /* Fall through. XXX Can we treat this as allocated data?  */
+    case SHN_BROWNIE32_DATA:
+      /* This section is used in a shared object.  */
+      if (elf_tdata (abfd)->elf_data_section == NULL)
+	{
+	  asymbol *elf_data_symbol;
+	  asection *elf_data_section;
+	  bfd_size_type amt = sizeof (asection);
+
+	  elf_data_section = bfd_zalloc (abfd, amt);
+	  if (elf_data_section == NULL)
+	    return FALSE;
+
+	  amt = sizeof (asymbol);
+	  elf_data_symbol = bfd_zalloc (abfd, amt);
+	  if (elf_data_symbol == NULL)
+	    return FALSE;
+
+	  /* Initialize the section.  */
+
+	  elf_tdata (abfd)->elf_data_section = elf_data_section;
+	  elf_tdata (abfd)->elf_data_symbol = elf_data_symbol;
+
+	  elf_data_section->symbol = elf_data_symbol;
+	  elf_data_section->symbol_ptr_ptr = &elf_tdata (abfd)->elf_data_symbol;
+
+	  elf_data_section->name = ".data";
+	  elf_data_section->flags = SEC_NO_FLAGS;
+	  elf_data_section->output_section = NULL;
+	  elf_data_section->owner = abfd;
+	  elf_data_symbol->name = ".data";
+	  elf_data_symbol->flags = BSF_SECTION_SYM | BSF_DYNAMIC;
+	  elf_data_symbol->section = elf_data_section;
+	}
+      /* This code used to do *secp = bfd_und_section_ptr if
+         info->shared.  I don't know why, and that doesn't make sense,
+         so I took it out.  */
+      *secp = elf_tdata (abfd)->elf_data_section;
+      break;
+
+    case SHN_BROWNIE32_SUNDEFINED:
+      *secp = bfd_und_section_ptr;
+      break;
+    }
+
+  if (SGI_COMPAT (abfd)
+      && ! info->shared
+      && info->hash->creator == abfd->xvec
+      && strcmp (*namep, "__rld_obj_head") == 0)
+    {
+      struct elf_link_hash_entry *h;
+      struct bfd_link_hash_entry *bh;
+
+      /* Mark __rld_obj_head as dynamic.  */
+      bh = NULL;
+      if (! (_bfd_generic_link_add_one_symbol
+	     (info, abfd, *namep, BSF_GLOBAL, *secp, *valp, NULL, FALSE,
+	      get_elf_backend_data (abfd)->collect, &bh)))
+	return FALSE;
+
+      h = (struct elf_link_hash_entry *) bh;
+      h->non_elf = 0;
+      h->def_regular = 1;
+      h->type = STT_OBJECT;
+
+      if (! bfd_elf_link_record_dynamic_symbol (info, h))
+	return FALSE;
+
+      brownie32_elf_hash_table (info)->use_rld_obj_head = TRUE;
+    }
+
+  /* If this is a brownie3216 text symbol, add 1 to the value to make it
+     odd.  This will cause something like .word SYM to come up with
+     the right value when it is loaded into the PC.  */
+  if (sym->st_other == STO_BROWNIE3216)
+    ++*valp;
+
+  return TRUE;
+}
+
+/* This hook function is called before the linker writes out a global
+   symbol.  We mark symbols as small common if appropriate.  This is
+   also where we undo the increment of the value for a brownie3216 symbol.  */
+
+bfd_boolean
+_bfd_brownie32_elf_link_output_symbol_hook
+  (struct bfd_link_info *info ATTRIBUTE_UNUSED,
+   const char *name ATTRIBUTE_UNUSED, Elf_Internal_Sym *sym,
+   asection *input_sec, struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
+{
+  /* If we see a common symbol, which implies a relocatable link, then
+     if a symbol was small common in an input file, mark it as small
+     common in the output file.  */
+  if (sym->st_shndx == SHN_COMMON
+      && strcmp (input_sec->name, ".scommon") == 0)
+    sym->st_shndx = SHN_BROWNIE32_SCOMMON;
+
+  if (sym->st_other == STO_BROWNIE3216)
+    sym->st_value &= ~1;
+
+  return TRUE;
+}
+
+/* Functions for the dynamic linker.  */
+
+/* Create dynamic sections when linking against a dynamic object.  */
+
+bfd_boolean
+_bfd_brownie32_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
+{
+  struct elf_link_hash_entry *h;
+  struct bfd_link_hash_entry *bh;
+  flagword flags;
+  register asection *s;
+  const char * const *namep;
+
+  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
+	   | SEC_LINKER_CREATED | SEC_READONLY);
+
+  /* Mips ABI requests the .dynamic section to be read only.  */
+  s = bfd_get_section_by_name (abfd, ".dynamic");
+  if (s != NULL)
+    {
+      if (! bfd_set_section_flags (abfd, s, flags))
+	return FALSE;
+    }
+
+  /* We need to create .got section.  */
+  if (! brownie32_elf_create_got_section (abfd, info, FALSE))
+    return FALSE;
+
+  if (! brownie32_elf_rel_dyn_section (elf_hash_table (info)->dynobj, TRUE))
+    return FALSE;
+
+  /* Create .stub section.  */
+  if (bfd_get_section_by_name (abfd,
+			       BROWNIE32_ELF_STUB_SECTION_NAME (abfd)) == NULL)
+    {
+      s = bfd_make_section_with_flags (abfd,
+				       BROWNIE32_ELF_STUB_SECTION_NAME (abfd),
+				       flags | SEC_CODE);
+      if (s == NULL
+	  || ! bfd_set_section_alignment (abfd, s,
+					  BROWNIE32_ELF_LOG_FILE_ALIGN (abfd)))
+	return FALSE;
+    }
+
+  if ((IRIX_COMPAT (abfd) == ict_irix5 || IRIX_COMPAT (abfd) == ict_none)
+      && !info->shared
+      && bfd_get_section_by_name (abfd, ".rld_map") == NULL)
+    {
+      s = bfd_make_section_with_flags (abfd, ".rld_map",
+				       flags &~ (flagword) SEC_READONLY);
+      if (s == NULL
+	  || ! bfd_set_section_alignment (abfd, s,
+					  BROWNIE32_ELF_LOG_FILE_ALIGN (abfd)))
+	return FALSE;
+    }
+
+  /* On IRIX5, we adjust add some additional symbols and change the
+     alignments of several sections.  There is no ABI documentation
+     indicating that this is necessary on IRIX6, nor any evidence that
+     the linker takes such action.  */
+  if (IRIX_COMPAT (abfd) == ict_irix5)
+    {
+      for (namep = brownie32_elf_dynsym_rtproc_names; *namep != NULL; namep++)
+	{
+	  bh = NULL;
+	  if (! (_bfd_generic_link_add_one_symbol
+		 (info, abfd, *namep, BSF_GLOBAL, bfd_und_section_ptr, 0,
+		  NULL, FALSE, get_elf_backend_data (abfd)->collect, &bh)))
+	    return FALSE;
+
+	  h = (struct elf_link_hash_entry *) bh;
+	  h->non_elf = 0;
+	  h->def_regular = 1;
+	  h->type = STT_SECTION;
+
+	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
+	    return FALSE;
+	}
+
+      /* We need to create a .compact_rel section.  */
+      if (SGI_COMPAT (abfd))
+	{
+	  if (!brownie32_elf_create_compact_rel_section (abfd, info))
+	    return FALSE;
+	}
+
+      /* Change alignments of some sections.  */
+      s = bfd_get_section_by_name (abfd, ".hash");
+      if (s != NULL)
+	bfd_set_section_alignment (abfd, s, BROWNIE32_ELF_LOG_FILE_ALIGN (abfd));
+      s = bfd_get_section_by_name (abfd, ".dynsym");
+      if (s != NULL)
+	bfd_set_section_alignment (abfd, s, BROWNIE32_ELF_LOG_FILE_ALIGN (abfd));
+      s = bfd_get_section_by_name (abfd, ".dynstr");
+      if (s != NULL)
+	bfd_set_section_alignment (abfd, s, BROWNIE32_ELF_LOG_FILE_ALIGN (abfd));
+      s = bfd_get_section_by_name (abfd, ".reginfo");
+      if (s != NULL)
+	bfd_set_section_alignment (abfd, s, BROWNIE32_ELF_LOG_FILE_ALIGN (abfd));
+      s = bfd_get_section_by_name (abfd, ".dynamic");
+      if (s != NULL)
+	bfd_set_section_alignment (abfd, s, BROWNIE32_ELF_LOG_FILE_ALIGN (abfd));
+    }
+
+  if (!info->shared)
+    {
+      const char *name;
+
+      name = SGI_COMPAT (abfd) ? "_DYNAMIC_LINK" : "_DYNAMIC_LINKING";
+      bh = NULL;
+      if (!(_bfd_generic_link_add_one_symbol
+	    (info, abfd, name, BSF_GLOBAL, bfd_abs_section_ptr, 0,
+	     NULL, FALSE, get_elf_backend_data (abfd)->collect, &bh)))
+	return FALSE;
+
+      h = (struct elf_link_hash_entry *) bh;
+      h->non_elf = 0;
+      h->def_regular = 1;
+      h->type = STT_SECTION;
+
+      if (! bfd_elf_link_record_dynamic_symbol (info, h))
+	return FALSE;
+
+      if (! brownie32_elf_hash_table (info)->use_rld_obj_head)
+	{
+	  /* __rld_map is a four byte word located in the .data section
+	     and is filled in by the rtld to contain a pointer to
+	     the _r_debug structure. Its symbol value will be set in
+	     _bfd_brownie32_elf_finish_dynamic_symbol.  */
+	  s = bfd_get_section_by_name (abfd, ".rld_map");
+	  BFD_ASSERT (s != NULL);
+
+	  name = SGI_COMPAT (abfd) ? "__rld_map" : "__RLD_MAP";
+	  bh = NULL;
+	  if (!(_bfd_generic_link_add_one_symbol
+		(info, abfd, name, BSF_GLOBAL, s, 0, NULL, FALSE,
+		 get_elf_backend_data (abfd)->collect, &bh)))
+	    return FALSE;
+
+	  h = (struct elf_link_hash_entry *) bh;
+	  h->non_elf = 0;
+	  h->def_regular = 1;
+	  h->type = STT_OBJECT;
+
+	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
+	    return FALSE;
+	}
+    }
+
+  return TRUE;
+}
+
+/* Look through the relocs for a section during the first phase, and
+   allocate space in the global offset table.  */
+
+bfd_boolean
+_bfd_brownie32_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
+			    asection *sec, const Elf_Internal_Rela *relocs)
+{
+  const char *name;
+  bfd *dynobj;
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  struct brownie32_got_info *g;
+  size_t extsymoff;
+  const Elf_Internal_Rela *rel;
+  const Elf_Internal_Rela *rel_end;
+  asection *sgot;
+  asection *sreloc;
+  const struct elf_backend_data *bed;
+
+  if (info->relocatable)
+    return TRUE;
+
+  dynobj = elf_hash_table (info)->dynobj;
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (abfd);
+  extsymoff = (elf_bad_symtab (abfd)) ? 0 : symtab_hdr->sh_info;
+
+  /* Check for the brownie3216 stub sections.  */
+
+  name = bfd_get_section_name (abfd, sec);
+  if (strncmp (name, FN_STUB, sizeof FN_STUB - 1) == 0)
+    {
+      unsigned long r_symndx;
+
+      /* Look at the relocation information to figure out which symbol
+         this is for.  */
+
+      r_symndx = ELF_R_SYM (abfd, relocs->r_info);
+
+      if (r_symndx < extsymoff
+	  || sym_hashes[r_symndx - extsymoff] == NULL)
+	{
+	  asection *o;
+
+	  /* This stub is for a local symbol.  This stub will only be
+             needed if there is some relocation in this BFD, other
+             than a 16 bit function call, which refers to this symbol.  */
+	  for (o = abfd->sections; o != NULL; o = o->next)
+	    {
+	      Elf_Internal_Rela *sec_relocs;
+	      const Elf_Internal_Rela *r, *rend;
+
+	      /* We can ignore stub sections when looking for relocs.  */
+	      if ((o->flags & SEC_RELOC) == 0
+		  || o->reloc_count == 0
+		  || strncmp (bfd_get_section_name (abfd, o), FN_STUB,
+			      sizeof FN_STUB - 1) == 0
+		  || strncmp (bfd_get_section_name (abfd, o), CALL_STUB,
+			      sizeof CALL_STUB - 1) == 0
+		  || strncmp (bfd_get_section_name (abfd, o), CALL_FP_STUB,
+			      sizeof CALL_FP_STUB - 1) == 0)
+		continue;
+
+	      sec_relocs
+		= _bfd_elf_link_read_relocs (abfd, o, NULL, NULL,
+					     info->keep_memory);
+	      if (sec_relocs == NULL)
+		return FALSE;
+
+	      rend = sec_relocs + o->reloc_count;
+	      for (r = sec_relocs; r < rend; r++)
+		if (ELF_R_SYM (abfd, r->r_info) == r_symndx
+		    && ELF_R_TYPE (abfd, r->r_info) != R_BROWNIE3216_26)
+		  break;
+
+	      if (elf_section_data (o)->relocs != sec_relocs)
+		free (sec_relocs);
+
+	      if (r < rend)
+		break;
+	    }
+
+	  if (o == NULL)
+	    {
+	      /* There is no non-call reloc for this stub, so we do
+                 not need it.  Since this function is called before
+                 the linker maps input sections to output sections, we
+                 can easily discard it by setting the SEC_EXCLUDE
+                 flag.  */
+	      sec->flags |= SEC_EXCLUDE;
+	      return TRUE;
+	    }
+
+	  /* Record this stub in an array of local symbol stubs for
+             this BFD.  */
+	  if (elf_tdata (abfd)->local_stubs == NULL)
+	    {
+	      unsigned long symcount;
+	      asection **n;
+	      bfd_size_type amt;
+
+	      if (elf_bad_symtab (abfd))
+		symcount = NUM_SHDR_ENTRIES (symtab_hdr);
+	      else
+		symcount = symtab_hdr->sh_info;
+	      amt = symcount * sizeof (asection *);
+	      n = bfd_zalloc (abfd, amt);
+	      if (n == NULL)
+		return FALSE;
+	      elf_tdata (abfd)->local_stubs = n;
+	    }
+
+	  elf_tdata (abfd)->local_stubs[r_symndx] = sec;
+
+	  /* We don't need to set brownie3216_stubs_seen in this case.
+             That flag is used to see whether we need to look through
+             the global symbol table for stubs.  We don't need to set
+             it here, because we just have a local stub.  */
+	}
+      else
+	{
+	  struct brownie32_elf_link_hash_entry *h;
+
+	  h = ((struct brownie32_elf_link_hash_entry *)
+	       sym_hashes[r_symndx - extsymoff]);
+
+	  while (h->root.root.type == bfd_link_hash_indirect
+		 || h->root.root.type == bfd_link_hash_warning)
+	    h = (struct brownie32_elf_link_hash_entry *) h->root.root.u.i.link;
+
+	  /* H is the symbol this stub is for.  */
+
+	  h->fn_stub = sec;
+	  brownie32_elf_hash_table (info)->brownie3216_stubs_seen = TRUE;
+	}
+    }
+  else if (strncmp (name, CALL_STUB, sizeof CALL_STUB - 1) == 0
+	   || strncmp (name, CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0)
+    {
+      unsigned long r_symndx;
+      struct brownie32_elf_link_hash_entry *h;
+      asection **loc;
+
+      /* Look at the relocation information to figure out which symbol
+         this is for.  */
+
+      r_symndx = ELF_R_SYM (abfd, relocs->r_info);
+
+      if (r_symndx < extsymoff
+	  || sym_hashes[r_symndx - extsymoff] == NULL)
+	{
+	  /* This stub was actually built for a static symbol defined
+	     in the same file.  We assume that all static symbols in
+	     brownie3216 code are themselves brownie3216, so we can simply
+	     discard this stub.  Since this function is called before
+	     the linker maps input sections to output sections, we can
+	     easily discard it by setting the SEC_EXCLUDE flag.  */
+	  sec->flags |= SEC_EXCLUDE;
+	  return TRUE;
+	}
+
+      h = ((struct brownie32_elf_link_hash_entry *)
+	   sym_hashes[r_symndx - extsymoff]);
+
+      /* H is the symbol this stub is for.  */
+
+      if (strncmp (name, CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0)
+	loc = &h->call_fp_stub;
+      else
+	loc = &h->call_stub;
+
+      /* If we already have an appropriate stub for this function, we
+	 don't need another one, so we can discard this one.  Since
+	 this function is called before the linker maps input sections
+	 to output sections, we can easily discard it by setting the
+	 SEC_EXCLUDE flag.  We can also discard this section if we
+	 happen to already know that this is a brownie3216 function; it is
+	 not necessary to check this here, as it is checked later, but
+	 it is slightly faster to check now.  */
+      if (*loc != NULL || h->root.other == STO_BROWNIE3216)
+	{
+	  sec->flags |= SEC_EXCLUDE;
+	  return TRUE;
+	}
+
+      *loc = sec;
+      brownie32_elf_hash_table (info)->brownie3216_stubs_seen = TRUE;
+    }
+
+  if (dynobj == NULL)
+    {
+      sgot = NULL;
+      g = NULL;
+    }
+  else
+    {
+      sgot = brownie32_elf_got_section (dynobj, FALSE);
+      if (sgot == NULL)
+	g = NULL;
+      else
+	{
+	  BFD_ASSERT (brownie32_elf_section_data (sgot) != NULL);
+	  g = brownie32_elf_section_data (sgot)->u.got_info;
+	  BFD_ASSERT (g != NULL);
+	}
+    }
+
+  sreloc = NULL;
+  bed = get_elf_backend_data (abfd);
+  rel_end = relocs + sec->reloc_count * bed->s->int_rels_per_ext_rel;
+  for (rel = relocs; rel < rel_end; ++rel)
+    {
+      unsigned long r_symndx;
+      unsigned int r_type;
+      struct elf_link_hash_entry *h;
+
+      r_symndx = ELF_R_SYM (abfd, rel->r_info);
+      r_type = ELF_R_TYPE (abfd, rel->r_info);
+
+      if (r_symndx < extsymoff)
+	h = NULL;
+      else if (r_symndx >= extsymoff + NUM_SHDR_ENTRIES (symtab_hdr))
+	{
+	  (*_bfd_error_handler)
+	    (_("%B: Malformed reloc detected for section %s"),
+	     abfd, name);
+	  bfd_set_error (bfd_error_bad_value);
+	  return FALSE;
+	}
+      else
+	{
+	  h = sym_hashes[r_symndx - extsymoff];
+
+	  /* This may be an indirect symbol created because of a version.  */
+	  if (h != NULL)
+	    {
+	      while (h->root.type == bfd_link_hash_indirect)
+		h = (struct elf_link_hash_entry *) h->root.u.i.link;
+	    }
+	}
+
+      /* Some relocs require a global offset table.  */
+      if (dynobj == NULL || sgot == NULL)
+	{
+	  switch (r_type)
+	    {
+	    case R_BROWNIE32_GOT16:
+	    case R_BROWNIE32_CALL16:
+	    case R_BROWNIE32_CALL_HI16:
+	    case R_BROWNIE32_CALL_LO16:
+	    case R_BROWNIE32_GOT_HI16:
+	    case R_BROWNIE32_GOT_LO16:
+	    case R_BROWNIE32_GOT_PAGE:
+	    case R_BROWNIE32_GOT_OFST:
+	    case R_BROWNIE32_GOT_DISP:
+	    case R_BROWNIE32_TLS_GD:
+	    case R_BROWNIE32_TLS_LDM:
+	      if (dynobj == NULL)
+		elf_hash_table (info)->dynobj = dynobj = abfd;
+	      if (! brownie32_elf_create_got_section (dynobj, info, FALSE))
+		return FALSE;
+	      g = brownie32_elf_got_info (dynobj, &sgot);
+	      break;
+
+	    case R_BROWNIE32_32:
+	    case R_BROWNIE32_REL32:
+	    case R_BROWNIE32_64:
+	      if (dynobj == NULL
+		  && (info->shared || h != NULL)
+		  && (sec->flags & SEC_ALLOC) != 0)
+		elf_hash_table (info)->dynobj = dynobj = abfd;
+	      break;
+
+	    default:
+	      break;
+	    }
+	}
+
+      if (!h && (r_type == R_BROWNIE32_CALL_LO16
+		 || r_type == R_BROWNIE32_GOT_LO16
+		 || r_type == R_BROWNIE32_GOT_DISP))
+	{
+	  /* We may need a local GOT entry for this relocation.  We
+	     don't count R_BROWNIE32_GOT_PAGE because we can estimate the
+	     maximum number of pages needed by looking at the size of
+	     the segment.  Similar comments apply to R_BROWNIE32_GOT16 and
+	     R_BROWNIE32_CALL16.  We don't count R_BROWNIE32_GOT_HI16, or
+	     R_BROWNIE32_CALL_HI16 because these are always followed by an
+	     R_BROWNIE32_GOT_LO16 or R_BROWNIE32_CALL_LO16.  */
+	  if (! brownie32_elf_record_local_got_symbol (abfd, r_symndx,
+						  rel->r_addend, g, 0))
+	    return FALSE;
+	}
+
+      switch (r_type)
+	{
+	case R_BROWNIE32_CALL16:
+	  if (h == NULL)
+	    {
+	      (*_bfd_error_handler)
+		(_("%B: CALL16 reloc at 0x%lx not against global symbol"),
+		 abfd, (unsigned long) rel->r_offset);
+	      bfd_set_error (bfd_error_bad_value);
+	      return FALSE;
+	    }
+	  /* Fall through.  */
+
+	case R_BROWNIE32_CALL_HI16:
+	case R_BROWNIE32_CALL_LO16:
+	  if (h != NULL)
+	    {
+	      /* This symbol requires a global offset table entry.  */
+	      if (! brownie32_elf_record_global_got_symbol (h, abfd, info, g, 0))
+		return FALSE;
+
+	      /* We need a stub, not a plt entry for the undefined
+		 function.  But we record it as if it needs plt.  See
+		 _bfd_elf_adjust_dynamic_symbol.  */
+	      h->needs_plt = 1;
+	      h->type = STT_FUNC;
+	    }
+	  break;
+
+	case R_BROWNIE32_GOT_PAGE:
+	  /* If this is a global, overridable symbol, GOT_PAGE will
+	     decay to GOT_DISP, so we'll need a GOT entry for it.  */
+	  if (h == NULL)
+	    break;
+	  else
+	    {
+	      struct brownie32_elf_link_hash_entry *hbrownie32 =
+		(struct brownie32_elf_link_hash_entry *) h;
+
+	      while (hbrownie32->root.root.type == bfd_link_hash_indirect
+		     || hbrownie32->root.root.type == bfd_link_hash_warning)
+		hbrownie32 = (struct brownie32_elf_link_hash_entry *)
+		  hbrownie32->root.root.u.i.link;
+
+	      if (hbrownie32->root.def_regular
+		  && ! (info->shared && ! info->symbolic
+			&& ! hbrownie32->root.forced_local))
+		break;
+	    }
+	  /* Fall through.  */
+
+	case R_BROWNIE32_GOT16:
+	case R_BROWNIE32_GOT_HI16:
+	case R_BROWNIE32_GOT_LO16:
+	case R_BROWNIE32_GOT_DISP:
+	  if (h && ! brownie32_elf_record_global_got_symbol (h, abfd, info, g, 0))
+	    return FALSE;
+	  break;
+
+	case R_BROWNIE32_TLS_GOTTPREL:
+	  if (info->shared)
+	    info->flags |= DF_STATIC_TLS;
+	  /* Fall through */
+
+	case R_BROWNIE32_TLS_LDM:
+	  if (r_type == R_BROWNIE32_TLS_LDM)
+	    {
+	      r_symndx = 0;
+	      h = NULL;
+	    }
+	  /* Fall through */
+
+	case R_BROWNIE32_TLS_GD:
+	  /* This symbol requires a global offset table entry, or two
+	     for TLS GD relocations.  */
+	  {
+	    unsigned char flag = (r_type == R_BROWNIE32_TLS_GD
+				  ? GOT_TLS_GD
+				  : r_type == R_BROWNIE32_TLS_LDM
+				  ? GOT_TLS_LDM
+				  : GOT_TLS_IE);
+	    if (h != NULL)
+	      {
+		struct brownie32_elf_link_hash_entry *hbrownie32 =
+		  (struct brownie32_elf_link_hash_entry *) h;
+		hbrownie32->tls_type |= flag;
+
+		if (h && ! brownie32_elf_record_global_got_symbol (h, abfd, info, g, flag))
+		  return FALSE;
+	      }
+	    else
+	      {
+		BFD_ASSERT (flag == GOT_TLS_LDM || r_symndx != 0);
+
+		if (! brownie32_elf_record_local_got_symbol (abfd, r_symndx,
+							rel->r_addend, g, flag))
+		  return FALSE;
+	      }
+	  }
+	  break;
+
+	case R_BROWNIE32_32:
+	case R_BROWNIE32_REL32:
+	case R_BROWNIE32_64:
+	  if ((info->shared || h != NULL)
+	      && (sec->flags & SEC_ALLOC) != 0)
+	    {
+	      if (sreloc == NULL)
+		{
+		  sreloc = brownie32_elf_rel_dyn_section (dynobj, TRUE);
+		  if (sreloc == NULL)
+		    return FALSE;
+		}
+#define BROWNIE32_READONLY_SECTION (SEC_ALLOC | SEC_LOAD | SEC_READONLY)
+	      if (info->shared)
+		{
+		  /* When creating a shared object, we must copy these
+		     reloc types into the output file as R_BROWNIE32_REL32
+		     relocs.  We make room for this reloc in the
+		     .rel.dyn reloc section.  */
+		  brownie32_elf_allocate_dynamic_relocations (dynobj, 1);
+		  if ((sec->flags & BROWNIE32_READONLY_SECTION)
+		      == BROWNIE32_READONLY_SECTION)
+		    /* We tell the dynamic linker that there are
+		       relocations against the text segment.  */
+		    info->flags |= DF_TEXTREL;
+		}
+	      else
+		{
+		  struct brownie32_elf_link_hash_entry *hbrownie32;
+
+		  /* We only need to copy this reloc if the symbol is
+                     defined in a dynamic object.  */
+		  hbrownie32 = (struct brownie32_elf_link_hash_entry *) h;
+		  ++hbrownie32->possibly_dynamic_relocs;
+		  if ((sec->flags & BROWNIE32_READONLY_SECTION)
+		      == BROWNIE32_READONLY_SECTION)
+		    /* We need it to tell the dynamic linker if there
+		       are relocations against the text segment.  */
+		    hbrownie32->readonly_reloc = TRUE;
+		}
+
+	      /* Even though we don't directly need a GOT entry for
+		 this symbol, a symbol must have a dynamic symbol
+		 table index greater that DT_BROWNIE32_GOTSYM if there are
+		 dynamic relocations against it.  */
+	      if (h != NULL)
+		{
+		  if (dynobj == NULL)
+		    elf_hash_table (info)->dynobj = dynobj = abfd;
+		  if (! brownie32_elf_create_got_section (dynobj, info, TRUE))
+		    return FALSE;
+		  g = brownie32_elf_got_info (dynobj, &sgot);
+		  if (! brownie32_elf_record_global_got_symbol (h, abfd, info, g, 0))
+		    return FALSE;
+		}
+	    }
+
+	  if (SGI_COMPAT (abfd))
+	    brownie32_elf_hash_table (info)->compact_rel_size +=
+	      sizeof (Elf32_External_crinfo);
+	  break;
+
+	case R_BROWNIE32_26:
+	case R_BROWNIE32_GPREL16:
+	case R_BROWNIE32_LITERAL:
+	case R_BROWNIE32_GPREL32:
+	  if (SGI_COMPAT (abfd))
+	    brownie32_elf_hash_table (info)->compact_rel_size +=
+	      sizeof (Elf32_External_crinfo);
+	  break;
+
+	  /* This relocation describes the C++ object vtable hierarchy.
+	     Reconstruct it for later use during GC.  */
+	case R_BROWNIE32_GNU_VTINHERIT:
+	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
+	    return FALSE;
+	  break;
+
+	  /* This relocation describes which C++ vtable entries are actually
+	     used.  Record for later use during GC.  */
+	case R_BROWNIE32_GNU_VTENTRY:
+	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
+	    return FALSE;
+	  break;
+
+	default:
+	  break;
+	}
+
+      /* We must not create a stub for a symbol that has relocations
+         related to taking the function's address.  */
+      switch (r_type)
+	{
+	default:
+	  if (h != NULL)
+	    {
+	      struct brownie32_elf_link_hash_entry *mh;
+
+	      mh = (struct brownie32_elf_link_hash_entry *) h;
+	      mh->no_fn_stub = TRUE;
+	    }
+	  break;
+	case R_BROWNIE32_CALL16:
+	case R_BROWNIE32_CALL_HI16:
+	case R_BROWNIE32_CALL_LO16:
+	case R_BROWNIE32_JALR:
+	  break;
+	}
+
+      /* If this reloc is not a 16 bit call, and it has a global
+         symbol, then we will need the fn_stub if there is one.
+         References from a stub section do not count.  */
+      if (h != NULL
+	  && r_type != R_BROWNIE3216_26
+	  && strncmp (bfd_get_section_name (abfd, sec), FN_STUB,
+		      sizeof FN_STUB - 1) != 0
+	  && strncmp (bfd_get_section_name (abfd, sec), CALL_STUB,
+		      sizeof CALL_STUB - 1) != 0
+	  && strncmp (bfd_get_section_name (abfd, sec), CALL_FP_STUB,
+		      sizeof CALL_FP_STUB - 1) != 0)
+	{
+	  struct brownie32_elf_link_hash_entry *mh;
+
+	  mh = (struct brownie32_elf_link_hash_entry *) h;
+	  mh->need_fn_stub = TRUE;
+	}
+    }
+
+  return TRUE;
+}
+
+bfd_boolean
+_bfd_brownie32_relax_section (bfd *abfd, asection *sec,
+			 struct bfd_link_info *link_info,
+			 bfd_boolean *again)
+{
+  Elf_Internal_Rela *internal_relocs;
+  Elf_Internal_Rela *irel, *irelend;
+  Elf_Internal_Shdr *symtab_hdr;
+  bfd_byte *contents = NULL;
+  size_t extsymoff;
+  bfd_boolean changed_contents = FALSE;
+  bfd_vma sec_start = sec->output_section->vma + sec->output_offset;
+  Elf_Internal_Sym *isymbuf = NULL;
+
+  /* We are not currently changing any sizes, so only one pass.  */
+  *again = FALSE;
+
+  if (link_info->relocatable)
+    return TRUE;
+
+  internal_relocs = _bfd_elf_link_read_relocs (abfd, sec, NULL, NULL,
+					       link_info->keep_memory);
+  if (internal_relocs == NULL)
+    return TRUE;
+
+  irelend = internal_relocs + sec->reloc_count
+    * get_elf_backend_data (abfd)->s->int_rels_per_ext_rel;
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  extsymoff = (elf_bad_symtab (abfd)) ? 0 : symtab_hdr->sh_info;
+
+  for (irel = internal_relocs; irel < irelend; irel++)
+    {
+      bfd_vma symval;
+      bfd_signed_vma sym_offset;
+      unsigned int r_type;
+      unsigned long r_symndx;
+      asection *sym_sec;
+      unsigned long instruction;
+
+      /* Turn jalr into bgezal, and jr into beq, if they're marked
+	 with a JALR relocation, that indicate where they jump to.
+	 This saves some pipeline bubbles.  */
+      r_type = ELF_R_TYPE (abfd, irel->r_info);
+      if (r_type != R_BROWNIE32_JALR)
+	continue;
+
+      r_symndx = ELF_R_SYM (abfd, irel->r_info);
+      /* Compute the address of the jump target.  */
+      if (r_symndx >= extsymoff)
+	{
+	  struct brownie32_elf_link_hash_entry *h
+	    = ((struct brownie32_elf_link_hash_entry *)
+	       elf_sym_hashes (abfd) [r_symndx - extsymoff]);
+
+	  while (h->root.root.type == bfd_link_hash_indirect
+		 || h->root.root.type == bfd_link_hash_warning)
+	    h = (struct brownie32_elf_link_hash_entry *) h->root.root.u.i.link;
+
+	  /* If a symbol is undefined, or if it may be overridden,
+	     skip it.  */
+	  if (! ((h->root.root.type == bfd_link_hash_defined
+		  || h->root.root.type == bfd_link_hash_defweak)
+		 && h->root.root.u.def.section)
+	      || (link_info->shared && ! link_info->symbolic
+		  && !h->root.forced_local))
+	    continue;
+
+	  sym_sec = h->root.root.u.def.section;
+	  if (sym_sec->output_section)
+	    symval = (h->root.root.u.def.value
+		      + sym_sec->output_section->vma
+		      + sym_sec->output_offset);
+	  else
+	    symval = h->root.root.u.def.value;
+	}
+      else
+	{
+	  Elf_Internal_Sym *isym;
+
+	  /* Read this BFD's symbols if we haven't done so already.  */
+	  if (isymbuf == NULL && symtab_hdr->sh_info != 0)
+	    {
+	      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
+	      if (isymbuf == NULL)
+		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
+						symtab_hdr->sh_info, 0,
+						NULL, NULL, NULL);
+	      if (isymbuf == NULL)
+		goto relax_return;
+	    }
+
+	  isym = isymbuf + r_symndx;
+	  if (isym->st_shndx == SHN_UNDEF)
+	    continue;
+	  else if (isym->st_shndx == SHN_ABS)
+	    sym_sec = bfd_abs_section_ptr;
+	  else if (isym->st_shndx == SHN_COMMON)
+	    sym_sec = bfd_com_section_ptr;
+	  else
+	    sym_sec
+	      = bfd_section_from_elf_index (abfd, isym->st_shndx);
+	  symval = isym->st_value
+	    + sym_sec->output_section->vma
+	    + sym_sec->output_offset;
+	}
+
+      /* Compute branch offset, from delay slot of the jump to the
+	 branch target.  */
+      sym_offset = (symval + irel->r_addend)
+	- (sec_start + irel->r_offset + 4);
+
+      /* Branch offset must be properly aligned.  */
+      if ((sym_offset & 3) != 0)
+	continue;
+
+      sym_offset >>= 2;
+
+      /* Check that it's in range.  */
+      if (sym_offset < -0x8000 || sym_offset >= 0x8000)
+	continue;
+
+      /* Get the section contents if we haven't done so already.  */
+      if (contents == NULL)
+	{
+	  /* Get cached copy if it exists.  */
+	  if (elf_section_data (sec)->this_hdr.contents != NULL)
+	    contents = elf_section_data (sec)->this_hdr.contents;
+	  else
+	    {
+	      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
+		goto relax_return;
+	    }
+	}
+
+      instruction = bfd_get_32 (abfd, contents + irel->r_offset);
+
+      /* If it was jalr <reg>, turn it into bgezal $zero, <target>.  */
+      if ((instruction & 0xfc1fffff) == 0x0000f809)
+	instruction = 0x04110000;
+      /* If it was jr <reg>, turn it into b <target>.  */
+      else if ((instruction & 0xfc1fffff) == 0x00000008)
+	instruction = 0x10000000;
+      else
+	continue;
+
+      instruction |= (sym_offset & 0xffff);
+      bfd_put_32 (abfd, instruction, contents + irel->r_offset);
+      changed_contents = TRUE;
+    }
+
+  if (contents != NULL
+      && elf_section_data (sec)->this_hdr.contents != contents)
+    {
+      if (!changed_contents && !link_info->keep_memory)
+        free (contents);
+      else
+        {
+          /* Cache the section contents for elf_link_input_bfd.  */
+          elf_section_data (sec)->this_hdr.contents = contents;
+        }
+    }
+  return TRUE;
+
+ relax_return:
+  if (contents != NULL
+      && elf_section_data (sec)->this_hdr.contents != contents)
+    free (contents);
+  return FALSE;
+}
+
+/* Adjust a symbol defined by a dynamic object and referenced by a
+   regular object.  The current definition is in some section of the
+   dynamic object, but we're not including those sections.  We have to
+   change the definition to something the rest of the link can
+   understand.  */
+
+bfd_boolean
+_bfd_brownie32_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
+				     struct elf_link_hash_entry *h)
+{
+  bfd *dynobj;
+  struct brownie32_elf_link_hash_entry *hbrownie32;
+  asection *s;
+
+  dynobj = elf_hash_table (info)->dynobj;
+
+  /* Make sure we know what is going on here.  */
+  BFD_ASSERT (dynobj != NULL
+	      && (h->needs_plt
+		  || h->u.weakdef != NULL
+		  || (h->def_dynamic
+		      && h->ref_regular
+		      && !h->def_regular)));
+
+  /* If this symbol is defined in a dynamic object, we need to copy
+     any R_BROWNIE32_32 or R_BROWNIE32_REL32 relocs against it into the output
+     file.  */
+  hbrownie32 = (struct brownie32_elf_link_hash_entry *) h;
+  if (! info->relocatable
+      && hbrownie32->possibly_dynamic_relocs != 0
+      && (h->root.type == bfd_link_hash_defweak
+	  || !h->def_regular))
+    {
+      brownie32_elf_allocate_dynamic_relocations (dynobj,
+					     hbrownie32->possibly_dynamic_relocs);
+      if (hbrownie32->readonly_reloc)
+	/* We tell the dynamic linker that there are relocations
+	   against the text segment.  */
+	info->flags |= DF_TEXTREL;
+    }
+
+  /* For a function, create a stub, if allowed.  */
+  if (! hbrownie32->no_fn_stub
+      && h->needs_plt)
+    {
+      if (! elf_hash_table (info)->dynamic_sections_created)
+	return TRUE;
+
+      /* If this symbol is not defined in a regular file, then set
+	 the symbol to the stub location.  This is required to make
+	 function pointers compare as equal between the normal
+	 executable and the shared library.  */
+      if (!h->def_regular)
+	{
+	  /* We need .stub section.  */
+	  s = bfd_get_section_by_name (dynobj,
+				       BROWNIE32_ELF_STUB_SECTION_NAME (dynobj));
+	  BFD_ASSERT (s != NULL);
+
+	  h->root.u.def.section = s;
+	  h->root.u.def.value = s->size;
+
+	  /* XXX Write this stub address somewhere.  */
+	  h->plt.offset = s->size;
+
+	  /* Make room for this stub code.  */
+	  s->size += BROWNIE32_FUNCTION_STUB_SIZE;
+
+	  /* The last half word of the stub will be filled with the index
+	     of this symbol in .dynsym section.  */
+	  return TRUE;
+	}
+    }
+  else if ((h->type == STT_FUNC)
+	   && !h->needs_plt)
+    {
+      /* This will set the entry for this symbol in the GOT to 0, and
+         the dynamic linker will take care of this.  */
+      h->root.u.def.value = 0;
+      return TRUE;
+    }
+
+  /* If this is a weak symbol, and there is a real definition, the
+     processor independent code will have arranged for us to see the
+     real definition first, and we can just use the same value.  */
+  if (h->u.weakdef != NULL)
+    {
+      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
+		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
+      h->root.u.def.section = h->u.weakdef->root.u.def.section;
+      h->root.u.def.value = h->u.weakdef->root.u.def.value;
+      return TRUE;
+    }
+
+  /* This is a reference to a symbol defined by a dynamic object which
+     is not a function.  */
+
+  return TRUE;
+}
+
+/* This function is called after all the input files have been read,
+   and the input sections have been assigned to output sections.  We
+   check for any brownie3216 stub sections that we can discard.  */
+
+bfd_boolean
+_bfd_brownie32_elf_always_size_sections (bfd *output_bfd,
+				    struct bfd_link_info *info)
+{
+  asection *ri;
+
+  bfd *dynobj;
+  asection *s;
+  struct brownie32_got_info *g;
+  int i;
+  bfd_size_type loadable_size = 0;
+  bfd_size_type local_gotno;
+  bfd *sub;
+  struct brownie32_elf_count_tls_arg count_tls_arg;
+
+  /* The .reginfo section has a fixed size.  */
+  ri = bfd_get_section_by_name (output_bfd, ".reginfo");
+  if (ri != NULL)
+    bfd_set_section_size (output_bfd, ri, sizeof (Elf32_External_RegInfo));
+
+  if (! (info->relocatable
+	 || ! brownie32_elf_hash_table (info)->brownie3216_stubs_seen))
+    brownie32_elf_link_hash_traverse (brownie32_elf_hash_table (info),
+				 brownie32_elf_check_brownie3216_stubs, NULL);
+
+  dynobj = elf_hash_table (info)->dynobj;
+  if (dynobj == NULL)
+    /* Relocatable links don't have it.  */
+    return TRUE;
+
+  g = brownie32_elf_got_info (dynobj, &s);
+  if (s == NULL)
+    return TRUE;
+
+  /* Calculate the total loadable size of the output.  That
+     will give us the maximum number of GOT_PAGE entries
+     required.  */
+  for (sub = info->input_bfds; sub; sub = sub->link_next)
+    {
+      asection *subsection;
+
+      for (subsection = sub->sections;
+	   subsection;
+	   subsection = subsection->next)
+	{
+	  if ((subsection->flags & SEC_ALLOC) == 0)
+	    continue;
+	  loadable_size += ((subsection->size + 0xf)
+			    &~ (bfd_size_type) 0xf);
+	}
+    }
+
+  /* There has to be a global GOT entry for every symbol with
+     a dynamic symbol table index of DT_BROWNIE32_GOTSYM or
+     higher.  Therefore, it make sense to put those symbols
+     that need GOT entries at the end of the symbol table.  We
+     do that here.  */
+  if (! brownie32_elf_sort_hash_table (info, 1))
+    return FALSE;
+
+  if (g->global_gotsym != NULL)
+    i = elf_hash_table (info)->dynsymcount - g->global_gotsym->dynindx;
+  else
+    /* If there are no global symbols, or none requiring
+       relocations, then GLOBAL_GOTSYM will be NULL.  */
+    i = 0;
+
+  /* In the worst case, we'll get one stub per dynamic symbol, plus
+     one to account for the dummy entry at the end required by IRIX
+     rld.  */
+  loadable_size += BROWNIE32_FUNCTION_STUB_SIZE * (i + 1);
+
+  /* Assume there are two loadable segments consisting of
+     contiguous sections.  Is 5 enough?  */
+  local_gotno = (loadable_size >> 16) + 5;
+
+  g->local_gotno += local_gotno;
+  s->size += g->local_gotno * BROWNIE32_ELF_GOT_SIZE (output_bfd);
+
+  g->global_gotno = i;
+  s->size += i * BROWNIE32_ELF_GOT_SIZE (output_bfd);
+
+  /* We need to calculate tls_gotno for global symbols at this point
+     instead of building it up earlier, to avoid doublecounting
+     entries for one global symbol from multiple input files.  */
+  count_tls_arg.info = info;
+  count_tls_arg.needed = 0;
+  elf_link_hash_traverse (elf_hash_table (info),
+			  brownie32_elf_count_global_tls_entries,
+			  &count_tls_arg);
+  g->tls_gotno += count_tls_arg.needed;
+  s->size += g->tls_gotno * BROWNIE32_ELF_GOT_SIZE (output_bfd);
+
+  brownie32_elf_resolve_final_got_entries (g);
+
+  if (s->size > BROWNIE32_ELF_GOT_MAX_SIZE (output_bfd))
+    {
+      if (! brownie32_elf_multi_got (output_bfd, info, g, s, local_gotno))
+	return FALSE;
+    }
+  else
+    {
+      /* Set up TLS entries for the first GOT.  */
+      g->tls_assigned_gotno = g->global_gotno + g->local_gotno;
+      htab_traverse (g->got_entries, brownie32_elf_initialize_tls_index, g);
+    }
+
+  return TRUE;
+}
+
+/* Set the sizes of the dynamic sections.  */
+
+bfd_boolean
+_bfd_brownie32_elf_size_dynamic_sections (bfd *output_bfd,
+				     struct bfd_link_info *info)
+{
+  bfd *dynobj;
+  asection *s;
+  bfd_boolean reltext;
+
+  dynobj = elf_hash_table (info)->dynobj;
+  BFD_ASSERT (dynobj != NULL);
+
+  if (elf_hash_table (info)->dynamic_sections_created)
+    {
+      /* Set the contents of the .interp section to the interpreter.  */
+      if (info->executable)
+	{
+	  s = bfd_get_section_by_name (dynobj, ".interp");
+	  BFD_ASSERT (s != NULL);
+	  s->size
+	    = strlen (ELF_DYNAMIC_INTERPRETER (output_bfd)) + 1;
+	  s->contents
+	    = (bfd_byte *) ELF_DYNAMIC_INTERPRETER (output_bfd);
+	}
+    }
+
+  /* The check_relocs and adjust_dynamic_symbol entry points have
+     determined the sizes of the various dynamic sections.  Allocate
+     memory for them.  */
+  reltext = FALSE;
+  for (s = dynobj->sections; s != NULL; s = s->next)
+    {
+      const char *name;
+
+      /* It's OK to base decisions on the section name, because none
+	 of the dynobj section names depend upon the input files.  */
+      name = bfd_get_section_name (dynobj, s);
+
+      if ((s->flags & SEC_LINKER_CREATED) == 0)
+	continue;
+
+      if (strncmp (name, ".rel", 4) == 0)
+	{
+	  if (s->size != 0)
+	    {
+	      const char *outname;
+	      asection *target;
+
+	      /* If this relocation section applies to a read only
+                 section, then we probably need a DT_TEXTREL entry.
+                 If the relocation section is .rel.dyn, we always
+                 assert a DT_TEXTREL entry rather than testing whether
+                 there exists a relocation to a read only section or
+                 not.  */
+	      outname = bfd_get_section_name (output_bfd,
+					      s->output_section);
+	      target = bfd_get_section_by_name (output_bfd, outname + 4);
+	      if ((target != NULL
+		   && (target->flags & SEC_READONLY) != 0
+		   && (target->flags & SEC_ALLOC) != 0)
+		  || strcmp (outname, ".rel.dyn") == 0)
+		reltext = TRUE;
+
+	      /* We use the reloc_count field as a counter if we need
+		 to copy relocs into the output file.  */
+	      if (strcmp (name, ".rel.dyn") != 0)
+		s->reloc_count = 0;
+
+	      /* If combreloc is enabled, elf_link_sort_relocs() will
+		 sort relocations, but in a different way than we do,
+		 and before we're done creating relocations.  Also, it
+		 will move them around between input sections'
+		 relocation's contents, so our sorting would be
+		 broken, so don't let it run.  */
+	      info->combreloc = 0;
+	    }
+	}
+      else if (strncmp (name, ".got", 4) == 0)
+	{
+	  /* _bfd_brownie32_elf_always_size_sections() has already done
+	     most of the work, but some symbols may have been mapped
+	     to versions that we must now resolve in the got_entries
+	     hash tables.  */
+	  struct brownie32_got_info *gg = brownie32_elf_got_info (dynobj, NULL);
+	  struct brownie32_got_info *g = gg;
+	  struct brownie32_elf_set_global_got_offset_arg set_got_offset_arg;
+	  unsigned int needed_relocs = 0;
+
+	  if (gg->next)
+	    {
+	      set_got_offset_arg.value = BROWNIE32_ELF_GOT_SIZE (output_bfd);
+	      set_got_offset_arg.info = info;
+
+	      /* NOTE 2005-02-03: How can this call, or the next, ever
+		 find any indirect entries to resolve?  They were all
+		 resolved in brownie32_elf_multi_got.  */
+	      brownie32_elf_resolve_final_got_entries (gg);
+	      for (g = gg->next; g && g->next != gg; g = g->next)
+		{
+		  unsigned int save_assign;
+
+		  brownie32_elf_resolve_final_got_entries (g);
+
+		  /* Assign offsets to global GOT entries.  */
+		  save_assign = g->assigned_gotno;
+		  g->assigned_gotno = g->local_gotno;
+		  set_got_offset_arg.g = g;
+		  set_got_offset_arg.needed_relocs = 0;
+		  htab_traverse (g->got_entries,
+				 brownie32_elf_set_global_got_offset,
+				 &set_got_offset_arg);
+		  needed_relocs += set_got_offset_arg.needed_relocs;
+		  BFD_ASSERT (g->assigned_gotno - g->local_gotno
+			      <= g->global_gotno);
+
+		  g->assigned_gotno = save_assign;
+		  if (info->shared)
+		    {
+		      needed_relocs += g->local_gotno - g->assigned_gotno;
+		      BFD_ASSERT (g->assigned_gotno == g->next->local_gotno
+				  + g->next->global_gotno
+				  + g->next->tls_gotno
+				  + BROWNIE32_RESERVED_GOTNO);
+		    }
+		}
+	    }
+	  else
+	    {
+	      struct brownie32_elf_count_tls_arg arg;
+	      arg.info = info;
+	      arg.needed = 0;
+
+	      htab_traverse (gg->got_entries, brownie32_elf_count_local_tls_relocs,
+			     &arg);
+	      elf_link_hash_traverse (elf_hash_table (info),
+				      brownie32_elf_count_global_tls_relocs,
+				      &arg);
+
+	      needed_relocs += arg.needed;
+	    }
+
+	  if (needed_relocs)
+	    brownie32_elf_allocate_dynamic_relocations (dynobj, needed_relocs);
+	}
+      else if (strcmp (name, BROWNIE32_ELF_STUB_SECTION_NAME (output_bfd)) == 0)
+	{
+	  /* IRIX rld assumes that the function stub isn't at the end
+	     of .text section. So put a dummy. XXX  */
+	  s->size += BROWNIE32_FUNCTION_STUB_SIZE;
+	}
+      else if (! info->shared
+	       && ! brownie32_elf_hash_table (info)->use_rld_obj_head
+	       && strncmp (name, ".rld_map", 8) == 0)
+	{
+	  /* We add a room for __rld_map. It will be filled in by the
+	     rtld to contain a pointer to the _r_debug structure.  */
+	  s->size += 4;
+	}
+      else if (SGI_COMPAT (output_bfd)
+	       && strncmp (name, ".compact_rel", 12) == 0)
+	s->size += brownie32_elf_hash_table (info)->compact_rel_size;
+      else if (strncmp (name, ".init", 5) != 0)
+	{
+	  /* It's not one of our sections, so don't allocate space.  */
+	  continue;
+	}
+
+      if (s->size == 0)
+	{
+	  s->flags |= SEC_EXCLUDE;
+	  continue;
+	}
+
+      if ((s->flags & SEC_HAS_CONTENTS) == 0)
+	continue;
+
+      /* Allocate memory for the section contents.  */
+      s->contents = bfd_zalloc (dynobj, s->size);
+      if (s->contents == NULL)
+	{
+	  bfd_set_error (bfd_error_no_memory);
+	  return FALSE;
+	}
+    }
+
+  if (elf_hash_table (info)->dynamic_sections_created)
+    {
+      /* Add some entries to the .dynamic section.  We fill in the
+	 values later, in _bfd_brownie32_elf_finish_dynamic_sections, but we
+	 must add the entries now so that we get the correct size for
+	 the .dynamic section.  The DT_DEBUG entry is filled in by the
+	 dynamic linker and used by the debugger.  */
+      if (! info->shared)
+	{
+	  /* SGI object has the equivalence of DT_DEBUG in the
+	     DT_BROWNIE32_RLD_MAP entry.  */
+	  if (!BROWNIE32_ELF_ADD_DYNAMIC_ENTRY (info, DT_BROWNIE32_RLD_MAP, 0))
+	    return FALSE;
+	  if (!SGI_COMPAT (output_bfd))
+	    {
+	      if (!BROWNIE32_ELF_ADD_DYNAMIC_ENTRY (info, DT_DEBUG, 0))
+		return FALSE;
+	    }
+	}
+      else
+	{
+	  /* Shared libraries on traditional brownie32 have DT_DEBUG.  */
+	  if (!SGI_COMPAT (output_bfd))
+	    {
+	      if (!BROWNIE32_ELF_ADD_DYNAMIC_ENTRY (info, DT_DEBUG, 0))
+		return FALSE;
+	    }
+	}
+
+      if (reltext && SGI_COMPAT (output_bfd))
+	info->flags |= DF_TEXTREL;
+
+      if ((info->flags & DF_TEXTREL) != 0)
+	{
+	  if (! BROWNIE32_ELF_ADD_DYNAMIC_ENTRY (info, DT_TEXTREL, 0))
+	    return FALSE;
+	}
+
+      if (! BROWNIE32_ELF_ADD_DYNAMIC_ENTRY (info, DT_PLTGOT, 0))
+	return FALSE;
+
+      if (brownie32_elf_rel_dyn_section (dynobj, FALSE))
+	{
+	  if (! BROWNIE32_ELF_ADD_DYNAMIC_ENTRY (info, DT_REL, 0))
+	    return FALSE;
+
+	  if (! BROWNIE32_ELF_ADD_DYNAMIC_ENTRY (info, DT_RELSZ, 0))
+	    return FALSE;
+
+	  if (! BROWNIE32_ELF_ADD_DYNAMIC_ENTRY (info, DT_RELENT, 0))
+	    return FALSE;
+	}
+
+      if (! BROWNIE32_ELF_ADD_DYNAMIC_ENTRY (info, DT_BROWNIE32_RLD_VERSION, 0))
+	return FALSE;
+
+      if (! BROWNIE32_ELF_ADD_DYNAMIC_ENTRY (info, DT_BROWNIE32_FLAGS, 0))
+	return FALSE;
+
+      if (! BROWNIE32_ELF_ADD_DYNAMIC_ENTRY (info, DT_BROWNIE32_BASE_ADDRESS, 0))
+	return FALSE;
+
+      if (! BROWNIE32_ELF_ADD_DYNAMIC_ENTRY (info, DT_BROWNIE32_LOCAL_GOTNO, 0))
+	return FALSE;
+
+      if (! BROWNIE32_ELF_ADD_DYNAMIC_ENTRY (info, DT_BROWNIE32_SYMTABNO, 0))
+	return FALSE;
+
+      if (! BROWNIE32_ELF_ADD_DYNAMIC_ENTRY (info, DT_BROWNIE32_UNREFEXTNO, 0))
+	return FALSE;
+
+      if (! BROWNIE32_ELF_ADD_DYNAMIC_ENTRY (info, DT_BROWNIE32_GOTSYM, 0))
+	return FALSE;
+
+      if (IRIX_COMPAT (dynobj) == ict_irix5
+	  && ! BROWNIE32_ELF_ADD_DYNAMIC_ENTRY (info, DT_BROWNIE32_HIPAGENO, 0))
+	return FALSE;
+
+      if (IRIX_COMPAT (dynobj) == ict_irix6
+	  && (bfd_get_section_by_name
+	      (dynobj, BROWNIE32_ELF_OPTIONS_SECTION_NAME (dynobj)))
+	  && !BROWNIE32_ELF_ADD_DYNAMIC_ENTRY (info, DT_BROWNIE32_OPTIONS, 0))
+	return FALSE;
+    }
+
+  return TRUE;
+}
+
+/* Relocate a BROWNIE32 ELF section.  */
+
+bfd_boolean
+_bfd_brownie32_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
+				bfd *input_bfd, asection *input_section,
+				bfd_byte *contents, Elf_Internal_Rela *relocs,
+				Elf_Internal_Sym *local_syms,
+				asection **local_sections)
+{
+  Elf_Internal_Rela *rel;
+  const Elf_Internal_Rela *relend;
+  bfd_vma addend = 0;
+  bfd_boolean use_saved_addend_p = FALSE;
+  const struct elf_backend_data *bed;
+
+  bed = get_elf_backend_data (output_bfd);
+  relend = relocs + input_section->reloc_count * bed->s->int_rels_per_ext_rel;
+  for (rel = relocs; rel < relend; ++rel)
+    {
+      const char *name;
+      bfd_vma value = 0;
+      reloc_howto_type *howto;
+      bfd_boolean require_jalx;
+      /* TRUE if the relocation is a RELA relocation, rather than a
+         REL relocation.  */
+      bfd_boolean rela_relocation_p = TRUE;
+      unsigned int r_type = ELF_R_TYPE (output_bfd, rel->r_info);
+      const char *msg;
+
+      /* Find the relocation howto for this relocation.  */
+      if (r_type == R_BROWNIE32_64 && ! NEWABI_P (input_bfd))
+	{
+	  /* Some 32-bit code uses R_BROWNIE32_64.  In particular, people use
+	     64-bit code, but make sure all their addresses are in the
+	     lowermost or uppermost 32-bit section of the 64-bit address
+	     space.  Thus, when they use an R_BROWNIE32_64 they mean what is
+	     usually meant by R_BROWNIE32_32, with the exception that the
+	     stored value is sign-extended to 64 bits.  */
+	  howto = BROWNIE32_ELF_RTYPE_TO_HOWTO (input_bfd, R_BROWNIE32_32, FALSE);
+
+	  /* On big-endian systems, we need to lie about the position
+	     of the reloc.  */
+	  if (bfd_big_endian (input_bfd))
+	    rel->r_offset += 4;
+	}
+      else
+	/* NewABI defaults to RELA relocations.  */
+	howto = BROWNIE32_ELF_RTYPE_TO_HOWTO (input_bfd, r_type,
+					 NEWABI_P (input_bfd)
+					 && (BROWNIE32_RELOC_RELA_P
+					     (input_bfd, input_section,
+					      rel - relocs)));
+
+      if (!use_saved_addend_p)
+	{
+	  Elf_Internal_Shdr *rel_hdr;
+
+	  /* If these relocations were originally of the REL variety,
+	     we must pull the addend out of the field that will be
+	     relocated.  Otherwise, we simply use the contents of the
+	     RELA relocation.  To determine which flavor or relocation
+	     this is, we depend on the fact that the INPUT_SECTION's
+	     REL_HDR is read before its REL_HDR2.  */
+	  rel_hdr = &elf_section_data (input_section)->rel_hdr;
+	  if ((size_t) (rel - relocs)
+	      >= (NUM_SHDR_ENTRIES (rel_hdr) * bed->s->int_rels_per_ext_rel))
+	    rel_hdr = elf_section_data (input_section)->rel_hdr2;
+	  if (rel_hdr->sh_entsize == BROWNIE32_ELF_REL_SIZE (input_bfd))
+	    {
+	      bfd_byte *location = contents + rel->r_offset;
+
+	      /* Note that this is a REL relocation.  */
+	      rela_relocation_p = FALSE;
+
+	      /* Get the addend, which is stored in the input file.  */
+	      _bfd_brownie3216_elf_reloc_unshuffle (input_bfd, r_type, FALSE,
+					       location);
+	      addend = brownie32_elf_obtain_contents (howto, rel, input_bfd,
+						 contents);
+	      _bfd_brownie3216_elf_reloc_shuffle(input_bfd, r_type, FALSE,
+					    location);
+
+	      addend &= howto->src_mask;
+
+	      /* For some kinds of relocations, the ADDEND is a
+		 combination of the addend stored in two different
+		 relocations.   */
+	      if (r_type == R_BROWNIE32_HI16 || r_type == R_BROWNIE3216_HI16
+		  || (r_type == R_BROWNIE32_GOT16
+		      && brownie32_elf_local_relocation_p (input_bfd, rel,
+						      local_sections, FALSE)))
+		{
+		  bfd_vma l;
+		  const Elf_Internal_Rela *lo16_relocation;
+		  reloc_howto_type *lo16_howto;
+		  bfd_byte *lo16_location;
+		  int lo16_type;
+
+		  if (r_type == R_BROWNIE3216_HI16)
+		    lo16_type = R_BROWNIE3216_LO16;
+		  else
+		    lo16_type = R_BROWNIE32_LO16;
+
+		  /* The combined value is the sum of the HI16 addend,
+		     left-shifted by sixteen bits, and the LO16
+		     addend, sign extended.  (Usually, the code does
+		     a `lui' of the HI16 value, and then an `addiu' of
+		     the LO16 value.)
+
+		     Scan ahead to find a matching LO16 relocation.
+
+		     According to the BROWNIE32 ELF ABI, the R_BROWNIE32_LO16
+		     relocation must be immediately following.
+		     However, for the IRIX6 ABI, the next relocation
+		     may be a composed relocation consisting of
+		     several relocations for the same address.  In
+		     that case, the R_BROWNIE32_LO16 relocation may occur
+		     as one of these.  We permit a similar extension
+		     in general, as that is useful for GCC.  */
+		  lo16_relocation = brownie32_elf_next_relocation (input_bfd,
+							      lo16_type,
+							      rel, relend);
+		  if (lo16_relocation == NULL)
+		    return FALSE;
+
+		  lo16_location = contents + lo16_relocation->r_offset;
+
+		  /* Obtain the addend kept there.  */
+		  lo16_howto = BROWNIE32_ELF_RTYPE_TO_HOWTO (input_bfd,
+							lo16_type, FALSE);
+		  _bfd_brownie3216_elf_reloc_unshuffle (input_bfd, lo16_type, FALSE,
+						   lo16_location);
+		  l = brownie32_elf_obtain_contents (lo16_howto, lo16_relocation,
+						input_bfd, contents);
+		  _bfd_brownie3216_elf_reloc_shuffle (input_bfd, lo16_type, FALSE,
+						 lo16_location);
+		  l &= lo16_howto->src_mask;
+		  l <<= lo16_howto->rightshift;
+		  l = _bfd_brownie32_elf_sign_extend (l, 16);
+
+		  addend <<= 16;
+
+		  /* Compute the combined addend.  */
+		  addend += l;
+		}
+	      else
+		addend <<= howto->rightshift;
+	    }
+	  else
+	    addend = rel->r_addend;
+	}
+
+      if (info->relocatable)
+	{
+	  Elf_Internal_Sym *sym;
+	  unsigned long r_symndx;
+
+	  if (r_type == R_BROWNIE32_64 && ! NEWABI_P (output_bfd)
+	      && bfd_big_endian (input_bfd))
+	    rel->r_offset -= 4;
+
+	  /* Since we're just relocating, all we need to do is copy
+	     the relocations back out to the object file, unless
+	     they're against a section symbol, in which case we need
+	     to adjust by the section offset, or unless they're GP
+	     relative in which case we need to adjust by the amount
+	     that we're adjusting GP in this relocatable object.  */
+
+	  if (! brownie32_elf_local_relocation_p (input_bfd, rel, local_sections,
+					     FALSE))
+	    /* There's nothing to do for non-local relocations.  */
+	    continue;
+
+	  if (r_type == R_BROWNIE3216_GPREL
+	      || r_type == R_BROWNIE32_GPREL16
+	      || r_type == R_BROWNIE32_GPREL32
+	      || r_type == R_BROWNIE32_LITERAL)
+	    addend -= (_bfd_get_gp_value (output_bfd)
+		       - _bfd_get_gp_value (input_bfd));
+
+	  r_symndx = ELF_R_SYM (output_bfd, rel->r_info);
+	  sym = local_syms + r_symndx;
+	  if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
+	    /* Adjust the addend appropriately.  */
+	    addend += local_sections[r_symndx]->output_offset;
+
+	  if (rela_relocation_p)
+	    /* If this is a RELA relocation, just update the addend.  */
+	    rel->r_addend = addend;
+	  else
+	    {
+	      if (r_type == R_BROWNIE32_HI16
+		  || r_type == R_BROWNIE32_GOT16)
+		addend = brownie32_elf_high (addend);
+	      else if (r_type == R_BROWNIE32_HIGHER)
+		addend = brownie32_elf_higher (addend);
+	      else if (r_type == R_BROWNIE32_HIGHEST)
+		addend = brownie32_elf_highest (addend);
+	      else
+		addend >>= howto->rightshift;
+
+	      /* We use the source mask, rather than the destination
+		 mask because the place to which we are writing will be
+		 source of the addend in the final link.  */
+	      addend &= howto->src_mask;
+
+	      if (r_type == R_BROWNIE32_64 && ! NEWABI_P (output_bfd))
+		/* See the comment above about using R_BROWNIE32_64 in the 32-bit
+		   ABI.  Here, we need to update the addend.  It would be
+		   possible to get away with just using the R_BROWNIE32_32 reloc
+		   but for endianness.  */
+		{
+		  bfd_vma sign_bits;
+		  bfd_vma low_bits;
+		  bfd_vma high_bits;
+
+		  if (addend & ((bfd_vma) 1 << 31))
+#ifdef BFD64
+		    sign_bits = ((bfd_vma) 1 << 32) - 1;
+#else
+		    sign_bits = -1;
+#endif
+		  else
+		    sign_bits = 0;
+
+		  /* If we don't know that we have a 64-bit type,
+		     do two separate stores.  */
+		  if (bfd_big_endian (input_bfd))
+		    {
+		      /* Store the sign-bits (which are most significant)
+			 first.  */
+		      low_bits = sign_bits;
+		      high_bits = addend;
+		    }
+		  else
+		    {
+		      low_bits = addend;
+		      high_bits = sign_bits;
+		    }
+		  bfd_put_32 (input_bfd, low_bits,
+			      contents + rel->r_offset);
+		  bfd_put_32 (input_bfd, high_bits,
+			      contents + rel->r_offset + 4);
+		  continue;
+		}
+
+	      if (! brownie32_elf_perform_relocation (info, howto, rel, addend,
+						 input_bfd, input_section,
+						 contents, FALSE))
+		return FALSE;
+	    }
+
+	  /* Go on to the next relocation.  */
+	  continue;
+	}
+
+      /* In the N32 and 64-bit ABIs there may be multiple consecutive
+	 relocations for the same offset.  In that case we are
+	 supposed to treat the output of each relocation as the addend
+	 for the next.  */
+      if (rel + 1 < relend
+	  && rel->r_offset == rel[1].r_offset
+	  && ELF_R_TYPE (input_bfd, rel[1].r_info) != R_BROWNIE32_NONE)
+	use_saved_addend_p = TRUE;
+      else
+	use_saved_addend_p = FALSE;
+
+      /* Figure out what value we are supposed to relocate.  */
+      switch (brownie32_elf_calculate_relocation (output_bfd, input_bfd,
+					     input_section, info, rel,
+					     addend, howto, local_syms,
+					     local_sections, &value,
+					     &name, &require_jalx,
+					     use_saved_addend_p))
+	{
+	case bfd_reloc_continue:
+	  /* There's nothing to do.  */
+	  continue;
+
+	case bfd_reloc_undefined:
+	  /* brownie32_elf_calculate_relocation already called the
+	     undefined_symbol callback.  There's no real point in
+	     trying to perform the relocation at this point, so we
+	     just skip ahead to the next relocation.  */
+	  continue;
+
+	case bfd_reloc_notsupported:
+	  msg = _("internal error: unsupported relocation error");
+	  info->callbacks->warning
+	    (info, msg, name, input_bfd, input_section, rel->r_offset);
+	  return FALSE;
+
+	case bfd_reloc_overflow:
+	  if (use_saved_addend_p)
+	    /* Ignore overflow until we reach the last relocation for
+	       a given location.  */
+	    ;
+	  else
+	    {
+	      BFD_ASSERT (name != NULL);
+	      if (! ((*info->callbacks->reloc_overflow)
+		     (info, NULL, name, howto->name, (bfd_vma) 0,
+		      input_bfd, input_section, rel->r_offset)))
+		return FALSE;
+	    }
+	  break;
+
+	case bfd_reloc_ok:
+	  break;
+
+	default:
+	  abort ();
+	  break;
+	}
+
+      /* If we've got another relocation for the address, keep going
+	 until we reach the last one.  */
+      if (use_saved_addend_p)
+	{
+	  addend = value;
+	  continue;
+	}
+
+      if (r_type == R_BROWNIE32_64 && ! NEWABI_P (output_bfd))
+	/* See the comment above about using R_BROWNIE32_64 in the 32-bit
+	   ABI.  Until now, we've been using the HOWTO for R_BROWNIE32_32;
+	   that calculated the right value.  Now, however, we
+	   sign-extend the 32-bit result to 64-bits, and store it as a
+	   64-bit value.  We are especially generous here in that we
+	   go to extreme lengths to support this usage on systems with
+	   only a 32-bit VMA.  */
+	{
+	  bfd_vma sign_bits;
+	  bfd_vma low_bits;
+	  bfd_vma high_bits;
+
+	  if (value & ((bfd_vma) 1 << 31))
+#ifdef BFD64
+	    sign_bits = ((bfd_vma) 1 << 32) - 1;
+#else
+	    sign_bits = -1;
+#endif
+	  else
+	    sign_bits = 0;
+
+	  /* If we don't know that we have a 64-bit type,
+	     do two separate stores.  */
+	  if (bfd_big_endian (input_bfd))
+	    {
+	      /* Undo what we did above.  */
+	      rel->r_offset -= 4;
+	      /* Store the sign-bits (which are most significant)
+		 first.  */
+	      low_bits = sign_bits;
+	      high_bits = value;
+	    }
+	  else
+	    {
+	      low_bits = value;
+	      high_bits = sign_bits;
+	    }
+	  bfd_put_32 (input_bfd, low_bits,
+		      contents + rel->r_offset);
+	  bfd_put_32 (input_bfd, high_bits,
+		      contents + rel->r_offset + 4);
+	  continue;
+	}
+
+      /* Actually perform the relocation.  */
+      if (! brownie32_elf_perform_relocation (info, howto, rel, value,
+					 input_bfd, input_section,
+					 contents, require_jalx))
+	return FALSE;
+    }
+
+  return TRUE;
+}
+
+/* If NAME is one of the special IRIX6 symbols defined by the linker,
+   adjust it appropriately now.  */
+
+static void
+brownie32_elf_irix6_finish_dynamic_symbol (bfd *abfd ATTRIBUTE_UNUSED,
+				      const char *name, Elf_Internal_Sym *sym)
+{
+  /* The linker script takes care of providing names and values for
+     these, but we must place them into the right sections.  */
+  static const char* const text_section_symbols[] = {
+    "_ftext",
+    "_etext",
+    "__dso_displacement",
+    "__elf_header",
+    "__program_header_table",
+    NULL
+  };
+
+  static const char* const data_section_symbols[] = {
+    "_fdata",
+    "_edata",
+    "_end",
+    "_fbss",
+    NULL
+  };
+
+  const char* const *p;
+  int i;
+
+  for (i = 0; i < 2; ++i)
+    for (p = (i == 0) ? text_section_symbols : data_section_symbols;
+	 *p;
+	 ++p)
+      if (strcmp (*p, name) == 0)
+	{
+	  /* All of these symbols are given type STT_SECTION by the
+	     IRIX6 linker.  */
+	  sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
+	  sym->st_other = STO_PROTECTED;
+
+	  /* The IRIX linker puts these symbols in special sections.  */
+	  if (i == 0)
+	    sym->st_shndx = SHN_BROWNIE32_TEXT;
+	  else
+	    sym->st_shndx = SHN_BROWNIE32_DATA;
+
+	  break;
+	}
+}
+
+/* Finish up dynamic symbol handling.  We set the contents of various
+   dynamic sections here.  */
+
+bfd_boolean
+_bfd_brownie32_elf_finish_dynamic_symbol (bfd *output_bfd,
+				     struct bfd_link_info *info,
+				     struct elf_link_hash_entry *h,
+				     Elf_Internal_Sym *sym)
+{
+  bfd *dynobj;
+  asection *sgot;
+  struct brownie32_got_info *g, *gg;
+  const char *name;
+
+  dynobj = elf_hash_table (info)->dynobj;
+
+  if (h->plt.offset != MINUS_ONE)
+    {
+      asection *s;
+      bfd_byte stub[BROWNIE32_FUNCTION_STUB_SIZE];
+
+      /* This symbol has a stub.  Set it up.  */
+
+      BFD_ASSERT (h->dynindx != -1);
+
+      s = bfd_get_section_by_name (dynobj,
+				   BROWNIE32_ELF_STUB_SECTION_NAME (dynobj));
+      BFD_ASSERT (s != NULL);
+
+      /* FIXME: Can h->dynindex be more than 64K?  */
+      if (h->dynindx & 0xffff0000)
+	return FALSE;
+
+      /* Fill the stub.  */
+      bfd_put_32 (output_bfd, STUB_LW (output_bfd), stub);
+      bfd_put_32 (output_bfd, STUB_MOVE (output_bfd), stub + 4);
+      bfd_put_32 (output_bfd, STUB_JALR, stub + 8);
+      bfd_put_32 (output_bfd, STUB_LI16 (output_bfd) + h->dynindx, stub + 12);
+
+      BFD_ASSERT (h->plt.offset <= s->size);
+      memcpy (s->contents + h->plt.offset, stub, BROWNIE32_FUNCTION_STUB_SIZE);
+
+      /* Mark the symbol as undefined.  plt.offset != -1 occurs
+	 only for the referenced symbol.  */
+      sym->st_shndx = SHN_UNDEF;
+
+      /* The run-time linker uses the st_value field of the symbol
+	 to reset the global offset table entry for this external
+	 to its stub address when unlinking a shared object.  */
+      sym->st_value = (s->output_section->vma + s->output_offset
+		       + h->plt.offset);
+    }
+
+  BFD_ASSERT (h->dynindx != -1
+	      || h->forced_local);
+
+  sgot = brownie32_elf_got_section (dynobj, FALSE);
+  BFD_ASSERT (sgot != NULL);
+  BFD_ASSERT (brownie32_elf_section_data (sgot) != NULL);
+  g = brownie32_elf_section_data (sgot)->u.got_info;
+  BFD_ASSERT (g != NULL);
+
+  /* Run through the global symbol table, creating GOT entries for all
+     the symbols that need them.  */
+  if (g->global_gotsym != NULL
+      && h->dynindx >= g->global_gotsym->dynindx)
+    {
+      bfd_vma offset;
+      bfd_vma value;
+
+      value = sym->st_value;
+      offset = brownie32_elf_global_got_index (dynobj, output_bfd, h, R_BROWNIE32_GOT16, info);
+      BROWNIE32_ELF_PUT_WORD (output_bfd, value, sgot->contents + offset);
+    }
+
+  if (g->next && h->dynindx != -1 && h->type != STT_TLS)
+    {
+      struct brownie32_got_entry e, *p;
+      bfd_vma entry;
+      bfd_vma offset;
+
+      gg = g;
+
+      e.abfd = output_bfd;
+      e.symndx = -1;
+      e.d.h = (struct brownie32_elf_link_hash_entry *)h;
+      e.tls_type = 0;
+
+      for (g = g->next; g->next != gg; g = g->next)
+	{
+	  if (g->got_entries
+	      && (p = (struct brownie32_got_entry *) htab_find (g->got_entries,
+							   &e)))
+	    {
+	      offset = p->gotidx;
+	      if (info->shared
+		  || (elf_hash_table (info)->dynamic_sections_created
+		      && p->d.h != NULL
+		      && p->d.h->root.def_dynamic
+		      && !p->d.h->root.def_regular))
+		{
+		  /* Create an R_BROWNIE32_REL32 relocation for this entry.  Due to
+		     the various compatibility problems, it's easier to mock
+		     up an R_BROWNIE32_32 or R_BROWNIE32_64 relocation and leave
+		     brownie32_elf_create_dynamic_relocation to calculate the
+		     appropriate addend.  */
+		  Elf_Internal_Rela rel[3];
+
+		  memset (rel, 0, sizeof (rel));
+		  if (ABI_64_P (output_bfd))
+		    rel[0].r_info = ELF_R_INFO (output_bfd, 0, R_BROWNIE32_64);
+		  else
+		    rel[0].r_info = ELF_R_INFO (output_bfd, 0, R_BROWNIE32_32);
+		  rel[0].r_offset = rel[1].r_offset = rel[2].r_offset = offset;
+
+		  entry = 0;
+		  if (! (brownie32_elf_create_dynamic_relocation
+			 (output_bfd, info, rel,
+			  e.d.h, NULL, sym->st_value, &entry, sgot)))
+		    return FALSE;
+		}
+	      else
+		entry = sym->st_value;
+	      BROWNIE32_ELF_PUT_WORD (output_bfd, entry, sgot->contents + offset);
+	    }
+	}
+    }
+
+  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
+  name = h->root.root.string;
+  if (strcmp (name, "_DYNAMIC") == 0
+      || strcmp (name, "_GLOBAL_OFFSET_TABLE_") == 0)
+    sym->st_shndx = SHN_ABS;
+  else if (strcmp (name, "_DYNAMIC_LINK") == 0
+	   || strcmp (name, "_DYNAMIC_LINKING") == 0)
+    {
+      sym->st_shndx = SHN_ABS;
+      sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
+      sym->st_value = 1;
+    }
+  else if (strcmp (name, "_gp_disp") == 0 && ! NEWABI_P (output_bfd))
+    {
+      sym->st_shndx = SHN_ABS;
+      sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
+      sym->st_value = elf_gp (output_bfd);
+    }
+  else if (SGI_COMPAT (output_bfd))
+    {
+      if (strcmp (name, brownie32_elf_dynsym_rtproc_names[0]) == 0
+	  || strcmp (name, brownie32_elf_dynsym_rtproc_names[1]) == 0)
+	{
+	  sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
+	  sym->st_other = STO_PROTECTED;
+	  sym->st_value = 0;
+	  sym->st_shndx = SHN_BROWNIE32_DATA;
+	}
+      else if (strcmp (name, brownie32_elf_dynsym_rtproc_names[2]) == 0)
+	{
+	  sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
+	  sym->st_other = STO_PROTECTED;
+	  sym->st_value = brownie32_elf_hash_table (info)->procedure_count;
+	  sym->st_shndx = SHN_ABS;
+	}
+      else if (sym->st_shndx != SHN_UNDEF && sym->st_shndx != SHN_ABS)
+	{
+	  if (h->type == STT_FUNC)
+	    sym->st_shndx = SHN_BROWNIE32_TEXT;
+	  else if (h->type == STT_OBJECT)
+	    sym->st_shndx = SHN_BROWNIE32_DATA;
+	}
+    }
+
+  /* Handle the IRIX6-specific symbols.  */
+  if (IRIX_COMPAT (output_bfd) == ict_irix6)
+    brownie32_elf_irix6_finish_dynamic_symbol (output_bfd, name, sym);
+
+  if (! info->shared)
+    {
+      if (! brownie32_elf_hash_table (info)->use_rld_obj_head
+	  && (strcmp (name, "__rld_map") == 0
+	      || strcmp (name, "__RLD_MAP") == 0))
+	{
+	  asection *s = bfd_get_section_by_name (dynobj, ".rld_map");
+	  BFD_ASSERT (s != NULL);
+	  sym->st_value = s->output_section->vma + s->output_offset;
+	  bfd_put_32 (output_bfd, 0, s->contents);
+	  if (brownie32_elf_hash_table (info)->rld_value == 0)
+	    brownie32_elf_hash_table (info)->rld_value = sym->st_value;
+	}
+      else if (brownie32_elf_hash_table (info)->use_rld_obj_head
+	       && strcmp (name, "__rld_obj_head") == 0)
+	{
+	  /* IRIX6 does not use a .rld_map section.  */
+	  if (IRIX_COMPAT (output_bfd) == ict_irix5
+              || IRIX_COMPAT (output_bfd) == ict_none)
+	    BFD_ASSERT (bfd_get_section_by_name (dynobj, ".rld_map")
+			!= NULL);
+	  brownie32_elf_hash_table (info)->rld_value = sym->st_value;
+	}
+    }
+
+  /* If this is a brownie3216 symbol, force the value to be even.  */
+  if (sym->st_other == STO_BROWNIE3216)
+    sym->st_value &= ~1;
+
+  return TRUE;
+}
+
+/* Finish up the dynamic sections.  */
+
+bfd_boolean
+_bfd_brownie32_elf_finish_dynamic_sections (bfd *output_bfd,
+				       struct bfd_link_info *info)
+{
+  bfd *dynobj;
+  asection *sdyn;
+  asection *sgot;
+  struct brownie32_got_info *gg, *g;
+
+  dynobj = elf_hash_table (info)->dynobj;
+
+  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
+
+  sgot = brownie32_elf_got_section (dynobj, FALSE);
+  if (sgot == NULL)
+    gg = g = NULL;
+  else
+    {
+      BFD_ASSERT (brownie32_elf_section_data (sgot) != NULL);
+      gg = brownie32_elf_section_data (sgot)->u.got_info;
+      BFD_ASSERT (gg != NULL);
+      g = brownie32_elf_got_for_ibfd (gg, output_bfd);
+      BFD_ASSERT (g != NULL);
+    }
+
+  if (elf_hash_table (info)->dynamic_sections_created)
+    {
+      bfd_byte *b;
+
+      BFD_ASSERT (sdyn != NULL);
+      BFD_ASSERT (g != NULL);
+
+      for (b = sdyn->contents;
+	   b < sdyn->contents + sdyn->size;
+	   b += BROWNIE32_ELF_DYN_SIZE (dynobj))
+	{
+	  Elf_Internal_Dyn dyn;
+	  const char *name;
+	  size_t elemsize;
+	  asection *s;
+	  bfd_boolean swap_out_p;
+
+	  /* Read in the current dynamic entry.  */
+	  (*get_elf_backend_data (dynobj)->s->swap_dyn_in) (dynobj, b, &dyn);
+
+	  /* Assume that we're going to modify it and write it out.  */
+	  swap_out_p = TRUE;
+
+	  switch (dyn.d_tag)
+	    {
+	    case DT_RELENT:
+	      s = brownie32_elf_rel_dyn_section (dynobj, FALSE);
+	      BFD_ASSERT (s != NULL);
+	      dyn.d_un.d_val = BROWNIE32_ELF_REL_SIZE (dynobj);
+	      break;
+
+	    case DT_STRSZ:
+	      /* Rewrite DT_STRSZ.  */
+	      dyn.d_un.d_val =
+		_bfd_elf_strtab_size (elf_hash_table (info)->dynstr);
+	      break;
+
+	    case DT_PLTGOT:
+	      name = ".got";
+	      s = bfd_get_section_by_name (output_bfd, name);
+	      BFD_ASSERT (s != NULL);
+	      dyn.d_un.d_ptr = s->vma;
+	      break;
+
+	    case DT_BROWNIE32_RLD_VERSION:
+	      dyn.d_un.d_val = 1; /* XXX */
+	      break;
+
+	    case DT_BROWNIE32_FLAGS:
+	      dyn.d_un.d_val = RHF_NOTPOT; /* XXX */
+	      break;
+
+	    case DT_BROWNIE32_TIME_STAMP:
+	      {
+		time_t t;
+		time (&t);
+		dyn.d_un.d_val = t;
+	      }
+	      break;
+
+	    case DT_BROWNIE32_ICHECKSUM:
+	      /* XXX FIXME: */
+	      swap_out_p = FALSE;
+	      break;
+
+	    case DT_BROWNIE32_IVERSION:
+	      /* XXX FIXME: */
+	      swap_out_p = FALSE;
+	      break;
+
+	    case DT_BROWNIE32_BASE_ADDRESS:
+	      s = output_bfd->sections;
+	      BFD_ASSERT (s != NULL);
+	      dyn.d_un.d_ptr = s->vma & ~(bfd_vma) 0xffff;
+	      break;
+
+	    case DT_BROWNIE32_LOCAL_GOTNO:
+	      dyn.d_un.d_val = g->local_gotno;
+	      break;
+
+	    case DT_BROWNIE32_UNREFEXTNO:
+	      /* The index into the dynamic symbol table which is the
+		 entry of the first external symbol that is not
+		 referenced within the same object.  */
+	      dyn.d_un.d_val = bfd_count_sections (output_bfd) + 1;
+	      break;
+
+	    case DT_BROWNIE32_GOTSYM:
+	      if (gg->global_gotsym)
+		{
+		  dyn.d_un.d_val = gg->global_gotsym->dynindx;
+		  break;
+		}
+	      /* In case if we don't have global got symbols we default
+		 to setting DT_BROWNIE32_GOTSYM to the same value as
+		 DT_BROWNIE32_SYMTABNO, so we just fall through.  */
+
+	    case DT_BROWNIE32_SYMTABNO:
+	      name = ".dynsym";
+	      elemsize = BROWNIE32_ELF_SYM_SIZE (output_bfd);
+	      s = bfd_get_section_by_name (output_bfd, name);
+	      BFD_ASSERT (s != NULL);
+
+	      dyn.d_un.d_val = s->size / elemsize;
+	      break;
+
+	    case DT_BROWNIE32_HIPAGENO:
+	      dyn.d_un.d_val = g->local_gotno - BROWNIE32_RESERVED_GOTNO;
+	      break;
+
+	    case DT_BROWNIE32_RLD_MAP:
+	      dyn.d_un.d_ptr = brownie32_elf_hash_table (info)->rld_value;
+	      break;
+
+	    case DT_BROWNIE32_OPTIONS:
+	      s = (bfd_get_section_by_name
+		   (output_bfd, BROWNIE32_ELF_OPTIONS_SECTION_NAME (output_bfd)));
+	      dyn.d_un.d_ptr = s->vma;
+	      break;
+
+	    default:
+	      swap_out_p = FALSE;
+	      break;
+	    }
+
+	  if (swap_out_p)
+	    (*get_elf_backend_data (dynobj)->s->swap_dyn_out)
+	      (dynobj, &dyn, b);
+	}
+    }
+
+  /* The first entry of the global offset table will be filled at
+     runtime. The second entry will be used by some runtime loaders.
+     This isn't the case of IRIX rld.  */
+  if (sgot != NULL && sgot->size > 0)
+    {
+      BROWNIE32_ELF_PUT_WORD (output_bfd, 0, sgot->contents);
+      BROWNIE32_ELF_PUT_WORD (output_bfd, 0x80000000,
+			 sgot->contents + BROWNIE32_ELF_GOT_SIZE (output_bfd));
+    }
+
+  if (sgot != NULL)
+    elf_section_data (sgot->output_section)->this_hdr.sh_entsize
+      = BROWNIE32_ELF_GOT_SIZE (output_bfd);
+
+  /* Generate dynamic relocations for the non-primary gots.  */
+  if (gg != NULL && gg->next)
+    {
+      Elf_Internal_Rela rel[3];
+      bfd_vma addend = 0;
+
+      memset (rel, 0, sizeof (rel));
+      rel[0].r_info = ELF_R_INFO (output_bfd, 0, R_BROWNIE32_REL32);
+
+      for (g = gg->next; g->next != gg; g = g->next)
+	{
+	  bfd_vma index = g->next->local_gotno + g->next->global_gotno
+	    + g->next->tls_gotno;
+
+	  BROWNIE32_ELF_PUT_WORD (output_bfd, 0, sgot->contents
+			     + index++ * BROWNIE32_ELF_GOT_SIZE (output_bfd));
+	  BROWNIE32_ELF_PUT_WORD (output_bfd, 0x80000000, sgot->contents
+			     + index++ * BROWNIE32_ELF_GOT_SIZE (output_bfd));
+
+	  if (! info->shared)
+	    continue;
+
+	  while (index < g->assigned_gotno)
+	    {
+	      rel[0].r_offset = rel[1].r_offset = rel[2].r_offset
+		= index++ * BROWNIE32_ELF_GOT_SIZE (output_bfd);
+	      if (!(brownie32_elf_create_dynamic_relocation
+		    (output_bfd, info, rel, NULL,
+		     bfd_abs_section_ptr,
+		     0, &addend, sgot)))
+		return FALSE;
+	      BFD_ASSERT (addend == 0);
+	    }
+	}
+    }
+
+  /* The generation of dynamic relocations for the non-primary gots
+     adds more dynamic relocations.  We cannot count them until
+     here.  */
+
+  if (elf_hash_table (info)->dynamic_sections_created)
+    {
+      bfd_byte *b;
+      bfd_boolean swap_out_p;
+
+      BFD_ASSERT (sdyn != NULL);
+
+      for (b = sdyn->contents;
+	   b < sdyn->contents + sdyn->size;
+	   b += BROWNIE32_ELF_DYN_SIZE (dynobj))
+	{
+	  Elf_Internal_Dyn dyn;
+	  asection *s;
+
+	  /* Read in the current dynamic entry.  */
+	  (*get_elf_backend_data (dynobj)->s->swap_dyn_in) (dynobj, b, &dyn);
+
+	  /* Assume that we're going to modify it and write it out.  */
+	  swap_out_p = TRUE;
+
+	  switch (dyn.d_tag)
+	    {
+	    case DT_RELSZ:
+	      /* Reduce DT_RELSZ to account for any relocations we
+		 decided not to make.  This is for the n64 irix rld,
+		 which doesn't seem to apply any relocations if there
+		 are trailing null entries.  */
+	      s = brownie32_elf_rel_dyn_section (dynobj, FALSE);
+	      dyn.d_un.d_val = (s->reloc_count
+				* (ABI_64_P (output_bfd)
+				   ? sizeof (Elf64_Mips_External_Rel)
+				   : sizeof (Elf32_External_Rel)));
+	      break;
+
+	    default:
+	      swap_out_p = FALSE;
+	      break;
+	    }
+
+	  if (swap_out_p)
+	    (*get_elf_backend_data (dynobj)->s->swap_dyn_out)
+	      (dynobj, &dyn, b);
+	}
+    }
+
+  {
+    asection *s;
+    Elf32_compact_rel cpt;
+
+    if (SGI_COMPAT (output_bfd))
+      {
+	/* Write .compact_rel section out.  */
+	s = bfd_get_section_by_name (dynobj, ".compact_rel");
+	if (s != NULL)
+	  {
+	    cpt.id1 = 1;
+	    cpt.num = s->reloc_count;
+	    cpt.id2 = 2;
+	    cpt.offset = (s->output_section->filepos
+			  + sizeof (Elf32_External_compact_rel));
+	    cpt.reserved0 = 0;
+	    cpt.reserved1 = 0;
+	    bfd_elf32_swap_compact_rel_out (output_bfd, &cpt,
+					    ((Elf32_External_compact_rel *)
+					     s->contents));
+
+	    /* Clean up a dummy stub function entry in .text.  */
+	    s = bfd_get_section_by_name (dynobj,
+					 BROWNIE32_ELF_STUB_SECTION_NAME (dynobj));
+	    if (s != NULL)
+	      {
+		file_ptr dummy_offset;
+
+		BFD_ASSERT (s->size >= BROWNIE32_FUNCTION_STUB_SIZE);
+		dummy_offset = s->size - BROWNIE32_FUNCTION_STUB_SIZE;
+		memset (s->contents + dummy_offset, 0,
+			BROWNIE32_FUNCTION_STUB_SIZE);
+	      }
+	  }
+      }
+
+    /* We need to sort the entries of the dynamic relocation section.  */
+
+    s = brownie32_elf_rel_dyn_section (dynobj, FALSE);
+
+    if (s != NULL
+	&& s->size > (bfd_vma)2 * BROWNIE32_ELF_REL_SIZE (output_bfd))
+      {
+	reldyn_sorting_bfd = output_bfd;
+
+	if (ABI_64_P (output_bfd))
+	  qsort ((Elf64_External_Rel *) s->contents + 1, s->reloc_count - 1,
+		 sizeof (Elf64_Mips_External_Rel), sort_dynamic_relocs_64);
+	else
+	  qsort ((Elf32_External_Rel *) s->contents + 1, s->reloc_count - 1,
+		 sizeof (Elf32_External_Rel), sort_dynamic_relocs);
+      }
+  }
+
+  return TRUE;
+}
+
+
+/* Set ABFD's EF_BROWNIE32_ARCH and EF_BROWNIE32_MACH flags.  */
+
+static void
+brownie32_set_isa_flags (bfd *abfd)
+{
+  flagword val;
+
+  switch (bfd_get_mach (abfd))
+    {
+    default:
+    case bfd_mach_brownie32_std:
+      val = E_BROWNIE32_ARCH_1;
+      break;
+
+    }
+  elf_elfheader (abfd)->e_flags &= ~(EF_BROWNIE32_ARCH | EF_BROWNIE32_MACH);
+  elf_elfheader (abfd)->e_flags |= val;
+
+}
+
+
+/* The final processing done just before writing out a BROWNIE32 ELF object
+   file.  This gets the BROWNIE32 architecture right based on the machine
+   number.  This is used by both the 32-bit and the 64-bit ABI.  */
+
+void
+_bfd_brownie32_elf_final_write_processing (bfd *abfd,
+				      bfd_boolean linker ATTRIBUTE_UNUSED)
+{
+  unsigned int i;
+  Elf_Internal_Shdr **hdrpp;
+  const char *name;
+  asection *sec;
+
+  /* Keep the existing EF_BROWNIE32_MACH and EF_BROWNIE32_ARCH flags if the former
+     is nonzero.  This is for compatibility with old objects, which used
+     a combination of a 32-bit EF_BROWNIE32_ARCH and a 64-bit EF_BROWNIE32_MACH.  */
+  if ((elf_elfheader (abfd)->e_flags & EF_BROWNIE32_MACH) == 0)
+    brownie32_set_isa_flags (abfd);
+
+  /* Set the sh_info field for .gptab sections and other appropriate
+     info for each special section.  */
+  for (i = 1, hdrpp = elf_elfsections (abfd) + 1;
+       i < elf_numsections (abfd);
+       i++, hdrpp++)
+    {
+      switch ((*hdrpp)->sh_type)
+	{
+	case SHT_BROWNIE32_MSYM:
+	case SHT_BROWNIE32_LIBLIST:
+	  sec = bfd_get_section_by_name (abfd, ".dynstr");
+	  if (sec != NULL)
+	    (*hdrpp)->sh_link = elf_section_data (sec)->this_idx;
+	  break;
+
+	case SHT_BROWNIE32_GPTAB:
+	  BFD_ASSERT ((*hdrpp)->bfd_section != NULL);
+	  name = bfd_get_section_name (abfd, (*hdrpp)->bfd_section);
+	  BFD_ASSERT (name != NULL
+		      && strncmp (name, ".gptab.", sizeof ".gptab." - 1) == 0);
+	  sec = bfd_get_section_by_name (abfd, name + sizeof ".gptab" - 1);
+	  BFD_ASSERT (sec != NULL);
+	  (*hdrpp)->sh_info = elf_section_data (sec)->this_idx;
+	  break;
+
+	case SHT_BROWNIE32_CONTENT:
+	  BFD_ASSERT ((*hdrpp)->bfd_section != NULL);
+	  name = bfd_get_section_name (abfd, (*hdrpp)->bfd_section);
+	  BFD_ASSERT (name != NULL
+		      && strncmp (name, ".BROWNIE32.content",
+				  sizeof ".BROWNIE32.content" - 1) == 0);
+	  sec = bfd_get_section_by_name (abfd,
+					 name + sizeof ".BROWNIE32.content" - 1);
+	  BFD_ASSERT (sec != NULL);
+	  (*hdrpp)->sh_link = elf_section_data (sec)->this_idx;
+	  break;
+
+	case SHT_BROWNIE32_SYMBOL_LIB:
+	  sec = bfd_get_section_by_name (abfd, ".dynsym");
+	  if (sec != NULL)
+	    (*hdrpp)->sh_link = elf_section_data (sec)->this_idx;
+	  sec = bfd_get_section_by_name (abfd, ".liblist");
+	  if (sec != NULL)
+	    (*hdrpp)->sh_info = elf_section_data (sec)->this_idx;
+	  break;
+
+	case SHT_BROWNIE32_EVENTS:
+	  BFD_ASSERT ((*hdrpp)->bfd_section != NULL);
+	  name = bfd_get_section_name (abfd, (*hdrpp)->bfd_section);
+	  BFD_ASSERT (name != NULL);
+	  if (strncmp (name, ".BROWNIE32.events", sizeof ".BROWNIE32.events" - 1) == 0)
+	    sec = bfd_get_section_by_name (abfd,
+					   name + sizeof ".BROWNIE32.events" - 1);
+	  else
+	    {
+	      BFD_ASSERT (strncmp (name, ".BROWNIE32.post_rel",
+				   sizeof ".BROWNIE32.post_rel" - 1) == 0);
+	      sec = bfd_get_section_by_name (abfd,
+					     (name
+					      + sizeof ".BROWNIE32.post_rel" - 1));
+	    }
+	  BFD_ASSERT (sec != NULL);
+	  (*hdrpp)->sh_link = elf_section_data (sec)->this_idx;
+	  break;
+
+	}
+    }
+}
+
+/* When creating an IRIX5 executable, we need REGINFO and RTPROC
+   segments.  */
+
+int
+_bfd_brownie32_elf_additional_program_headers (bfd *abfd)
+{
+  asection *s;
+  int ret = 0;
+
+  /* See if we need a PT_BROWNIE32_REGINFO segment.  */
+  s = bfd_get_section_by_name (abfd, ".reginfo");
+  if (s && (s->flags & SEC_LOAD))
+    ++ret;
+
+  /* See if we need a PT_BROWNIE32_OPTIONS segment.  */
+  if (IRIX_COMPAT (abfd) == ict_irix6
+      && bfd_get_section_by_name (abfd,
+				  BROWNIE32_ELF_OPTIONS_SECTION_NAME (abfd)))
+    ++ret;
+
+  /* See if we need a PT_BROWNIE32_RTPROC segment.  */
+  if (IRIX_COMPAT (abfd) == ict_irix5
+      && bfd_get_section_by_name (abfd, ".dynamic")
+      && bfd_get_section_by_name (abfd, ".mdebug"))
+    ++ret;
+
+  return ret;
+}
+
+/* Modify the segment map for an IRIX5 executable.  */
+
+bfd_boolean
+_bfd_brownie32_elf_modify_segment_map (bfd *abfd,
+				  struct bfd_link_info *info ATTRIBUTE_UNUSED)
+{
+  asection *s;
+  struct elf_segment_map *m, **pm;
+  bfd_size_type amt;
+
+  /* If there is a .reginfo section, we need a PT_BROWNIE32_REGINFO
+     segment.  */
+  s = bfd_get_section_by_name (abfd, ".reginfo");
+  if (s != NULL && (s->flags & SEC_LOAD) != 0)
+    {
+      for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
+	if (m->p_type == PT_BROWNIE32_REGINFO)
+	  break;
+      if (m == NULL)
+	{
+	  amt = sizeof *m;
+	  m = bfd_zalloc (abfd, amt);
+	  if (m == NULL)
+	    return FALSE;
+
+	  m->p_type = PT_BROWNIE32_REGINFO;
+	  m->count = 1;
+	  m->sections[0] = s;
+
+	  /* We want to put it after the PHDR and INTERP segments.  */
+	  pm = &elf_tdata (abfd)->segment_map;
+	  while (*pm != NULL
+		 && ((*pm)->p_type == PT_PHDR
+		     || (*pm)->p_type == PT_INTERP))
+	    pm = &(*pm)->next;
+
+	  m->next = *pm;
+	  *pm = m;
+	}
+    }
+
+  /* For IRIX 6, we don't have .mdebug sections, nor does anything but
+     .dynamic end up in PT_DYNAMIC.  However, we do have to insert a
+     PT_BROWNIE32_OPTIONS segment immediately following the program header
+     table.  */
+  if (NEWABI_P (abfd)
+      /* On non-IRIX6 new abi, we'll have already created a segment
+	 for this section, so don't create another.  I'm not sure this
+	 is not also the case for IRIX 6, but I can't test it right
+	 now.  */
+      && IRIX_COMPAT (abfd) == ict_irix6)
+    {
+      for (s = abfd->sections; s; s = s->next)
+	if (elf_section_data (s)->this_hdr.sh_type == SHT_BROWNIE32_OPTIONS)
+	  break;
+
+      if (s)
+	{
+	  struct elf_segment_map *options_segment;
+
+	  pm = &elf_tdata (abfd)->segment_map;
+	  while (*pm != NULL
+		 && ((*pm)->p_type == PT_PHDR
+		     || (*pm)->p_type == PT_INTERP))
+	    pm = &(*pm)->next;
+
+	  amt = sizeof (struct elf_segment_map);
+	  options_segment = bfd_zalloc (abfd, amt);
+	  options_segment->next = *pm;
+	  options_segment->p_type = PT_BROWNIE32_OPTIONS;
+	  options_segment->p_flags = PF_R;
+	  options_segment->p_flags_valid = TRUE;
+	  options_segment->count = 1;
+	  options_segment->sections[0] = s;
+	  *pm = options_segment;
+	}
+    }
+  else
+    {
+      if (IRIX_COMPAT (abfd) == ict_irix5)
+	{
+	  /* If there are .dynamic and .mdebug sections, we make a room
+	     for the RTPROC header.  FIXME: Rewrite without section names.  */
+	  if (bfd_get_section_by_name (abfd, ".interp") == NULL
+	      && bfd_get_section_by_name (abfd, ".dynamic") != NULL
+	      && bfd_get_section_by_name (abfd, ".mdebug") != NULL)
+	    {
+	      for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
+		if (m->p_type == PT_BROWNIE32_RTPROC)
+		  break;
+	      if (m == NULL)
+		{
+		  amt = sizeof *m;
+		  m = bfd_zalloc (abfd, amt);
+		  if (m == NULL)
+		    return FALSE;
+
+		  m->p_type = PT_BROWNIE32_RTPROC;
+
+		  s = bfd_get_section_by_name (abfd, ".rtproc");
+		  if (s == NULL)
+		    {
+		      m->count = 0;
+		      m->p_flags = 0;
+		      m->p_flags_valid = 1;
+		    }
+		  else
+		    {
+		      m->count = 1;
+		      m->sections[0] = s;
+		    }
+
+		  /* We want to put it after the DYNAMIC segment.  */
+		  pm = &elf_tdata (abfd)->segment_map;
+		  while (*pm != NULL && (*pm)->p_type != PT_DYNAMIC)
+		    pm = &(*pm)->next;
+		  if (*pm != NULL)
+		    pm = &(*pm)->next;
+
+		  m->next = *pm;
+		  *pm = m;
+		}
+	    }
+	}
+      /* On IRIX5, the PT_DYNAMIC segment includes the .dynamic,
+	 .dynstr, .dynsym, and .hash sections, and everything in
+	 between.  */
+      for (pm = &elf_tdata (abfd)->segment_map; *pm != NULL;
+	   pm = &(*pm)->next)
+	if ((*pm)->p_type == PT_DYNAMIC)
+	  break;
+      m = *pm;
+      if (m != NULL && IRIX_COMPAT (abfd) == ict_none)
+	{
+	  /* For a normal brownie32 executable the permissions for the PT_DYNAMIC
+	     segment are read, write and execute. We do that here since
+	     the code in elf.c sets only the read permission. This matters
+	     sometimes for the dynamic linker.  */
+	  if (bfd_get_section_by_name (abfd, ".dynamic") != NULL)
+	    {
+	      m->p_flags = PF_R | PF_W | PF_X;
+	      m->p_flags_valid = 1;
+	    }
+	}
+      if (m != NULL
+	  && m->count == 1 && strcmp (m->sections[0]->name, ".dynamic") == 0)
+	{
+	  static const char *sec_names[] =
+	  {
+	    ".dynamic", ".dynstr", ".dynsym", ".hash"
+	  };
+	  bfd_vma low, high;
+	  unsigned int i, c;
+	  struct elf_segment_map *n;
+
+	  low = ~(bfd_vma) 0;
+	  high = 0;
+	  for (i = 0; i < sizeof sec_names / sizeof sec_names[0]; i++)
+	    {
+	      s = bfd_get_section_by_name (abfd, sec_names[i]);
+	      if (s != NULL && (s->flags & SEC_LOAD) != 0)
+		{
+		  bfd_size_type sz;
+
+		  if (low > s->vma)
+		    low = s->vma;
+		  sz = s->size;
+		  if (high < s->vma + sz)
+		    high = s->vma + sz;
+		}
+	    }
+
+	  c = 0;
+	  for (s = abfd->sections; s != NULL; s = s->next)
+	    if ((s->flags & SEC_LOAD) != 0
+		&& s->vma >= low
+		&& s->vma + s->size <= high)
+	      ++c;
+
+	  amt = sizeof *n + (bfd_size_type) (c - 1) * sizeof (asection *);
+	  n = bfd_zalloc (abfd, amt);
+	  if (n == NULL)
+	    return FALSE;
+	  *n = *m;
+	  n->count = c;
+
+	  i = 0;
+	  for (s = abfd->sections; s != NULL; s = s->next)
+	    {
+	      if ((s->flags & SEC_LOAD) != 0
+		  && s->vma >= low
+		  && s->vma + s->size <= high)
+		{
+		  n->sections[i] = s;
+		  ++i;
+		}
+	    }
+
+	  *pm = n;
+	}
+    }
+
+  return TRUE;
+}
+
+/* Return the section that should be marked against GC for a given
+   relocation.  */
+
+asection *
+_bfd_brownie32_elf_gc_mark_hook (asection *sec,
+			    struct bfd_link_info *info ATTRIBUTE_UNUSED,
+			    Elf_Internal_Rela *rel,
+			    struct elf_link_hash_entry *h,
+			    Elf_Internal_Sym *sym)
+{
+  /* ??? Do brownie3216 stub sections need to be handled special?  */
+
+  if (h != NULL)
+    {
+      switch (ELF_R_TYPE (sec->owner, rel->r_info))
+	{
+	case R_BROWNIE32_GNU_VTINHERIT:
+	case R_BROWNIE32_GNU_VTENTRY:
+	  break;
+
+	default:
+	  switch (h->root.type)
+	    {
+	    case bfd_link_hash_defined:
+	    case bfd_link_hash_defweak:
+	      return h->root.u.def.section;
+
+	    case bfd_link_hash_common:
+	      return h->root.u.c.p->section;
+
+	    default:
+	      break;
+	    }
+	}
+    }
+  else
+    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
+
+  return NULL;
+}
+
+/* Update the got entry reference counts for the section being removed.  */
+
+bfd_boolean
+_bfd_brownie32_elf_gc_sweep_hook (bfd *abfd ATTRIBUTE_UNUSED,
+			     struct bfd_link_info *info ATTRIBUTE_UNUSED,
+			     asection *sec ATTRIBUTE_UNUSED,
+			     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED)
+{
+#if 0
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  bfd_signed_vma *local_got_refcounts;
+  const Elf_Internal_Rela *rel, *relend;
+  unsigned long r_symndx;
+  struct elf_link_hash_entry *h;
+
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (abfd);
+  local_got_refcounts = elf_local_got_refcounts (abfd);
+
+  relend = relocs + sec->reloc_count;
+  for (rel = relocs; rel < relend; rel++)
+    switch (ELF_R_TYPE (abfd, rel->r_info))
+      {
+      case R_BROWNIE32_GOT16:
+      case R_BROWNIE32_CALL16:
+      case R_BROWNIE32_CALL_HI16:
+      case R_BROWNIE32_CALL_LO16:
+      case R_BROWNIE32_GOT_HI16:
+      case R_BROWNIE32_GOT_LO16:
+      case R_BROWNIE32_GOT_DISP:
+      case R_BROWNIE32_GOT_PAGE:
+      case R_BROWNIE32_GOT_OFST:
+	/* ??? It would seem that the existing BROWNIE32 code does no sort
+	   of reference counting or whatnot on its GOT and PLT entries,
+	   so it is not possible to garbage collect them at this time.  */
+	break;
+
+      default:
+	break;
+      }
+#endif
+
+  return TRUE;
+}
+
+/* Copy data from a BROWNIE32 ELF indirect symbol to its direct symbol,
+   hiding the old indirect symbol.  Process additional relocation
+   information.  Also called for weakdefs, in which case we just let
+   _bfd_elf_link_hash_copy_indirect copy the flags for us.  */
+
+void
+_bfd_brownie32_elf_copy_indirect_symbol (struct bfd_link_info *info,
+				    struct elf_link_hash_entry *dir,
+				    struct elf_link_hash_entry *ind)
+{
+  struct brownie32_elf_link_hash_entry *dirbrownie32, *indbrownie32;
+
+  _bfd_elf_link_hash_copy_indirect (info, dir, ind);
+
+  if (ind->root.type != bfd_link_hash_indirect)
+    return;
+
+  dirbrownie32 = (struct brownie32_elf_link_hash_entry *) dir;
+  indbrownie32 = (struct brownie32_elf_link_hash_entry *) ind;
+  dirbrownie32->possibly_dynamic_relocs += indbrownie32->possibly_dynamic_relocs;
+  if (indbrownie32->readonly_reloc)
+    dirbrownie32->readonly_reloc = TRUE;
+  if (indbrownie32->no_fn_stub)
+    dirbrownie32->no_fn_stub = TRUE;
+
+  if (dirbrownie32->tls_type == 0)
+    dirbrownie32->tls_type = indbrownie32->tls_type;
+}
+
+void
+_bfd_brownie32_elf_hide_symbol (struct bfd_link_info *info,
+			   struct elf_link_hash_entry *entry,
+			   bfd_boolean force_local)
+{
+  bfd *dynobj;
+  asection *got;
+  struct brownie32_got_info *g;
+  struct brownie32_elf_link_hash_entry *h;
+
+  h = (struct brownie32_elf_link_hash_entry *) entry;
+  if (h->forced_local)
+    return;
+  h->forced_local = force_local;
+
+  dynobj = elf_hash_table (info)->dynobj;
+  if (dynobj != NULL && force_local && h->root.type != STT_TLS
+      && (got = brownie32_elf_got_section (dynobj, FALSE)) != NULL
+      && (g = brownie32_elf_section_data (got)->u.got_info) != NULL)
+    {
+      if (g->next)
+	{
+	  struct brownie32_got_entry e;
+	  struct brownie32_got_info *gg = g;
+
+	  /* Since we're turning what used to be a global symbol into a
+	     local one, bump up the number of local entries of each GOT
+	     that had an entry for it.  This will automatically decrease
+	     the number of global entries, since global_gotno is actually
+	     the upper limit of global entries.  */
+	  e.abfd = dynobj;
+	  e.symndx = -1;
+	  e.d.h = h;
+	  e.tls_type = 0;
+
+	  for (g = g->next; g != gg; g = g->next)
+	    if (htab_find (g->got_entries, &e))
+	      {
+		BFD_ASSERT (g->global_gotno > 0);
+		g->local_gotno++;
+		g->global_gotno--;
+	      }
+
+	  /* If this was a global symbol forced into the primary GOT, we
+	     no longer need an entry for it.  We can't release the entry
+	     at this point, but we must at least stop counting it as one
+	     of the symbols that required a forced got entry.  */
+	  if (h->root.got.offset == 2)
+	    {
+	      BFD_ASSERT (gg->assigned_gotno > 0);
+	      gg->assigned_gotno--;
+	    }
+	}
+      else if (g->global_gotno == 0 && g->global_gotsym == NULL)
+	/* If we haven't got through GOT allocation yet, just bump up the
+	   number of local entries, as this symbol won't be counted as
+	   global.  */
+	g->local_gotno++;
+      else if (h->root.got.offset == 1)
+	{
+	  /* If we're past non-multi-GOT allocation and this symbol had
+	     been marked for a global got entry, give it a local entry
+	     instead.  */
+	  BFD_ASSERT (g->global_gotno > 0);
+	  g->local_gotno++;
+	  g->global_gotno--;
+	}
+    }
+
+  _bfd_elf_link_hash_hide_symbol (info, &h->root, force_local);
+}
+
+#define PDR_SIZE 32
+
+bfd_boolean
+_bfd_brownie32_elf_discard_info (bfd *abfd, struct elf_reloc_cookie *cookie,
+			    struct bfd_link_info *info)
+{
+  asection *o;
+  bfd_boolean ret = FALSE;
+  unsigned char *tdata;
+  size_t i, skip;
+
+  o = bfd_get_section_by_name (abfd, ".pdr");
+  if (! o)
+    return FALSE;
+  if (o->size == 0)
+    return FALSE;
+  if (o->size % PDR_SIZE != 0)
+    return FALSE;
+  if (o->output_section != NULL
+      && bfd_is_abs_section (o->output_section))
+    return FALSE;
+
+  tdata = bfd_zmalloc (o->size / PDR_SIZE);
+  if (! tdata)
+    return FALSE;
+
+  cookie->rels = _bfd_elf_link_read_relocs (abfd, o, NULL, NULL,
+					    info->keep_memory);
+  if (!cookie->rels)
+    {
+      free (tdata);
+      return FALSE;
+    }
+
+  cookie->rel = cookie->rels;
+  cookie->relend = cookie->rels + o->reloc_count;
+
+  for (i = 0, skip = 0; i < o->size / PDR_SIZE; i ++)
+    {
+      if (bfd_elf_reloc_symbol_deleted_p (i * PDR_SIZE, cookie))
+	{
+	  tdata[i] = 1;
+	  skip ++;
+	}
+    }
+
+  if (skip != 0)
+    {
+      brownie32_elf_section_data (o)->u.tdata = tdata;
+      o->size -= skip * PDR_SIZE;
+      ret = TRUE;
+    }
+  else
+    free (tdata);
+
+  if (! info->keep_memory)
+    free (cookie->rels);
+
+  return ret;
+}
+
+bfd_boolean
+_bfd_brownie32_elf_ignore_discarded_relocs (asection *sec)
+{
+  if (strcmp (sec->name, ".pdr") == 0)
+    return TRUE;
+  return FALSE;
+}
+
+bfd_boolean
+_bfd_brownie32_elf_write_section (bfd *output_bfd, asection *sec,
+			     bfd_byte *contents)
+{
+  bfd_byte *to, *from, *end;
+  int i;
+
+  if (strcmp (sec->name, ".pdr") != 0)
+    return FALSE;
+
+  if (brownie32_elf_section_data (sec)->u.tdata == NULL)
+    return FALSE;
+
+  to = contents;
+  end = contents + sec->size;
+  for (from = contents, i = 0;
+       from < end;
+       from += PDR_SIZE, i++)
+    {
+      if ((brownie32_elf_section_data (sec)->u.tdata)[i] == 1)
+	continue;
+      if (to != from)
+	memcpy (to, from, PDR_SIZE);
+      to += PDR_SIZE;
+    }
+  bfd_set_section_contents (output_bfd, sec->output_section, contents,
+			    sec->output_offset, sec->size);
+  return TRUE;
+}
+
+/* BROWNIE32 ELF uses a special find_nearest_line routine in order the
+   handle the ECOFF debugging information.  */
+
+struct brownie32_elf_find_line
+{
+  struct ecoff_debug_info d;
+  struct ecoff_find_line i;
+};
+
+bfd_boolean
+_bfd_brownie32_elf_find_nearest_line (bfd *abfd, asection *section,
+				 asymbol **symbols, bfd_vma offset,
+				 const char **filename_ptr,
+				 const char **functionname_ptr,
+				 unsigned int *line_ptr)
+{
+  asection *msec;
+
+  if (_bfd_dwarf1_find_nearest_line (abfd, section, symbols, offset,
+				     filename_ptr, functionname_ptr,
+				     line_ptr))
+    return TRUE;
+
+  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
+				     filename_ptr, functionname_ptr,
+				     line_ptr, ABI_64_P (abfd) ? 8 : 0,
+				     &elf_tdata (abfd)->dwarf2_find_line_info))
+    return TRUE;
+
+  msec = bfd_get_section_by_name (abfd, ".mdebug");
+  if (msec != NULL)
+    {
+      flagword origflags;
+      struct brownie32_elf_find_line *fi;
+      const struct ecoff_debug_swap * const swap =
+	get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;
+
+      /* If we are called during a link, brownie32_elf_final_link may have
+	 cleared the SEC_HAS_CONTENTS field.  We force it back on here
+	 if appropriate (which it normally will be).  */
+      origflags = msec->flags;
+      if (elf_section_data (msec)->this_hdr.sh_type != SHT_NOBITS)
+	msec->flags |= SEC_HAS_CONTENTS;
+
+      fi = elf_tdata (abfd)->find_line_info;
+      if (fi == NULL)
+	{
+	  bfd_size_type external_fdr_size;
+	  char *fraw_src;
+	  char *fraw_end;
+	  struct fdr *fdr_ptr;
+	  bfd_size_type amt = sizeof (struct brownie32_elf_find_line);
+
+	  fi = bfd_zalloc (abfd, amt);
+	  if (fi == NULL)
+	    {
+	      msec->flags = origflags;
+	      return FALSE;
+	    }
+
+	  if (! _bfd_brownie32_elf_read_ecoff_info (abfd, msec, &fi->d))
+	    {
+	      msec->flags = origflags;
+	      return FALSE;
+	    }
+
+	  /* Swap in the FDR information.  */
+	  amt = fi->d.symbolic_header.ifdMax * sizeof (struct fdr);
+	  fi->d.fdr = bfd_alloc (abfd, amt);
+	  if (fi->d.fdr == NULL)
+	    {
+	      msec->flags = origflags;
+	      return FALSE;
+	    }
+	  external_fdr_size = swap->external_fdr_size;
+	  fdr_ptr = fi->d.fdr;
+	  fraw_src = (char *) fi->d.external_fdr;
+	  fraw_end = (fraw_src
+		      + fi->d.symbolic_header.ifdMax * external_fdr_size);
+	  for (; fraw_src < fraw_end; fraw_src += external_fdr_size, fdr_ptr++)
+	    (*swap->swap_fdr_in) (abfd, fraw_src, fdr_ptr);
+
+	  elf_tdata (abfd)->find_line_info = fi;
+
+	  /* Note that we don't bother to ever free this information.
+             find_nearest_line is either called all the time, as in
+             objdump -l, so the information should be saved, or it is
+             rarely called, as in ld error messages, so the memory
+             wasted is unimportant.  Still, it would probably be a
+             good idea for free_cached_info to throw it away.  */
+	}
+
+      if (_bfd_ecoff_locate_line (abfd, section, offset, &fi->d, swap,
+				  &fi->i, filename_ptr, functionname_ptr,
+				  line_ptr))
+	{
+	  msec->flags = origflags;
+	  return TRUE;
+	}
+
+      msec->flags = origflags;
+    }
+
+  /* Fall back on the generic ELF find_nearest_line routine.  */
+
+  return _bfd_elf_find_nearest_line (abfd, section, symbols, offset,
+				     filename_ptr, functionname_ptr,
+				     line_ptr);
+}
+
+bfd_boolean
+_bfd_brownie32_elf_find_inliner_info (bfd *abfd,
+				 const char **filename_ptr,
+				 const char **functionname_ptr,
+				 unsigned int *line_ptr)
+{
+  bfd_boolean found;
+  found = _bfd_dwarf2_find_inliner_info (abfd, filename_ptr,
+					 functionname_ptr, line_ptr,
+					 & elf_tdata (abfd)->dwarf2_find_line_info);
+  return found;
+}
+
+
+/* When are writing out the .options or .BROWNIE32.options section,
+   remember the bytes we are writing out, so that we can install the
+   GP value in the section_processing routine.  */
+
+bfd_boolean
+_bfd_brownie32_elf_set_section_contents (bfd *abfd, sec_ptr section,
+				    const void *location,
+				    file_ptr offset, bfd_size_type count)
+{
+  if (BROWNIE32_ELF_OPTIONS_SECTION_NAME_P (section->name))
+    {
+      bfd_byte *c;
+
+      if (elf_section_data (section) == NULL)
+	{
+	  bfd_size_type amt = sizeof (struct bfd_elf_section_data);
+	  section->used_by_bfd = bfd_zalloc (abfd, amt);
+	  if (elf_section_data (section) == NULL)
+	    return FALSE;
+	}
+      c = brownie32_elf_section_data (section)->u.tdata;
+      if (c == NULL)
+	{
+	  c = bfd_zalloc (abfd, section->size);
+	  if (c == NULL)
+	    return FALSE;
+	  brownie32_elf_section_data (section)->u.tdata = c;
+	}
+
+      memcpy (c + offset, location, count);
+    }
+
+  return _bfd_elf_set_section_contents (abfd, section, location, offset,
+					count);
+}
+
+/* This is almost identical to bfd_generic_get_... except that some
+   BROWNIE32 relocations need to be handled specially.  Sigh.  */
+
+bfd_byte *
+_bfd_elf_brownie32_get_relocated_section_contents
+  (bfd *abfd,
+   struct bfd_link_info *link_info,
+   struct bfd_link_order *link_order,
+   bfd_byte *data,
+   bfd_boolean relocatable,
+   asymbol **symbols)
+{
+  /* Get enough memory to hold the stuff */
+  bfd *input_bfd = link_order->u.indirect.section->owner;
+  asection *input_section = link_order->u.indirect.section;
+  bfd_size_type sz;
+
+  long reloc_size = bfd_get_reloc_upper_bound (input_bfd, input_section);
+  arelent **reloc_vector = NULL;
+  long reloc_count;
+
+  if (reloc_size < 0)
+    goto error_return;
+
+  reloc_vector = bfd_malloc (reloc_size);
+  if (reloc_vector == NULL && reloc_size != 0)
+    goto error_return;
+
+  /* read in the section */
+  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
+  if (!bfd_get_section_contents (input_bfd, input_section, data, 0, sz))
+    goto error_return;
+
+  reloc_count = bfd_canonicalize_reloc (input_bfd,
+					input_section,
+					reloc_vector,
+					symbols);
+  if (reloc_count < 0)
+    goto error_return;
+
+  if (reloc_count > 0)
+    {
+      arelent **parent;
+      /* for brownie32 */
+      int gp_found;
+      bfd_vma gp = 0x12345678;	/* initialize just to shut gcc up */
+
+      {
+	struct bfd_hash_entry *h;
+	struct bfd_link_hash_entry *lh;
+	/* Skip all this stuff if we aren't mixing formats.  */
+	if (abfd && input_bfd
+	    && abfd->xvec == input_bfd->xvec)
+	  lh = 0;
+	else
+	  {
+	    h = bfd_hash_lookup (&link_info->hash->table, "_gp", FALSE, FALSE);
+	    lh = (struct bfd_link_hash_entry *) h;
+	  }
+      lookup:
+	if (lh)
+	  {
+	    switch (lh->type)
+	      {
+	      case bfd_link_hash_undefined:
+	      case bfd_link_hash_undefweak:
+	      case bfd_link_hash_common:
+		gp_found = 0;
+		break;
+	      case bfd_link_hash_defined:
+	      case bfd_link_hash_defweak:
+		gp_found = 1;
+		gp = lh->u.def.value;
+		break;
+	      case bfd_link_hash_indirect:
+	      case bfd_link_hash_warning:
+		lh = lh->u.i.link;
+		/* @@FIXME  ignoring warning for now */
+		goto lookup;
+	      case bfd_link_hash_new:
+	      default:
+		abort ();
+	      }
+	  }
+	else
+	  gp_found = 0;
+      }
+      /* end brownie32 */
+      for (parent = reloc_vector; *parent != NULL; parent++)
+	{
+	  char *error_message = NULL;
+	  bfd_reloc_status_type r;
+
+	  /* Specific to BROWNIE32: Deal with relocation types that require
+	     knowing the gp of the output bfd.  */
+	  asymbol *sym = *(*parent)->sym_ptr_ptr;
+
+	  /* If we've managed to find the gp and have a special
+	     function for the relocation then go ahead, else default
+	     to the generic handling.  */
+	  if (gp_found
+	      && (*parent)->howto->special_function
+	      == _bfd_brownie32_elf32_gprel16_reloc)
+	    r = _bfd_brownie32_elf_gprel16_with_gp (input_bfd, sym, *parent,
+					       input_section, relocatable,
+					       data, gp);
+	  else
+	    r = bfd_perform_relocation (input_bfd, *parent, data, 
+					input_section,
+					relocatable ? abfd : NULL,
+					&error_message);
+
+	  if (relocatable)
+	    {
+	      asection *os = input_section->output_section;
+
+	      /* A partial link, so keep the relocs */
+	      os->orelocation[os->reloc_count] = *parent;
+	      os->reloc_count++;
+	    }
+
+	  if (r != bfd_reloc_ok)
+	    {
+	      switch (r)
+		{
+		case bfd_reloc_undefined:
+		  if (!((*link_info->callbacks->undefined_symbol)
+			(link_info, bfd_asymbol_name (*(*parent)->sym_ptr_ptr),
+			 input_bfd, input_section, (*parent)->address,
+			 TRUE)))
+		    goto error_return;
+		  break;
+		case bfd_reloc_dangerous:
+		  BFD_ASSERT (error_message != NULL);
+		  if (!((*link_info->callbacks->reloc_dangerous)
+			(link_info, error_message, input_bfd, input_section,
+			 (*parent)->address)))
+		    goto error_return;
+		  break;
+		case bfd_reloc_overflow:
+		  if (!((*link_info->callbacks->reloc_overflow)
+			(link_info, NULL,
+			 bfd_asymbol_name (*(*parent)->sym_ptr_ptr),
+			 (*parent)->howto->name, (*parent)->addend,
+			 input_bfd, input_section, (*parent)->address)))
+		    goto error_return;
+		  break;
+		case bfd_reloc_outofrange:
+		default:
+		  abort ();
+		  break;
+		}
+
+	    }
+	}
+    }
+  if (reloc_vector != NULL)
+    free (reloc_vector);
+  return data;
+
+error_return:
+  if (reloc_vector != NULL)
+    free (reloc_vector);
+  return NULL;
+}
+
+/* Create a BROWNIE32 ELF linker hash table.  */
+
+struct bfd_link_hash_table *
+_bfd_brownie32_elf_link_hash_table_create (bfd *abfd)
+{
+  struct brownie32_elf_link_hash_table *ret;
+  bfd_size_type amt = sizeof (struct brownie32_elf_link_hash_table);
+
+  ret = bfd_malloc (amt);
+  if (ret == NULL)
+    return NULL;
+
+  if (! _bfd_elf_link_hash_table_init (&ret->root, abfd,
+				       brownie32_elf_link_hash_newfunc))
+    {
+      free (ret);
+      return NULL;
+    }
+
+#if 0
+  /* We no longer use this.  */
+  for (i = 0; i < SIZEOF_BROWNIE32_DYNSYM_SECNAMES; i++)
+    ret->dynsym_sec_strindex[i] = (bfd_size_type) -1;
+#endif
+  ret->procedure_count = 0;
+  ret->compact_rel_size = 0;
+  ret->use_rld_obj_head = FALSE;
+  ret->rld_value = 0;
+  ret->brownie3216_stubs_seen = FALSE;
+
+  return &ret->root.root;
+}
+
+/* We need to use a special link routine to handle the .reginfo and
+   the .mdebug sections.  We need to merge all instances of these
+   sections together, not write them all out sequentially.  */
+
+bfd_boolean
+_bfd_brownie32_elf_final_link (bfd *abfd, struct bfd_link_info *info)
+{
+  asection *o;
+  struct bfd_link_order *p;
+  asection *reginfo_sec, *mdebug_sec, *gptab_data_sec, *gptab_bss_sec;
+  asection *rtproc_sec;
+  Elf32_RegInfo reginfo;
+  struct ecoff_debug_info debug;
+  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
+  const struct ecoff_debug_swap *swap = bed->elf_backend_ecoff_debug_swap;
+  HDRR *symhdr = &debug.symbolic_header;
+  void *mdebug_handle = NULL;
+  asection *s;
+  EXTR esym;
+  unsigned int i;
+  bfd_size_type amt;
+
+  static const char * const secname[] =
+  {
+    ".text", ".init", ".fini", ".data",
+    ".rodata", ".sdata", ".sbss", ".bss"
+  };
+  static const int sc[] =
+  {
+    scText, scInit, scFini, scData,
+    scRData, scSData, scSBss, scBss
+  };
+
+  /* We'd carefully arranged the dynamic symbol indices, and then the
+     generic size_dynamic_sections renumbered them out from under us.
+     Rather than trying somehow to prevent the renumbering, just do
+     the sort again.  */
+  if (elf_hash_table (info)->dynamic_sections_created)
+    {
+      bfd *dynobj;
+      asection *got;
+      struct brownie32_got_info *g;
+      bfd_size_type dynsecsymcount;
+
+      /* When we resort, we must tell brownie32_elf_sort_hash_table what
+	 the lowest index it may use is.  That's the number of section
+	 symbols we're going to add.  The generic ELF linker only
+	 adds these symbols when building a shared object.  Note that
+	 we count the sections after (possibly) removing the .options
+	 section above.  */
+
+      dynsecsymcount = 0;
+      if (info->shared)
+	{
+	  asection * p;
+
+	  for (p = abfd->sections; p ; p = p->next)
+	    if ((p->flags & SEC_EXCLUDE) == 0
+		&& (p->flags & SEC_ALLOC) != 0
+		&& !(*bed->elf_backend_omit_section_dynsym) (abfd, info, p))
+	      ++ dynsecsymcount;
+	}
+      
+      if (! brownie32_elf_sort_hash_table (info, dynsecsymcount + 1))
+	return FALSE;
+
+      /* Make sure we didn't grow the global .got region.  */
+      dynobj = elf_hash_table (info)->dynobj;
+      got = brownie32_elf_got_section (dynobj, FALSE);
+      g = brownie32_elf_section_data (got)->u.got_info;
+
+      if (g->global_gotsym != NULL)
+	BFD_ASSERT ((elf_hash_table (info)->dynsymcount
+		     - g->global_gotsym->dynindx)
+		    <= g->global_gotno);
+    }
+
+  /* Get a value for the GP register.  */
+  if (elf_gp (abfd) == 0)
+    {
+      struct bfd_link_hash_entry *h;
+
+      h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);
+      if (h != NULL && h->type == bfd_link_hash_defined)
+	elf_gp (abfd) = (h->u.def.value
+			 + h->u.def.section->output_section->vma
+			 + h->u.def.section->output_offset);
+      else if (info->relocatable)
+	{
+	  bfd_vma lo = MINUS_ONE;
+
+	  /* Find the GP-relative section with the lowest offset.  */
+	  for (o = abfd->sections; o != NULL; o = o->next)
+	    if (o->vma < lo
+		&& (elf_section_data (o)->this_hdr.sh_flags & SHF_BROWNIE32_GPREL))
+	      lo = o->vma;
+
+	  /* And calculate GP relative to that.  */
+	  elf_gp (abfd) = lo + ELF_BROWNIE32_GP_OFFSET (abfd);
+	}
+      else
+	{
+	  /* If the relocate_section function needs to do a reloc
+	     involving the GP value, it should make a reloc_dangerous
+	     callback to warn that GP is not defined.  */
+	}
+    }
+
+  /* Go through the sections and collect the .reginfo and .mdebug
+     information.  */
+  reginfo_sec = NULL;
+  mdebug_sec = NULL;
+  gptab_data_sec = NULL;
+  gptab_bss_sec = NULL;
+  for (o = abfd->sections; o != NULL; o = o->next)
+    {
+      if (strcmp (o->name, ".reginfo") == 0)
+	{
+	  memset (&reginfo, 0, sizeof reginfo);
+
+	  /* We have found the .reginfo section in the output file.
+	     Look through all the link_orders comprising it and merge
+	     the information together.  */
+	  for (p = o->map_head.link_order; p != NULL; p = p->next)
+	    {
+	      asection *input_section;
+	      bfd *input_bfd;
+	      Elf32_External_RegInfo ext;
+	      Elf32_RegInfo sub;
+
+	      if (p->type != bfd_indirect_link_order)
+		{
+		  if (p->type == bfd_data_link_order)
+		    continue;
+		  abort ();
+		}
+
+	      input_section = p->u.indirect.section;
+	      input_bfd = input_section->owner;
+
+	      if (! bfd_get_section_contents (input_bfd, input_section,
+					      &ext, 0, sizeof ext))
+		return FALSE;
+
+	      bfd_brownie32_elf32_swap_reginfo_in (input_bfd, &ext, &sub);
+
+	      reginfo.ri_gprmask |= sub.ri_gprmask;
+	      reginfo.ri_cprmask[0] |= sub.ri_cprmask[0];
+	      reginfo.ri_cprmask[1] |= sub.ri_cprmask[1];
+	      reginfo.ri_cprmask[2] |= sub.ri_cprmask[2];
+	      reginfo.ri_cprmask[3] |= sub.ri_cprmask[3];
+
+	      /* ri_gp_value is set by the function
+		 brownie32_elf32_section_processing when the section is
+		 finally written out.  */
+
+	      /* Hack: reset the SEC_HAS_CONTENTS flag so that
+		 elf_link_input_bfd ignores this section.  */
+	      input_section->flags &= ~SEC_HAS_CONTENTS;
+	    }
+
+	  /* Size has been set in _bfd_brownie32_elf_always_size_sections.  */
+	  BFD_ASSERT(o->size == sizeof (Elf32_External_RegInfo));
+
+	  /* Skip this section later on (I don't think this currently
+	     matters, but someday it might).  */
+	  o->map_head.link_order = NULL;
+
+	  reginfo_sec = o;
+	}
+
+      if (strcmp (o->name, ".mdebug") == 0)
+	{
+	  struct extsym_info einfo;
+	  bfd_vma last;
+
+	  /* We have found the .mdebug section in the output file.
+	     Look through all the link_orders comprising it and merge
+	     the information together.  */
+	  symhdr->magic = swap->sym_magic;
+	  /* FIXME: What should the version stamp be?  */
+	  symhdr->vstamp = 0;
+	  symhdr->ilineMax = 0;
+	  symhdr->cbLine = 0;
+	  symhdr->idnMax = 0;
+	  symhdr->ipdMax = 0;
+	  symhdr->isymMax = 0;
+	  symhdr->ioptMax = 0;
+	  symhdr->iauxMax = 0;
+	  symhdr->issMax = 0;
+	  symhdr->issExtMax = 0;
+	  symhdr->ifdMax = 0;
+	  symhdr->crfd = 0;
+	  symhdr->iextMax = 0;
+
+	  /* We accumulate the debugging information itself in the
+	     debug_info structure.  */
+	  debug.line = NULL;
+	  debug.external_dnr = NULL;
+	  debug.external_pdr = NULL;
+	  debug.external_sym = NULL;
+	  debug.external_opt = NULL;
+	  debug.external_aux = NULL;
+	  debug.ss = NULL;
+	  debug.ssext = debug.ssext_end = NULL;
+	  debug.external_fdr = NULL;
+	  debug.external_rfd = NULL;
+	  debug.external_ext = debug.external_ext_end = NULL;
+
+	  mdebug_handle = bfd_ecoff_debug_init (abfd, &debug, swap, info);
+	  if (mdebug_handle == NULL)
+	    return FALSE;
+
+	  esym.jmptbl = 0;
+	  esym.cobol_main = 0;
+	  esym.weakext = 0;
+	  esym.reserved = 0;
+	  esym.ifd = ifdNil;
+	  esym.asym.iss = issNil;
+	  esym.asym.st = stLocal;
+	  esym.asym.reserved = 0;
+	  esym.asym.index = indexNil;
+	  last = 0;
+	  for (i = 0; i < sizeof (secname) / sizeof (secname[0]); i++)
+	    {
+	      esym.asym.sc = sc[i];
+	      s = bfd_get_section_by_name (abfd, secname[i]);
+	      if (s != NULL)
+		{
+		  esym.asym.value = s->vma;
+		  last = s->vma + s->size;
+		}
+	      else
+		esym.asym.value = last;
+	      if (!bfd_ecoff_debug_one_external (abfd, &debug, swap,
+						 secname[i], &esym))
+		return FALSE;
+	    }
+
+	  for (p = o->map_head.link_order; p != NULL; p = p->next)
+	    {
+	      asection *input_section;
+	      bfd *input_bfd;
+	      const struct ecoff_debug_swap *input_swap;
+	      struct ecoff_debug_info input_debug;
+	      char *eraw_src;
+	      char *eraw_end;
+
+	      if (p->type != bfd_indirect_link_order)
+		{
+		  if (p->type == bfd_data_link_order)
+		    continue;
+		  abort ();
+		}
+
+	      input_section = p->u.indirect.section;
+	      input_bfd = input_section->owner;
+
+	      if (bfd_get_flavour (input_bfd) != bfd_target_elf_flavour
+		  || (get_elf_backend_data (input_bfd)
+		      ->elf_backend_ecoff_debug_swap) == NULL)
+		{
+		  /* I don't know what a non BROWNIE32 ELF bfd would be
+		     doing with a .mdebug section, but I don't really
+		     want to deal with it.  */
+		  continue;
+		}
+
+	      input_swap = (get_elf_backend_data (input_bfd)
+			    ->elf_backend_ecoff_debug_swap);
+
+	      BFD_ASSERT (p->size == input_section->size);
+
+	      /* The ECOFF linking code expects that we have already
+		 read in the debugging information and set up an
+		 ecoff_debug_info structure, so we do that now.  */
+	      if (! _bfd_brownie32_elf_read_ecoff_info (input_bfd, input_section,
+						   &input_debug))
+		return FALSE;
+
+	      if (! (bfd_ecoff_debug_accumulate
+		     (mdebug_handle, abfd, &debug, swap, input_bfd,
+		      &input_debug, input_swap, info)))
+		return FALSE;
+
+	      /* Loop through the external symbols.  For each one with
+		 interesting information, try to find the symbol in
+		 the linker global hash table and save the information
+		 for the output external symbols.  */
+	      eraw_src = input_debug.external_ext;
+	      eraw_end = (eraw_src
+			  + (input_debug.symbolic_header.iextMax
+			     * input_swap->external_ext_size));
+	      for (;
+		   eraw_src < eraw_end;
+		   eraw_src += input_swap->external_ext_size)
+		{
+		  EXTR ext;
+		  const char *name;
+		  struct brownie32_elf_link_hash_entry *h;
+
+		  (*input_swap->swap_ext_in) (input_bfd, eraw_src, &ext);
+		  if (ext.asym.sc == scNil
+		      || ext.asym.sc == scUndefined
+		      || ext.asym.sc == scSUndefined)
+		    continue;
+
+		  name = input_debug.ssext + ext.asym.iss;
+		  h = brownie32_elf_link_hash_lookup (brownie32_elf_hash_table (info),
+						 name, FALSE, FALSE, TRUE);
+		  if (h == NULL || h->esym.ifd != -2)
+		    continue;
+
+		  if (ext.ifd != -1)
+		    {
+		      BFD_ASSERT (ext.ifd
+				  < input_debug.symbolic_header.ifdMax);
+		      ext.ifd = input_debug.ifdmap[ext.ifd];
+		    }
+
+		  h->esym = ext;
+		}
+
+	      /* Free up the information we just read.  */
+	      free (input_debug.line);
+	      free (input_debug.external_dnr);
+	      free (input_debug.external_pdr);
+	      free (input_debug.external_sym);
+	      free (input_debug.external_opt);
+	      free (input_debug.external_aux);
+	      free (input_debug.ss);
+	      free (input_debug.ssext);
+	      free (input_debug.external_fdr);
+	      free (input_debug.external_rfd);
+	      free (input_debug.external_ext);
+
+	      /* Hack: reset the SEC_HAS_CONTENTS flag so that
+		 elf_link_input_bfd ignores this section.  */
+	      input_section->flags &= ~SEC_HAS_CONTENTS;
+	    }
+
+	  if (SGI_COMPAT (abfd) && info->shared)
+	    {
+	      /* Create .rtproc section.  */
+	      rtproc_sec = bfd_get_section_by_name (abfd, ".rtproc");
+	      if (rtproc_sec == NULL)
+		{
+		  flagword flags = (SEC_HAS_CONTENTS | SEC_IN_MEMORY
+				    | SEC_LINKER_CREATED | SEC_READONLY);
+
+		  rtproc_sec = bfd_make_section_with_flags (abfd,
+							    ".rtproc",
+							    flags);
+		  if (rtproc_sec == NULL
+		      || ! bfd_set_section_alignment (abfd, rtproc_sec, 4))
+		    return FALSE;
+		}
+
+	      if (! brownie32_elf_create_procedure_table (mdebug_handle, abfd,
+						     info, rtproc_sec,
+						     &debug))
+		return FALSE;
+	    }
+
+	  /* Build the external symbol information.  */
+	  einfo.abfd = abfd;
+	  einfo.info = info;
+	  einfo.debug = &debug;
+	  einfo.swap = swap;
+	  einfo.failed = FALSE;
+	  brownie32_elf_link_hash_traverse (brownie32_elf_hash_table (info),
+				       brownie32_elf_output_extsym, &einfo);
+	  if (einfo.failed)
+	    return FALSE;
+
+	  /* Set the size of the .mdebug section.  */
+	  o->size = bfd_ecoff_debug_size (abfd, &debug, swap);
+
+	  /* Skip this section later on (I don't think this currently
+	     matters, but someday it might).  */
+	  o->map_head.link_order = NULL;
+
+	  mdebug_sec = o;
+	}
+
+      if (strncmp (o->name, ".gptab.", sizeof ".gptab." - 1) == 0)
+	{
+	  const char *subname;
+	  unsigned int c;
+	  Elf32_gptab *tab;
+	  Elf32_External_gptab *ext_tab;
+	  unsigned int j;
+
+	  /* The .gptab.sdata and .gptab.sbss sections hold
+	     information describing how the small data area would
+	     change depending upon the -G switch.  These sections
+	     not used in executables files.  */
+	  if (! info->relocatable)
+	    {
+	      for (p = o->map_head.link_order; p != NULL; p = p->next)
+		{
+		  asection *input_section;
+
+		  if (p->type != bfd_indirect_link_order)
+		    {
+		      if (p->type == bfd_data_link_order)
+			continue;
+		      abort ();
+		    }
+
+		  input_section = p->u.indirect.section;
+
+		  /* Hack: reset the SEC_HAS_CONTENTS flag so that
+		     elf_link_input_bfd ignores this section.  */
+		  input_section->flags &= ~SEC_HAS_CONTENTS;
+		}
+
+	      /* Skip this section later on (I don't think this
+		 currently matters, but someday it might).  */
+	      o->map_head.link_order = NULL;
+
+	      /* Really remove the section.  */
+	      bfd_section_list_remove (abfd, o);
+	      --abfd->section_count;
+
+	      continue;
+	    }
+
+	  /* There is one gptab for initialized data, and one for
+	     uninitialized data.  */
+	  if (strcmp (o->name, ".gptab.sdata") == 0)
+	    gptab_data_sec = o;
+	  else if (strcmp (o->name, ".gptab.sbss") == 0)
+	    gptab_bss_sec = o;
+	  else
+	    {
+	      (*_bfd_error_handler)
+		(_("%s: illegal section name `%s'"),
+		 bfd_get_filename (abfd), o->name);
+	      bfd_set_error (bfd_error_nonrepresentable_section);
+	      return FALSE;
+	    }
+
+	  /* The linker script always combines .gptab.data and
+	     .gptab.sdata into .gptab.sdata, and likewise for
+	     .gptab.bss and .gptab.sbss.  It is possible that there is
+	     no .sdata or .sbss section in the output file, in which
+	     case we must change the name of the output section.  */
+	  subname = o->name + sizeof ".gptab" - 1;
+	  if (bfd_get_section_by_name (abfd, subname) == NULL)
+	    {
+	      if (o == gptab_data_sec)
+		o->name = ".gptab.data";
+	      else
+		o->name = ".gptab.bss";
+	      subname = o->name + sizeof ".gptab" - 1;
+	      BFD_ASSERT (bfd_get_section_by_name (abfd, subname) != NULL);
+	    }
+
+	  /* Set up the first entry.  */
+	  c = 1;
+	  amt = c * sizeof (Elf32_gptab);
+	  tab = bfd_malloc (amt);
+	  if (tab == NULL)
+	    return FALSE;
+	  tab[0].gt_header.gt_current_g_value = elf_gp_size (abfd);
+	  tab[0].gt_header.gt_unused = 0;
+
+	  /* Combine the input sections.  */
+	  for (p = o->map_head.link_order; p != NULL; p = p->next)
+	    {
+	      asection *input_section;
+	      bfd *input_bfd;
+	      bfd_size_type size;
+	      unsigned long last;
+	      bfd_size_type gpentry;
+
+	      if (p->type != bfd_indirect_link_order)
+		{
+		  if (p->type == bfd_data_link_order)
+		    continue;
+		  abort ();
+		}
+
+	      input_section = p->u.indirect.section;
+	      input_bfd = input_section->owner;
+
+	      /* Combine the gptab entries for this input section one
+		 by one.  We know that the input gptab entries are
+		 sorted by ascending -G value.  */
+	      size = input_section->size;
+	      last = 0;
+	      for (gpentry = sizeof (Elf32_External_gptab);
+		   gpentry < size;
+		   gpentry += sizeof (Elf32_External_gptab))
+		{
+		  Elf32_External_gptab ext_gptab;
+		  Elf32_gptab int_gptab;
+		  unsigned long val;
+		  unsigned long add;
+		  bfd_boolean exact;
+		  unsigned int look;
+
+		  if (! (bfd_get_section_contents
+			 (input_bfd, input_section, &ext_gptab, gpentry,
+			  sizeof (Elf32_External_gptab))))
+		    {
+		      free (tab);
+		      return FALSE;
+		    }
+
+		  bfd_brownie32_elf32_swap_gptab_in (input_bfd, &ext_gptab,
+						&int_gptab);
+		  val = int_gptab.gt_entry.gt_g_value;
+		  add = int_gptab.gt_entry.gt_bytes - last;
+
+		  exact = FALSE;
+		  for (look = 1; look < c; look++)
+		    {
+		      if (tab[look].gt_entry.gt_g_value >= val)
+			tab[look].gt_entry.gt_bytes += add;
+
+		      if (tab[look].gt_entry.gt_g_value == val)
+			exact = TRUE;
+		    }
+
+		  if (! exact)
+		    {
+		      Elf32_gptab *new_tab;
+		      unsigned int max;
+
+		      /* We need a new table entry.  */
+		      amt = (bfd_size_type) (c + 1) * sizeof (Elf32_gptab);
+		      new_tab = bfd_realloc (tab, amt);
+		      if (new_tab == NULL)
+			{
+			  free (tab);
+			  return FALSE;
+			}
+		      tab = new_tab;
+		      tab[c].gt_entry.gt_g_value = val;
+		      tab[c].gt_entry.gt_bytes = add;
+
+		      /* Merge in the size for the next smallest -G
+			 value, since that will be implied by this new
+			 value.  */
+		      max = 0;
+		      for (look = 1; look < c; look++)
+			{
+			  if (tab[look].gt_entry.gt_g_value < val
+			      && (max == 0
+				  || (tab[look].gt_entry.gt_g_value
+				      > tab[max].gt_entry.gt_g_value)))
+			    max = look;
+			}
+		      if (max != 0)
+			tab[c].gt_entry.gt_bytes +=
+			  tab[max].gt_entry.gt_bytes;
+
+		      ++c;
+		    }
+
+		  last = int_gptab.gt_entry.gt_bytes;
+		}
+
+	      /* Hack: reset the SEC_HAS_CONTENTS flag so that
+		 elf_link_input_bfd ignores this section.  */
+	      input_section->flags &= ~SEC_HAS_CONTENTS;
+	    }
+
+	  /* The table must be sorted by -G value.  */
+	  if (c > 2)
+	    qsort (tab + 1, c - 1, sizeof (tab[0]), gptab_compare);
+
+	  /* Swap out the table.  */
+	  amt = (bfd_size_type) c * sizeof (Elf32_External_gptab);
+	  ext_tab = bfd_alloc (abfd, amt);
+	  if (ext_tab == NULL)
+	    {
+	      free (tab);
+	      return FALSE;
+	    }
+
+	  for (j = 0; j < c; j++)
+	    bfd_brownie32_elf32_swap_gptab_out (abfd, tab + j, ext_tab + j);
+	  free (tab);
+
+	  o->size = c * sizeof (Elf32_External_gptab);
+	  o->contents = (bfd_byte *) ext_tab;
+
+	  /* Skip this section later on (I don't think this currently
+	     matters, but someday it might).  */
+	  o->map_head.link_order = NULL;
+	}
+    }
+
+  /* Invoke the regular ELF backend linker to do all the work.  */
+  if (!bfd_elf_final_link (abfd, info))
+    return FALSE;
+
+  /* Now write out the computed sections.  */
+
+  if (reginfo_sec != NULL)
+    {
+      Elf32_External_RegInfo ext;
+
+      bfd_brownie32_elf32_swap_reginfo_out (abfd, &reginfo, &ext);
+      if (! bfd_set_section_contents (abfd, reginfo_sec, &ext, 0, sizeof ext))
+	return FALSE;
+    }
+
+  if (mdebug_sec != NULL)
+    {
+      BFD_ASSERT (abfd->output_has_begun);
+      if (! bfd_ecoff_write_accumulated_debug (mdebug_handle, abfd, &debug,
+					       swap, info,
+					       mdebug_sec->filepos))
+	return FALSE;
+
+      bfd_ecoff_debug_free (mdebug_handle, abfd, &debug, swap, info);
+    }
+
+  if (gptab_data_sec != NULL)
+    {
+      if (! bfd_set_section_contents (abfd, gptab_data_sec,
+				      gptab_data_sec->contents,
+				      0, gptab_data_sec->size))
+	return FALSE;
+    }
+
+  if (gptab_bss_sec != NULL)
+    {
+      if (! bfd_set_section_contents (abfd, gptab_bss_sec,
+				      gptab_bss_sec->contents,
+				      0, gptab_bss_sec->size))
+	return FALSE;
+    }
+
+  if (SGI_COMPAT (abfd))
+    {
+      rtproc_sec = bfd_get_section_by_name (abfd, ".rtproc");
+      if (rtproc_sec != NULL)
+	{
+	  if (! bfd_set_section_contents (abfd, rtproc_sec,
+					  rtproc_sec->contents,
+					  0, rtproc_sec->size))
+	    return FALSE;
+	}
+    }
+
+  return TRUE;
+}
+
+/* Structure for saying that BFD machine EXTENSION extends BASE.  */
+
+struct brownie32_mach_extension {
+  unsigned long extension, base;
+};
+
+
+/* An array describing how BFD machines relate to one another.  The entries
+   are ordered topologically with BROWNIE32 I extensions listed last.  */
+
+static const struct brownie32_mach_extension brownie32_mach_extensions[] = {
+  /* BROWNIE3264 extensions.  */
+  { bfd_mach_brownie32_std, bfd_mach_brownie32_std },
+};
+
+
+/* Return true if bfd machine EXTENSION is an extension of machine BASE.  */
+
+static bfd_boolean
+brownie32_mach_extends_p (unsigned long base, unsigned long extension)
+{
+  size_t i;
+
+  if (extension == base)
+    return TRUE;
+
+  for (i = 0; i < ARRAY_SIZE (brownie32_mach_extensions); i++)
+    if (extension == brownie32_mach_extensions[i].extension)
+      {
+	extension = brownie32_mach_extensions[i].base;
+	if (extension == base)
+	  return TRUE;
+      }
+
+  return FALSE;
+}
+
+
+/* Return true if the given ELF header flags describe a 32-bit binary.  */
+
+static bfd_boolean
+brownie32_32bit_flags_p (flagword flags)
+{
+  return ((flags & EF_BROWNIE32_32BITMODE) != 0
+	  || (flags & EF_BROWNIE32_ABI) == E_BROWNIE32_ABI_O32
+	  || (flags & EF_BROWNIE32_ABI) == E_BROWNIE32_ABI_EABI32
+	  || (flags & EF_BROWNIE32_ARCH) == E_BROWNIE32_ARCH_1
+	  || (flags & EF_BROWNIE32_ARCH) == E_BROWNIE32_ARCH_2
+	  || (flags & EF_BROWNIE32_ARCH) == E_BROWNIE32_ARCH_32
+	  || (flags & EF_BROWNIE32_ARCH) == E_BROWNIE32_ARCH_32R2);
+}
+
+
+/* Merge backend specific data from an object file to the output
+   object file when linking.  */
+
+bfd_boolean
+_bfd_brownie32_elf_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
+{
+  flagword old_flags;
+  flagword new_flags;
+  bfd_boolean ok;
+  bfd_boolean null_input_bfd = TRUE;
+  asection *sec;
+
+  /* Check if we have the same endianess */
+  if (! _bfd_generic_verify_endian_match (ibfd, obfd))
+    {
+      (*_bfd_error_handler)
+	(_("%B: endianness incompatible with that of the selected emulation"),
+	 ibfd);
+      return FALSE;
+    }
+
+  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
+      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
+    return TRUE;
+
+  if (strcmp (bfd_get_target (ibfd), bfd_get_target (obfd)) != 0)
+    {
+      (*_bfd_error_handler)
+	(_("%B: ABI is incompatible with that of the selected emulation"),
+	 ibfd);
+      return FALSE;
+    }
+
+  new_flags = elf_elfheader (ibfd)->e_flags;
+  elf_elfheader (obfd)->e_flags |= new_flags & EF_BROWNIE32_NOREORDER;
+  old_flags = elf_elfheader (obfd)->e_flags;
+
+  if (! elf_flags_init (obfd))
+    {
+      elf_flags_init (obfd) = TRUE;
+      elf_elfheader (obfd)->e_flags = new_flags;
+      elf_elfheader (obfd)->e_ident[EI_CLASS]
+	= elf_elfheader (ibfd)->e_ident[EI_CLASS];
+
+      if (bfd_get_arch (obfd) == bfd_get_arch (ibfd)
+	  && bfd_get_arch_info (obfd)->the_default)
+	{
+	  if (! bfd_set_arch_mach (obfd, bfd_get_arch (ibfd),
+				   bfd_get_mach (ibfd)))
+	    return FALSE;
+	}
+
+      return TRUE;
+    }
+
+  /* Check flag compatibility.  */
+
+  new_flags &= ~EF_BROWNIE32_NOREORDER;
+  old_flags &= ~EF_BROWNIE32_NOREORDER;
+
+  /* Some IRIX 6 BSD-compatibility objects have this bit set.  It
+     doesn't seem to matter.  */
+  new_flags &= ~EF_BROWNIE32_XGOT;
+  old_flags &= ~EF_BROWNIE32_XGOT;
+
+  /* BROWNIE32pro generates ucode info in n64 objects.  Again, we should
+     just be able to ignore this.  */
+  new_flags &= ~EF_BROWNIE32_UCODE;
+  old_flags &= ~EF_BROWNIE32_UCODE;
+
+  if (new_flags == old_flags)
+    return TRUE;
+
+  /* Check to see if the input BFD actually contains any sections.
+     If not, its flags may not have been initialised either, but it cannot
+     actually cause any incompatibility.  */
+  for (sec = ibfd->sections; sec != NULL; sec = sec->next)
+    {
+      /* Ignore synthetic sections and empty .text, .data and .bss sections
+	  which are automatically generated by gas.  */
+      if (strcmp (sec->name, ".reginfo")
+	  && strcmp (sec->name, ".mdebug")
+	  && (sec->size != 0
+	      || (strcmp (sec->name, ".text")
+		  && strcmp (sec->name, ".data")
+		  && strcmp (sec->name, ".bss"))))
+	{
+	  null_input_bfd = FALSE;
+	  break;
+	}
+    }
+  if (null_input_bfd)
+    return TRUE;
+
+  ok = TRUE;
+
+  if (((new_flags & (EF_BROWNIE32_PIC | EF_BROWNIE32_CPIC)) != 0)
+      != ((old_flags & (EF_BROWNIE32_PIC | EF_BROWNIE32_CPIC)) != 0))
+    {
+      (*_bfd_error_handler)
+	(_("%B: warning: linking PIC files with non-PIC files"),
+	 ibfd);
+      ok = TRUE;
+    }
+
+  if (new_flags & (EF_BROWNIE32_PIC | EF_BROWNIE32_CPIC))
+    elf_elfheader (obfd)->e_flags |= EF_BROWNIE32_CPIC;
+  if (! (new_flags & EF_BROWNIE32_PIC))
+    elf_elfheader (obfd)->e_flags &= ~EF_BROWNIE32_PIC;
+
+  new_flags &= ~ (EF_BROWNIE32_PIC | EF_BROWNIE32_CPIC);
+  old_flags &= ~ (EF_BROWNIE32_PIC | EF_BROWNIE32_CPIC);
+
+  /* Compare the ISAs.  */
+  if (brownie32_32bit_flags_p (old_flags) != brownie32_32bit_flags_p (new_flags))
+    {
+      (*_bfd_error_handler)
+	(_("%B: linking 32-bit code with 64-bit code"),
+	 ibfd);
+      ok = FALSE;
+    }
+  else if (!brownie32_mach_extends_p (bfd_get_mach (ibfd), bfd_get_mach (obfd)))
+    {
+      /* OBFD's ISA isn't the same as, or an extension of, IBFD's.  */
+      if (brownie32_mach_extends_p (bfd_get_mach (obfd), bfd_get_mach (ibfd)))
+	{
+	  /* Copy the architecture info from IBFD to OBFD.  Also copy
+	     the 32-bit flag (if set) so that we continue to recognise
+	     OBFD as a 32-bit binary.  */
+	  bfd_set_arch_info (obfd, bfd_get_arch_info (ibfd));
+	  elf_elfheader (obfd)->e_flags &= ~(EF_BROWNIE32_ARCH | EF_BROWNIE32_MACH);
+	  elf_elfheader (obfd)->e_flags
+	    |= new_flags & (EF_BROWNIE32_ARCH | EF_BROWNIE32_MACH | EF_BROWNIE32_32BITMODE);
+
+	  /* Copy across the ABI flags if OBFD doesn't use them
+	     and if that was what caused us to treat IBFD as 32-bit.  */
+	  if ((old_flags & EF_BROWNIE32_ABI) == 0
+	      && brownie32_32bit_flags_p (new_flags)
+	      && !brownie32_32bit_flags_p (new_flags & ~EF_BROWNIE32_ABI))
+	    elf_elfheader (obfd)->e_flags |= new_flags & EF_BROWNIE32_ABI;
+	}
+      else
+	{
+	  /* The ISAs aren't compatible.  */
+	  (*_bfd_error_handler)
+	    (_("%B: linking %s module with previous %s modules"),
+	     ibfd,
+	     bfd_printable_name (ibfd),
+	     bfd_printable_name (obfd));
+	  ok = FALSE;
+	}
+    }
+
+  new_flags &= ~(EF_BROWNIE32_ARCH | EF_BROWNIE32_MACH | EF_BROWNIE32_32BITMODE);
+  old_flags &= ~(EF_BROWNIE32_ARCH | EF_BROWNIE32_MACH | EF_BROWNIE32_32BITMODE);
+
+  /* Compare ABIs.  The 64-bit ABI does not use EF_BROWNIE32_ABI.  But, it
+     does set EI_CLASS differently from any 32-bit ABI.  */
+  if ((new_flags & EF_BROWNIE32_ABI) != (old_flags & EF_BROWNIE32_ABI)
+      || (elf_elfheader (ibfd)->e_ident[EI_CLASS]
+	  != elf_elfheader (obfd)->e_ident[EI_CLASS]))
+    {
+      /* Only error if both are set (to different values).  */
+      if (((new_flags & EF_BROWNIE32_ABI) && (old_flags & EF_BROWNIE32_ABI))
+	  || (elf_elfheader (ibfd)->e_ident[EI_CLASS]
+	      != elf_elfheader (obfd)->e_ident[EI_CLASS]))
+	{
+	  (*_bfd_error_handler)
+	    (_("%B: ABI mismatch: linking %s module with previous %s modules"),
+	     ibfd,
+	     elf_brownie32_abi_name (ibfd),
+	     elf_brownie32_abi_name (obfd));
+	  ok = FALSE;
+	}
+      new_flags &= ~EF_BROWNIE32_ABI;
+      old_flags &= ~EF_BROWNIE32_ABI;
+    }
+
+  /* For now, allow arbitrary mixing of ASEs (retain the union).  */
+  if ((new_flags & EF_BROWNIE32_ARCH_ASE) != (old_flags & EF_BROWNIE32_ARCH_ASE))
+    {
+      elf_elfheader (obfd)->e_flags |= new_flags & EF_BROWNIE32_ARCH_ASE;
+
+      new_flags &= ~ EF_BROWNIE32_ARCH_ASE;
+      old_flags &= ~ EF_BROWNIE32_ARCH_ASE;
+    }
+
+  /* Warn about any other mismatches */
+  if (new_flags != old_flags)
+    {
+      (*_bfd_error_handler)
+	(_("%B: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"),
+	 ibfd, (unsigned long) new_flags,
+	 (unsigned long) old_flags);
+      ok = FALSE;
+    }
+
+  if (! ok)
+    {
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+/* Function to keep BROWNIE32 specific file flags like as EF_BROWNIE32_PIC.  */
+
+bfd_boolean
+_bfd_brownie32_elf_set_private_flags (bfd *abfd, flagword flags)
+{
+  BFD_ASSERT (!elf_flags_init (abfd)
+	      || elf_elfheader (abfd)->e_flags == flags);
+
+  elf_elfheader (abfd)->e_flags = flags;
+  elf_flags_init (abfd) = TRUE;
+  return TRUE;
+}
+
+bfd_boolean
+_bfd_brownie32_elf_print_private_bfd_data (bfd *abfd, void *ptr)
+{
+  FILE *file = ptr;
+
+  BFD_ASSERT (abfd != NULL && ptr != NULL);
+
+  /* Print normal ELF private data.  */
+  _bfd_elf_print_private_bfd_data (abfd, ptr);
+
+  /* xgettext:c-format */
+  fprintf (file, _("private flags = %lx:"), elf_elfheader (abfd)->e_flags);
+
+  if ((elf_elfheader (abfd)->e_flags & EF_BROWNIE32_ABI) == E_BROWNIE32_ABI_O32)
+    fprintf (file, _(" [abi=O32]"));
+  else if ((elf_elfheader (abfd)->e_flags & EF_BROWNIE32_ABI) == E_BROWNIE32_ABI_O64)
+    fprintf (file, _(" [abi=O64]"));
+  else if ((elf_elfheader (abfd)->e_flags & EF_BROWNIE32_ABI) == E_BROWNIE32_ABI_EABI32)
+    fprintf (file, _(" [abi=EABI32]"));
+  else if ((elf_elfheader (abfd)->e_flags & EF_BROWNIE32_ABI) == E_BROWNIE32_ABI_EABI64)
+    fprintf (file, _(" [abi=EABI64]"));
+  else if ((elf_elfheader (abfd)->e_flags & EF_BROWNIE32_ABI))
+    fprintf (file, _(" [abi unknown]"));
+  else if (ABI_N32_P (abfd))
+    fprintf (file, _(" [abi=N32]"));
+  else if (ABI_64_P (abfd))
+    fprintf (file, _(" [abi=64]"));
+  else
+    fprintf (file, _(" [no abi set]"));
+
+  if ((elf_elfheader (abfd)->e_flags & EF_BROWNIE32_ARCH) == E_BROWNIE32_ARCH_1)
+    fprintf (file, _(" [brownie321]"));
+  else if ((elf_elfheader (abfd)->e_flags & EF_BROWNIE32_ARCH) == E_BROWNIE32_ARCH_2)
+    fprintf (file, _(" [brownie322]"));
+  else if ((elf_elfheader (abfd)->e_flags & EF_BROWNIE32_ARCH) == E_BROWNIE32_ARCH_3)
+    fprintf (file, _(" [brownie323]"));
+  else if ((elf_elfheader (abfd)->e_flags & EF_BROWNIE32_ARCH) == E_BROWNIE32_ARCH_4)
+    fprintf (file, _(" [brownie324]"));
+  else if ((elf_elfheader (abfd)->e_flags & EF_BROWNIE32_ARCH) == E_BROWNIE32_ARCH_5)
+    fprintf (file, _(" [brownie325]"));
+  else if ((elf_elfheader (abfd)->e_flags & EF_BROWNIE32_ARCH) == E_BROWNIE32_ARCH_32)
+    fprintf (file, _(" [brownie3232]"));
+  else if ((elf_elfheader (abfd)->e_flags & EF_BROWNIE32_ARCH) == E_BROWNIE32_ARCH_64)
+    fprintf (file, _(" [brownie3264]"));
+  else if ((elf_elfheader (abfd)->e_flags & EF_BROWNIE32_ARCH) == E_BROWNIE32_ARCH_32R2)
+    fprintf (file, _(" [brownie3232r2]"));
+  else if ((elf_elfheader (abfd)->e_flags & EF_BROWNIE32_ARCH) == E_BROWNIE32_ARCH_64R2)
+    fprintf (file, _(" [brownie3264r2]"));
+  else
+    fprintf (file, _(" [unknown ISA]"));
+
+  if (elf_elfheader (abfd)->e_flags & EF_BROWNIE32_ARCH_ASE_MDMX)
+    fprintf (file, _(" [mdmx]"));
+
+  if (elf_elfheader (abfd)->e_flags & EF_BROWNIE32_ARCH_ASE_M16)
+    fprintf (file, _(" [brownie3216]"));
+
+  if (elf_elfheader (abfd)->e_flags & EF_BROWNIE32_32BITMODE)
+    fprintf (file, _(" [32bitmode]"));
+  else
+    fprintf (file, _(" [not 32bitmode]"));
+
+  fputc ('\n', file);
+
+  return TRUE;
+}
+
+const struct bfd_elf_special_section _bfd_brownie32_elf_special_sections[] =
+{
+  { ".lit4",   5,  0, SHT_PROGBITS,   SHF_ALLOC + SHF_WRITE + SHF_BROWNIE32_GPREL },
+  { ".lit8",   5,  0, SHT_PROGBITS,   SHF_ALLOC + SHF_WRITE + SHF_BROWNIE32_GPREL },
+  { ".mdebug", 7,  0, SHT_BROWNIE32_DEBUG, 0 },
+  { ".sbss",   5, -2, SHT_NOBITS,     SHF_ALLOC + SHF_WRITE + SHF_BROWNIE32_GPREL },
+  { ".sdata",  6, -2, SHT_PROGBITS,   SHF_ALLOC + SHF_WRITE + SHF_BROWNIE32_GPREL },
+  { ".ucode",  6,  0, SHT_BROWNIE32_UCODE, 0 },
+  { NULL,      0,  0, 0,              0 }
+};
Index: bfd/elfxx-brownie32.h
===================================================================
RCS file: bfd/elfxx-brownie32.h
diff -N bfd/elfxx-brownie32.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ bfd/elfxx-brownie32.h	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,138 @@
+/* BROWNIE32 ELF specific backend routines.
+   Copyright 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#include "elf/common.h"
+#include "elf/internal.h"
+
+extern bfd_boolean _bfd_brownie32_elf_new_section_hook
+  (bfd *, asection *);
+extern void _bfd_brownie32_elf_symbol_processing
+  (bfd *, asymbol *);
+extern unsigned int _bfd_brownie32_elf_eh_frame_address_size
+  (bfd *, asection *);
+extern bfd_boolean _bfd_brownie32_elf_name_local_section_symbols
+  (bfd *);
+extern bfd_boolean _bfd_brownie32_elf_section_processing
+  (bfd *, Elf_Internal_Shdr *);
+extern bfd_boolean _bfd_brownie32_elf_section_from_shdr
+  (bfd *, Elf_Internal_Shdr *, const char *, int);
+extern bfd_boolean _bfd_brownie32_elf_fake_sections
+  (bfd *, Elf_Internal_Shdr *, asection *);
+extern bfd_boolean _bfd_brownie32_elf_section_from_bfd_section
+  (bfd *, asection *, int *);
+extern bfd_boolean _bfd_brownie32_elf_add_symbol_hook
+  (bfd *, struct bfd_link_info *, Elf_Internal_Sym *,
+   const char **, flagword *, asection **, bfd_vma *);
+extern bfd_boolean _bfd_brownie32_elf_link_output_symbol_hook
+  (struct bfd_link_info *, const char *, Elf_Internal_Sym *,
+   asection *, struct elf_link_hash_entry *);
+extern bfd_boolean _bfd_brownie32_elf_create_dynamic_sections
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean _bfd_brownie32_elf_check_relocs
+  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
+extern bfd_boolean _bfd_brownie32_elf_adjust_dynamic_symbol
+  (struct bfd_link_info *, struct elf_link_hash_entry *);
+extern bfd_boolean _bfd_brownie32_elf_always_size_sections
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean _bfd_brownie32_elf_size_dynamic_sections
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean _bfd_brownie32_elf_relocate_section
+  (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
+   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **);
+extern bfd_boolean _bfd_brownie32_elf_finish_dynamic_symbol
+  (bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
+   Elf_Internal_Sym *);
+extern bfd_boolean _bfd_brownie32_elf_finish_dynamic_sections
+  (bfd *, struct bfd_link_info *);
+extern void _bfd_brownie32_elf_final_write_processing
+  (bfd *, bfd_boolean);
+extern int _bfd_brownie32_elf_additional_program_headers
+  (bfd *);
+extern bfd_boolean _bfd_brownie32_elf_modify_segment_map
+  (bfd *, struct bfd_link_info *);
+extern asection * _bfd_brownie32_elf_gc_mark_hook
+  (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
+   struct elf_link_hash_entry *, Elf_Internal_Sym *);
+extern bfd_boolean _bfd_brownie32_elf_gc_sweep_hook
+  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
+extern void _bfd_brownie32_elf_copy_indirect_symbol
+  (struct bfd_link_info *, struct elf_link_hash_entry *,
+   struct elf_link_hash_entry *);
+extern void _bfd_brownie32_elf_hide_symbol
+  (struct bfd_link_info *, struct elf_link_hash_entry *, bfd_boolean);
+extern bfd_boolean _bfd_brownie32_elf_ignore_discarded_relocs
+  (asection *);
+extern bfd_boolean _bfd_brownie32_elf_find_nearest_line
+  (bfd *, asection *, asymbol **, bfd_vma, const char **,
+   const char **, unsigned int *);
+extern bfd_boolean _bfd_brownie32_elf_find_inliner_info
+  (bfd *, const char **, const char **, unsigned int *);
+extern bfd_boolean _bfd_brownie32_elf_set_section_contents
+  (bfd *, asection *, const void *, file_ptr, bfd_size_type);
+extern bfd_byte *_bfd_elf_brownie32_get_relocated_section_contents
+  (bfd *, struct bfd_link_info *, struct bfd_link_order *,
+   bfd_byte *, bfd_boolean, asymbol **);
+extern struct bfd_link_hash_table *_bfd_brownie32_elf_link_hash_table_create
+  (bfd *);
+extern bfd_boolean _bfd_brownie32_elf_final_link
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean _bfd_brownie32_elf_merge_private_bfd_data
+  (bfd *, bfd *);
+extern bfd_boolean _bfd_brownie32_elf_set_private_flags
+  (bfd *, flagword);
+extern bfd_boolean _bfd_brownie32_elf_print_private_bfd_data
+  (bfd *, void *);
+extern bfd_boolean _bfd_brownie32_elf_discard_info
+  (bfd *, struct elf_reloc_cookie *, struct bfd_link_info *);
+extern bfd_boolean _bfd_brownie32_elf_write_section
+  (bfd *, asection *, bfd_byte *);
+
+extern bfd_boolean _bfd_brownie32_elf_read_ecoff_info
+  (bfd *, asection *, struct ecoff_debug_info *);
+extern void _bfd_brownie3216_elf_reloc_unshuffle
+  (bfd *, int, bfd_boolean, bfd_byte *);
+extern void _bfd_brownie3216_elf_reloc_shuffle
+  (bfd *, int, bfd_boolean, bfd_byte *);
+extern bfd_reloc_status_type _bfd_brownie32_elf_gprel16_with_gp
+  (bfd *, asymbol *, arelent *, asection *, bfd_boolean, void *, bfd_vma);
+extern bfd_reloc_status_type _bfd_brownie32_elf32_gprel16_reloc
+  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
+extern bfd_reloc_status_type _bfd_brownie32_elf_hi16_reloc
+  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
+extern bfd_reloc_status_type _bfd_brownie32_elf_got16_reloc
+  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
+extern bfd_reloc_status_type _bfd_brownie32_elf_lo16_reloc
+  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
+extern bfd_reloc_status_type _bfd_brownie32_elf_generic_reloc
+  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
+extern unsigned long _bfd_elf_brownie32_mach
+  (flagword);
+extern bfd_boolean _bfd_brownie32_relax_section
+  (bfd *, asection *, struct bfd_link_info *, bfd_boolean *);
+extern bfd_vma _bfd_brownie32_elf_sign_extend
+  (bfd_vma, int);
+
+extern const struct bfd_elf_special_section _bfd_brownie32_elf_special_sections [];
+
+#define elf_backend_name_local_section_symbols \
+  _bfd_brownie32_elf_name_local_section_symbols
+#define elf_backend_special_sections _bfd_brownie32_elf_special_sections
+#define elf_backend_eh_frame_address_size _bfd_brownie32_elf_eh_frame_address_size
Index: bfd/elfxx-target.h
===================================================================
RCS file: /home/prj/asip/cvs/gdb/bfd/elfxx-target.h,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- bfd/elfxx-target.h	31 Jul 2007 11:40:33 -0000	1.1.1.1
+++ bfd/elfxx-target.h	8 Aug 2007 08:49:54 -0000	1.2
@@ -2,6 +2,8 @@
    Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
    2003, 2004, 2005 Free Software Foundation, Inc.
 
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
    This file is part of BFD, the Binary File Descriptor library.
 
    This program is free software; you can redistribute it and/or modify
@@ -471,6 +473,12 @@
 #ifndef elf_backend_mips_rtype_to_howto
 #define elf_backend_mips_rtype_to_howto		NULL
 #endif
+#ifndef elf_backend_brownie32_irix_compat
+#define elf_backend_brownie32_irix_compat		NULL
+#endif
+#ifndef elf_backend_brownie32_rtype_to_howto
+#define elf_backend_brownie32_rtype_to_howto		NULL
+#endif
 
 /* Previously, backends could only use SHT_REL or SHT_RELA relocation
    sections, but not both.  They defined USE_REL to indicate SHT_REL
@@ -607,8 +615,8 @@ static const struct elf_backend_data elf
   elf_backend_can_make_lsda_relative_eh_frame,
   elf_backend_encode_eh_address,
   elf_backend_write_section,
-  elf_backend_mips_irix_compat,
-  elf_backend_mips_rtype_to_howto,
+  elf_backend_brownie32_irix_compat,
+  elf_backend_brownie32_rtype_to_howto,
   elf_backend_ecoff_debug_swap,
   elf_backend_bfd_from_remote_memory,
   elf_backend_plt_sym_val,
Index: bfd/libbfd.h
===================================================================
RCS file: /home/prj/asip/cvs/gdb/bfd/libbfd.h,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- bfd/libbfd.h	31 Jul 2007 11:40:32 -0000	1.1.1.1
+++ bfd/libbfd.h	8 Aug 2007 08:49:54 -0000	1.2
@@ -10,6 +10,8 @@
    1999, 2000, 2001, 2002, 2003, 2004, 2005
    Free Software Foundation, Inc.
 
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
    Written by Cygnus Support.
 
 This file is part of BFD, the Binary File Descriptor library.
@@ -922,6 +924,9 @@ static const char *const bfd_reloc_code_
   "BFD_RELOC_MIPS_JMP",
   "BFD_RELOC_MIPS16_JMP",
   "BFD_RELOC_MIPS16_GPREL",
+  "BFD_RELOC_BROWNIE32_JMP",
+  "BFD_RELOC_BROWNIE3216_JMP",
+  "BFD_RELOC_BROWNIE3216_GPREL",
   "BFD_RELOC_HI16",
   "BFD_RELOC_HI16_S",
   "BFD_RELOC_LO16",
@@ -966,6 +971,44 @@ static const char *const bfd_reloc_code_
   "BFD_RELOC_MIPS_TLS_TPREL64",
   "BFD_RELOC_MIPS_TLS_TPREL_HI16",
   "BFD_RELOC_MIPS_TLS_TPREL_LO16",
+  "BFD_RELOC_BROWNIE3216_HI16",
+  "BFD_RELOC_BROWNIE3216_HI16_S",
+  "BFD_RELOC_BROWNIE3216_LO16",
+  "BFD_RELOC_BROWNIE32_LITERAL",
+  "BFD_RELOC_BROWNIE32_GOT16",
+  "BFD_RELOC_BROWNIE32_CALL16",
+  "BFD_RELOC_BROWNIE32_GOT_HI16",
+  "BFD_RELOC_BROWNIE32_GOT_LO16",
+  "BFD_RELOC_BROWNIE32_CALL_HI16",
+  "BFD_RELOC_BROWNIE32_CALL_LO16",
+  "BFD_RELOC_BROWNIE32_SUB",
+  "BFD_RELOC_BROWNIE32_GOT_PAGE",
+  "BFD_RELOC_BROWNIE32_GOT_OFST",
+  "BFD_RELOC_BROWNIE32_GOT_DISP",
+  "BFD_RELOC_BROWNIE32_SHIFT5",
+  "BFD_RELOC_BROWNIE32_SHIFT6",
+  "BFD_RELOC_BROWNIE32_INSERT_A",
+  "BFD_RELOC_BROWNIE32_INSERT_B",
+  "BFD_RELOC_BROWNIE32_DELETE",
+  "BFD_RELOC_BROWNIE32_HIGHEST",
+  "BFD_RELOC_BROWNIE32_HIGHER",
+  "BFD_RELOC_BROWNIE32_SCN_DISP",
+  "BFD_RELOC_BROWNIE32_REL16",
+  "BFD_RELOC_BROWNIE32_RELGOT",
+  "BFD_RELOC_BROWNIE32_JALR",
+  "BFD_RELOC_BROWNIE32_TLS_DTPMOD32",
+  "BFD_RELOC_BROWNIE32_TLS_DTPREL32",
+  "BFD_RELOC_BROWNIE32_TLS_DTPMOD64",
+  "BFD_RELOC_BROWNIE32_TLS_DTPREL64",
+  "BFD_RELOC_BROWNIE32_TLS_GD",
+  "BFD_RELOC_BROWNIE32_TLS_LDM",
+  "BFD_RELOC_BROWNIE32_TLS_DTPREL_HI16",
+  "BFD_RELOC_BROWNIE32_TLS_DTPREL_LO16",
+  "BFD_RELOC_BROWNIE32_TLS_GOTTPREL",
+  "BFD_RELOC_BROWNIE32_TLS_TPREL32",
+  "BFD_RELOC_BROWNIE32_TLS_TPREL64",
+  "BFD_RELOC_BROWNIE32_TLS_TPREL_HI16",
+  "BFD_RELOC_BROWNIE32_TLS_TPREL_LO16",
 
   "BFD_RELOC_FRV_LABEL16",
   "BFD_RELOC_FRV_LABEL24",
Index: bfd/pe-brownie32.c
===================================================================
RCS file: bfd/pe-brownie32.c
diff -N bfd/pe-brownie32.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ bfd/pe-brownie32.c	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,905 @@
+/* BFD back-end for BROWNIE32 PE COFF files.
+   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+   Modified from coff-i386.c by DJ Delorie, dj@cygnus.com
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#define COFF_WITH_PE
+#define COFF_LONG_SECTION_NAMES
+#define PCRELOFFSET TRUE
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "libbfd.h"
+#include "coff/brownie32pe.h"
+#include "coff/internal.h"
+#include "coff/pe.h"
+#include "libcoff.h"
+
+#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER 2
+/* The page size is a guess based on ELF.  */
+
+#define COFF_PAGE_SIZE 0x1000
+
+/* For some reason when using brownie32 COFF the value stored in the .text
+   section for a reference to a common symbol is the value itself plus
+   any desired offset.  Ian Taylor, Cygnus Support.  */
+
+/* If we are producing relocatable output, we need to do some
+   adjustments to the object file that are not done by the
+   bfd_perform_relocation function.  This function is called by every
+   reloc type to make any required adjustments.  */
+
+static bfd_reloc_status_type
+coff_brownie32_reloc (bfd *abfd,
+		 arelent *reloc_entry,
+		 asymbol *symbol,
+		 void * data,
+		 asection *input_section ATTRIBUTE_UNUSED,
+		 bfd *output_bfd,
+		 char **error_message ATTRIBUTE_UNUSED)
+{
+  symvalue diff;
+
+  if (output_bfd == NULL)
+    return bfd_reloc_continue;
+
+  if (bfd_is_com_section (symbol->section))
+    {
+#ifndef COFF_WITH_PE
+      /* We are relocating a common symbol.  The current value in the
+	 object file is ORIG + OFFSET, where ORIG is the value of the
+	 common symbol as seen by the object file when it was compiled
+	 (this may be zero if the symbol was undefined) and OFFSET is
+	 the offset into the common symbol (normally zero, but may be
+	 non-zero when referring to a field in a common structure).
+	 ORIG is the negative of reloc_entry->addend, which is set by
+	 the CALC_ADDEND macro below.  We want to replace the value in
+	 the object file with NEW + OFFSET, where NEW is the value of
+	 the common symbol which we are going to put in the final
+	 object file.  NEW is symbol->value.  */
+      diff = symbol->value + reloc_entry->addend;
+#else
+      /* In PE mode, we do not offset the common symbol.  */
+      diff = reloc_entry->addend;
+#endif
+    }
+  else
+    /* For some reason bfd_perform_relocation always effectively
+       ignores the addend for a COFF target when producing
+       relocatable output.  This seems to be always wrong for 386
+       COFF, so we handle the addend here instead.  */
+    diff = reloc_entry->addend;
+
+#define DOIT(x) \
+  x = ((x & ~howto->dst_mask) | (((x & howto->src_mask) + (diff >> howto->rightshift)) & howto->dst_mask))
+
+    if (diff != 0)
+      {
+	reloc_howto_type *howto = reloc_entry->howto;
+	unsigned char *addr = (unsigned char *) data + reloc_entry->address;
+
+	switch (howto->size)
+	  {
+	  case 0:
+	    {
+	      char x = bfd_get_8 (abfd, addr);
+
+	      DOIT (x);
+	      bfd_put_8 (abfd, x, addr);
+	    }
+	    break;
+
+	  case 1:
+	    {
+	      short x = bfd_get_16 (abfd, addr);
+
+	      DOIT (x);
+	      bfd_put_16 (abfd, (bfd_vma) x, addr);
+	    }
+	    break;
+
+	  case 2:
+	    {
+	      long x = bfd_get_32 (abfd, addr);
+
+	      DOIT (x);
+	      bfd_put_32 (abfd, (bfd_vma) x, addr);
+	    }
+	    break;
+
+	  default:
+	    abort ();
+	  }
+      }
+
+  /* Now let bfd_perform_relocation finish everything up.  */
+  return bfd_reloc_continue;
+}
+
+#ifdef COFF_WITH_PE
+/* Return TRUE if this relocation should
+   appear in the output .reloc section.  */
+
+static bfd_boolean
+in_reloc_p (bfd * abfd ATTRIBUTE_UNUSED, reloc_howto_type *howto)
+{
+  return ! howto->pc_relative && howto->type != BROWNIE32_R_RVA;
+}
+#endif
+
+#ifndef PCRELOFFSET
+#define PCRELOFFSET FALSE
+#endif
+
+static reloc_howto_type howto_table[] =
+{
+  /* Reloc type 0 is ignored.  The reloc reading code ensures that
+     this is a reference to the .abs section, which will cause
+     bfd_perform_relocation to do nothing.  */
+  HOWTO (BROWNIE32_R_ABSOLUTE,	/* Type.  */
+	 0,			/* Rightshift.  */
+	 0,			/* Size (0 = byte, 1 = short, 2 = long).  */
+	 8,			/* Bitsize.  */
+	 FALSE,			/* PC_relative.  */
+	 0,			/* Bitpos. */
+	 complain_overflow_dont, /* Complain_on_overflow. */
+	 0,			/* Special_function. */
+	 "IGNORE",		/* Name. */
+	 FALSE,			/* Partial_inplace. */
+	 0,			/* Src_mask. */
+	 0,			/* Dst_mask. */
+	 FALSE),		/* Pcrel_offset. */
+
+  /* A 16 bit reference to a symbol, normally from a data section.  */
+  HOWTO (BROWNIE32_R_REFHALF,	/* Type.  */
+	 0,			/* Rightshift.  */
+	 1,			/* Size (0 = byte, 1 = short, 2 = long).  */
+	 16,			/* Bitsize.  */
+	 FALSE,			/* PC_relative.  */
+	 0,			/* Bitpos. */
+	 complain_overflow_bitfield, /* Complain_on_overflow. */
+	 coff_brownie32_reloc,	/* Special_function. */
+	 "REFHALF",		/* Name. */
+	 TRUE,			/* Partial_inplace. */
+	 0xffff,		/* Src_mask. */
+	 0xffff,		/* Dst_mask. */
+	 FALSE),		/* Pcrel_offset. */
+
+  /* A 32 bit reference to a symbol, normally from a data section.  */
+  HOWTO (BROWNIE32_R_REFWORD,	/* Type.  */
+	 0,			/* Rightshift.  */
+	 2,			/* Size (0 = byte, 1 = short, 2 = long).  */
+	 32,			/* Bitsize.  */
+	 FALSE,			/* PC_relative.  */
+	 0,			/* Bitpos. */
+	 complain_overflow_bitfield, /* Complain_on_overflow. */
+	 coff_brownie32_reloc,	/* Special_function. */
+	 "REFWORD",		/* Name. */
+	 TRUE,			/* Partial_inplace. */
+	 0xffffffff,		/* Src_mask. */
+	 0xffffffff,		/* Dst_mask. */
+	 FALSE),		/* Pcrel_offset. */
+
+  /* A 26 bit absolute jump address.  */
+  HOWTO (BROWNIE32_R_JMPADDR,	/* Type.  */
+	 2,			/* Rightshift.  */
+	 2,			/* Size (0 = byte, 1 = short, 2 = long).  */
+	 26,			/* Bitsize.  */
+	 FALSE,			/* PC_relative.  */
+	 0,			/* Bitpos. */
+	 complain_overflow_dont, /* Complain_on_overflow. */
+	 			/* This needs complex overflow
+				   detection, because the upper four
+				   bits must match the PC.  */
+	 coff_brownie32_reloc,	/* Special_function. */
+	 "JMPADDR",		/* Name. */
+	 TRUE,			/* Partial_inplace. */
+	 0x3ffffff,		/* Src_mask. */
+	 0x3ffffff,		/* Dst_mask. */
+	 FALSE),		/* Pcrel_offset. */
+
+  /* The high 16 bits of a symbol value.  Handled by the function
+     brownie32_refhi_reloc.  */
+  HOWTO (BROWNIE32_R_REFHI,		/* Type.  */
+	 16,			/* Rightshift.  */
+	 2,			/* Size (0 = byte, 1 = short, 2 = long).  */
+	 16,			/* Bitsize.  */
+	 FALSE,			/* PC_relative.  */
+	 0,			/* Bitpos. */
+	 complain_overflow_bitfield, /* Complain_on_overflow. */
+	 coff_brownie32_reloc,	/* Special_function. */
+	 "REFHI",		/* Name. */
+	 TRUE,			/* Partial_inplace. */
+	 0xffff,		/* Src_mask. */
+	 0xffff,		/* Dst_mask. */
+	 FALSE),		/* Pcrel_offset. */
+
+  /* The low 16 bits of a symbol value.  */
+  HOWTO (BROWNIE32_R_REFLO,		/* Type.  */
+	 0,			/* Rightshift.  */
+	 2,			/* Size (0 = byte, 1 = short, 2 = long).  */
+	 16,			/* Bitsize.  */
+	 FALSE,			/* PC_relative.  */
+	 0,			/* Bitpos. */
+	 complain_overflow_dont, /* Complain_on_overflow. */
+	 coff_brownie32_reloc,	/* Special_function. */
+	 "REFLO",		/* Name. */
+	 TRUE,			/* Partial_inplace. */
+	 0xffff,		/* Src_mask. */
+	 0xffff,		/* Dst_mask. */
+	 FALSE),		/* Pcrel_offset. */
+
+  /* A reference to an offset from the gp register.  Handled by the
+     function brownie32_gprel_reloc.  */
+  HOWTO (BROWNIE32_R_GPREL,		/* Type.  */
+	 0,			/* Rightshift.  */
+	 2,			/* Size (0 = byte, 1 = short, 2 = long).  */
+	 16,			/* Bitsize.  */
+	 FALSE,			/* PC_relative.  */
+	 0,			/* Bitpos. */
+	 complain_overflow_signed, /* Complain_on_overflow. */
+	 coff_brownie32_reloc,	/* Special_function. */
+	 "GPREL",		/* Name. */
+	 TRUE,			/* Partial_inplace. */
+	 0xffff,		/* Src_mask. */
+	 0xffff,		/* Dst_mask. */
+	 FALSE),		/* Pcrel_offset. */
+
+  /* A reference to a literal using an offset from the gp register.
+     Handled by the function brownie32_gprel_reloc.  */
+  HOWTO (BROWNIE32_R_LITERAL,	/* Type.  */
+	 0,			/* Rightshift.  */
+	 2,			/* Size (0 = byte, 1 = short, 2 = long).  */
+	 16,			/* Bitsize.  */
+	 FALSE,			/* PC_relative.  */
+	 0,			/* Bitpos. */
+	 complain_overflow_signed, /* Complain_on_overflow. */
+	 coff_brownie32_reloc,	/* Special_function. */
+	 "LITERAL",		/* Name. */
+	 TRUE,			/* Partial_inplace. */
+	 0xffff,		/* Src_mask. */
+	 0xffff,		/* Dst_mask. */
+	 FALSE),		/* Pcrel_offset. */
+
+  EMPTY_HOWTO (8),
+  EMPTY_HOWTO (9),
+  EMPTY_HOWTO (10),
+  EMPTY_HOWTO (11),
+  EMPTY_HOWTO (12),
+  EMPTY_HOWTO (13),
+  EMPTY_HOWTO (14),
+  EMPTY_HOWTO (15),
+  EMPTY_HOWTO (16),
+  EMPTY_HOWTO (17),
+  EMPTY_HOWTO (18),
+  EMPTY_HOWTO (19),
+  EMPTY_HOWTO (20),
+  EMPTY_HOWTO (21),
+  EMPTY_HOWTO (22),
+  EMPTY_HOWTO (23),
+  EMPTY_HOWTO (24),
+  EMPTY_HOWTO (25),
+  EMPTY_HOWTO (26),
+  EMPTY_HOWTO (27),
+  EMPTY_HOWTO (28),
+  EMPTY_HOWTO (29),
+  EMPTY_HOWTO (30),
+  EMPTY_HOWTO (31),
+  EMPTY_HOWTO (32),
+  EMPTY_HOWTO (33),
+  HOWTO (BROWNIE32_R_RVA,            /* Type.  */
+	 0,	                /* Rightshift.  */
+	 2,	                /* Size (0 = byte, 1 = short, 2 = long).  */
+	 32,	                /* Bitsize.  */
+	 FALSE,	                /* PC_relative.  */
+	 0,	                /* Bitpos. */
+	 complain_overflow_bitfield, /* Complain_on_overflow. */
+	 coff_brownie32_reloc,       /* Special_function. */
+	 "rva32",	        /* Name. */
+	 TRUE,	                /* Partial_inplace. */
+	 0xffffffff,            /* Src_mask. */
+	 0xffffffff,            /* Dst_mask. */
+	 FALSE),                /* Pcrel_offset. */
+  EMPTY_HOWTO (35),
+  EMPTY_HOWTO (36),
+  HOWTO (BROWNIE32_R_PAIR,           /* Type.  */
+	 0,	                /* Rightshift.  */
+	 2,	                /* Size (0 = byte, 1 = short, 2 = long).  */
+	 32,	                /* Bitsize.  */
+	 FALSE,	                /* PC_relative.  */
+	 0,	                /* Bitpos. */
+	 complain_overflow_bitfield, /* Complain_on_overflow. */
+	 coff_brownie32_reloc,       /* Special_function. */
+	 "PAIR",	        /* Name. */
+	 TRUE,	                /* Partial_inplace. */
+	 0xffffffff,            /* Src_mask. */
+	 0xffffffff,            /* Dst_mask. */
+	 FALSE),                /* Pcrel_offset. */
+};
+
+/* Turn a howto into a reloc nunmber.  */
+
+#define SELECT_RELOC(x, howto) { x.r_type = howto->type; }
+#define BADMAG(x)              BROWNIE32BADMAG (x)
+
+/* Customize coffcode.h.  */
+#define BROWNIE32 1
+
+#define RTYPE2HOWTO(cache_ptr, dst) \
+	    (cache_ptr)->howto = howto_table + (dst)->r_type;
+
+/* Compute the addend of a reloc.  If the reloc is to a common symbol,
+   the object file contains the value of the common symbol.  By the
+   time this is called, the linker may be using a different symbol
+   from a different object file with a different value.  Therefore, we
+   hack wildly to locate the original symbol from this file so that we
+   can make the correct adjustment.  This macro sets coffsym to the
+   symbol from the original file, and uses it to set the addend value
+   correctly.  If this is not a common symbol, the usual addend
+   calculation is done, except that an additional tweak is needed for
+   PC relative relocs.
+   FIXME: This macro refers to symbols and asect; these are from the
+   calling function, not the macro arguments.  */
+
+#define CALC_ADDEND(abfd, ptr, reloc, cache_ptr)		\
+  {								\
+    coff_symbol_type *coffsym = NULL;				\
+    if (ptr && bfd_asymbol_bfd (ptr) != abfd)			\
+      coffsym = (obj_symbols (abfd)				\
+	         + (cache_ptr->sym_ptr_ptr - symbols));		\
+    else if (ptr)						\
+      coffsym = coff_symbol_from (abfd, ptr);			\
+    if (coffsym != NULL						\
+	&& coffsym->native->u.syment.n_scnum == 0)		\
+      cache_ptr->addend = - coffsym->native->u.syment.n_value;	\
+    else if (ptr && bfd_asymbol_bfd (ptr) == abfd		\
+	     && ptr->section != NULL)				\
+      cache_ptr->addend = - (ptr->section->vma + ptr->value);	\
+    else							\
+      cache_ptr->addend = 0;					\
+    if (ptr && howto_table[reloc.r_type].pc_relative)		\
+      cache_ptr->addend += asect->vma;				\
+  }
+
+/* Convert an rtype to howto for the COFF backend linker.  */
+
+static reloc_howto_type *
+coff_brownie32_rtype_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
+			  asection *sec,
+			  struct internal_reloc *rel,
+			  struct coff_link_hash_entry *h,
+			  struct internal_syment *sym,
+			  bfd_vma *addendp)
+{
+
+  reloc_howto_type *howto;
+
+  howto = howto_table + rel->r_type;
+
+#ifdef COFF_WITH_PE
+  *addendp = 0;
+#endif
+
+  if (howto->pc_relative)
+    *addendp += sec->vma;
+
+  if (sym != NULL && sym->n_scnum == 0 && sym->n_value != 0)
+    {
+      /* This is a common symbol.  The section contents include the
+	 size (sym->n_value) as an addend.  The relocate_section
+	 function will be adding in the final value of the symbol.  We
+	 need to subtract out the current size in order to get the
+	 correct result.  */
+
+      BFD_ASSERT (h != NULL);
+
+#ifndef COFF_WITH_PE
+      /* I think we *do* want to bypass this.  If we don't, I have
+	 seen some data parameters get the wrong relocation address.
+	 If I link two versions with and without this section bypassed
+	 and then do a binary comparison, the addresses which are
+	 different can be looked up in the map.  The case in which
+	 this section has been bypassed has addresses which correspond
+	 to values I can find in the map.  */
+      *addendp -= sym->n_value;
+#endif
+    }
+
+#ifndef COFF_WITH_PE
+  /* If the output symbol is common (in which case this must be a
+     relocatable link), we need to add in the final size of the
+     common symbol.  */
+  if (h != NULL && h->root.type == bfd_link_hash_common)
+    *addendp += h->root.u.c.size;
+#endif
+
+#ifdef COFF_WITH_PE
+  if (howto->pc_relative)
+    {
+      *addendp -= 4;
+
+      /* If the symbol is defined, then the generic code is going to
+         add back the symbol value in order to cancel out an
+         adjustment it made to the addend.  However, we set the addend
+         to 0 at the start of this function.  We need to adjust here,
+         to avoid the adjustment the generic code will make.  FIXME:
+         This is getting a bit hackish.  */
+      if (sym != NULL && sym->n_scnum != 0)
+	*addendp -= sym->n_value;
+    }
+
+  if (rel->r_type == BROWNIE32_R_RVA)
+    *addendp -= pe_data (sec->output_section->owner)->pe_opthdr.ImageBase;
+#endif
+
+  return howto;
+}
+
+#define coff_rtype_to_howto         coff_brownie32_rtype_to_howto
+#define coff_bfd_reloc_type_lookup  coff_brownie32_reloc_type_lookup
+
+/* Get the howto structure for a generic reloc type.  */
+
+static reloc_howto_type *
+coff_brownie32_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+			     bfd_reloc_code_real_type code)
+{
+  int brownie32_type;
+
+  switch (code)
+    {
+    case BFD_RELOC_16:
+      brownie32_type = BROWNIE32_R_REFHALF;
+      break;
+    case BFD_RELOC_32:
+    case BFD_RELOC_CTOR:
+      brownie32_type = BROWNIE32_R_REFWORD;
+      break;
+    case BFD_RELOC_BROWNIE32_JMP:
+      brownie32_type = BROWNIE32_R_JMPADDR;
+      break;
+    case BFD_RELOC_HI16_S:
+      brownie32_type = BROWNIE32_R_REFHI;
+      break;
+    case BFD_RELOC_LO16:
+      brownie32_type = BROWNIE32_R_REFLO;
+      break;
+    case BFD_RELOC_GPREL16:
+      brownie32_type = BROWNIE32_R_GPREL;
+      break;
+    case BFD_RELOC_BROWNIE32_LITERAL:
+      brownie32_type = BROWNIE32_R_LITERAL;
+      break;
+    case BFD_RELOC_RVA:
+      brownie32_type = BROWNIE32_R_RVA;
+      break;
+    default:
+      return NULL;
+    }
+
+  return & howto_table [brownie32_type];
+}
+
+static void
+brownie32_swap_reloc_in (bfd * abfd, void * src, void * dst)
+{
+  static struct internal_reloc pair_prev;
+  RELOC *reloc_src = (RELOC *) src;
+  struct internal_reloc *reloc_dst = (struct internal_reloc *) dst;
+
+  reloc_dst->r_vaddr = H_GET_32 (abfd, reloc_src->r_vaddr);
+  reloc_dst->r_symndx = H_GET_S32 (abfd, reloc_src->r_symndx);
+  reloc_dst->r_type = H_GET_16 (abfd, reloc_src->r_type);
+  reloc_dst->r_size = 0;
+  reloc_dst->r_extern = 0;
+  reloc_dst->r_offset = 0;
+
+  switch (reloc_dst->r_type)
+  {
+  case BROWNIE32_R_REFHI:
+    pair_prev = *reloc_dst;
+    break;
+  case BROWNIE32_R_PAIR:
+    reloc_dst->r_offset = reloc_dst->r_symndx;
+    if (reloc_dst->r_offset & 0x8000)
+      reloc_dst->r_offset -= 0x10000;
+    reloc_dst->r_symndx = pair_prev.r_symndx;
+    break;
+  }
+}
+
+static unsigned int
+brownie32_swap_reloc_out (bfd * abfd, void * src, void * dst)
+{
+  static int prev_offset = 1;
+  static bfd_vma prev_addr = 0;
+  struct internal_reloc *reloc_src = (struct internal_reloc *)src;
+  struct external_reloc *reloc_dst = (struct external_reloc *)dst;
+
+  switch (reloc_src->r_type)
+    {
+    case BROWNIE32_R_REFHI:
+      prev_addr = reloc_src->r_vaddr;
+      prev_offset = reloc_src->r_offset;
+      break;
+    case BROWNIE32_R_REFLO:
+      if (reloc_src->r_vaddr == prev_addr)
+	{
+	  /* FIXME: only slightly hackish.  If we see a REFLO pointing to
+	     the same address as a REFHI, we assume this is the matching
+	     PAIR reloc and output it accordingly.  The symndx is really
+	     the low 16 bits of the addend */
+	  H_PUT_32 (abfd, reloc_src->r_vaddr, reloc_dst->r_vaddr);
+	  H_PUT_32 (abfd, reloc_src->r_symndx, reloc_dst->r_symndx);
+	  H_PUT_16 (abfd, BROWNIE32_R_PAIR, reloc_dst->r_type);
+	  return RELSZ;
+	}
+      break;
+    }
+
+  H_PUT_32 (abfd, reloc_src->r_vaddr, reloc_dst->r_vaddr);
+  H_PUT_32 (abfd, reloc_src->r_symndx, reloc_dst->r_symndx);
+
+  H_PUT_16 (abfd, reloc_src->r_type, reloc_dst->r_type);
+  return RELSZ;
+}
+
+#define coff_swap_reloc_in   brownie32_swap_reloc_in
+#define coff_swap_reloc_out  brownie32_swap_reloc_out
+#define NO_COFF_RELOCS
+
+static bfd_boolean
+coff_pe_brownie32_relocate_section (bfd *output_bfd,
+			       struct bfd_link_info *info,
+			       bfd *input_bfd,
+			       asection *input_section,
+			       bfd_byte *contents,
+			       struct internal_reloc *relocs,
+			       struct internal_syment *syms,
+			       asection **sections)
+{
+  bfd_vma gp;
+  bfd_boolean gp_undefined;
+  size_t adjust;
+  struct internal_reloc *rel;
+  struct internal_reloc *rel_end;
+  unsigned int i;
+  bfd_boolean got_lo;
+
+  if (info->relocatable)
+    {
+      (*_bfd_error_handler)
+	(_("%B: `ld -r' not supported with PE BROWNIE32 objects\n"), input_bfd);
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }
+
+  BFD_ASSERT (input_bfd->xvec->byteorder
+	      == output_bfd->xvec->byteorder);
+
+  gp = _bfd_get_gp_value (output_bfd);
+  gp_undefined = (gp == 0) ? TRUE : FALSE;
+  got_lo = FALSE;
+  adjust = 0;
+  rel = relocs;
+  rel_end = rel + input_section->reloc_count;
+
+  for (i = 0; rel < rel_end; rel++, i++)
+    {
+      long symndx;
+      struct coff_link_hash_entry *h;
+      struct internal_syment *sym;
+      bfd_vma addend = 0;
+      bfd_vma val, tmp, targ, src, low;
+      reloc_howto_type *howto;
+      unsigned char *mem = contents + rel->r_vaddr;
+
+      symndx = rel->r_symndx;
+
+      if (symndx == -1)
+	{
+	  h = NULL;
+	  sym = NULL;
+	}
+      else
+	{
+	  h = obj_coff_sym_hashes (input_bfd)[symndx];
+	  sym = syms + symndx;
+	}
+
+      /* COFF treats common symbols in one of two ways.  Either the
+         size of the symbol is included in the section contents, or it
+         is not.  We assume that the size is not included, and force
+         the rtype_to_howto function to adjust the addend as needed.  */
+
+      if (sym != NULL && sym->n_scnum != 0)
+	addend = - sym->n_value;
+      else
+	addend = 0;
+
+      howto = bfd_coff_rtype_to_howto (input_bfd, input_section, rel, h,
+				       sym, &addend);
+      if (howto == NULL)
+	return FALSE;
+
+      /* If we are doing a relocatable link, then we can just ignore
+         a PC relative reloc that is pcrel_offset.  It will already
+         have the correct value.  If this is not a relocatable link,
+         then we should ignore the symbol value.  */
+      if (howto->pc_relative && howto->pcrel_offset)
+	{
+	  if (info->relocatable)
+	    continue;
+	  if (sym != NULL && sym->n_scnum != 0)
+	    addend += sym->n_value;
+	}
+
+      val = 0;
+
+      if (h == NULL)
+	{
+	  asection *sec;
+
+	  if (symndx == -1)
+	    {
+	      sec = bfd_abs_section_ptr;
+	      val = 0;
+	    }
+	  else
+	    {
+	      sec = sections[symndx];
+              val = (sec->output_section->vma
+		     + sec->output_offset
+		     + sym->n_value);
+	      if (! obj_pe (input_bfd))
+		val -= sec->vma;
+	    }
+	}
+      else
+	{
+	  if (h->root.type == bfd_link_hash_defined
+	      || h->root.type == bfd_link_hash_defweak)
+	    {
+	      asection *sec;
+
+	      sec = h->root.u.def.section;
+	      val = (h->root.u.def.value
+		     + sec->output_section->vma
+		     + sec->output_offset);
+	      }
+
+	  else if (! info->relocatable)
+	    {
+	      if (! ((*info->callbacks->undefined_symbol)
+		     (info, h->root.root.string, input_bfd, input_section,
+		      rel->r_vaddr - input_section->vma, TRUE)))
+		return FALSE;
+	    }
+	}
+
+      src = rel->r_vaddr + input_section->output_section->vma
+	+ input_section->output_offset;
+
+      /* OK, at this point the following variables are set up:
+	   src = VMA of the memory we're fixing up
+	   mem = pointer to memory we're fixing up
+	   val = VMA of what we need to refer to.  */
+
+#define UI(x) (*_bfd_error_handler) (_("%B: unimplemented %s\n"), \
+				     input_bfd, x); \
+	      bfd_set_error (bfd_error_bad_value);
+
+      switch (rel->r_type)
+	{
+	case BROWNIE32_R_ABSOLUTE:
+	  /* Ignore these.  */
+	  break;
+
+	case BROWNIE32_R_REFHALF:
+	  UI ("refhalf");
+	  break;
+
+	case BROWNIE32_R_REFWORD:
+	  tmp = bfd_get_32 (input_bfd, mem);
+	  /* printf ("refword: src=%08x targ=%08x+%08x\n", src, tmp, val); */
+	  tmp += val;
+	  bfd_put_32 (input_bfd, tmp, mem);
+	  break;
+
+	case BROWNIE32_R_JMPADDR:
+	  tmp = bfd_get_32 (input_bfd, mem);
+	  targ = val + (tmp & 0x03ffffff) * 4;
+	  if ((src & 0xf0000000) != (targ & 0xf0000000))
+	    {
+	      (*_bfd_error_handler) (_("%B: jump too far away\n"), input_bfd);
+	      bfd_set_error (bfd_error_bad_value);
+	      return FALSE;
+	    }
+	  tmp &= 0xfc000000;
+	  tmp |= (targ / 4) & 0x3ffffff;
+	  bfd_put_32 (input_bfd, tmp, mem);
+	  break;
+
+	case BROWNIE32_R_REFHI:
+	  tmp = bfd_get_32 (input_bfd, mem);
+	  switch (rel[1].r_type)
+	    {
+	    case BROWNIE32_R_PAIR:
+	      /* MS PE object */
+	      targ = val + rel[1].r_offset + ((tmp & 0xffff) << 16);
+	      break;
+	    case BROWNIE32_R_REFLO:
+	      /* GNU COFF object */
+	      low = bfd_get_32 (input_bfd, contents + rel[1].r_vaddr);
+	      low &= 0xffff;
+	      if (low & 0x8000)
+		low -= 0x10000;
+	      targ = val + low + ((tmp & 0xffff) << 16);
+	      break;
+	    default:
+	      (*_bfd_error_handler) (_("%B: bad pair/reflo after refhi\n"),
+				     input_bfd);
+	      bfd_set_error (bfd_error_bad_value);
+	      return FALSE;
+	    }
+	  tmp &= 0xffff0000;
+	  tmp |= (targ >> 16) & 0xffff;
+	  bfd_put_32 (input_bfd, tmp, mem);
+	  break;
+
+	case BROWNIE32_R_REFLO:
+	  tmp = bfd_get_32 (input_bfd, mem);
+	  targ = val + (tmp & 0xffff);
+	  /* printf ("refword: src=%08x targ=%08x\n", src, targ); */
+	  tmp &= 0xffff0000;
+	  tmp |= targ & 0xffff;
+	  bfd_put_32 (input_bfd, tmp, mem);
+	  break;
+
+	case BROWNIE32_R_GPREL:
+	case BROWNIE32_R_LITERAL:
+	  UI ("gprel");
+	  break;
+
+	case BROWNIE32_R_SECTION:
+	  UI ("section");
+	  break;
+
+	case BROWNIE32_R_SECREL:
+	  UI ("secrel");
+	  break;
+
+	case BROWNIE32_R_SECRELLO:
+	  UI ("secrello");
+	  break;
+
+	case BROWNIE32_R_SECRELHI:
+	  UI ("secrelhi");
+	  break;
+
+	case BROWNIE32_R_RVA:
+	  tmp = bfd_get_32 (input_bfd, mem);
+	  /* printf ("rva: src=%08x targ=%08x+%08x\n", src, tmp, val); */
+	  tmp += val
+	    - pe_data (input_section->output_section->owner)->pe_opthdr.ImageBase;
+	  bfd_put_32 (input_bfd, tmp, mem);
+	  break;
+
+	case BROWNIE32_R_PAIR:
+	  /* ignore these */
+	  break;
+	}
+    }
+
+  return TRUE;
+}
+
+#define coff_relocate_section coff_pe_brownie32_relocate_section
+
+#ifdef TARGET_UNDERSCORE
+
+/* If brownie32 gcc uses underscores for symbol names, then it does not use
+   a leading dot for local labels, so if TARGET_UNDERSCORE is defined
+   we treat all symbols starting with L as local.  */
+
+static bfd_boolean
+coff_brownie32_is_local_label_name (bfd *abfd, const char *name)
+{
+  if (name[0] == 'L')
+    return TRUE;
+
+  return _bfd_coff_is_local_label_name (abfd, name);
+}
+
+#define coff_bfd_is_local_label_name coff_brownie32_is_local_label_name
+
+#endif /* TARGET_UNDERSCORE */
+
+#define COFF_NO_HACK_SCNHDR_SIZE
+
+#include "coffcode.h"
+
+const bfd_target
+#ifdef TARGET_SYM
+  TARGET_SYM =
+#else
+  brownie32lpe_vec =
+#endif
+{
+#ifdef TARGET_NAME
+  TARGET_NAME,
+#else
+  "pe-brownie32",			/* Name.  */
+#endif
+  bfd_target_coff_flavour,
+  BFD_ENDIAN_LITTLE,		/* Data byte order is little.  */
+  BFD_ENDIAN_LITTLE,		/* Header byte order is little.  */
+
+  (HAS_RELOC | EXEC_P |		/* Object flags.  */
+   HAS_LINENO | HAS_DEBUG |
+   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
+
+#ifndef COFF_WITH_PE
+  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC /* Section flags.  */
+   | SEC_CODE | SEC_DATA),
+#else
+  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC /* Section flags.  */
+   | SEC_CODE | SEC_DATA
+   | SEC_LINK_ONCE | SEC_LINK_DUPLICATES),
+#endif
+
+#ifdef TARGET_UNDERSCORE
+  TARGET_UNDERSCORE,		/* Leading underscore.  */
+#else
+  0,				/* leading underscore */
+#endif
+  '/',				/* AR_pad_char.  */
+  15,				/* AR_max_namelen.  */
+
+  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
+     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
+     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* Data.  */
+  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
+     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
+     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* Headers.  */
+
+  /* Note that we allow an object file to be treated as a core file as well.  */
+  {_bfd_dummy_target, coff_object_p, /* bfd_check_format.  */
+   bfd_generic_archive_p, coff_object_p},
+  {bfd_false, coff_mkobject, _bfd_generic_mkarchive, /* bfd_set_format.  */
+   bfd_false},
+  {bfd_false, coff_write_object_contents, /* bfd_write_contents.  */
+   _bfd_write_archive_contents, bfd_false},
+
+  BFD_JUMP_TABLE_GENERIC (coff),
+  BFD_JUMP_TABLE_COPY (coff),
+  BFD_JUMP_TABLE_CORE (_bfd_nocore),
+  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
+  BFD_JUMP_TABLE_SYMBOLS (coff),
+  BFD_JUMP_TABLE_RELOCS (coff),
+  BFD_JUMP_TABLE_WRITE (coff),
+  BFD_JUMP_TABLE_LINK (coff),
+  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
+
+  NULL,
+
+  COFF_SWAP_TABLE
+};
Index: bfd/pei-brownie32.c
===================================================================
RCS file: bfd/pei-brownie32.c
diff -N bfd/pei-brownie32.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ bfd/pei-brownie32.c	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,32 @@
+/* BFD back-end for BROWNIE32 PE IMAGE COFF files.
+   Copyright 1995, 2000, 2001, 2002 Free Software Foundation, Inc.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#include "bfd.h"
+#include "sysdep.h"
+
+#define TARGET_SYM brownie32lpei_vec
+#define TARGET_NAME "pei-brownie32"
+#define COFF_IMAGE_WITH_PE
+#define PCRELOFFSET TRUE
+#define COFF_LONG_SECTION_NAMES
+
+#include "pe-brownie32.c"
+
Index: bfd/targets.c
===================================================================
RCS file: /home/prj/asip/cvs/gdb/bfd/targets.c,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- bfd/targets.c	31 Jul 2007 11:40:32 -0000	1.1.1.1
+++ bfd/targets.c	8 Aug 2007 08:49:54 -0000	1.2
@@ -4,6 +4,8 @@
    Free Software Foundation, Inc.
    Written by Cygnus Support.
 
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
    This file is part of BFD, the Binary File Descriptor library.
 
    This program is free software; you can redistribute it and/or modify
@@ -567,6 +569,7 @@ extern const bfd_target bfd_elf32_bigarm
 extern const bfd_target bfd_elf32_bigarm_symbian_vec;
 extern const bfd_target bfd_elf32_bigarm_vxworks_vec;
 extern const bfd_target bfd_elf32_bigmips_vec;
+extern const bfd_target bfd_elf32_bigbrownie32_vec;
 extern const bfd_target bfd_elf32_cr16c_vec;
 extern const bfd_target bfd_elf32_cris_vec;
 extern const bfd_target bfd_elf32_crx_vec;
@@ -597,6 +600,7 @@ extern const bfd_target bfd_elf32_little
 extern const bfd_target bfd_elf32_littlearm_symbian_vec;
 extern const bfd_target bfd_elf32_littlearm_vxworks_vec;
 extern const bfd_target bfd_elf32_littlemips_vec;
+extern const bfd_target bfd_elf32_littlebrownie32_vec;
 extern const bfd_target bfd_elf32_m32c_vec;
 extern const bfd_target bfd_elf32_m32r_vec;
 extern const bfd_target bfd_elf32_m32rle_vec;
@@ -650,6 +654,7 @@ extern const bfd_target bfd_elf64_alpha_
 extern const bfd_target bfd_elf64_alpha_vec;
 extern const bfd_target bfd_elf64_big_generic_vec;
 extern const bfd_target bfd_elf64_bigmips_vec;
+extern const bfd_target bfd_elf64_bigbrownie32_vec;
 extern const bfd_target bfd_elf64_hppa_linux_vec;
 extern const bfd_target bfd_elf64_hppa_vec;
 extern const bfd_target bfd_elf64_ia64_big_vec;
@@ -657,6 +662,7 @@ extern const bfd_target bfd_elf64_ia64_h
 extern const bfd_target bfd_elf64_ia64_little_vec;
 extern const bfd_target bfd_elf64_little_generic_vec;
 extern const bfd_target bfd_elf64_littlemips_vec;
+extern const bfd_target bfd_elf64_littlebrownie32_vec;
 extern const bfd_target bfd_elf64_mmix_vec;
 extern const bfd_target bfd_elf64_powerpc_vec;
 extern const bfd_target bfd_elf64_powerpcle_vec;
Index: bfd/doc/Makefile.in
===================================================================
RCS file: /home/prj/asip/cvs/gdb/bfd/doc/Makefile.in,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- bfd/doc/Makefile.in	31 Jul 2007 11:40:33 -0000	1.1.1.1
+++ bfd/doc/Makefile.in	8 Aug 2007 08:49:54 -0000	1.2
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.9.5 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
@@ -36,6 +36,7 @@ POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
 target_triplet = @target@
+LIBOBJDIR =
 subdir = doc
 DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
@@ -360,9 +361,11 @@ distclean-libtool:
 	restore=: && backupdir="$(am__leading_dot)am$$$$" && \
 	am__cwd=`pwd` && cd $(srcdir) && \
 	rm -rf $$backupdir && mkdir $$backupdir && \
-	for f in $@ $@-[0-9] $@-[0-9][0-9] $(@:.info=).i[0-9] $(@:.info=).i[0-9][0-9]; do \
-	  if test -f $$f; then mv $$f $$backupdir; restore=mv; else :; fi; \
-	done; \
+	if ($(MAKEINFO) --version) >/dev/null 2>&1; then \
+	  for f in $@ $@-[0-9] $@-[0-9][0-9] $(@:.info=).i[0-9] $(@:.info=).i[0-9][0-9]; do \
+	    if test -f $$f; then mv $$f $$backupdir; restore=mv; else :; fi; \
+	  done; \
+	else :; fi && \
 	cd "$$am__cwd"; \
 	if $(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I $(srcdir) \
 	 -o $@ $<; \
@@ -404,6 +407,7 @@ bfd.dvi: bfd.texinfo 
 bfd.pdf: bfd.texinfo 
 bfd.html: bfd.texinfo 
 .dvi.ps:
+	TEXINPUTS="$(am__TEXINFO_TEX_DIR)$(PATH_SEPARATOR)$$TEXINPUTS" \
 	$(DVIPS) -o $@ $<
 
 uninstall-info-am:
Index: bfd/doc/bfd.info
===================================================================
RCS file: /home/prj/asip/cvs/gdb/bfd/doc/bfd.info,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- bfd/doc/bfd.info	31 Jul 2007 11:40:33 -0000	1.1.1.1
+++ bfd/doc/bfd.info	8 Aug 2007 08:49:54 -0000	1.2
@@ -1,5 +1,6 @@
-This is ../.././bfd/doc/bfd.info, produced by makeinfo version 4.8 from
-../.././bfd/doc/bfd.texinfo.
+This is /opt/src/gnu/gdb-6.4-brownie32/bfd/doc/bfd.info, produced by
+makeinfo version 4.8 from
+/opt/src/gnu/gdb-6.4-brownie32/bfd/doc/bfd.texinfo.
 
 START-INFO-DIR-ENTRY
 * Bfd: (bfd).                   The Binary File Descriptor library.
@@ -17,73 +18,10181 @@ END-INFO-DIR-ENTRY
 section entitled "GNU Free Documentation License".
 
 
-Indirect:
-bfd.info-1: 724
-bfd.info-2: 277335
+File: bfd.info,  Node: Top,  Next: Overview,  Prev: (dir),  Up: (dir)
+
+   This file documents the binary file descriptor library libbfd.
+
+* Menu:
+
+* Overview::			Overview of BFD
+* BFD front end::		BFD front end
+* BFD back ends::		BFD back ends
+* GNU Free Documentation License::  GNU Free Documentation License
+* Index::			Index
+
+
+File: bfd.info,  Node: Overview,  Next: BFD front end,  Prev: Top,  Up: Top
+
+1 Introduction
+**************
+
+BFD is a package which allows applications to use the same routines to
+operate on object files whatever the object file format.  A new object
+file format can be supported simply by creating a new BFD back end and
+adding it to the library.
+
+   BFD is split into two parts: the front end, and the back ends (one
+for each object file format).
+   * The front end of BFD provides the interface to the user. It manages
+     memory and various canonical data structures. The front end also
+     decides which back end to use and when to call back end routines.
+
+   * The back ends provide BFD its view of the real world. Each back
+     end provides a set of calls which the BFD front end can use to
+     maintain its canonical form. The back ends also may keep around
+     information for their own use, for greater efficiency.
+
+* Menu:
+
+* History::			History
+* How It Works::		How It Works
+* What BFD Version 2 Can Do::	What BFD Version 2 Can Do
+
+
+File: bfd.info,  Node: History,  Next: How It Works,  Prev: Overview,  Up: Overview
+
+1.1 History
+===========
+
+One spur behind BFD was the desire, on the part of the GNU 960 team at
+Intel Oregon, for interoperability of applications on their COFF and
+b.out file formats.  Cygnus was providing GNU support for the team, and
+was contracted to provide the required functionality.
+
+   The name came from a conversation David Wallace was having with
+Richard Stallman about the library: RMS said that it would be quite
+hard--David said "BFD".  Stallman was right, but the name stuck.
+
+   At the same time, Ready Systems wanted much the same thing, but for
+different object file formats: IEEE-695, Oasys, Srecords, a.out and 68k
+coff.
+
+   BFD was first implemented by members of Cygnus Support; Steve
+Chamberlain (`sac@cygnus.com'), John Gilmore (`gnu@cygnus.com'), K.
+Richard Pixley (`rich@cygnus.com') and David Henkel-Wallace
+(`gumby@cygnus.com').
+
+
+File: bfd.info,  Node: How It Works,  Next: What BFD Version 2 Can Do,  Prev: History,  Up: Overview
+
+1.2 How To Use BFD
+==================
+
+To use the library, include `bfd.h' and link with `libbfd.a'.
+
+   BFD provides a common interface to the parts of an object file for a
+calling application.
+
+   When an application sucessfully opens a target file (object,
+archive, or whatever), a pointer to an internal structure is returned.
+This pointer points to a structure called `bfd', described in `bfd.h'.
+Our convention is to call this pointer a BFD, and instances of it
+within code `abfd'.  All operations on the target object file are
+applied as methods to the BFD.  The mapping is defined within `bfd.h'
+in a set of macros, all beginning with `bfd_' to reduce namespace
+pollution.
+
+   For example, this sequence does what you would probably expect:
+return the number of sections in an object file attached to a BFD
+`abfd'.
+
+     #include "bfd.h"
+
+     unsigned int number_of_sections (abfd)
+     bfd *abfd;
+     {
+       return bfd_count_sections (abfd);
+     }
+
+   The abstraction used within BFD is that an object file has:
+
+   * a header,
+
+   * a number of sections containing raw data (*note Sections::),
+
+   * a set of relocations (*note Relocations::), and
+
+   * some symbol information (*note Symbols::).
+   Also, BFDs opened for archives have the additional attribute of an
+index and contain subordinate BFDs. This approach is fine for a.out and
+coff, but loses efficiency when applied to formats such as S-records and
+IEEE-695.
+
+
+File: bfd.info,  Node: What BFD Version 2 Can Do,  Prev: How It Works,  Up: Overview
+
+1.3 What BFD Version 2 Can Do
+=============================
+
+When an object file is opened, BFD subroutines automatically determine
+the format of the input object file.  They then build a descriptor in
+memory with pointers to routines that will be used to access elements of
+the object file's data structures.
+
+   As different information from the object files is required, BFD
+reads from different sections of the file and processes them.  For
+example, a very common operation for the linker is processing symbol
+tables.  Each BFD back end provides a routine for converting between
+the object file's representation of symbols and an internal canonical
+format. When the linker asks for the symbol table of an object file, it
+calls through a memory pointer to the routine from the relevant BFD
+back end which reads and converts the table into a canonical form.  The
+linker then operates upon the canonical form. When the link is finished
+and the linker writes the output file's symbol table, another BFD back
+end routine is called to take the newly created symbol table and
+convert it into the chosen output format.
+
+* Menu:
+
+* BFD information loss::	Information Loss
+* Canonical format::		The BFD	canonical object-file format
+
+
+File: bfd.info,  Node: BFD information loss,  Next: Canonical format,  Up: What BFD Version 2 Can Do
+
+1.3.1 Information Loss
+----------------------
+
+_Information can be lost during output._ The output formats supported
+by BFD do not provide identical facilities, and information which can
+be described in one form has nowhere to go in another format. One
+example of this is alignment information in `b.out'. There is nowhere
+in an `a.out' format file to store alignment information on the
+contained data, so when a file is linked from `b.out' and an `a.out'
+image is produced, alignment information will not propagate to the
+output file. (The linker will still use the alignment information
+internally, so the link is performed correctly).
+
+   Another example is COFF section names. COFF files may contain an
+unlimited number of sections, each one with a textual section name. If
+the target of the link is a format which does not have many sections
+(e.g., `a.out') or has sections without names (e.g., the Oasys format),
+the link cannot be done simply. You can circumvent this problem by
+describing the desired input-to-output section mapping with the linker
+command language.
+
+   _Information can be lost during canonicalization._ The BFD internal
+canonical form of the external formats is not exhaustive; there are
+structures in input formats for which there is no direct representation
+internally.  This means that the BFD back ends cannot maintain all
+possible data richness through the transformation between external to
+internal and back to external formats.
+
+   This limitation is only a problem when an application reads one
+format and writes another.  Each BFD back end is responsible for
+maintaining as much data as possible, and the internal BFD canonical
+form has structures which are opaque to the BFD core, and exported only
+to the back ends. When a file is read in one format, the canonical form
+is generated for BFD and the application. At the same time, the back
+end saves away any information which may otherwise be lost. If the data
+is then written back in the same format, the back end routine will be
+able to use the canonical form provided by the BFD core as well as the
+information it prepared earlier.  Since there is a great deal of
+commonality between back ends, there is no information lost when
+linking or copying big endian COFF to little endian COFF, or `a.out' to
+`b.out'.  When a mixture of formats is linked, the information is only
+lost from the files whose format differs from the destination.
+
+
+File: bfd.info,  Node: Canonical format,  Prev: BFD information loss,  Up: What BFD Version 2 Can Do
+
+1.3.2 The BFD canonical object-file format
+------------------------------------------
+
+The greatest potential for loss of information occurs when there is the
+least overlap between the information provided by the source format,
+that stored by the canonical format, and that needed by the destination
+format. A brief description of the canonical form may help you
+understand which kinds of data you can count on preserving across
+conversions.  
+
+_files_
+     Information stored on a per-file basis includes target machine
+     architecture, particular implementation format type, a demand
+     pageable bit, and a write protected bit.  Information like Unix
+     magic numbers is not stored here--only the magic numbers' meaning,
+     so a `ZMAGIC' file would have both the demand pageable bit and the
+     write protected text bit set.  The byte order of the target is
+     stored on a per-file basis, so that big- and little-endian object
+     files may be used with one another.
+
+_sections_
+     Each section in the input file contains the name of the section,
+     the section's original address in the object file, size and
+     alignment information, various flags, and pointers into other BFD
+     data structures.
+
+_symbols_
+     Each symbol contains a pointer to the information for the object
+     file which originally defined it, its name, its value, and various
+     flag bits.  When a BFD back end reads in a symbol table, it
+     relocates all symbols to make them relative to the base of the
+     section where they were defined.  Doing this ensures that each
+     symbol points to its containing section.  Each symbol also has a
+     varying amount of hidden private data for the BFD back end.  Since
+     the symbol points to the original file, the private data format
+     for that symbol is accessible.  `ld' can operate on a collection
+     of symbols of wildly different formats without problems.
+
+     Normal global and simple local symbols are maintained on output,
+     so an output file (no matter its format) will retain symbols
+     pointing to functions and to global, static, and common variables.
+     Some symbol information is not worth retaining; in `a.out', type
+     information is stored in the symbol table as long symbol names.
+     This information would be useless to most COFF debuggers; the
+     linker has command line switches to allow users to throw it away.
+
+     There is one word of type information within the symbol, so if the
+     format supports symbol type information within symbols (for
+     example, COFF, IEEE, Oasys) and the type is simple enough to fit
+     within one word (nearly everything but aggregates), the
+     information will be preserved.
+
+_relocation level_
+     Each canonical BFD relocation record contains a pointer to the
+     symbol to relocate to, the offset of the data to relocate, the
+     section the data is in, and a pointer to a relocation type
+     descriptor. Relocation is performed by passing messages through
+     the relocation type descriptor and the symbol pointer. Therefore,
+     relocations can be performed on output data using a relocation
+     method that is only available in one of the input formats. For
+     instance, Oasys provides a byte relocation format.  A relocation
+     record requesting this relocation type would point indirectly to a
+     routine to perform this, so the relocation may be performed on a
+     byte being written to a 68k COFF file, even though 68k COFF has no
+     such relocation type.
+
+_line numbers_
+     Object formats can contain, for debugging purposes, some form of
+     mapping between symbols, source line numbers, and addresses in the
+     output file.  These addresses have to be relocated along with the
+     symbol information.  Each symbol with an associated list of line
+     number records points to the first record of the list.  The head
+     of a line number list consists of a pointer to the symbol, which
+     allows finding out the address of the function whose line number
+     is being described. The rest of the list is made up of pairs:
+     offsets into the section and line numbers. Any format which can
+     simply derive this information can pass it successfully between
+     formats (COFF, IEEE and Oasys).
+
+
+File: bfd.info,  Node: BFD front end,  Next: BFD back ends,  Prev: Overview,  Up: Top
+
+2 BFD Front End
+***************
+
+2.1 `typedef bfd'
+=================
+
+A BFD has type `bfd'; objects of this type are the cornerstone of any
+application using BFD. Using BFD consists of making references though
+the BFD and to data in the BFD.
+
+   Here is the structure that defines the type `bfd'.  It contains the
+major data about the file and pointers to the rest of the data.
+
+
+     struct bfd
+     {
+       /* A unique identifier of the BFD  */
+       unsigned int id;
+
+       /* The filename the application opened the BFD with.  */
+       const char *filename;
+
+       /* A pointer to the target jump table.  */
+       const struct bfd_target *xvec;
+
+       /* The IOSTREAM, and corresponding IO vector that provide access
+          to the file backing the BFD.  */
+       void *iostream;
+       const struct bfd_iovec *iovec;
+
+       /* Is the file descriptor being cached?  That is, can it be closed as
+          needed, and re-opened when accessed later?  */
+       bfd_boolean cacheable;
+
+       /* Marks whether there was a default target specified when the
+          BFD was opened. This is used to select which matching algorithm
+          to use to choose the back end.  */
+       bfd_boolean target_defaulted;
+
+       /* The caching routines use these to maintain a
+          least-recently-used list of BFDs.  */
+       struct bfd *lru_prev, *lru_next;
+
+       /* When a file is closed by the caching routines, BFD retains
+          state information on the file here...  */
+       ufile_ptr where;
+
+       /* ... and here: (``once'' means at least once).  */
+       bfd_boolean opened_once;
+
+       /* Set if we have a locally maintained mtime value, rather than
+          getting it from the file each time.  */
+       bfd_boolean mtime_set;
+
+       /* File modified time, if mtime_set is TRUE.  */
+       long mtime;
+
+       /* Reserved for an unimplemented file locking extension.  */
+       int ifd;
+
+       /* The format which belongs to the BFD. (object, core, etc.)  */
+       bfd_format format;
+
+       /* The direction with which the BFD was opened.  */
+       enum bfd_direction
+         {
+           no_direction = 0,
+           read_direction = 1,
+           write_direction = 2,
+           both_direction = 3
+         }
+       direction;
+
+       /* Format_specific flags.  */
+       flagword flags;
+
+       /* Currently my_archive is tested before adding origin to
+          anything. I believe that this can become always an add of
+          origin, with origin set to 0 for non archive files.  */
+       ufile_ptr origin;
+
+       /* Remember when output has begun, to stop strange things
+          from happening.  */
+       bfd_boolean output_has_begun;
+
+       /* A hash table for section names.  */
+       struct bfd_hash_table section_htab;
+
+       /* Pointer to linked list of sections.  */
+       struct bfd_section *sections;
+
+       /* The last section on the section list.  */
+       struct bfd_section *section_last;
+
+       /* The number of sections.  */
+       unsigned int section_count;
+
+       /* Stuff only useful for object files:
+          The start address.  */
+       bfd_vma start_address;
+
+       /* Used for input and output.  */
+       unsigned int symcount;
+
+       /* Symbol table for output BFD (with symcount entries).  */
+       struct bfd_symbol  **outsymbols;
+
+       /* Used for slurped dynamic symbol tables.  */
+       unsigned int dynsymcount;
+
+       /* Pointer to structure which contains architecture information.  */
+       const struct bfd_arch_info *arch_info;
+
+       /* Flag set if symbols from this BFD should not be exported.  */
+       bfd_boolean no_export;
+
+       /* Stuff only useful for archives.  */
+       void *arelt_data;
+       struct bfd *my_archive;      /* The containing archive BFD.  */
+       struct bfd *next;            /* The next BFD in the archive.  */
+       struct bfd *archive_head;    /* The first BFD in the archive.  */
+       bfd_boolean has_armap;
+
+       /* A chain of BFD structures involved in a link.  */
+       struct bfd *link_next;
+
+       /* A field used by _bfd_generic_link_add_archive_symbols.  This will
+          be used only for archive elements.  */
+       int archive_pass;
+
+       /* Used by the back end to hold private data.  */
+       union
+         {
+           struct aout_data_struct *aout_data;
+           struct artdata *aout_ar_data;
+           struct _oasys_data *oasys_obj_data;
+           struct _oasys_ar_data *oasys_ar_data;
+           struct coff_tdata *coff_obj_data;
+           struct pe_tdata *pe_obj_data;
+           struct xcoff_tdata *xcoff_obj_data;
+           struct ecoff_tdata *ecoff_obj_data;
+           struct ieee_data_struct *ieee_data;
+           struct ieee_ar_data_struct *ieee_ar_data;
+           struct srec_data_struct *srec_data;
+           struct ihex_data_struct *ihex_data;
+           struct tekhex_data_struct *tekhex_data;
+           struct elf_obj_tdata *elf_obj_data;
+           struct nlm_obj_tdata *nlm_obj_data;
+           struct bout_data_struct *bout_data;
+           struct mmo_data_struct *mmo_data;
+           struct sun_core_struct *sun_core_data;
+           struct sco5_core_struct *sco5_core_data;
+           struct trad_core_struct *trad_core_data;
+           struct som_data_struct *som_data;
+           struct hpux_core_struct *hpux_core_data;
+           struct hppabsd_core_struct *hppabsd_core_data;
+           struct sgi_core_struct *sgi_core_data;
+           struct lynx_core_struct *lynx_core_data;
+           struct osf_core_struct *osf_core_data;
+           struct cisco_core_struct *cisco_core_data;
+           struct versados_data_struct *versados_data;
+           struct netbsd_core_struct *netbsd_core_data;
+           struct mach_o_data_struct *mach_o_data;
+           struct mach_o_fat_data_struct *mach_o_fat_data;
+           struct bfd_pef_data_struct *pef_data;
+           struct bfd_pef_xlib_data_struct *pef_xlib_data;
+           struct bfd_sym_data_struct *sym_data;
+           void *any;
+         }
+       tdata;
+
+       /* Used by the application to hold private data.  */
+       void *usrdata;
+
+       /* Where all the allocated stuff under this BFD goes.  This is a
+          struct objalloc *, but we use void * to avoid requiring the inclusion
+          of objalloc.h.  */
+       void *memory;
+     };
+
+2.2 Error reporting
+===================
+
+Most BFD functions return nonzero on success (check their individual
+documentation for precise semantics).  On an error, they call
+`bfd_set_error' to set an error condition that callers can check by
+calling `bfd_get_error'.  If that returns `bfd_error_system_call', then
+check `errno'.
+
+   The easiest way to report a BFD error to the user is to use
+`bfd_perror'.
+
+2.2.1 Type `bfd_error_type'
+---------------------------
+
+The values returned by `bfd_get_error' are defined by the enumerated
+type `bfd_error_type'.
+
+
+     typedef enum bfd_error
+     {
+       bfd_error_no_error = 0,
+       bfd_error_system_call,
+       bfd_error_invalid_target,
+       bfd_error_wrong_format,
+       bfd_error_wrong_object_format,
+       bfd_error_invalid_operation,
+       bfd_error_no_memory,
+       bfd_error_no_symbols,
+       bfd_error_no_armap,
+       bfd_error_no_more_archived_files,
+       bfd_error_malformed_archive,
+       bfd_error_file_not_recognized,
+       bfd_error_file_ambiguously_recognized,
+       bfd_error_no_contents,
+       bfd_error_nonrepresentable_section,
+       bfd_error_no_debug_section,
+       bfd_error_bad_value,
+       bfd_error_file_truncated,
+       bfd_error_file_too_big,
+       bfd_error_invalid_error_code
+     }
+     bfd_error_type;
+   
+2.2.1.1 `bfd_get_error'
+.......................
+
+*Synopsis*
+     bfd_error_type bfd_get_error (void);
+   *Description*
+Return the current BFD error condition.
+
+2.2.1.2 `bfd_set_error'
+.......................
+
+*Synopsis*
+     void bfd_set_error (bfd_error_type error_tag);
+   *Description*
+Set the BFD error condition to be ERROR_TAG.
+
+2.2.1.3 `bfd_errmsg'
+....................
+
+*Synopsis*
+     const char *bfd_errmsg (bfd_error_type error_tag);
+   *Description*
+Return a string describing the error ERROR_TAG, or the system error if
+ERROR_TAG is `bfd_error_system_call'.
+
+2.2.1.4 `bfd_perror'
+....................
+
+*Synopsis*
+     void bfd_perror (const char *message);
+   *Description*
+Print to the standard error stream a string describing the last BFD
+error that occurred, or the last system error if the last BFD error was
+a system call failure.  If MESSAGE is non-NULL and non-empty, the error
+string printed is preceded by MESSAGE, a colon, and a space.  It is
+followed by a newline.
+
+2.2.2 BFD error handler
+-----------------------
+
+Some BFD functions want to print messages describing the problem.  They
+call a BFD error handler function.  This function may be overridden by
+the program.
+
+   The BFD error handler acts like printf.
+
+
+     typedef void (*bfd_error_handler_type) (const char *, ...);
+   
+2.2.2.1 `bfd_set_error_handler'
+...............................
+
+*Synopsis*
+     bfd_error_handler_type bfd_set_error_handler (bfd_error_handler_type);
+   *Description*
+Set the BFD error handler function.  Returns the previous function.
+
+2.2.2.2 `bfd_set_error_program_name'
+....................................
+
+*Synopsis*
+     void bfd_set_error_program_name (const char *);
+   *Description*
+Set the program name to use when printing a BFD error.  This is printed
+before the error message followed by a colon and space.  The string
+must not be changed after it is passed to this function.
+
+2.2.2.3 `bfd_get_error_handler'
+...............................
+
+*Synopsis*
+     bfd_error_handler_type bfd_get_error_handler (void);
+   *Description*
+Return the BFD error handler function.
+
+2.3 Miscellaneous
+=================
+
+2.3.1 Miscellaneous functions
+-----------------------------
+
+2.3.1.1 `bfd_get_reloc_upper_bound'
+...................................
+
+*Synopsis*
+     long bfd_get_reloc_upper_bound (bfd *abfd, asection *sect);
+   *Description*
+Return the number of bytes required to store the relocation information
+associated with section SECT attached to bfd ABFD.  If an error occurs,
+return -1.
+
+2.3.1.2 `bfd_canonicalize_reloc'
+................................
+
+*Synopsis*
+     long bfd_canonicalize_reloc
+        (bfd *abfd, asection *sec, arelent **loc, asymbol **syms);
+   *Description*
+Call the back end associated with the open BFD ABFD and translate the
+external form of the relocation information attached to SEC into the
+internal canonical form.  Place the table into memory at LOC, which has
+been preallocated, usually by a call to `bfd_get_reloc_upper_bound'.
+Returns the number of relocs, or -1 on error.
+
+   The SYMS table is also needed for horrible internal magic reasons.
+
+2.3.1.3 `bfd_set_reloc'
+.......................
+
+*Synopsis*
+     void bfd_set_reloc
+        (bfd *abfd, asection *sec, arelent **rel, unsigned int count);
+   *Description*
+Set the relocation pointer and count within section SEC to the values
+REL and COUNT.  The argument ABFD is ignored.
+
+2.3.1.4 `bfd_set_file_flags'
+............................
+
+*Synopsis*
+     bfd_boolean bfd_set_file_flags (bfd *abfd, flagword flags);
+   *Description*
+Set the flag word in the BFD ABFD to the value FLAGS.
+
+   Possible errors are:
+   * `bfd_error_wrong_format' - The target bfd was not of object format.
+
+   * `bfd_error_invalid_operation' - The target bfd was open for
+     reading.
+
+   * `bfd_error_invalid_operation' - The flag word contained a bit
+     which was not applicable to the type of file.  E.g., an attempt
+     was made to set the `D_PAGED' bit on a BFD format which does not
+     support demand paging.
+
+2.3.1.5 `bfd_get_arch_size'
+...........................
+
+*Synopsis*
+     int bfd_get_arch_size (bfd *abfd);
+   *Description*
+Returns the architecture address size, in bits, as determined by the
+object file's format.  For ELF, this information is included in the
+header.
+
+   *Returns*
+Returns the arch size in bits if known, `-1' otherwise.
+
+2.3.1.6 `bfd_get_sign_extend_vma'
+.................................
+
+*Synopsis*
+     int bfd_get_sign_extend_vma (bfd *abfd);
+   *Description*
+Indicates if the target architecture "naturally" sign extends an
+address.  Some architectures implicitly sign extend address values when
+they are converted to types larger than the size of an address.  For
+instance, bfd_get_start_address() will return an address sign extended
+to fill a bfd_vma when this is the case.
+
+   *Returns*
+Returns `1' if the target architecture is known to sign extend
+addresses, `0' if the target architecture is known to not sign extend
+addresses, and `-1' otherwise.
+
+2.3.1.7 `bfd_set_start_address'
+...............................
+
+*Synopsis*
+     bfd_boolean bfd_set_start_address (bfd *abfd, bfd_vma vma);
+   *Description*
+Make VMA the entry point of output BFD ABFD.
+
+   *Returns*
+Returns `TRUE' on success, `FALSE' otherwise.
+
+2.3.1.8 `bfd_get_gp_size'
+.........................
+
+*Synopsis*
+     unsigned int bfd_get_gp_size (bfd *abfd);
+   *Description*
+Return the maximum size of objects to be optimized using the GP
+register under MIPS ECOFF.  This is typically set by the `-G' argument
+to the compiler, assembler or linker.
+
+2.3.1.9 `bfd_set_gp_size'
+.........................
+
+*Synopsis*
+     void bfd_set_gp_size (bfd *abfd, unsigned int i);
+   *Description*
+Set the maximum size of objects to be optimized using the GP register
+under ECOFF or MIPS ELF.  This is typically set by the `-G' argument to
+the compiler, assembler or linker.
+
+2.3.1.10 `bfd_scan_vma'
+.......................
+
+*Synopsis*
+     bfd_vma bfd_scan_vma (const char *string, const char **end, int base);
+   *Description*
+Convert, like `strtoul', a numerical expression STRING into a `bfd_vma'
+integer, and return that integer.  (Though without as many bells and
+whistles as `strtoul'.)  The expression is assumed to be unsigned
+(i.e., positive).  If given a BASE, it is used as the base for
+conversion.  A base of 0 causes the function to interpret the string in
+hex if a leading "0x" or "0X" is found, otherwise in octal if a leading
+zero is found, otherwise in decimal.
+
+   If the value would overflow, the maximum `bfd_vma' value is returned.
+
+2.3.1.11 `bfd_copy_private_header_data'
+.......................................
+
+*Synopsis*
+     bfd_boolean bfd_copy_private_header_data (bfd *ibfd, bfd *obfd);
+   *Description*
+Copy private BFD header information from the BFD IBFD to the the BFD
+OBFD.  This copies information that may require sections to exist, but
+does not require symbol tables.  Return `true' on success, `false' on
+error.  Possible error returns are:
+
+   * `bfd_error_no_memory' - Not enough memory exists to create private
+     data for OBFD.
+
+     #define bfd_copy_private_header_data(ibfd, obfd) \
+          BFD_SEND (obfd, _bfd_copy_private_header_data, \
+                    (ibfd, obfd))
+
+2.3.1.12 `bfd_copy_private_bfd_data'
+....................................
+
+*Synopsis*
+     bfd_boolean bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd);
+   *Description*
+Copy private BFD information from the BFD IBFD to the the BFD OBFD.
+Return `TRUE' on success, `FALSE' on error.  Possible error returns are:
+
+   * `bfd_error_no_memory' - Not enough memory exists to create private
+     data for OBFD.
+
+     #define bfd_copy_private_bfd_data(ibfd, obfd) \
+          BFD_SEND (obfd, _bfd_copy_private_bfd_data, \
+                    (ibfd, obfd))
+
+2.3.1.13 `bfd_merge_private_bfd_data'
+.....................................
+
+*Synopsis*
+     bfd_boolean bfd_merge_private_bfd_data (bfd *ibfd, bfd *obfd);
+   *Description*
+Merge private BFD information from the BFD IBFD to the the output file
+BFD OBFD when linking.  Return `TRUE' on success, `FALSE' on error.
+Possible error returns are:
+
+   * `bfd_error_no_memory' - Not enough memory exists to create private
+     data for OBFD.
+
+     #define bfd_merge_private_bfd_data(ibfd, obfd) \
+          BFD_SEND (obfd, _bfd_merge_private_bfd_data, \
+                    (ibfd, obfd))
+
+2.3.1.14 `bfd_set_private_flags'
+................................
+
+*Synopsis*
+     bfd_boolean bfd_set_private_flags (bfd *abfd, flagword flags);
+   *Description*
+Set private BFD flag information in the BFD ABFD.  Return `TRUE' on
+success, `FALSE' on error.  Possible error returns are:
+
+   * `bfd_error_no_memory' - Not enough memory exists to create private
+     data for OBFD.
+
+     #define bfd_set_private_flags(abfd, flags) \
+          BFD_SEND (abfd, _bfd_set_private_flags, (abfd, flags))
+
+2.3.1.15 `Other functions'
+..........................
+
+*Description*
+The following functions exist but have not yet been documented.
+     #define bfd_sizeof_headers(abfd, reloc) \
+            BFD_SEND (abfd, _bfd_sizeof_headers, (abfd, reloc))
+
+     #define bfd_find_nearest_line(abfd, sec, syms, off, file, func, line) \
+            BFD_SEND (abfd, _bfd_find_nearest_line, \
+                      (abfd, sec, syms, off, file, func, line))
+
+     #define bfd_find_line(abfd, syms, sym, file, line) \
+            BFD_SEND (abfd, _bfd_find_line, \
+                      (abfd, syms, sym, file, line))
+
+     #define bfd_find_inliner_info(abfd, file, func, line) \
+            BFD_SEND (abfd, _bfd_find_inliner_info, \
+                      (abfd, file, func, line))
+
+     #define bfd_debug_info_start(abfd) \
+            BFD_SEND (abfd, _bfd_debug_info_start, (abfd))
+
+     #define bfd_debug_info_end(abfd) \
+            BFD_SEND (abfd, _bfd_debug_info_end, (abfd))
+
+     #define bfd_debug_info_accumulate(abfd, section) \
+            BFD_SEND (abfd, _bfd_debug_info_accumulate, (abfd, section))
+
+     #define bfd_stat_arch_elt(abfd, stat) \
+            BFD_SEND (abfd, _bfd_stat_arch_elt,(abfd, stat))
+
+     #define bfd_update_armap_timestamp(abfd) \
+            BFD_SEND (abfd, _bfd_update_armap_timestamp, (abfd))
+
+     #define bfd_set_arch_mach(abfd, arch, mach)\
+            BFD_SEND ( abfd, _bfd_set_arch_mach, (abfd, arch, mach))
+
+     #define bfd_relax_section(abfd, section, link_info, again) \
+            BFD_SEND (abfd, _bfd_relax_section, (abfd, section, link_info, again))
+
+     #define bfd_gc_sections(abfd, link_info) \
+            BFD_SEND (abfd, _bfd_gc_sections, (abfd, link_info))
+
+     #define bfd_merge_sections(abfd, link_info) \
+            BFD_SEND (abfd, _bfd_merge_sections, (abfd, link_info))
+
+     #define bfd_is_group_section(abfd, sec) \
+            BFD_SEND (abfd, _bfd_is_group_section, (abfd, sec))
+
+     #define bfd_discard_group(abfd, sec) \
+            BFD_SEND (abfd, _bfd_discard_group, (abfd, sec))
+
+     #define bfd_link_hash_table_create(abfd) \
+            BFD_SEND (abfd, _bfd_link_hash_table_create, (abfd))
+
+     #define bfd_link_hash_table_free(abfd, hash) \
+            BFD_SEND (abfd, _bfd_link_hash_table_free, (hash))
+
+     #define bfd_link_add_symbols(abfd, info) \
+            BFD_SEND (abfd, _bfd_link_add_symbols, (abfd, info))
+
+     #define bfd_link_just_syms(abfd, sec, info) \
+            BFD_SEND (abfd, _bfd_link_just_syms, (sec, info))
+
+     #define bfd_final_link(abfd, info) \
+            BFD_SEND (abfd, _bfd_final_link, (abfd, info))
+
+     #define bfd_free_cached_info(abfd) \
+            BFD_SEND (abfd, _bfd_free_cached_info, (abfd))
+
+     #define bfd_get_dynamic_symtab_upper_bound(abfd) \
+            BFD_SEND (abfd, _bfd_get_dynamic_symtab_upper_bound, (abfd))
+
+     #define bfd_print_private_bfd_data(abfd, file)\
+            BFD_SEND (abfd, _bfd_print_private_bfd_data, (abfd, file))
+
+     #define bfd_canonicalize_dynamic_symtab(abfd, asymbols) \
+            BFD_SEND (abfd, _bfd_canonicalize_dynamic_symtab, (abfd, asymbols))
+
+     #define bfd_get_synthetic_symtab(abfd, count, syms, dyncount, dynsyms, ret) \
+            BFD_SEND (abfd, _bfd_get_synthetic_symtab, (abfd, count, syms, \
+                                                        dyncount, dynsyms, ret))
+
+     #define bfd_get_dynamic_reloc_upper_bound(abfd) \
+            BFD_SEND (abfd, _bfd_get_dynamic_reloc_upper_bound, (abfd))
+
+     #define bfd_canonicalize_dynamic_reloc(abfd, arels, asyms) \
+            BFD_SEND (abfd, _bfd_canonicalize_dynamic_reloc, (abfd, arels, asyms))
+
+     extern bfd_byte *bfd_get_relocated_section_contents
+       (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
+        bfd_boolean, asymbol **);
+
+2.3.1.16 `bfd_alt_mach_code'
+............................
+
+*Synopsis*
+     bfd_boolean bfd_alt_mach_code (bfd *abfd, int alternative);
+   *Description*
+When more than one machine code number is available for the same
+machine type, this function can be used to switch between the preferred
+one (alternative == 0) and any others.  Currently, only ELF supports
+this feature, with up to two alternate machine codes.
+
+     struct bfd_preserve
+     {
+       void *marker;
+       void *tdata;
+       flagword flags;
+       const struct bfd_arch_info *arch_info;
+       struct bfd_section *sections;
+       struct bfd_section *section_last;
+       unsigned int section_count;
+       struct bfd_hash_table section_htab;
+     };
+   
+2.3.1.17 `bfd_preserve_save'
+............................
+
+*Synopsis*
+     bfd_boolean bfd_preserve_save (bfd *, struct bfd_preserve *);
+   *Description*
+When testing an object for compatibility with a particular target
+back-end, the back-end object_p function needs to set up certain fields
+in the bfd on successfully recognizing the object.  This typically
+happens in a piecemeal fashion, with failures possible at many points.
+On failure, the bfd is supposed to be restored to its initial state,
+which is virtually impossible.  However, restoring a subset of the bfd
+state works in practice.  This function stores the subset and
+reinitializes the bfd.
+
+2.3.1.18 `bfd_preserve_restore'
+...............................
+
+*Synopsis*
+     void bfd_preserve_restore (bfd *, struct bfd_preserve *);
+   *Description*
+This function restores bfd state saved by bfd_preserve_save.  If MARKER
+is non-NULL in struct bfd_preserve then that block and all subsequently
+bfd_alloc'd memory is freed.
+
+2.3.1.19 `bfd_preserve_finish'
+..............................
+
+*Synopsis*
+     void bfd_preserve_finish (bfd *, struct bfd_preserve *);
+   *Description*
+This function should be called when the bfd state saved by
+bfd_preserve_save is no longer needed.  ie. when the back-end object_p
+function returns with success.
+
+2.3.1.20 `bfd_hide_symbol'
+..........................
+
+*Synopsis*
+     void bfd_hide_symbol (bfd *,
+         struct bfd_link_info *,
+         struct bfd_link_hash_entry *,
+         bfd_boolean);
+   *Description*
+This function hides a symbol so that it won't be exported.
+
+2.3.1.21 `struct bfd_iovec'
+...........................
+
+*Description*
+The `struct bfd_iovec' contains the internal file I/O class.  Each
+`BFD' has an instance of this class and all file I/O is routed through
+it (it is assumed that the instance implements all methods listed
+below).
+     struct bfd_iovec
+     {
+       /* To avoid problems with macros, a "b" rather than "f"
+          prefix is prepended to each method name.  */
+       /* Attempt to read/write NBYTES on ABFD's IOSTREAM storing/fetching
+          bytes starting at PTR.  Return the number of bytes actually
+          transfered (a read past end-of-file returns less than NBYTES),
+          or -1 (setting `bfd_error') if an error occurs.  */
+       file_ptr (*bread) (struct bfd *abfd, void *ptr, file_ptr nbytes);
+       file_ptr (*bwrite) (struct bfd *abfd, const void *ptr,
+                           file_ptr nbytes);
+       /* Return the current IOSTREAM file offset, or -1 (setting `bfd_error'
+          if an error occurs.  */
+       file_ptr (*btell) (struct bfd *abfd);
+       /* For the following, on successful completion a value of 0 is returned.
+          Otherwise, a value of -1 is returned (and  `bfd_error' is set).  */
+       int (*bseek) (struct bfd *abfd, file_ptr offset, int whence);
+       int (*bclose) (struct bfd *abfd);
+       int (*bflush) (struct bfd *abfd);
+       int (*bstat) (struct bfd *abfd, struct stat *sb);
+     };
+
+2.3.1.22 `bfd_get_mtime'
+........................
+
+*Synopsis*
+     long bfd_get_mtime (bfd *abfd);
+   *Description*
+Return the file modification time (as read from the file system, or
+from the archive header for archive members).
+
+2.3.1.23 `bfd_get_size'
+.......................
+
+*Synopsis*
+     long bfd_get_size (bfd *abfd);
+   *Description*
+Return the file size (as read from file system) for the file associated
+with BFD ABFD.
+
+   The initial motivation for, and use of, this routine is not so we
+can get the exact size of the object the BFD applies to, since that
+might not be generally possible (archive members for example).  It
+would be ideal if someone could eventually modify it so that such
+results were guaranteed.
+
+   Instead, we want to ask questions like "is this NNN byte sized
+object I'm about to try read from file offset YYY reasonable?"  As as
+example of where we might do this, some object formats use string
+tables for which the first `sizeof (long)' bytes of the table contain
+the size of the table itself, including the size bytes.  If an
+application tries to read what it thinks is one of these string tables,
+without some way to validate the size, and for some reason the size is
+wrong (byte swapping error, wrong location for the string table, etc.),
+the only clue is likely to be a read error when it tries to read the
+table, or a "virtual memory exhausted" error when it tries to allocate
+15 bazillon bytes of space for the 15 bazillon byte table it is about
+to read.  This function at least allows us to answer the question, "is
+the size reasonable?".
+
+* Menu:
+
+* Memory Usage::
+* Initialization::
+* Sections::
+* Symbols::
+* Archives::
+* Formats::
+* Relocations::
+* Core Files::
+* Targets::
+* Architectures::
+* Opening and Closing::
+* Internal::
+* File Caching::
+* Linker Functions::
+* Hash Tables::
+
+
+File: bfd.info,  Node: Memory Usage,  Next: Initialization,  Prev: BFD front end,  Up: BFD front end
+
+2.4 Memory Usage
+================
+
+BFD keeps all of its internal structures in obstacks. There is one
+obstack per open BFD file, into which the current state is stored. When
+a BFD is closed, the obstack is deleted, and so everything which has
+been allocated by BFD for the closing file is thrown away.
+
+   BFD does not free anything created by an application, but pointers
+into `bfd' structures become invalid on a `bfd_close'; for example,
+after a `bfd_close' the vector passed to `bfd_canonicalize_symtab' is
+still around, since it has been allocated by the application, but the
+data that it pointed to are lost.
+
+   The general rule is to not close a BFD until all operations dependent
+upon data from the BFD have been completed, or all the data from within
+the file has been copied. To help with the management of memory, there
+is a function (`bfd_alloc_size') which returns the number of bytes in
+obstacks associated with the supplied BFD. This could be used to select
+the greediest open BFD, close it to reclaim the memory, perform some
+operation and reopen the BFD again, to get a fresh copy of the data
+structures.
+
+
+File: bfd.info,  Node: Initialization,  Next: Sections,  Prev: Memory Usage,  Up: BFD front end
+
+2.5 Initialization
+==================
+
+2.5.1 Initialization functions
+------------------------------
+
+These are the functions that handle initializing a BFD.
+
+2.5.1.1 `bfd_init'
+..................
+
+*Synopsis*
+     void bfd_init (void);
+   *Description*
+This routine must be called before any other BFD function to initialize
+magical internal data structures.
+
+
+File: bfd.info,  Node: Sections,  Next: Symbols,  Prev: Initialization,  Up: BFD front end
+
+2.6 Sections
+============
+
+The raw data contained within a BFD is maintained through the section
+abstraction.  A single BFD may have any number of sections.  It keeps
+hold of them by pointing to the first; each one points to the next in
+the list.
+
+   Sections are supported in BFD in `section.c'.
+
+* Menu:
+
+* Section Input::
+* Section Output::
+* typedef asection::
+* section prototypes::
+
+
+File: bfd.info,  Node: Section Input,  Next: Section Output,  Prev: Sections,  Up: Sections
+
+2.6.1 Section input
+-------------------
+
+When a BFD is opened for reading, the section structures are created
+and attached to the BFD.
+
+   Each section has a name which describes the section in the outside
+world--for example, `a.out' would contain at least three sections,
+called `.text', `.data' and `.bss'.
+
+   Names need not be unique; for example a COFF file may have several
+sections named `.data'.
+
+   Sometimes a BFD will contain more than the "natural" number of
+sections. A back end may attach other sections containing constructor
+data, or an application may add a section (using `bfd_make_section') to
+the sections attached to an already open BFD. For example, the linker
+creates an extra section `COMMON' for each input file's BFD to hold
+information about common storage.
+
+   The raw data is not necessarily read in when the section descriptor
+is created. Some targets may leave the data in place until a
+`bfd_get_section_contents' call is made. Other back ends may read in
+all the data at once.  For example, an S-record file has to be read
+once to determine the size of the data. An IEEE-695 file doesn't
+contain raw data in sections, but data and relocation expressions
+intermixed, so the data area has to be parsed to get out the data and
+relocations.
+
+
+File: bfd.info,  Node: Section Output,  Next: typedef asection,  Prev: Section Input,  Up: Sections
+
+2.6.2 Section output
+--------------------
+
+To write a new object style BFD, the various sections to be written
+have to be created. They are attached to the BFD in the same way as
+input sections; data is written to the sections using
+`bfd_set_section_contents'.
+
+   Any program that creates or combines sections (e.g., the assembler
+and linker) must use the `asection' fields `output_section' and
+`output_offset' to indicate the file sections to which each section
+must be written.  (If the section is being created from scratch,
+`output_section' should probably point to the section itself and
+`output_offset' should probably be zero.)
+
+   The data to be written comes from input sections attached (via
+`output_section' pointers) to the output sections.  The output section
+structure can be considered a filter for the input section: the output
+section determines the vma of the output data and the name, but the
+input section determines the offset into the output section of the data
+to be written.
+
+   E.g., to create a section "O", starting at 0x100, 0x123 long,
+containing two subsections, "A" at offset 0x0 (i.e., at vma 0x100) and
+"B" at offset 0x20 (i.e., at vma 0x120) the `asection' structures would
+look like:
+
+        section name          "A"
+          output_offset   0x00
+          size            0x20
+          output_section ----------->  section name    "O"
+                                  |    vma             0x100
+        section name          "B" |    size            0x123
+          output_offset   0x20    |
+          size            0x103   |
+          output_section  --------|
+
+2.6.3 Link orders
+-----------------
+
+The data within a section is stored in a "link_order".  These are much
+like the fixups in `gas'.  The link_order abstraction allows a section
+to grow and shrink within itself.
+
+   A link_order knows how big it is, and which is the next link_order
+and where the raw data for it is; it also points to a list of
+relocations which apply to it.
+
+   The link_order is used by the linker to perform relaxing on final
+code.  The compiler creates code which is as big as necessary to make
+it work without relaxing, and the user can select whether to relax.
+Sometimes relaxing takes a lot of time.  The linker runs around the
+relocations to see if any are attached to data which can be shrunk, if
+so it does it on a link_order by link_order basis.
+
+
+File: bfd.info,  Node: typedef asection,  Next: section prototypes,  Prev: Section Output,  Up: Sections
+
+2.6.4 typedef asection
+----------------------
+
+Here is the section structure:
+
+
+     typedef struct bfd_section
+     {
+       /* The name of the section; the name isn't a copy, the pointer is
+          the same as that passed to bfd_make_section.  */
+       const char *name;
+
+       /* A unique sequence number.  */
+       int id;
+
+       /* Which section in the bfd; 0..n-1 as sections are created in a bfd.  */
+       int index;
+
+       /* The next section in the list belonging to the BFD, or NULL.  */
+       struct bfd_section *next;
+
+       /* The previous section in the list belonging to the BFD, or NULL.  */
+       struct bfd_section *prev;
+
+       /* The field flags contains attributes of the section. Some
+          flags are read in from the object file, and some are
+          synthesized from other information.  */
+       flagword flags;
+
+     #define SEC_NO_FLAGS   0x000
+
+       /* Tells the OS to allocate space for this section when loading.
+          This is clear for a section containing debug information only.  */
+     #define SEC_ALLOC      0x001
+
+       /* Tells the OS to load the section from the file when loading.
+          This is clear for a .bss section.  */
+     #define SEC_LOAD       0x002
+
+       /* The section contains data still to be relocated, so there is
+          some relocation information too.  */
+     #define SEC_RELOC      0x004
+
+       /* A signal to the OS that the section contains read only data.  */
+     #define SEC_READONLY   0x008
+
+       /* The section contains code only.  */
+     #define SEC_CODE       0x010
+
+       /* The section contains data only.  */
+     #define SEC_DATA       0x020
+
+       /* The section will reside in ROM.  */
+     #define SEC_ROM        0x040
+
+       /* The section contains constructor information. This section
+          type is used by the linker to create lists of constructors and
+          destructors used by `g++'. When a back end sees a symbol
+          which should be used in a constructor list, it creates a new
+          section for the type of name (e.g., `__CTOR_LIST__'), attaches
+          the symbol to it, and builds a relocation. To build the lists
+          of constructors, all the linker has to do is catenate all the
+          sections called `__CTOR_LIST__' and relocate the data
+          contained within - exactly the operations it would peform on
+          standard data.  */
+     #define SEC_CONSTRUCTOR 0x080
+
+       /* The section has contents - a data section could be
+          `SEC_ALLOC' | `SEC_HAS_CONTENTS'; a debug section could be
+          `SEC_HAS_CONTENTS'  */
+     #define SEC_HAS_CONTENTS 0x100
+
+       /* An instruction to the linker to not output the section
+          even if it has information which would normally be written.  */
+     #define SEC_NEVER_LOAD 0x200
+
+       /* The section contains thread local data.  */
+     #define SEC_THREAD_LOCAL 0x400
+
+       /* The section has GOT references.  This flag is only for the
+          linker, and is currently only used by the elf32-hppa back end.
+          It will be set if global offset table references were detected
+          in this section, which indicate to the linker that the section
+          contains PIC code, and must be handled specially when doing a
+          static link.  */
+     #define SEC_HAS_GOT_REF 0x800
+
+       /* The section contains common symbols (symbols may be defined
+          multiple times, the value of a symbol is the amount of
+          space it requires, and the largest symbol value is the one
+          used).  Most targets have exactly one of these (which we
+          translate to bfd_com_section_ptr), but ECOFF has two.  */
+     #define SEC_IS_COMMON 0x1000
+
+       /* The section contains only debugging information.  For
+          example, this is set for ELF .debug and .stab sections.
+          strip tests this flag to see if a section can be
+          discarded.  */
+     #define SEC_DEBUGGING 0x2000
+
+       /* The contents of this section are held in memory pointed to
+          by the contents field.  This is checked by bfd_get_section_contents,
+          and the data is retrieved from memory if appropriate.  */
+     #define SEC_IN_MEMORY 0x4000
+
+       /* The contents of this section are to be excluded by the
+          linker for executable and shared objects unless those
+          objects are to be further relocated.  */
+     #define SEC_EXCLUDE 0x8000
+
+       /* The contents of this section are to be sorted based on the sum of
+          the symbol and addend values specified by the associated relocation
+          entries.  Entries without associated relocation entries will be
+          appended to the end of the section in an unspecified order.  */
+     #define SEC_SORT_ENTRIES 0x10000
+
+       /* When linking, duplicate sections of the same name should be
+          discarded, rather than being combined into a single section as
+          is usually done.  This is similar to how common symbols are
+          handled.  See SEC_LINK_DUPLICATES below.  */
+     #define SEC_LINK_ONCE 0x20000
+
+       /* If SEC_LINK_ONCE is set, this bitfield describes how the linker
+          should handle duplicate sections.  */
+     #define SEC_LINK_DUPLICATES 0x40000
+
+       /* This value for SEC_LINK_DUPLICATES means that duplicate
+          sections with the same name should simply be discarded.  */
+     #define SEC_LINK_DUPLICATES_DISCARD 0x0
+
+       /* This value for SEC_LINK_DUPLICATES means that the linker
+          should warn if there are any duplicate sections, although
+          it should still only link one copy.  */
+     #define SEC_LINK_DUPLICATES_ONE_ONLY 0x80000
+
+       /* This value for SEC_LINK_DUPLICATES means that the linker
+          should warn if any duplicate sections are a different size.  */
+     #define SEC_LINK_DUPLICATES_SAME_SIZE 0x100000
+
+       /* This value for SEC_LINK_DUPLICATES means that the linker
+          should warn if any duplicate sections contain different
+          contents.  */
+     #define SEC_LINK_DUPLICATES_SAME_CONTENTS \
+       (SEC_LINK_DUPLICATES_ONE_ONLY | SEC_LINK_DUPLICATES_SAME_SIZE)
+
+       /* This section was created by the linker as part of dynamic
+          relocation or other arcane processing.  It is skipped when
+          going through the first-pass output, trusting that someone
+          else up the line will take care of it later.  */
+     #define SEC_LINKER_CREATED 0x200000
+
+       /* This section should not be subject to garbage collection.  */
+     #define SEC_KEEP 0x400000
+
+       /* This section contains "short" data, and should be placed
+          "near" the GP.  */
+     #define SEC_SMALL_DATA 0x800000
+
+       /* Attempt to merge identical entities in the section.
+          Entity size is given in the entsize field.  */
+     #define SEC_MERGE 0x1000000
+
+       /* If given with SEC_MERGE, entities to merge are zero terminated
+          strings where entsize specifies character size instead of fixed
+          size entries.  */
+     #define SEC_STRINGS 0x2000000
+
+       /* This section contains data about section groups.  */
+     #define SEC_GROUP 0x4000000
+
+       /* The section is a COFF shared library section.  This flag is
+          only for the linker.  If this type of section appears in
+          the input file, the linker must copy it to the output file
+          without changing the vma or size.  FIXME: Although this
+          was originally intended to be general, it really is COFF
+          specific (and the flag was renamed to indicate this).  It
+          might be cleaner to have some more general mechanism to
+          allow the back end to control what the linker does with
+          sections.  */
+     #define SEC_COFF_SHARED_LIBRARY 0x10000000
+
+       /* This section contains data which may be shared with other
+          executables or shared objects. This is for COFF only.  */
+     #define SEC_COFF_SHARED 0x20000000
+
+       /* When a section with this flag is being linked, then if the size of
+          the input section is less than a page, it should not cross a page
+          boundary.  If the size of the input section is one page or more,
+          it should be aligned on a page boundary.  This is for TI
+          TMS320C54X only.  */
+     #define SEC_TIC54X_BLOCK 0x40000000
+
+       /* Conditionally link this section; do not link if there are no
+          references found to any symbol in the section.  This is for TI
+          TMS320C54X only.  */
+     #define SEC_TIC54X_CLINK 0x80000000
+
+       /*  End of section flags.  */
+
+       /* Some internal packed boolean fields.  */
+
+       /* See the vma field.  */
+       unsigned int user_set_vma : 1;
+
+       /* A mark flag used by some of the linker backends.  */
+       unsigned int linker_mark : 1;
+
+       /* Another mark flag used by some of the linker backends.  Set for
+          output sections that have an input section.  */
+       unsigned int linker_has_input : 1;
+
+       /* Mark flags used by some linker backends for garbage collection.  */
+       unsigned int gc_mark : 1;
+       unsigned int gc_mark_from_eh : 1;
+
+       /* The following flags are used by the ELF linker. */
+
+       /* Mark sections which have been allocated to segments.  */
+       unsigned int segment_mark : 1;
+
+       /* Type of sec_info information.  */
+       unsigned int sec_info_type:3;
+     #define ELF_INFO_TYPE_NONE      0
+     #define ELF_INFO_TYPE_STABS     1
+     #define ELF_INFO_TYPE_MERGE     2
+     #define ELF_INFO_TYPE_EH_FRAME  3
+     #define ELF_INFO_TYPE_JUST_SYMS 4
+
+       /* Nonzero if this section uses RELA relocations, rather than REL.  */
+       unsigned int use_rela_p:1;
+
+       /* Bits used by various backends.  The generic code doesn't touch
+          these fields.  */
+
+       /* Nonzero if this section has TLS related relocations.  */
+       unsigned int has_tls_reloc:1;
+
+       /* Nonzero if this section has a gp reloc.  */
+       unsigned int has_gp_reloc:1;
+
+       /* Nonzero if this section needs the relax finalize pass.  */
+       unsigned int need_finalize_relax:1;
+
+       /* Whether relocations have been processed.  */
+       unsigned int reloc_done : 1;
+
+       /* End of internal packed boolean fields.  */
+
+       /*  The virtual memory address of the section - where it will be
+           at run time.  The symbols are relocated against this.  The
+           user_set_vma flag is maintained by bfd; if it's not set, the
+           backend can assign addresses (for example, in `a.out', where
+           the default address for `.data' is dependent on the specific
+           target and various flags).  */
+       bfd_vma vma;
+
+       /*  The load address of the section - where it would be in a
+           rom image; really only used for writing section header
+           information.  */
+       bfd_vma lma;
+
+       /* The size of the section in octets, as it will be output.
+          Contains a value even if the section has no contents (e.g., the
+          size of `.bss').  */
+       bfd_size_type size;
+
+       /* For input sections, the original size on disk of the section, in
+          octets.  This field is used by the linker relaxation code.  It is
+          currently only set for sections where the linker relaxation scheme
+          doesn't cache altered section and reloc contents (stabs, eh_frame,
+          SEC_MERGE, some coff relaxing targets), and thus the original size
+          needs to be kept to read the section multiple times.
+          For output sections, rawsize holds the section size calculated on
+          a previous linker relaxation pass.  */
+       bfd_size_type rawsize;
+
+       /* If this section is going to be output, then this value is the
+          offset in *bytes* into the output section of the first byte in the
+          input section (byte ==> smallest addressable unit on the
+          target).  In most cases, if this was going to start at the
+          100th octet (8-bit quantity) in the output section, this value
+          would be 100.  However, if the target byte size is 16 bits
+          (bfd_octets_per_byte is "2"), this value would be 50.  */
+       bfd_vma output_offset;
+
+       /* The output section through which to map on output.  */
+       struct bfd_section *output_section;
+
+       /* The alignment requirement of the section, as an exponent of 2 -
+          e.g., 3 aligns to 2^3 (or 8).  */
+       unsigned int alignment_power;
+
+       /* If an input section, a pointer to a vector of relocation
+          records for the data in this section.  */
+       struct reloc_cache_entry *relocation;
+
+       /* If an output section, a pointer to a vector of pointers to
+          relocation records for the data in this section.  */
+       struct reloc_cache_entry **orelocation;
+
+       /* The number of relocation records in one of the above.  */
+       unsigned reloc_count;
+
+       /* Information below is back end specific - and not always used
+          or updated.  */
+
+       /* File position of section data.  */
+       file_ptr filepos;
+
+       /* File position of relocation info.  */
+       file_ptr rel_filepos;
+
+       /* File position of line data.  */
+       file_ptr line_filepos;
+
+       /* Pointer to data for applications.  */
+       void *userdata;
+
+       /* If the SEC_IN_MEMORY flag is set, this points to the actual
+          contents.  */
+       unsigned char *contents;
+
+       /* Attached line number information.  */
+       alent *lineno;
+
+       /* Number of line number records.  */
+       unsigned int lineno_count;
+
+       /* Entity size for merging purposes.  */
+       unsigned int entsize;
+
+       /* Points to the kept section if this section is a link-once section,
+          and is discarded.  */
+       struct bfd_section *kept_section;
+
+       /* When a section is being output, this value changes as more
+          linenumbers are written out.  */
+       file_ptr moving_line_filepos;
+
+       /* What the section number is in the target world.  */
+       int target_index;
+
+       void *used_by_bfd;
+
+       /* If this is a constructor section then here is a list of the
+          relocations created to relocate items within it.  */
+       struct relent_chain *constructor_chain;
+
+       /* The BFD which owns the section.  */
+       bfd *owner;
+
+       /* A symbol which points at this section only.  */
+       struct bfd_symbol *symbol;
+       struct bfd_symbol **symbol_ptr_ptr;
+
+       /* Early in the link process, map_head and map_tail are used to build
+          a list of input sections attached to an output section.  Later,
+          output sections use these fields for a list of bfd_link_order
+          structs.  */
+       union {
+         struct bfd_link_order *link_order;
+         struct bfd_section *s;
+       } map_head, map_tail;
+     } asection;
+
+     /* These sections are global, and are managed by BFD.  The application
+        and target back end are not permitted to change the values in
+        these sections.  New code should use the section_ptr macros rather
+        than referring directly to the const sections.  The const sections
+        may eventually vanish.  */
+     #define BFD_ABS_SECTION_NAME "*ABS*"
+     #define BFD_UND_SECTION_NAME "*UND*"
+     #define BFD_COM_SECTION_NAME "*COM*"
+     #define BFD_IND_SECTION_NAME "*IND*"
+
+     /* The absolute section.  */
+     extern asection bfd_abs_section;
+     #define bfd_abs_section_ptr ((asection *) &bfd_abs_section)
+     #define bfd_is_abs_section(sec) ((sec) == bfd_abs_section_ptr)
+     /* Pointer to the undefined section.  */
+     extern asection bfd_und_section;
+     #define bfd_und_section_ptr ((asection *) &bfd_und_section)
+     #define bfd_is_und_section(sec) ((sec) == bfd_und_section_ptr)
+     /* Pointer to the common section.  */
+     extern asection bfd_com_section;
+     #define bfd_com_section_ptr ((asection *) &bfd_com_section)
+     /* Pointer to the indirect section.  */
+     extern asection bfd_ind_section;
+     #define bfd_ind_section_ptr ((asection *) &bfd_ind_section)
+     #define bfd_is_ind_section(sec) ((sec) == bfd_ind_section_ptr)
+
+     #define bfd_is_const_section(SEC)              \
+      (   ((SEC) == bfd_abs_section_ptr)            \
+       || ((SEC) == bfd_und_section_ptr)            \
+       || ((SEC) == bfd_com_section_ptr)            \
+       || ((SEC) == bfd_ind_section_ptr))
+
+     extern const struct bfd_symbol * const bfd_abs_symbol;
+     extern const struct bfd_symbol * const bfd_com_symbol;
+     extern const struct bfd_symbol * const bfd_und_symbol;
+     extern const struct bfd_symbol * const bfd_ind_symbol;
+
+     /* Macros to handle insertion and deletion of a bfd's sections.  These
+        only handle the list pointers, ie. do not adjust section_count,
+        target_index etc.  */
+     #define bfd_section_list_remove(ABFD, S) \
+       do                                                   \
+         {                                                  \
+           asection *_s = S;                                \
+           asection *_next = _s->next;                      \
+           asection *_prev = _s->prev;                      \
+           if (_prev)                                       \
+             _prev->next = _next;                           \
+           else                                             \
+             (ABFD)->sections = _next;                      \
+           if (_next)                                       \
+             _next->prev = _prev;                           \
+           else                                             \
+             (ABFD)->section_last = _prev;                  \
+         }                                                  \
+       while (0)
+     #define bfd_section_list_append(ABFD, S) \
+       do                                                   \
+         {                                                  \
+           asection *_s = S;                                \
+           bfd *_abfd = ABFD;                               \
+           _s->next = NULL;                                 \
+           if (_abfd->section_last)                         \
+             {                                              \
+               _s->prev = _abfd->section_last;              \
+               _abfd->section_last->next = _s;              \
+             }                                              \
+           else                                             \
+             {                                              \
+               _s->prev = NULL;                             \
+               _abfd->sections = _s;                        \
+             }                                              \
+           _abfd->section_last = _s;                        \
+         }                                                  \
+       while (0)
+     #define bfd_section_list_prepend(ABFD, S) \
+       do                                                   \
+         {                                                  \
+           asection *_s = S;                                \
+           bfd *_abfd = ABFD;                               \
+           _s->prev = NULL;                                 \
+           if (_abfd->sections)                             \
+             {                                              \
+               _s->next = _abfd->sections;                  \
+               _abfd->sections->prev = _s;                  \
+             }                                              \
+           else                                             \
+             {                                              \
+               _s->next = NULL;                             \
+               _abfd->section_last = _s;                    \
+             }                                              \
+           _abfd->sections = _s;                            \
+         }                                                  \
+       while (0)
+     #define bfd_section_list_insert_after(ABFD, A, S) \
+       do                                                   \
+         {                                                  \
+           asection *_a = A;                                \
+           asection *_s = S;                                \
+           asection *_next = _a->next;                      \
+           _s->next = _next;                                \
+           _s->prev = _a;                                   \
+           _a->next = _s;                                   \
+           if (_next)                                       \
+             _next->prev = _s;                              \
+           else                                             \
+             (ABFD)->section_last = _s;                     \
+         }                                                  \
+       while (0)
+     #define bfd_section_list_insert_before(ABFD, B, S) \
+       do                                                   \
+         {                                                  \
+           asection *_b = B;                                \
+           asection *_s = S;                                \
+           asection *_prev = _b->prev;                      \
+           _s->prev = _prev;                                \
+           _s->next = _b;                                   \
+           _b->prev = _s;                                   \
+           if (_prev)                                       \
+             _prev->next = _s;                              \
+           else                                             \
+             (ABFD)->sections = _s;                         \
+         }                                                  \
+       while (0)
+     #define bfd_section_removed_from_list(ABFD, S) \
+       ((S)->next == NULL ? (ABFD)->section_last != (S) : (S)->next->prev != (S))
+
+     #define BFD_FAKE_SECTION(SEC, FLAGS, SYM, SYM_PTR, NAME, IDX)          \
+       /* name, id,  index, next, prev, flags, user_set_vma,            */  \
+       { NAME,  IDX, 0,     NULL, NULL, FLAGS, 0,                           \
+                                                                            \
+       /* linker_mark, linker_has_input, gc_mark, gc_mark_from_eh,      */  \
+          0,           0,                1,       0,                        \
+                                                                            \
+       /* segment_mark, sec_info_type, use_rela_p, has_tls_reloc,       */  \
+          0,            0,             0,          0,                       \
+                                                                            \
+       /* has_gp_reloc, need_finalize_relax, reloc_done,                */  \
+          0,            0,                   0,                             \
+                                                                            \
+       /* vma, lma, size, rawsize                                       */  \
+          0,   0,   0,    0,                                                \
+                                                                            \
+       /* output_offset, output_section,              alignment_power,  */  \
+          0,             (struct bfd_section *) &SEC, 0,                    \
+                                                                            \
+       /* relocation, orelocation, reloc_count, filepos, rel_filepos,   */  \
+          NULL,       NULL,        0,           0,       0,                 \
+                                                                            \
+       /* line_filepos, userdata, contents, lineno, lineno_count,       */  \
+          0,            NULL,     NULL,     NULL,   0,                      \
+                                                                            \
+       /* entsize, kept_section, moving_line_filepos,                    */ \
+          0,       NULL,          0,                                        \
+                                                                            \
+       /* target_index, used_by_bfd, constructor_chain, owner,          */  \
+          0,            NULL,        NULL,              NULL,               \
+                                                                            \
+       /* symbol,                                                       */  \
+          (struct bfd_symbol *) SYM,                                        \
+                                                                            \
+       /* symbol_ptr_ptr,                                               */  \
+          (struct bfd_symbol **) SYM_PTR,                                   \
+                                                                            \
+       /* map_head, map_tail                                            */  \
+          { NULL }, { NULL }                                                \
+         }
+
+
+File: bfd.info,  Node: section prototypes,  Prev: typedef asection,  Up: Sections
+
+2.6.5 Section prototypes
+------------------------
+
+These are the functions exported by the section handling part of BFD.
+
+2.6.5.1 `bfd_section_list_clear'
+................................
+
+*Synopsis*
+     void bfd_section_list_clear (bfd *);
+   *Description*
+Clears the section list, and also resets the section count and hash
+table entries.
+
+2.6.5.2 `bfd_get_section_by_name'
+.................................
+
+*Synopsis*
+     asection *bfd_get_section_by_name (bfd *abfd, const char *name);
+   *Description*
+Run through ABFD and return the one of the `asection's whose name
+matches NAME, otherwise `NULL'.  *Note Sections::, for more information.
+
+   This should only be used in special cases; the normal way to process
+all sections of a given name is to use `bfd_map_over_sections' and
+`strcmp' on the name (or better yet, base it on the section flags or
+something else) for each section.
+
+2.6.5.3 `bfd_get_section_by_name_if'
+....................................
+
+*Synopsis*
+     asection *bfd_get_section_by_name_if
+        (bfd *abfd,
+         const char *name,
+         bfd_boolean (*func) (bfd *abfd, asection *sect, void *obj),
+         void *obj);
+   *Description*
+Call the provided function FUNC for each section attached to the BFD
+ABFD whose name matches NAME, passing OBJ as an argument. The function
+will be called as if by
+
+            func (abfd, the_section, obj);
+
+   It returns the first section for which FUNC returns true, otherwise
+`NULL'.
+
+2.6.5.4 `bfd_get_unique_section_name'
+.....................................
+
+*Synopsis*
+     char *bfd_get_unique_section_name
+        (bfd *abfd, const char *templat, int *count);
+   *Description*
+Invent a section name that is unique in ABFD by tacking a dot and a
+digit suffix onto the original TEMPLAT.  If COUNT is non-NULL, then it
+specifies the first number tried as a suffix to generate a unique name.
+The value pointed to by COUNT will be incremented in this case.
+
+2.6.5.5 `bfd_make_section_old_way'
+..................................
+
+*Synopsis*
+     asection *bfd_make_section_old_way (bfd *abfd, const char *name);
+   *Description*
+Create a new empty section called NAME and attach it to the end of the
+chain of sections for the BFD ABFD. An attempt to create a section with
+a name which is already in use returns its pointer without changing the
+section chain.
+
+   It has the funny name since this is the way it used to be before it
+was rewritten....
+
+   Possible errors are:
+   * `bfd_error_invalid_operation' - If output has already started for
+     this BFD.
+
+   * `bfd_error_no_memory' - If memory allocation fails.
+
+2.6.5.6 `bfd_make_section_anyway_with_flags'
+............................................
+
+*Synopsis*
+     asection *bfd_make_section_anyway_with_flags
+        (bfd *abfd, const char *name, flagword flags);
+   *Description*
+Create a new empty section called NAME and attach it to the end of the
+chain of sections for ABFD.  Create a new section even if there is
+already a section with that name.  Also set the attributes of the new
+section to the value FLAGS.
+
+   Return `NULL' and set `bfd_error' on error; possible errors are:
+   * `bfd_error_invalid_operation' - If output has already started for
+     ABFD.
+
+   * `bfd_error_no_memory' - If memory allocation fails.
+
+2.6.5.7 `bfd_make_section_anyway'
+.................................
+
+*Synopsis*
+     asection *bfd_make_section_anyway (bfd *abfd, const char *name);
+   *Description*
+Create a new empty section called NAME and attach it to the end of the
+chain of sections for ABFD.  Create a new section even if there is
+already a section with that name.
+
+   Return `NULL' and set `bfd_error' on error; possible errors are:
+   * `bfd_error_invalid_operation' - If output has already started for
+     ABFD.
+
+   * `bfd_error_no_memory' - If memory allocation fails.
+
+2.6.5.8 `bfd_make_section_with_flags'
+.....................................
+
+*Synopsis*
+     asection *bfd_make_section_with_flags
+        (bfd *, const char *name, flagword flags);
+   *Description*
+Like `bfd_make_section_anyway', but return `NULL' (without calling
+bfd_set_error ()) without changing the section chain if there is
+already a section named NAME.  Also set the attributes of the new
+section to the value FLAGS.  If there is an error, return `NULL' and set
+`bfd_error'.
+
+2.6.5.9 `bfd_make_section'
+..........................
+
+*Synopsis*
+     asection *bfd_make_section (bfd *, const char *name);
+   *Description*
+Like `bfd_make_section_anyway', but return `NULL' (without calling
+bfd_set_error ()) without changing the section chain if there is
+already a section named NAME.  If there is an error, return `NULL' and
+set `bfd_error'.
+
+2.6.5.10 `bfd_set_section_flags'
+................................
+
+*Synopsis*
+     bfd_boolean bfd_set_section_flags
+        (bfd *abfd, asection *sec, flagword flags);
+   *Description*
+Set the attributes of the section SEC in the BFD ABFD to the value
+FLAGS. Return `TRUE' on success, `FALSE' on error. Possible error
+returns are:
+
+   * `bfd_error_invalid_operation' - The section cannot have one or
+     more of the attributes requested. For example, a .bss section in
+     `a.out' may not have the `SEC_HAS_CONTENTS' field set.
+
+2.6.5.11 `bfd_map_over_sections'
+................................
+
+*Synopsis*
+     void bfd_map_over_sections
+        (bfd *abfd,
+         void (*func) (bfd *abfd, asection *sect, void *obj),
+         void *obj);
+   *Description*
+Call the provided function FUNC for each section attached to the BFD
+ABFD, passing OBJ as an argument. The function will be called as if by
+
+            func (abfd, the_section, obj);
+
+   This is the preferred method for iterating over sections; an
+alternative would be to use a loop:
+
+               section *p;
+               for (p = abfd->sections; p != NULL; p = p->next)
+                  func (abfd, p, ...)
+
+2.6.5.12 `bfd_sections_find_if'
+...............................
+
+*Synopsis*
+     asection *bfd_sections_find_if
+        (bfd *abfd,
+         bfd_boolean (*operation) (bfd *abfd, asection *sect, void *obj),
+         void *obj);
+   *Description*
+Call the provided function OPERATION for each section attached to the
+BFD ABFD, passing OBJ as an argument. The function will be called as if
+by
+
+            operation (abfd, the_section, obj);
+
+   It returns the first section for which OPERATION returns true.
+
+2.6.5.13 `bfd_set_section_size'
+...............................
+
+*Synopsis*
+     bfd_boolean bfd_set_section_size
+        (bfd *abfd, asection *sec, bfd_size_type val);
+   *Description*
+Set SEC to the size VAL. If the operation is ok, then `TRUE' is
+returned, else `FALSE'.
+
+   Possible error returns:
+   * `bfd_error_invalid_operation' - Writing has started to the BFD, so
+     setting the size is invalid.
+
+2.6.5.14 `bfd_set_section_contents'
+...................................
+
+*Synopsis*
+     bfd_boolean bfd_set_section_contents
+        (bfd *abfd, asection *section, const void *data,
+         file_ptr offset, bfd_size_type count);
+   *Description*
+Sets the contents of the section SECTION in BFD ABFD to the data
+starting in memory at DATA. The data is written to the output section
+starting at offset OFFSET for COUNT octets.
+
+   Normally `TRUE' is returned, else `FALSE'. Possible error returns
+are:
+   * `bfd_error_no_contents' - The output section does not have the
+     `SEC_HAS_CONTENTS' attribute, so nothing can be written to it.
+
+   * and some more too
+   This routine is front end to the back end function
+`_bfd_set_section_contents'.
+
+2.6.5.15 `bfd_get_section_contents'
+...................................
+
+*Synopsis*
+     bfd_boolean bfd_get_section_contents
+        (bfd *abfd, asection *section, void *location, file_ptr offset,
+         bfd_size_type count);
+   *Description*
+Read data from SECTION in BFD ABFD into memory starting at LOCATION.
+The data is read at an offset of OFFSET from the start of the input
+section, and is read for COUNT bytes.
+
+   If the contents of a constructor with the `SEC_CONSTRUCTOR' flag set
+are requested or if the section does not have the `SEC_HAS_CONTENTS'
+flag set, then the LOCATION is filled with zeroes. If no errors occur,
+`TRUE' is returned, else `FALSE'.
+
+2.6.5.16 `bfd_malloc_and_get_section'
+.....................................
+
+*Synopsis*
+     bfd_boolean bfd_malloc_and_get_section
+        (bfd *abfd, asection *section, bfd_byte **buf);
+   *Description*
+Read all data from SECTION in BFD ABFD into a buffer, *BUF, malloc'd by
+this function.
+
+2.6.5.17 `bfd_copy_private_section_data'
+........................................
+
+*Synopsis*
+     bfd_boolean bfd_copy_private_section_data
+        (bfd *ibfd, asection *isec, bfd *obfd, asection *osec);
+   *Description*
+Copy private section information from ISEC in the BFD IBFD to the
+section OSEC in the BFD OBFD.  Return `TRUE' on success, `FALSE' on
+error.  Possible error returns are:
+
+   * `bfd_error_no_memory' - Not enough memory exists to create private
+     data for OSEC.
+
+     #define bfd_copy_private_section_data(ibfd, isection, obfd, osection) \
+          BFD_SEND (obfd, _bfd_copy_private_section_data, \
+                    (ibfd, isection, obfd, osection))
+
+2.6.5.18 `bfd_generic_is_group_section'
+.......................................
+
+*Synopsis*
+     bfd_boolean bfd_generic_is_group_section (bfd *, const asection *sec);
+   *Description*
+Returns TRUE if SEC is a member of a group.
+
+2.6.5.19 `bfd_generic_discard_group'
+....................................
+
+*Synopsis*
+     bfd_boolean bfd_generic_discard_group (bfd *abfd, asection *group);
+   *Description*
+Remove all members of GROUP from the output.
+
+
+File: bfd.info,  Node: Symbols,  Next: Archives,  Prev: Sections,  Up: BFD front end
+
+2.7 Symbols
+===========
+
+BFD tries to maintain as much symbol information as it can when it
+moves information from file to file. BFD passes information to
+applications though the `asymbol' structure. When the application
+requests the symbol table, BFD reads the table in the native form and
+translates parts of it into the internal format. To maintain more than
+the information passed to applications, some targets keep some
+information "behind the scenes" in a structure only the particular back
+end knows about. For example, the coff back end keeps the original
+symbol table structure as well as the canonical structure when a BFD is
+read in. On output, the coff back end can reconstruct the output symbol
+table so that no information is lost, even information unique to coff
+which BFD doesn't know or understand. If a coff symbol table were read,
+but were written through an a.out back end, all the coff specific
+information would be lost. The symbol table of a BFD is not necessarily
+read in until a canonicalize request is made. Then the BFD back end
+fills in a table provided by the application with pointers to the
+canonical information.  To output symbols, the application provides BFD
+with a table of pointers to pointers to `asymbol's. This allows
+applications like the linker to output a symbol as it was read, since
+the "behind the scenes" information will be still available.
+
+* Menu:
+
+* Reading Symbols::
+* Writing Symbols::
+* Mini Symbols::
+* typedef asymbol::
+* symbol handling functions::
+
+
+File: bfd.info,  Node: Reading Symbols,  Next: Writing Symbols,  Prev: Symbols,  Up: Symbols
+
+2.7.1 Reading symbols
+---------------------
+
+There are two stages to reading a symbol table from a BFD: allocating
+storage, and the actual reading process. This is an excerpt from an
+application which reads the symbol table:
+
+              long storage_needed;
+              asymbol **symbol_table;
+              long number_of_symbols;
+              long i;
+
+              storage_needed = bfd_get_symtab_upper_bound (abfd);
+
+              if (storage_needed < 0)
+                FAIL
+
+              if (storage_needed == 0)
+                return;
+
+              symbol_table = xmalloc (storage_needed);
+                ...
+              number_of_symbols =
+                 bfd_canonicalize_symtab (abfd, symbol_table);
+
+              if (number_of_symbols < 0)
+                FAIL
+
+              for (i = 0; i < number_of_symbols; i++)
+                process_symbol (symbol_table[i]);
+
+   All storage for the symbols themselves is in an objalloc connected
+to the BFD; it is freed when the BFD is closed.
+
+
+File: bfd.info,  Node: Writing Symbols,  Next: Mini Symbols,  Prev: Reading Symbols,  Up: Symbols
+
+2.7.2 Writing symbols
+---------------------
+
+Writing of a symbol table is automatic when a BFD open for writing is
+closed. The application attaches a vector of pointers to pointers to
+symbols to the BFD being written, and fills in the symbol count. The
+close and cleanup code reads through the table provided and performs
+all the necessary operations. The BFD output code must always be
+provided with an "owned" symbol: one which has come from another BFD,
+or one which has been created using `bfd_make_empty_symbol'.  Here is an
+example showing the creation of a symbol table with only one element:
+
+            #include "bfd.h"
+            int main (void)
+            {
+              bfd *abfd;
+              asymbol *ptrs[2];
+              asymbol *new;
+
+              abfd = bfd_openw ("foo","a.out-sunos-big");
+              bfd_set_format (abfd, bfd_object);
+              new = bfd_make_empty_symbol (abfd);
+              new->name = "dummy_symbol";
+              new->section = bfd_make_section_old_way (abfd, ".text");
+              new->flags = BSF_GLOBAL;
+              new->value = 0x12345;
+
+              ptrs[0] = new;
+              ptrs[1] = 0;
+
+              bfd_set_symtab (abfd, ptrs, 1);
+              bfd_close (abfd);
+              return 0;
+            }
+
+            ./makesym
+            nm foo
+            00012345 A dummy_symbol
+
+   Many formats cannot represent arbitrary symbol information; for
+instance, the `a.out' object format does not allow an arbitrary number
+of sections. A symbol pointing to a section which is not one  of
+`.text', `.data' or `.bss' cannot be described.
+
+
+File: bfd.info,  Node: Mini Symbols,  Next: typedef asymbol,  Prev: Writing Symbols,  Up: Symbols
+
+2.7.3 Mini Symbols
+------------------
+
+Mini symbols provide read-only access to the symbol table.  They use
+less memory space, but require more time to access.  They can be useful
+for tools like nm or objdump, which may have to handle symbol tables of
+extremely large executables.
+
+   The `bfd_read_minisymbols' function will read the symbols into
+memory in an internal form.  It will return a `void *' pointer to a
+block of memory, a symbol count, and the size of each symbol.  The
+pointer is allocated using `malloc', and should be freed by the caller
+when it is no longer needed.
+
+   The function `bfd_minisymbol_to_symbol' will take a pointer to a
+minisymbol, and a pointer to a structure returned by
+`bfd_make_empty_symbol', and return a `asymbol' structure.  The return
+value may or may not be the same as the value from
+`bfd_make_empty_symbol' which was passed in.
+
+
+File: bfd.info,  Node: typedef asymbol,  Next: symbol handling functions,  Prev: Mini Symbols,  Up: Symbols
+
+2.7.4 typedef asymbol
+---------------------
+
+An `asymbol' has the form:
+
+
+     typedef struct bfd_symbol
+     {
+       /* A pointer to the BFD which owns the symbol. This information
+          is necessary so that a back end can work out what additional
+          information (invisible to the application writer) is carried
+          with the symbol.
+
+          This field is *almost* redundant, since you can use section->owner
+          instead, except that some symbols point to the global sections
+          bfd_{abs,com,und}_section.  This could be fixed by making
+          these globals be per-bfd (or per-target-flavor).  FIXME.  */
+       struct bfd *the_bfd; /* Use bfd_asymbol_bfd(sym) to access this field.  */
+
+       /* The text of the symbol. The name is left alone, and not copied; the
+          application may not alter it.  */
+       const char *name;
+
+       /* The value of the symbol.  This really should be a union of a
+          numeric value with a pointer, since some flags indicate that
+          a pointer to another symbol is stored here.  */
+       symvalue value;
+
+       /* Attributes of a symbol.  */
+     #define BSF_NO_FLAGS    0x00
+
+       /* The symbol has local scope; `static' in `C'. The value
+          is the offset into the section of the data.  */
+     #define BSF_LOCAL      0x01
+
+       /* The symbol has global scope; initialized data in `C'. The
+          value is the offset into the section of the data.  */
+     #define BSF_GLOBAL     0x02
+
+       /* The symbol has global scope and is exported. The value is
+          the offset into the section of the data.  */
+     #define BSF_EXPORT     BSF_GLOBAL /* No real difference.  */
+
+       /* A normal C symbol would be one of:
+          `BSF_LOCAL', `BSF_FORT_COMM',  `BSF_UNDEFINED' or
+          `BSF_GLOBAL'.  */
+
+       /* The symbol is a debugging record. The value has an arbitrary
+          meaning, unless BSF_DEBUGGING_RELOC is also set.  */
+     #define BSF_DEBUGGING  0x08
+
+       /* The symbol denotes a function entry point.  Used in ELF,
+          perhaps others someday.  */
+     #define BSF_FUNCTION    0x10
+
+       /* Used by the linker.  */
+     #define BSF_KEEP        0x20
+     #define BSF_KEEP_G      0x40
+
+       /* A weak global symbol, overridable without warnings by
+          a regular global symbol of the same name.  */
+     #define BSF_WEAK        0x80
+
+       /* This symbol was created to point to a section, e.g. ELF's
+          STT_SECTION symbols.  */
+     #define BSF_SECTION_SYM 0x100
+
+       /* The symbol used to be a common symbol, but now it is
+          allocated.  */
+     #define BSF_OLD_COMMON  0x200
+
+       /* The default value for common data.  */
+     #define BFD_FORT_COMM_DEFAULT_VALUE 0
+
+       /* In some files the type of a symbol sometimes alters its
+          location in an output file - ie in coff a `ISFCN' symbol
+          which is also `C_EXT' symbol appears where it was
+          declared and not at the end of a section.  This bit is set
+          by the target BFD part to convey this information.  */
+     #define BSF_NOT_AT_END    0x400
+
+       /* Signal that the symbol is the label of constructor section.  */
+     #define BSF_CONSTRUCTOR   0x800
+
+       /* Signal that the symbol is a warning symbol.  The name is a
+          warning.  The name of the next symbol is the one to warn about;
+          if a reference is made to a symbol with the same name as the next
+          symbol, a warning is issued by the linker.  */
+     #define BSF_WARNING       0x1000
+
+       /* Signal that the symbol is indirect.  This symbol is an indirect
+          pointer to the symbol with the same name as the next symbol.  */
+     #define BSF_INDIRECT      0x2000
+
+       /* BSF_FILE marks symbols that contain a file name.  This is used
+          for ELF STT_FILE symbols.  */
+     #define BSF_FILE          0x4000
+
+       /* Symbol is from dynamic linking information.  */
+     #define BSF_DYNAMIC       0x8000
+
+       /* The symbol denotes a data object.  Used in ELF, and perhaps
+          others someday.  */
+     #define BSF_OBJECT        0x10000
+
+       /* This symbol is a debugging symbol.  The value is the offset
+          into the section of the data.  BSF_DEBUGGING should be set
+          as well.  */
+     #define BSF_DEBUGGING_RELOC 0x20000
+
+       /* This symbol is thread local.  Used in ELF.  */
+     #define BSF_THREAD_LOCAL  0x40000
+
+       flagword flags;
+
+       /* A pointer to the section to which this symbol is
+          relative.  This will always be non NULL, there are special
+          sections for undefined and absolute symbols.  */
+       struct bfd_section *section;
+
+       /* Back end special data.  */
+       union
+         {
+           void *p;
+           bfd_vma i;
+         }
+       udata;
+     }
+     asymbol;
+
+
+File: bfd.info,  Node: symbol handling functions,  Prev: typedef asymbol,  Up: Symbols
+
+2.7.5 Symbol handling functions
+-------------------------------
+
+2.7.5.1 `bfd_get_symtab_upper_bound'
+....................................
+
+*Description*
+Return the number of bytes required to store a vector of pointers to
+`asymbols' for all the symbols in the BFD ABFD, including a terminal
+NULL pointer. If there are no symbols in the BFD, then return 0.  If an
+error occurs, return -1.
+     #define bfd_get_symtab_upper_bound(abfd) \
+          BFD_SEND (abfd, _bfd_get_symtab_upper_bound, (abfd))
+
+2.7.5.2 `bfd_is_local_label'
+............................
+
+*Synopsis*
+     bfd_boolean bfd_is_local_label (bfd *abfd, asymbol *sym);
+   *Description*
+Return TRUE if the given symbol SYM in the BFD ABFD is a compiler
+generated local label, else return FALSE.
+
+2.7.5.3 `bfd_is_local_label_name'
+.................................
+
+*Synopsis*
+     bfd_boolean bfd_is_local_label_name (bfd *abfd, const char *name);
+   *Description*
+Return TRUE if a symbol with the name NAME in the BFD ABFD is a
+compiler generated local label, else return FALSE.  This just checks
+whether the name has the form of a local label.
+     #define bfd_is_local_label_name(abfd, name) \
+       BFD_SEND (abfd, _bfd_is_local_label_name, (abfd, name))
+
+2.7.5.4 `bfd_is_target_special_symbol'
+......................................
+
+*Synopsis*
+     bfd_boolean bfd_is_target_special_symbol (bfd *abfd, asymbol *sym);
+   *Description*
+Return TRUE iff a symbol SYM in the BFD ABFD is something special to
+the particular target represented by the BFD.  Such symbols should
+normally not be mentioned to the user.
+     #define bfd_is_target_special_symbol(abfd, sym) \
+       BFD_SEND (abfd, _bfd_is_target_special_symbol, (abfd, sym))
+
+2.7.5.5 `bfd_canonicalize_symtab'
+.................................
+
+*Description*
+Read the symbols from the BFD ABFD, and fills in the vector LOCATION
+with pointers to the symbols and a trailing NULL.  Return the actual
+number of symbol pointers, not including the NULL.
+     #define bfd_canonicalize_symtab(abfd, location) \
+       BFD_SEND (abfd, _bfd_canonicalize_symtab, (abfd, location))
+
+2.7.5.6 `bfd_set_symtab'
+........................
+
+*Synopsis*
+     bfd_boolean bfd_set_symtab
+        (bfd *abfd, asymbol **location, unsigned int count);
+   *Description*
+Arrange that when the output BFD ABFD is closed, the table LOCATION of
+COUNT pointers to symbols will be written.
+
+2.7.5.7 `bfd_print_symbol_vandf'
+................................
+
+*Synopsis*
+     void bfd_print_symbol_vandf (bfd *abfd, void *file, asymbol *symbol);
+   *Description*
+Print the value and flags of the SYMBOL supplied to the stream FILE.
+
+2.7.5.8 `bfd_make_empty_symbol'
+...............................
+
+*Description*
+Create a new `asymbol' structure for the BFD ABFD and return a pointer
+to it.
+
+   This routine is necessary because each back end has private
+information surrounding the `asymbol'. Building your own `asymbol' and
+pointing to it will not create the private information, and will cause
+problems later on.
+     #define bfd_make_empty_symbol(abfd) \
+       BFD_SEND (abfd, _bfd_make_empty_symbol, (abfd))
+
+2.7.5.9 `_bfd_generic_make_empty_symbol'
+........................................
+
+*Synopsis*
+     asymbol *_bfd_generic_make_empty_symbol (bfd *);
+   *Description*
+Create a new `asymbol' structure for the BFD ABFD and return a pointer
+to it.  Used by core file routines, binary back-end and anywhere else
+where no private info is needed.
+
+2.7.5.10 `bfd_make_debug_symbol'
+................................
+
+*Description*
+Create a new `asymbol' structure for the BFD ABFD, to be used as a
+debugging symbol.  Further details of its use have yet to be worked out.
+     #define bfd_make_debug_symbol(abfd,ptr,size) \
+       BFD_SEND (abfd, _bfd_make_debug_symbol, (abfd, ptr, size))
+
+2.7.5.11 `bfd_decode_symclass'
+..............................
+
+*Description*
+Return a character corresponding to the symbol class of SYMBOL, or '?'
+for an unknown class.
+
+   *Synopsis*
+     int bfd_decode_symclass (asymbol *symbol);
+   
+2.7.5.12 `bfd_is_undefined_symclass'
+....................................
+
+*Description*
+Returns non-zero if the class symbol returned by bfd_decode_symclass
+represents an undefined symbol.  Returns zero otherwise.
+
+   *Synopsis*
+     bfd_boolean bfd_is_undefined_symclass (int symclass);
+   
+2.7.5.13 `bfd_symbol_info'
+..........................
+
+*Description*
+Fill in the basic info about symbol that nm needs.  Additional info may
+be added by the back-ends after calling this function.
+
+   *Synopsis*
+     void bfd_symbol_info (asymbol *symbol, symbol_info *ret);
+   
+2.7.5.14 `bfd_copy_private_symbol_data'
+.......................................
+
+*Synopsis*
+     bfd_boolean bfd_copy_private_symbol_data
+        (bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);
+   *Description*
+Copy private symbol information from ISYM in the BFD IBFD to the symbol
+OSYM in the BFD OBFD.  Return `TRUE' on success, `FALSE' on error.
+Possible error returns are:
+
+   * `bfd_error_no_memory' - Not enough memory exists to create private
+     data for OSEC.
+
+     #define bfd_copy_private_symbol_data(ibfd, isymbol, obfd, osymbol) \
+       BFD_SEND (obfd, _bfd_copy_private_symbol_data, \
+                 (ibfd, isymbol, obfd, osymbol))
+
+
+File: bfd.info,  Node: Archives,  Next: Formats,  Prev: Symbols,  Up: BFD front end
+
+2.8 Archives
+============
+
+*Description*
+An archive (or library) is just another BFD.  It has a symbol table,
+although there's not much a user program will do with it.
+
+   The big difference between an archive BFD and an ordinary BFD is
+that the archive doesn't have sections.  Instead it has a chain of BFDs
+that are considered its contents.  These BFDs can be manipulated like
+any other.  The BFDs contained in an archive opened for reading will
+all be opened for reading.  You may put either input or output BFDs
+into an archive opened for output; they will be handled correctly when
+the archive is closed.
+
+   Use `bfd_openr_next_archived_file' to step through the contents of
+an archive opened for input.  You don't have to read the entire archive
+if you don't want to!  Read it until you find what you want.
+
+   Archive contents of output BFDs are chained through the `next'
+pointer in a BFD.  The first one is findable through the `archive_head'
+slot of the archive.  Set it with `bfd_set_archive_head' (q.v.).  A
+given BFD may be in only one open output archive at a time.
+
+   As expected, the BFD archive code is more general than the archive
+code of any given environment.  BFD archives may contain files of
+different formats (e.g., a.out and coff) and even different
+architectures.  You may even place archives recursively into archives!
+
+   This can cause unexpected confusion, since some archive formats are
+more expressive than others.  For instance, Intel COFF archives can
+preserve long filenames; SunOS a.out archives cannot.  If you move a
+file from the first to the second format and back again, the filename
+may be truncated.  Likewise, different a.out environments have different
+conventions as to how they truncate filenames, whether they preserve
+directory names in filenames, etc.  When interoperating with native
+tools, be sure your files are homogeneous.
+
+   Beware: most of these formats do not react well to the presence of
+spaces in filenames.  We do the best we can, but can't always handle
+this case due to restrictions in the format of archives.  Many Unix
+utilities are braindead in regards to spaces and such in filenames
+anyway, so this shouldn't be much of a restriction.
+
+   Archives are supported in BFD in `archive.c'.
+
+2.8.1 Archive functions
+-----------------------
+
+2.8.1.1 `bfd_get_next_mapent'
+.............................
+
+*Synopsis*
+     symindex bfd_get_next_mapent
+        (bfd *abfd, symindex previous, carsym **sym);
+   *Description*
+Step through archive ABFD's symbol table (if it has one).  Successively
+update SYM with the next symbol's information, returning that symbol's
+(internal) index into the symbol table.
+
+   Supply `BFD_NO_MORE_SYMBOLS' as the PREVIOUS entry to get the first
+one; returns `BFD_NO_MORE_SYMBOLS' when you've already got the last one.
+
+   A `carsym' is a canonical archive symbol.  The only user-visible
+element is its name, a null-terminated string.
+
+2.8.1.2 `bfd_set_archive_head'
+..............................
+
+*Synopsis*
+     bfd_boolean bfd_set_archive_head (bfd *output, bfd *new_head);
+   *Description*
+Set the head of the chain of BFDs contained in the archive OUTPUT to
+NEW_HEAD.
+
+2.8.1.3 `bfd_openr_next_archived_file'
+......................................
+
+*Synopsis*
+     bfd *bfd_openr_next_archived_file (bfd *archive, bfd *previous);
+   *Description*
+Provided a BFD, ARCHIVE, containing an archive and NULL, open an input
+BFD on the first contained element and returns that.  Subsequent calls
+should pass the archive and the previous return value to return a
+created BFD to the next contained element. NULL is returned when there
+are no more.
+
+
+File: bfd.info,  Node: Formats,  Next: Relocations,  Prev: Archives,  Up: BFD front end
+
+2.9 File formats
+================
+
+A format is a BFD concept of high level file contents type. The formats
+supported by BFD are:
+
+   * `bfd_object'
+   The BFD may contain data, symbols, relocations and debug info.
+
+   * `bfd_archive'
+   The BFD contains other BFDs and an optional index.
+
+   * `bfd_core'
+   The BFD contains the result of an executable core dump.
+
+2.9.1 File format functions
+---------------------------
+
+2.9.1.1 `bfd_check_format'
+..........................
+
+*Synopsis*
+     bfd_boolean bfd_check_format (bfd *abfd, bfd_format format);
+   *Description*
+Verify if the file attached to the BFD ABFD is compatible with the
+format FORMAT (i.e., one of `bfd_object', `bfd_archive' or `bfd_core').
+
+   If the BFD has been set to a specific target before the call, only
+the named target and format combination is checked. If the target has
+not been set, or has been set to `default', then all the known target
+backends is interrogated to determine a match.  If the default target
+matches, it is used.  If not, exactly one target must recognize the
+file, or an error results.
+
+   The function returns `TRUE' on success, otherwise `FALSE' with one
+of the following error codes:
+
+   * `bfd_error_invalid_operation' - if `format' is not one of
+     `bfd_object', `bfd_archive' or `bfd_core'.
+
+   * `bfd_error_system_call' - if an error occured during a read - even
+     some file mismatches can cause bfd_error_system_calls.
+
+   * `file_not_recognised' - none of the backends recognised the file
+     format.
+
+   * `bfd_error_file_ambiguously_recognized' - more than one backend
+     recognised the file format.
+
+2.9.1.2 `bfd_check_format_matches'
+..................................
+
+*Synopsis*
+     bfd_boolean bfd_check_format_matches
+        (bfd *abfd, bfd_format format, char ***matching);
+   *Description*
+Like `bfd_check_format', except when it returns FALSE with `bfd_errno'
+set to `bfd_error_file_ambiguously_recognized'.  In that case, if
+MATCHING is not NULL, it will be filled in with a NULL-terminated list
+of the names of the formats that matched, allocated with `malloc'.
+Then the user may choose a format and try again.
+
+   When done with the list that MATCHING points to, the caller should
+free it.
+
+2.9.1.3 `bfd_set_format'
+........................
+
+*Synopsis*
+     bfd_boolean bfd_set_format (bfd *abfd, bfd_format format);
+   *Description*
+This function sets the file format of the BFD ABFD to the format
+FORMAT. If the target set in the BFD does not support the format
+requested, the format is invalid, or the BFD is not open for writing,
+then an error occurs.
+
+2.9.1.4 `bfd_format_string'
+...........................
+
+*Synopsis*
+     const char *bfd_format_string (bfd_format format);
+   *Description*
+Return a pointer to a const string `invalid', `object', `archive',
+`core', or `unknown', depending upon the value of FORMAT.
+
+
+File: bfd.info,  Node: Relocations,  Next: Core Files,  Prev: Formats,  Up: BFD front end
+
+2.10 Relocations
+================
+
+BFD maintains relocations in much the same way it maintains symbols:
+they are left alone until required, then read in en-masse and
+translated into an internal form.  A common routine
+`bfd_perform_relocation' acts upon the canonical form to do the fixup.
+
+   Relocations are maintained on a per section basis, while symbols are
+maintained on a per BFD basis.
+
+   All that a back end has to do to fit the BFD interface is to create
+a `struct reloc_cache_entry' for each relocation in a particular
+section, and fill in the right bits of the structures.
+
+* Menu:
+
+* typedef arelent::
+* howto manager::
+
+
+File: bfd.info,  Node: typedef arelent,  Next: howto manager,  Prev: Relocations,  Up: Relocations
+
+2.10.1 typedef arelent
+----------------------
+
+This is the structure of a relocation entry:
+
+
+     typedef enum bfd_reloc_status
+     {
+       /* No errors detected.  */
+       bfd_reloc_ok,
+
+       /* The relocation was performed, but there was an overflow.  */
+       bfd_reloc_overflow,
+
+       /* The address to relocate was not within the section supplied.  */
+       bfd_reloc_outofrange,
+
+       /* Used by special functions.  */
+       bfd_reloc_continue,
+
+       /* Unsupported relocation size requested.  */
+       bfd_reloc_notsupported,
+
+       /* Unused.  */
+       bfd_reloc_other,
+
+       /* The symbol to relocate against was undefined.  */
+       bfd_reloc_undefined,
+
+       /* The relocation was performed, but may not be ok - presently
+          generated only when linking i960 coff files with i960 b.out
+          symbols.  If this type is returned, the error_message argument
+          to bfd_perform_relocation will be set.  */
+       bfd_reloc_dangerous
+      }
+      bfd_reloc_status_type;
+
+
+     typedef struct reloc_cache_entry
+     {
+       /* A pointer into the canonical table of pointers.  */
+       struct bfd_symbol **sym_ptr_ptr;
+
+       /* offset in section.  */
+       bfd_size_type address;
+
+       /* addend for relocation value.  */
+       bfd_vma addend;
+
+       /* Pointer to how to perform the required relocation.  */
+       reloc_howto_type *howto;
+
+     }
+     arelent;
+   *Description*
+Here is a description of each of the fields within an `arelent':
+
+   * `sym_ptr_ptr'
+   The symbol table pointer points to a pointer to the symbol
+associated with the relocation request.  It is the pointer into the
+table returned by the back end's `canonicalize_symtab' action. *Note
+Symbols::. The symbol is referenced through a pointer to a pointer so
+that tools like the linker can fix up all the symbols of the same name
+by modifying only one pointer. The relocation routine looks in the
+symbol and uses the base of the section the symbol is attached to and
+the value of the symbol as the initial relocation offset. If the symbol
+pointer is zero, then the section provided is looked up.
+
+   * `address'
+   The `address' field gives the offset in bytes from the base of the
+section data which owns the relocation record to the first byte of
+relocatable information. The actual data relocated will be relative to
+this point; for example, a relocation type which modifies the bottom
+two bytes of a four byte word would not touch the first byte pointed to
+in a big endian world.
+
+   * `addend'
+   The `addend' is a value provided by the back end to be added (!)  to
+the relocation offset. Its interpretation is dependent upon the howto.
+For example, on the 68k the code:
+
+             char foo[];
+             main()
+                     {
+                     return foo[0x12345678];
+                     }
+
+   Could be compiled into:
+
+             linkw fp,#-4
+             moveb @#12345678,d0
+             extbl d0
+             unlk fp
+             rts
+
+   This could create a reloc pointing to `foo', but leave the offset in
+the data, something like:
+
+     RELOCATION RECORDS FOR [.text]:
+     offset   type      value
+     00000006 32        _foo
+
+     00000000 4e56 fffc          ; linkw fp,#-4
+     00000004 1039 1234 5678     ; moveb @#12345678,d0
+     0000000a 49c0               ; extbl d0
+     0000000c 4e5e               ; unlk fp
+     0000000e 4e75               ; rts
+
+   Using coff and an 88k, some instructions don't have enough space in
+them to represent the full address range, and pointers have to be
+loaded in two parts. So you'd get something like:
+
+             or.u     r13,r0,hi16(_foo+0x12345678)
+             ld.b     r2,r13,lo16(_foo+0x12345678)
+             jmp      r1
+
+   This should create two relocs, both pointing to `_foo', and with
+0x12340000 in their addend field. The data would consist of:
+
+     RELOCATION RECORDS FOR [.text]:
+     offset   type      value
+     00000002 HVRT16    _foo+0x12340000
+     00000006 LVRT16    _foo+0x12340000
+
+     00000000 5da05678           ; or.u r13,r0,0x5678
+     00000004 1c4d5678           ; ld.b r2,r13,0x5678
+     00000008 f400c001           ; jmp r1
+
+   The relocation routine digs out the value from the data, adds it to
+the addend to get the original offset, and then adds the value of
+`_foo'. Note that all 32 bits have to be kept around somewhere, to cope
+with carry from bit 15 to bit 16.
+
+   One further example is the sparc and the a.out format. The sparc has
+a similar problem to the 88k, in that some instructions don't have room
+for an entire offset, but on the sparc the parts are created in odd
+sized lumps. The designers of the a.out format chose to not use the
+data within the section for storing part of the offset; all the offset
+is kept within the reloc. Anything in the data should be ignored.
+
+             save %sp,-112,%sp
+             sethi %hi(_foo+0x12345678),%g2
+             ldsb [%g2+%lo(_foo+0x12345678)],%i0
+             ret
+             restore
+
+   Both relocs contain a pointer to `foo', and the offsets contain junk.
+
+     RELOCATION RECORDS FOR [.text]:
+     offset   type      value
+     00000004 HI22      _foo+0x12345678
+     00000008 LO10      _foo+0x12345678
+
+     00000000 9de3bf90     ; save %sp,-112,%sp
+     00000004 05000000     ; sethi %hi(_foo+0),%g2
+     00000008 f048a000     ; ldsb [%g2+%lo(_foo+0)],%i0
+     0000000c 81c7e008     ; ret
+     00000010 81e80000     ; restore
+
+   * `howto'
+   The `howto' field can be imagined as a relocation instruction. It is
+a pointer to a structure which contains information on what to do with
+all of the other information in the reloc record and data section. A
+back end would normally have a relocation instruction set and turn
+relocations into pointers to the correct structure on input - but it
+would be possible to create each howto field on demand.
+
+2.10.1.1 `enum complain_overflow'
+.................................
+
+Indicates what sort of overflow checking should be done when performing
+a relocation.
+
+
+     enum complain_overflow
+     {
+       /* Do not complain on overflow.  */
+       complain_overflow_dont,
+
+       /* Complain if the bitfield overflows, whether it is considered
+          as signed or unsigned.  */
+       complain_overflow_bitfield,
+
+       /* Complain if the value overflows when considered as signed
+          number.  */
+       complain_overflow_signed,
+
+       /* Complain if the value overflows when considered as an
+          unsigned number.  */
+       complain_overflow_unsigned
+     };
+
+2.10.1.2 `reloc_howto_type'
+...........................
+
+The `reloc_howto_type' is a structure which contains all the
+information that libbfd needs to know to tie up a back end's data.
+
+     struct bfd_symbol;             /* Forward declaration.  */
+
+     struct reloc_howto_struct
+     {
+       /*  The type field has mainly a documentary use - the back end can
+           do what it wants with it, though normally the back end's
+           external idea of what a reloc number is stored
+           in this field.  For example, a PC relative word relocation
+           in a coff environment has the type 023 - because that's
+           what the outside world calls a R_PCRWORD reloc.  */
+       unsigned int type;
+
+       /*  The value the final relocation is shifted right by.  This drops
+           unwanted data from the relocation.  */
+       unsigned int rightshift;
+
+       /*  The size of the item to be relocated.  This is *not* a
+           power-of-two measure.  To get the number of bytes operated
+           on by a type of relocation, use bfd_get_reloc_size.  */
+       int size;
+
+       /*  The number of bits in the item to be relocated.  This is used
+           when doing overflow checking.  */
+       unsigned int bitsize;
+
+       /*  Notes that the relocation is relative to the location in the
+           data section of the addend.  The relocation function will
+           subtract from the relocation value the address of the location
+           being relocated.  */
+       bfd_boolean pc_relative;
+
+       /*  The bit position of the reloc value in the destination.
+           The relocated value is left shifted by this amount.  */
+       unsigned int bitpos;
+
+       /* What type of overflow error should be checked for when
+          relocating.  */
+       enum complain_overflow complain_on_overflow;
+
+       /* If this field is non null, then the supplied function is
+          called rather than the normal function.  This allows really
+          strange relocation methods to be accommodated (e.g., i960 callj
+          instructions).  */
+       bfd_reloc_status_type (*special_function)
+         (bfd *, arelent *, struct bfd_symbol *, void *, asection *,
+          bfd *, char **);
+
+       /* The textual name of the relocation type.  */
+       char *name;
+
+       /* Some formats record a relocation addend in the section contents
+          rather than with the relocation.  For ELF formats this is the
+          distinction between USE_REL and USE_RELA (though the code checks
+          for USE_REL == 1/0).  The value of this field is TRUE if the
+          addend is recorded with the section contents; when performing a
+          partial link (ld -r) the section contents (the data) will be
+          modified.  The value of this field is FALSE if addends are
+          recorded with the relocation (in arelent.addend); when performing
+          a partial link the relocation will be modified.
+          All relocations for all ELF USE_RELA targets should set this field
+          to FALSE (values of TRUE should be looked on with suspicion).
+          However, the converse is not true: not all relocations of all ELF
+          USE_REL targets set this field to TRUE.  Why this is so is peculiar
+          to each particular target.  For relocs that aren't used in partial
+          links (e.g. GOT stuff) it doesn't matter what this is set to.  */
+       bfd_boolean partial_inplace;
+
+       /* src_mask selects the part of the instruction (or data) to be used
+          in the relocation sum.  If the target relocations don't have an
+          addend in the reloc, eg. ELF USE_REL, src_mask will normally equal
+          dst_mask to extract the addend from the section contents.  If
+          relocations do have an addend in the reloc, eg. ELF USE_RELA, this
+          field should be zero.  Non-zero values for ELF USE_RELA targets are
+          bogus as in those cases the value in the dst_mask part of the
+          section contents should be treated as garbage.  */
+       bfd_vma src_mask;
+
+       /* dst_mask selects which parts of the instruction (or data) are
+          replaced with a relocated value.  */
+       bfd_vma dst_mask;
+
+       /* When some formats create PC relative instructions, they leave
+          the value of the pc of the place being relocated in the offset
+          slot of the instruction, so that a PC relative relocation can
+          be made just by adding in an ordinary offset (e.g., sun3 a.out).
+          Some formats leave the displacement part of an instruction
+          empty (e.g., m88k bcs); this flag signals the fact.  */
+       bfd_boolean pcrel_offset;
+     };
+   
+2.10.1.3 `The HOWTO Macro'
+..........................
+
+*Description*
+The HOWTO define is horrible and will go away.
+     #define HOWTO(C, R, S, B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC) \
+       { (unsigned) C, R, S, B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC }
+
+   *Description*
+And will be replaced with the totally magic way. But for the moment, we
+are compatible, so do it this way.
+     #define NEWHOWTO(FUNCTION, NAME, SIZE, REL, IN) \
+       HOWTO (0, 0, SIZE, 0, REL, 0, complain_overflow_dont, FUNCTION, \
+              NAME, FALSE, 0, 0, IN)
+
+   *Description*
+This is used to fill in an empty howto entry in an array.
+     #define EMPTY_HOWTO(C) \
+       HOWTO ((C), 0, 0, 0, FALSE, 0, complain_overflow_dont, NULL, \
+              NULL, FALSE, 0, 0, FALSE)
+
+   *Description*
+Helper routine to turn a symbol into a relocation value.
+     #define HOWTO_PREPARE(relocation, symbol)               \
+       {                                                     \
+         if (symbol != NULL)                                 \
+           {                                                 \
+             if (bfd_is_com_section (symbol->section))       \
+               {                                             \
+                 relocation = 0;                             \
+               }                                             \
+             else                                            \
+               {                                             \
+                 relocation = symbol->value;                 \
+               }                                             \
+           }                                                 \
+       }
+
+2.10.1.4 `bfd_get_reloc_size'
+.............................
+
+*Synopsis*
+     unsigned int bfd_get_reloc_size (reloc_howto_type *);
+   *Description*
+For a reloc_howto_type that operates on a fixed number of bytes, this
+returns the number of bytes operated on.
+
+2.10.1.5 `arelent_chain'
+........................
+
+*Description*
+How relocs are tied together in an `asection':
+     typedef struct relent_chain
+     {
+       arelent relent;
+       struct relent_chain *next;
+     }
+     arelent_chain;
+
+2.10.1.6 `bfd_check_overflow'
+.............................
+
+*Synopsis*
+     bfd_reloc_status_type bfd_check_overflow
+        (enum complain_overflow how,
+         unsigned int bitsize,
+         unsigned int rightshift,
+         unsigned int addrsize,
+         bfd_vma relocation);
+   *Description*
+Perform overflow checking on RELOCATION which has BITSIZE significant
+bits and will be shifted right by RIGHTSHIFT bits, on a machine with
+addresses containing ADDRSIZE significant bits.  The result is either of
+`bfd_reloc_ok' or `bfd_reloc_overflow'.
+
+2.10.1.7 `bfd_perform_relocation'
+.................................
+
+*Synopsis*
+     bfd_reloc_status_type bfd_perform_relocation
+        (bfd *abfd,
+         arelent *reloc_entry,
+         void *data,
+         asection *input_section,
+         bfd *output_bfd,
+         char **error_message);
+   *Description*
+If OUTPUT_BFD is supplied to this function, the generated image will be
+relocatable; the relocations are copied to the output file after they
+have been changed to reflect the new state of the world. There are two
+ways of reflecting the results of partial linkage in an output file: by
+modifying the output data in place, and by modifying the relocation
+record.  Some native formats (e.g., basic a.out and basic coff) have no
+way of specifying an addend in the relocation type, so the addend has
+to go in the output data.  This is no big deal since in these formats
+the output data slot will always be big enough for the addend. Complex
+reloc types with addends were invented to solve just this problem.  The
+ERROR_MESSAGE argument is set to an error message if this return
+`bfd_reloc_dangerous'.
+
+2.10.1.8 `bfd_install_relocation'
+.................................
+
+*Synopsis*
+     bfd_reloc_status_type bfd_install_relocation
+        (bfd *abfd,
+         arelent *reloc_entry,
+         void *data, bfd_vma data_start,
+         asection *input_section,
+         char **error_message);
+   *Description*
+This looks remarkably like `bfd_perform_relocation', except it does not
+expect that the section contents have been filled in.  I.e., it's
+suitable for use when creating, rather than applying a relocation.
+
+   For now, this function should be considered reserved for the
+assembler.
+
+
+File: bfd.info,  Node: howto manager,  Prev: typedef arelent,  Up: Relocations
+
+2.10.2 The howto manager
+------------------------
+
+When an application wants to create a relocation, but doesn't know what
+the target machine might call it, it can find out by using this bit of
+code.
+
+2.10.2.1 `bfd_reloc_code_type'
+..............................
+
+*Description*
+The insides of a reloc code.  The idea is that, eventually, there will
+be one enumerator for every type of relocation we ever do.  Pass one of
+these values to `bfd_reloc_type_lookup', and it'll return a howto
+pointer.
+
+   This does mean that the application must determine the correct
+enumerator value; you can't get a howto pointer from a random set of
+attributes.
+
+   Here are the possible values for `enum bfd_reloc_code_real':
+
+ -- : BFD_RELOC_64
+ -- : BFD_RELOC_32
+ -- : BFD_RELOC_26
+ -- : BFD_RELOC_24
+ -- : BFD_RELOC_16
+ -- : BFD_RELOC_14
+ -- : BFD_RELOC_8
+     Basic absolute relocations of N bits.
+
+ -- : BFD_RELOC_64_PCREL
+ -- : BFD_RELOC_32_PCREL
+ -- : BFD_RELOC_24_PCREL
+ -- : BFD_RELOC_16_PCREL
+ -- : BFD_RELOC_12_PCREL
+ -- : BFD_RELOC_8_PCREL
+     PC-relative relocations.  Sometimes these are relative to the
+     address of the relocation itself; sometimes they are relative to
+     the start of the section containing the relocation.  It depends on
+     the specific target.
+
+     The 24-bit relocation is used in some Intel 960 configurations.
+
+ -- : BFD_RELOC_32_SECREL
+     Section relative relocations.  Some targets need this for DWARF2.
+
+ -- : BFD_RELOC_32_GOT_PCREL
+ -- : BFD_RELOC_16_GOT_PCREL
+ -- : BFD_RELOC_8_GOT_PCREL
+ -- : BFD_RELOC_32_GOTOFF
+ -- : BFD_RELOC_16_GOTOFF
+ -- : BFD_RELOC_LO16_GOTOFF
+ -- : BFD_RELOC_HI16_GOTOFF
+ -- : BFD_RELOC_HI16_S_GOTOFF
+ -- : BFD_RELOC_8_GOTOFF
+ -- : BFD_RELOC_64_PLT_PCREL
+ -- : BFD_RELOC_32_PLT_PCREL
+ -- : BFD_RELOC_24_PLT_PCREL
+ -- : BFD_RELOC_16_PLT_PCREL
+ -- : BFD_RELOC_8_PLT_PCREL
+ -- : BFD_RELOC_64_PLTOFF
+ -- : BFD_RELOC_32_PLTOFF
+ -- : BFD_RELOC_16_PLTOFF
+ -- : BFD_RELOC_LO16_PLTOFF
+ -- : BFD_RELOC_HI16_PLTOFF
+ -- : BFD_RELOC_HI16_S_PLTOFF
+ -- : BFD_RELOC_8_PLTOFF
+     For ELF.
+
+ -- : BFD_RELOC_68K_GLOB_DAT
+ -- : BFD_RELOC_68K_JMP_SLOT
+ -- : BFD_RELOC_68K_RELATIVE
+     Relocations used by 68K ELF.
+
+ -- : BFD_RELOC_32_BASEREL
+ -- : BFD_RELOC_16_BASEREL
+ -- : BFD_RELOC_LO16_BASEREL
+ -- : BFD_RELOC_HI16_BASEREL
+ -- : BFD_RELOC_HI16_S_BASEREL
+ -- : BFD_RELOC_8_BASEREL
+ -- : BFD_RELOC_RVA
+     Linkage-table relative.
+
+ -- : BFD_RELOC_8_FFnn
+     Absolute 8-bit relocation, but used to form an address like 0xFFnn.
+
+ -- : BFD_RELOC_32_PCREL_S2
+ -- : BFD_RELOC_16_PCREL_S2
+ -- : BFD_RELOC_23_PCREL_S2
+     These PC-relative relocations are stored as word displacements -
+     i.e., byte displacements shifted right two bits.  The 30-bit word
+     displacement (<<32_PCREL_S2>> - 32 bits, shifted 2) is used on the
+     SPARC.  (SPARC tools generally refer to this as <<WDISP30>>.)  The
+     signed 16-bit displacement is used on the MIPS, and the 23-bit
+     displacement is used on the Alpha.
+
+ -- : BFD_RELOC_HI22
+ -- : BFD_RELOC_LO10
+     High 22 bits and low 10 bits of 32-bit value, placed into lower
+     bits of the target word.  These are used on the SPARC.
+
+ -- : BFD_RELOC_GPREL16
+ -- : BFD_RELOC_GPREL32
+     For systems that allocate a Global Pointer register, these are
+     displacements off that register.  These relocation types are
+     handled specially, because the value the register will have is
+     decided relatively late.
+
+ -- : BFD_RELOC_I960_CALLJ
+     Reloc types used for i960/b.out.
+
+ -- : BFD_RELOC_NONE
+ -- : BFD_RELOC_SPARC_WDISP22
+ -- : BFD_RELOC_SPARC22
+ -- : BFD_RELOC_SPARC13
+ -- : BFD_RELOC_SPARC_GOT10
+ -- : BFD_RELOC_SPARC_GOT13
+ -- : BFD_RELOC_SPARC_GOT22
+ -- : BFD_RELOC_SPARC_PC10
+ -- : BFD_RELOC_SPARC_PC22
+ -- : BFD_RELOC_SPARC_WPLT30
+ -- : BFD_RELOC_SPARC_COPY
+ -- : BFD_RELOC_SPARC_GLOB_DAT
+ -- : BFD_RELOC_SPARC_JMP_SLOT
+ -- : BFD_RELOC_SPARC_RELATIVE
+ -- : BFD_RELOC_SPARC_UA16
+ -- : BFD_RELOC_SPARC_UA32
+ -- : BFD_RELOC_SPARC_UA64
+     SPARC ELF relocations.  There is probably some overlap with other
+     relocation types already defined.
+
+ -- : BFD_RELOC_SPARC_BASE13
+ -- : BFD_RELOC_SPARC_BASE22
+     I think these are specific to SPARC a.out (e.g., Sun 4).
+
+ -- : BFD_RELOC_SPARC_64
+ -- : BFD_RELOC_SPARC_10
+ -- : BFD_RELOC_SPARC_11
+ -- : BFD_RELOC_SPARC_OLO10
+ -- : BFD_RELOC_SPARC_HH22
+ -- : BFD_RELOC_SPARC_HM10
+ -- : BFD_RELOC_SPARC_LM22
+ -- : BFD_RELOC_SPARC_PC_HH22
+ -- : BFD_RELOC_SPARC_PC_HM10
+ -- : BFD_RELOC_SPARC_PC_LM22
+ -- : BFD_RELOC_SPARC_WDISP16
+ -- : BFD_RELOC_SPARC_WDISP19
+ -- : BFD_RELOC_SPARC_7
+ -- : BFD_RELOC_SPARC_6
+ -- : BFD_RELOC_SPARC_5
+ -- : BFD_RELOC_SPARC_DISP64
+ -- : BFD_RELOC_SPARC_PLT32
+ -- : BFD_RELOC_SPARC_PLT64
+ -- : BFD_RELOC_SPARC_HIX22
+ -- : BFD_RELOC_SPARC_LOX10
+ -- : BFD_RELOC_SPARC_H44
+ -- : BFD_RELOC_SPARC_M44
+ -- : BFD_RELOC_SPARC_L44
+ -- : BFD_RELOC_SPARC_REGISTER
+     SPARC64 relocations
+
+ -- : BFD_RELOC_SPARC_REV32
+     SPARC little endian relocation
+
+ -- : BFD_RELOC_SPARC_TLS_GD_HI22
+ -- : BFD_RELOC_SPARC_TLS_GD_LO10
+ -- : BFD_RELOC_SPARC_TLS_GD_ADD
+ -- : BFD_RELOC_SPARC_TLS_GD_CALL
+ -- : BFD_RELOC_SPARC_TLS_LDM_HI22
+ -- : BFD_RELOC_SPARC_TLS_LDM_LO10
+ -- : BFD_RELOC_SPARC_TLS_LDM_ADD
+ -- : BFD_RELOC_SPARC_TLS_LDM_CALL
+ -- : BFD_RELOC_SPARC_TLS_LDO_HIX22
+ -- : BFD_RELOC_SPARC_TLS_LDO_LOX10
+ -- : BFD_RELOC_SPARC_TLS_LDO_ADD
+ -- : BFD_RELOC_SPARC_TLS_IE_HI22
+ -- : BFD_RELOC_SPARC_TLS_IE_LO10
+ -- : BFD_RELOC_SPARC_TLS_IE_LD
+ -- : BFD_RELOC_SPARC_TLS_IE_LDX
+ -- : BFD_RELOC_SPARC_TLS_IE_ADD
+ -- : BFD_RELOC_SPARC_TLS_LE_HIX22
+ -- : BFD_RELOC_SPARC_TLS_LE_LOX10
+ -- : BFD_RELOC_SPARC_TLS_DTPMOD32
+ -- : BFD_RELOC_SPARC_TLS_DTPMOD64
+ -- : BFD_RELOC_SPARC_TLS_DTPOFF32
+ -- : BFD_RELOC_SPARC_TLS_DTPOFF64
+ -- : BFD_RELOC_SPARC_TLS_TPOFF32
+ -- : BFD_RELOC_SPARC_TLS_TPOFF64
+     SPARC TLS relocations
+
+ -- : BFD_RELOC_ALPHA_GPDISP_HI16
+     Alpha ECOFF and ELF relocations.  Some of these treat the symbol or
+     "addend" in some special way.  For GPDISP_HI16 ("gpdisp")
+     relocations, the symbol is ignored when writing; when reading, it
+     will be the absolute section symbol.  The addend is the
+     displacement in bytes of the "lda" instruction from the "ldah"
+     instruction (which is at the address of this reloc).
+
+ -- : BFD_RELOC_ALPHA_GPDISP_LO16
+     For GPDISP_LO16 ("ignore") relocations, the symbol is handled as
+     with GPDISP_HI16 relocs.  The addend is ignored when writing the
+     relocations out, and is filled in with the file's GP value on
+     reading, for convenience.
+
+ -- : BFD_RELOC_ALPHA_GPDISP
+     The ELF GPDISP relocation is exactly the same as the GPDISP_HI16
+     relocation except that there is no accompanying GPDISP_LO16
+     relocation.
+
+ -- : BFD_RELOC_ALPHA_LITERAL
+ -- : BFD_RELOC_ALPHA_ELF_LITERAL
+ -- : BFD_RELOC_ALPHA_LITUSE
+     The Alpha LITERAL/LITUSE relocs are produced by a symbol reference;
+     the assembler turns it into a LDQ instruction to load the address
+     of the symbol, and then fills in a register in the real
+     instruction.
+
+     The LITERAL reloc, at the LDQ instruction, refers to the .lita
+     section symbol.  The addend is ignored when writing, but is filled
+     in with the file's GP value on reading, for convenience, as with
+     the GPDISP_LO16 reloc.
+
+     The ELF_LITERAL reloc is somewhere between 16_GOTOFF and
+     GPDISP_LO16.  It should refer to the symbol to be referenced, as
+     with 16_GOTOFF, but it generates output not based on the position
+     within the .got section, but relative to the GP value chosen for
+     the file during the final link stage.
+
+     The LITUSE reloc, on the instruction using the loaded address,
+     gives information to the linker that it might be able to use to
+     optimize away some literal section references.  The symbol is
+     ignored (read as the absolute section symbol), and the "addend"
+     indicates the type of instruction using the register: 1 - "memory"
+     fmt insn 2 - byte-manipulation (byte offset reg) 3 - jsr (target
+     of branch)
+
+ -- : BFD_RELOC_ALPHA_HINT
+     The HINT relocation indicates a value that should be filled into
+     the "hint" field of a jmp/jsr/ret instruction, for possible branch-
+     prediction logic which may be provided on some processors.
+
+ -- : BFD_RELOC_ALPHA_LINKAGE
+     The LINKAGE relocation outputs a linkage pair in the object file,
+     which is filled by the linker.
+
+ -- : BFD_RELOC_ALPHA_CODEADDR
+     The CODEADDR relocation outputs a STO_CA in the object file, which
+     is filled by the linker.
+
+ -- : BFD_RELOC_ALPHA_GPREL_HI16
+ -- : BFD_RELOC_ALPHA_GPREL_LO16
+     The GPREL_HI/LO relocations together form a 32-bit offset from the
+     GP register.
+
+ -- : BFD_RELOC_ALPHA_BRSGP
+     Like BFD_RELOC_23_PCREL_S2, except that the source and target must
+     share a common GP, and the target address is adjusted for
+     STO_ALPHA_STD_GPLOAD.
+
+ -- : BFD_RELOC_ALPHA_TLSGD
+ -- : BFD_RELOC_ALPHA_TLSLDM
+ -- : BFD_RELOC_ALPHA_DTPMOD64
+ -- : BFD_RELOC_ALPHA_GOTDTPREL16
+ -- : BFD_RELOC_ALPHA_DTPREL64
+ -- : BFD_RELOC_ALPHA_DTPREL_HI16
+ -- : BFD_RELOC_ALPHA_DTPREL_LO16
+ -- : BFD_RELOC_ALPHA_DTPREL16
+ -- : BFD_RELOC_ALPHA_GOTTPREL16
+ -- : BFD_RELOC_ALPHA_TPREL64
+ -- : BFD_RELOC_ALPHA_TPREL_HI16
+ -- : BFD_RELOC_ALPHA_TPREL_LO16
+ -- : BFD_RELOC_ALPHA_TPREL16
+     Alpha thread-local storage relocations.
+
+ -- : BFD_RELOC_MIPS_JMP
+     Bits 27..2 of the relocation address shifted right 2 bits; simple
+     reloc otherwise.
+
+ -- : BFD_RELOC_MIPS16_JMP
+     The MIPS16 jump instruction.
+
+ -- : BFD_RELOC_MIPS16_GPREL
+     MIPS16 GP relative reloc.
+
+ -- : BFD_RELOC_HI16
+     High 16 bits of 32-bit value; simple reloc.
+
+ -- : BFD_RELOC_HI16_S
+     High 16 bits of 32-bit value but the low 16 bits will be sign
+     extended and added to form the final result.  If the low 16 bits
+     form a negative number, we need to add one to the high value to
+     compensate for the borrow when the low bits are added.
+
+ -- : BFD_RELOC_LO16
+     Low 16 bits.
+
+ -- : BFD_RELOC_HI16_PCREL
+     High 16 bits of 32-bit pc-relative value
+
+ -- : BFD_RELOC_HI16_S_PCREL
+     High 16 bits of 32-bit pc-relative value, adjusted
+
+ -- : BFD_RELOC_LO16_PCREL
+     Low 16 bits of pc-relative value
+
+ -- : BFD_RELOC_MIPS16_HI16
+     MIPS16 high 16 bits of 32-bit value.
+
+ -- : BFD_RELOC_MIPS16_HI16_S
+     MIPS16 high 16 bits of 32-bit value but the low 16 bits will be
+     sign extended and added to form the final result.  If the low 16
+     bits form a negative number, we need to add one to the high value
+     to compensate for the borrow when the low bits are added.
+
+ -- : BFD_RELOC_MIPS16_LO16
+     MIPS16 low 16 bits.
+
+ -- : BFD_RELOC_MIPS_LITERAL
+     Relocation against a MIPS literal section.
+
+ -- : BFD_RELOC_MIPS_GOT16
+ -- : BFD_RELOC_MIPS_CALL16
+ -- : BFD_RELOC_MIPS_GOT_HI16
+ -- : BFD_RELOC_MIPS_GOT_LO16
+ -- : BFD_RELOC_MIPS_CALL_HI16
+ -- : BFD_RELOC_MIPS_CALL_LO16
+ -- : BFD_RELOC_MIPS_SUB
+ -- : BFD_RELOC_MIPS_GOT_PAGE
+ -- : BFD_RELOC_MIPS_GOT_OFST
+ -- : BFD_RELOC_MIPS_GOT_DISP
+ -- : BFD_RELOC_MIPS_SHIFT5
+ -- : BFD_RELOC_MIPS_SHIFT6
+ -- : BFD_RELOC_MIPS_INSERT_A
+ -- : BFD_RELOC_MIPS_INSERT_B
+ -- : BFD_RELOC_MIPS_DELETE
+ -- : BFD_RELOC_MIPS_HIGHEST
+ -- : BFD_RELOC_MIPS_HIGHER
+ -- : BFD_RELOC_MIPS_SCN_DISP
+ -- : BFD_RELOC_MIPS_REL16
+ -- : BFD_RELOC_MIPS_RELGOT
+ -- : BFD_RELOC_MIPS_JALR
+ -- : BFD_RELOC_MIPS_TLS_DTPMOD32
+ -- : BFD_RELOC_MIPS_TLS_DTPREL32
+ -- : BFD_RELOC_MIPS_TLS_DTPMOD64
+ -- : BFD_RELOC_MIPS_TLS_DTPREL64
+ -- : BFD_RELOC_MIPS_TLS_GD
+ -- : BFD_RELOC_MIPS_TLS_LDM
+ -- : BFD_RELOC_MIPS_TLS_DTPREL_HI16
+ -- : BFD_RELOC_MIPS_TLS_DTPREL_LO16
+ -- : BFD_RELOC_MIPS_TLS_GOTTPREL
+ -- : BFD_RELOC_MIPS_TLS_TPREL32
+ -- : BFD_RELOC_MIPS_TLS_TPREL64
+ -- : BFD_RELOC_MIPS_TLS_TPREL_HI16
+ -- : BFD_RELOC_MIPS_TLS_TPREL_LO16
+     MIPS ELF relocations.
+
+ -- : BFD_RELOC_FRV_LABEL16
+ -- : BFD_RELOC_FRV_LABEL24
+ -- : BFD_RELOC_FRV_LO16
+ -- : BFD_RELOC_FRV_HI16
+ -- : BFD_RELOC_FRV_GPREL12
+ -- : BFD_RELOC_FRV_GPRELU12
+ -- : BFD_RELOC_FRV_GPREL32
+ -- : BFD_RELOC_FRV_GPRELHI
+ -- : BFD_RELOC_FRV_GPRELLO
+ -- : BFD_RELOC_FRV_GOT12
+ -- : BFD_RELOC_FRV_GOTHI
+ -- : BFD_RELOC_FRV_GOTLO
+ -- : BFD_RELOC_FRV_FUNCDESC
+ -- : BFD_RELOC_FRV_FUNCDESC_GOT12
+ -- : BFD_RELOC_FRV_FUNCDESC_GOTHI
+ -- : BFD_RELOC_FRV_FUNCDESC_GOTLO
+ -- : BFD_RELOC_FRV_FUNCDESC_VALUE
+ -- : BFD_RELOC_FRV_FUNCDESC_GOTOFF12
+ -- : BFD_RELOC_FRV_FUNCDESC_GOTOFFHI
+ -- : BFD_RELOC_FRV_FUNCDESC_GOTOFFLO
+ -- : BFD_RELOC_FRV_GOTOFF12
+ -- : BFD_RELOC_FRV_GOTOFFHI
+ -- : BFD_RELOC_FRV_GOTOFFLO
+ -- : BFD_RELOC_FRV_GETTLSOFF
+ -- : BFD_RELOC_FRV_TLSDESC_VALUE
+ -- : BFD_RELOC_FRV_GOTTLSDESC12
+ -- : BFD_RELOC_FRV_GOTTLSDESCHI
+ -- : BFD_RELOC_FRV_GOTTLSDESCLO
+ -- : BFD_RELOC_FRV_TLSMOFF12
+ -- : BFD_RELOC_FRV_TLSMOFFHI
+ -- : BFD_RELOC_FRV_TLSMOFFLO
+ -- : BFD_RELOC_FRV_GOTTLSOFF12
+ -- : BFD_RELOC_FRV_GOTTLSOFFHI
+ -- : BFD_RELOC_FRV_GOTTLSOFFLO
+ -- : BFD_RELOC_FRV_TLSOFF
+ -- : BFD_RELOC_FRV_TLSDESC_RELAX
+ -- : BFD_RELOC_FRV_GETTLSOFF_RELAX
+ -- : BFD_RELOC_FRV_TLSOFF_RELAX
+ -- : BFD_RELOC_FRV_TLSMOFF
+     Fujitsu Frv Relocations.
+
+ -- : BFD_RELOC_MN10300_GOTOFF24
+     This is a 24bit GOT-relative reloc for the mn10300.
+
+ -- : BFD_RELOC_MN10300_GOT32
+     This is a 32bit GOT-relative reloc for the mn10300, offset by two
+     bytes in the instruction.
+
+ -- : BFD_RELOC_MN10300_GOT24
+     This is a 24bit GOT-relative reloc for the mn10300, offset by two
+     bytes in the instruction.
+
+ -- : BFD_RELOC_MN10300_GOT16
+     This is a 16bit GOT-relative reloc for the mn10300, offset by two
+     bytes in the instruction.
+
+ -- : BFD_RELOC_MN10300_COPY
+     Copy symbol at runtime.
+
+ -- : BFD_RELOC_MN10300_GLOB_DAT
+     Create GOT entry.
+
+ -- : BFD_RELOC_MN10300_JMP_SLOT
+     Create PLT entry.
+
+ -- : BFD_RELOC_MN10300_RELATIVE
+     Adjust by program base.
+
+ -- : BFD_RELOC_386_GOT32
+ -- : BFD_RELOC_386_PLT32
+ -- : BFD_RELOC_386_COPY
+ -- : BFD_RELOC_386_GLOB_DAT
+ -- : BFD_RELOC_386_JUMP_SLOT
+ -- : BFD_RELOC_386_RELATIVE
+ -- : BFD_RELOC_386_GOTOFF
+ -- : BFD_RELOC_386_GOTPC
+ -- : BFD_RELOC_386_TLS_TPOFF
+ -- : BFD_RELOC_386_TLS_IE
+ -- : BFD_RELOC_386_TLS_GOTIE
+ -- : BFD_RELOC_386_TLS_LE
+ -- : BFD_RELOC_386_TLS_GD
+ -- : BFD_RELOC_386_TLS_LDM
+ -- : BFD_RELOC_386_TLS_LDO_32
+ -- : BFD_RELOC_386_TLS_IE_32
+ -- : BFD_RELOC_386_TLS_LE_32
+ -- : BFD_RELOC_386_TLS_DTPMOD32
+ -- : BFD_RELOC_386_TLS_DTPOFF32
+ -- : BFD_RELOC_386_TLS_TPOFF32
+     i386/elf relocations
+
+ -- : BFD_RELOC_X86_64_GOT32
+ -- : BFD_RELOC_X86_64_PLT32
+ -- : BFD_RELOC_X86_64_COPY
+ -- : BFD_RELOC_X86_64_GLOB_DAT
+ -- : BFD_RELOC_X86_64_JUMP_SLOT
+ -- : BFD_RELOC_X86_64_RELATIVE
+ -- : BFD_RELOC_X86_64_GOTPCREL
+ -- : BFD_RELOC_X86_64_32S
+ -- : BFD_RELOC_X86_64_DTPMOD64
+ -- : BFD_RELOC_X86_64_DTPOFF64
+ -- : BFD_RELOC_X86_64_TPOFF64
+ -- : BFD_RELOC_X86_64_TLSGD
+ -- : BFD_RELOC_X86_64_TLSLD
+ -- : BFD_RELOC_X86_64_DTPOFF32
+ -- : BFD_RELOC_X86_64_GOTTPOFF
+ -- : BFD_RELOC_X86_64_TPOFF32
+ -- : BFD_RELOC_X86_64_GOTOFF64
+ -- : BFD_RELOC_X86_64_GOTPC32
+     x86-64/elf relocations
+
+ -- : BFD_RELOC_NS32K_IMM_8
+ -- : BFD_RELOC_NS32K_IMM_16
+ -- : BFD_RELOC_NS32K_IMM_32
+ -- : BFD_RELOC_NS32K_IMM_8_PCREL
+ -- : BFD_RELOC_NS32K_IMM_16_PCREL
+ -- : BFD_RELOC_NS32K_IMM_32_PCREL
+ -- : BFD_RELOC_NS32K_DISP_8
+ -- : BFD_RELOC_NS32K_DISP_16
+ -- : BFD_RELOC_NS32K_DISP_32
+ -- : BFD_RELOC_NS32K_DISP_8_PCREL
+ -- : BFD_RELOC_NS32K_DISP_16_PCREL
+ -- : BFD_RELOC_NS32K_DISP_32_PCREL
+     ns32k relocations
+
+ -- : BFD_RELOC_PDP11_DISP_8_PCREL
+ -- : BFD_RELOC_PDP11_DISP_6_PCREL
+     PDP11 relocations
+
+ -- : BFD_RELOC_PJ_CODE_HI16
+ -- : BFD_RELOC_PJ_CODE_LO16
+ -- : BFD_RELOC_PJ_CODE_DIR16
+ -- : BFD_RELOC_PJ_CODE_DIR32
+ -- : BFD_RELOC_PJ_CODE_REL16
+ -- : BFD_RELOC_PJ_CODE_REL32
+     Picojava relocs.  Not all of these appear in object files.
+
+ -- : BFD_RELOC_PPC_B26
+ -- : BFD_RELOC_PPC_BA26
+ -- : BFD_RELOC_PPC_TOC16
+ -- : BFD_RELOC_PPC_B16
+ -- : BFD_RELOC_PPC_B16_BRTAKEN
+ -- : BFD_RELOC_PPC_B16_BRNTAKEN
+ -- : BFD_RELOC_PPC_BA16
+ -- : BFD_RELOC_PPC_BA16_BRTAKEN
+ -- : BFD_RELOC_PPC_BA16_BRNTAKEN
+ -- : BFD_RELOC_PPC_COPY
+ -- : BFD_RELOC_PPC_GLOB_DAT
+ -- : BFD_RELOC_PPC_JMP_SLOT
+ -- : BFD_RELOC_PPC_RELATIVE
+ -- : BFD_RELOC_PPC_LOCAL24PC
+ -- : BFD_RELOC_PPC_EMB_NADDR32
+ -- : BFD_RELOC_PPC_EMB_NADDR16
+ -- : BFD_RELOC_PPC_EMB_NADDR16_LO
+ -- : BFD_RELOC_PPC_EMB_NADDR16_HI
+ -- : BFD_RELOC_PPC_EMB_NADDR16_HA
+ -- : BFD_RELOC_PPC_EMB_SDAI16
+ -- : BFD_RELOC_PPC_EMB_SDA2I16
+ -- : BFD_RELOC_PPC_EMB_SDA2REL
+ -- : BFD_RELOC_PPC_EMB_SDA21
+ -- : BFD_RELOC_PPC_EMB_MRKREF
+ -- : BFD_RELOC_PPC_EMB_RELSEC16
+ -- : BFD_RELOC_PPC_EMB_RELST_LO
+ -- : BFD_RELOC_PPC_EMB_RELST_HI
+ -- : BFD_RELOC_PPC_EMB_RELST_HA
+ -- : BFD_RELOC_PPC_EMB_BIT_FLD
+ -- : BFD_RELOC_PPC_EMB_RELSDA
+ -- : BFD_RELOC_PPC64_HIGHER
+ -- : BFD_RELOC_PPC64_HIGHER_S
+ -- : BFD_RELOC_PPC64_HIGHEST
+ -- : BFD_RELOC_PPC64_HIGHEST_S
+ -- : BFD_RELOC_PPC64_TOC16_LO
+ -- : BFD_RELOC_PPC64_TOC16_HI
+ -- : BFD_RELOC_PPC64_TOC16_HA
+ -- : BFD_RELOC_PPC64_TOC
+ -- : BFD_RELOC_PPC64_PLTGOT16
+ -- : BFD_RELOC_PPC64_PLTGOT16_LO
+ -- : BFD_RELOC_PPC64_PLTGOT16_HI
+ -- : BFD_RELOC_PPC64_PLTGOT16_HA
+ -- : BFD_RELOC_PPC64_ADDR16_DS
+ -- : BFD_RELOC_PPC64_ADDR16_LO_DS
+ -- : BFD_RELOC_PPC64_GOT16_DS
+ -- : BFD_RELOC_PPC64_GOT16_LO_DS
+ -- : BFD_RELOC_PPC64_PLT16_LO_DS
+ -- : BFD_RELOC_PPC64_SECTOFF_DS
+ -- : BFD_RELOC_PPC64_SECTOFF_LO_DS
+ -- : BFD_RELOC_PPC64_TOC16_DS
+ -- : BFD_RELOC_PPC64_TOC16_LO_DS
+ -- : BFD_RELOC_PPC64_PLTGOT16_DS
+ -- : BFD_RELOC_PPC64_PLTGOT16_LO_DS
+     Power(rs6000) and PowerPC relocations.
+
+ -- : BFD_RELOC_PPC_TLS
+ -- : BFD_RELOC_PPC_DTPMOD
+ -- : BFD_RELOC_PPC_TPREL16
+ -- : BFD_RELOC_PPC_TPREL16_LO
+ -- : BFD_RELOC_PPC_TPREL16_HI
+ -- : BFD_RELOC_PPC_TPREL16_HA
+ -- : BFD_RELOC_PPC_TPREL
+ -- : BFD_RELOC_PPC_DTPREL16
+ -- : BFD_RELOC_PPC_DTPREL16_LO
+ -- : BFD_RELOC_PPC_DTPREL16_HI
+ -- : BFD_RELOC_PPC_DTPREL16_HA
+ -- : BFD_RELOC_PPC_DTPREL
+ -- : BFD_RELOC_PPC_GOT_TLSGD16
+ -- : BFD_RELOC_PPC_GOT_TLSGD16_LO
+ -- : BFD_RELOC_PPC_GOT_TLSGD16_HI
+ -- : BFD_RELOC_PPC_GOT_TLSGD16_HA
+ -- : BFD_RELOC_PPC_GOT_TLSLD16
+ -- : BFD_RELOC_PPC_GOT_TLSLD16_LO
+ -- : BFD_RELOC_PPC_GOT_TLSLD16_HI
+ -- : BFD_RELOC_PPC_GOT_TLSLD16_HA
+ -- : BFD_RELOC_PPC_GOT_TPREL16
+ -- : BFD_RELOC_PPC_GOT_TPREL16_LO
+ -- : BFD_RELOC_PPC_GOT_TPREL16_HI
+ -- : BFD_RELOC_PPC_GOT_TPREL16_HA
+ -- : BFD_RELOC_PPC_GOT_DTPREL16
+ -- : BFD_RELOC_PPC_GOT_DTPREL16_LO
+ -- : BFD_RELOC_PPC_GOT_DTPREL16_HI
+ -- : BFD_RELOC_PPC_GOT_DTPREL16_HA
+ -- : BFD_RELOC_PPC64_TPREL16_DS
+ -- : BFD_RELOC_PPC64_TPREL16_LO_DS
+ -- : BFD_RELOC_PPC64_TPREL16_HIGHER
+ -- : BFD_RELOC_PPC64_TPREL16_HIGHERA
+ -- : BFD_RELOC_PPC64_TPREL16_HIGHEST
+ -- : BFD_RELOC_PPC64_TPREL16_HIGHESTA
+ -- : BFD_RELOC_PPC64_DTPREL16_DS
+ -- : BFD_RELOC_PPC64_DTPREL16_LO_DS
+ -- : BFD_RELOC_PPC64_DTPREL16_HIGHER
+ -- : BFD_RELOC_PPC64_DTPREL16_HIGHERA
+ -- : BFD_RELOC_PPC64_DTPREL16_HIGHEST
+ -- : BFD_RELOC_PPC64_DTPREL16_HIGHESTA
+     PowerPC and PowerPC64 thread-local storage relocations.
+
+ -- : BFD_RELOC_I370_D12
+     IBM 370/390 relocations
+
+ -- : BFD_RELOC_CTOR
+     The type of reloc used to build a constructor table - at the moment
+     probably a 32 bit wide absolute relocation, but the target can
+     choose.  It generally does map to one of the other relocation
+     types.
+
+ -- : BFD_RELOC_ARM_PCREL_BRANCH
+     ARM 26 bit pc-relative branch.  The lowest two bits must be zero
+     and are not stored in the instruction.
+
+ -- : BFD_RELOC_ARM_PCREL_BLX
+     ARM 26 bit pc-relative branch.  The lowest bit must be zero and is
+     not stored in the instruction.  The 2nd lowest bit comes from a 1
+     bit field in the instruction.
+
+ -- : BFD_RELOC_THUMB_PCREL_BLX
+     Thumb 22 bit pc-relative branch.  The lowest bit must be zero and
+     is not stored in the instruction.  The 2nd lowest bit comes from a
+     1 bit field in the instruction.
+
+ -- : BFD_RELOC_THUMB_PCREL_BRANCH7
+ -- : BFD_RELOC_THUMB_PCREL_BRANCH9
+ -- : BFD_RELOC_THUMB_PCREL_BRANCH12
+ -- : BFD_RELOC_THUMB_PCREL_BRANCH20
+ -- : BFD_RELOC_THUMB_PCREL_BRANCH23
+ -- : BFD_RELOC_THUMB_PCREL_BRANCH25
+     Thumb 7-, 9-, 12-, 20-, 23-, and 25-bit pc-relative branches.  The
+     lowest bit must be zero and is not stored in the instruction.
+     Note that the corresponding ELF R_ARM_THM_JUMPnn constant has an
+     "nn" one smaller in all cases.  Note further that BRANCH23
+     corresponds to R_ARM_THM_CALL.
+
+ -- : BFD_RELOC_ARM_OFFSET_IMM
+     12-bit immediate offset, used in ARM-format ldr and str
+     instructions.
+
+ -- : BFD_RELOC_ARM_THUMB_OFFSET
+     5-bit immediate offset, used in Thumb-format ldr and str
+     instructions.
+
+ -- : BFD_RELOC_ARM_TARGET1
+     Pc-relative or absolute relocation depending on target.  Used for
+     entries in .init_array sections.
+
+ -- : BFD_RELOC_ARM_ROSEGREL32
+     Read-only segment base relative address.
+
+ -- : BFD_RELOC_ARM_SBREL32
+     Data segment base relative address.
+
+ -- : BFD_RELOC_ARM_TARGET2
+     This reloc is used for references to RTTI data from exception
+     handling tables.  The actual definition depends on the target.  It
+     may be a pc-relative or some form of GOT-indirect relocation.
+
+ -- : BFD_RELOC_ARM_PREL31
+     31-bit PC relative address.
+
+ -- : BFD_RELOC_ARM_JUMP_SLOT
+ -- : BFD_RELOC_ARM_GLOB_DAT
+ -- : BFD_RELOC_ARM_GOT32
+ -- : BFD_RELOC_ARM_PLT32
+ -- : BFD_RELOC_ARM_RELATIVE
+ -- : BFD_RELOC_ARM_GOTOFF
+ -- : BFD_RELOC_ARM_GOTPC
+     Relocations for setting up GOTs and PLTs for shared libraries.
+
+ -- : BFD_RELOC_ARM_TLS_GD32
+ -- : BFD_RELOC_ARM_TLS_LDO32
+ -- : BFD_RELOC_ARM_TLS_LDM32
+ -- : BFD_RELOC_ARM_TLS_DTPOFF32
+ -- : BFD_RELOC_ARM_TLS_DTPMOD32
+ -- : BFD_RELOC_ARM_TLS_TPOFF32
+ -- : BFD_RELOC_ARM_TLS_IE32
+ -- : BFD_RELOC_ARM_TLS_LE32
+     ARM thread-local storage relocations.
+
+ -- : BFD_RELOC_ARM_IMMEDIATE
+ -- : BFD_RELOC_ARM_ADRL_IMMEDIATE
+ -- : BFD_RELOC_ARM_T32_IMMEDIATE
+ -- : BFD_RELOC_ARM_T32_IMM12
+ -- : BFD_RELOC_ARM_T32_ADD_PC12
+ -- : BFD_RELOC_ARM_SHIFT_IMM
+ -- : BFD_RELOC_ARM_SMC
+ -- : BFD_RELOC_ARM_SWI
+ -- : BFD_RELOC_ARM_MULTI
+ -- : BFD_RELOC_ARM_CP_OFF_IMM
+ -- : BFD_RELOC_ARM_CP_OFF_IMM_S2
+ -- : BFD_RELOC_ARM_T32_CP_OFF_IMM
+ -- : BFD_RELOC_ARM_T32_CP_OFF_IMM_S2
+ -- : BFD_RELOC_ARM_ADR_IMM
+ -- : BFD_RELOC_ARM_LDR_IMM
+ -- : BFD_RELOC_ARM_LITERAL
+ -- : BFD_RELOC_ARM_IN_POOL
+ -- : BFD_RELOC_ARM_OFFSET_IMM8
+ -- : BFD_RELOC_ARM_T32_OFFSET_U8
+ -- : BFD_RELOC_ARM_T32_OFFSET_IMM
+ -- : BFD_RELOC_ARM_HWLITERAL
+ -- : BFD_RELOC_ARM_THUMB_ADD
+ -- : BFD_RELOC_ARM_THUMB_IMM
+ -- : BFD_RELOC_ARM_THUMB_SHIFT
+     These relocs are only used within the ARM assembler.  They are not
+     (at present) written to any object files.
+
+ -- : BFD_RELOC_SH_PCDISP8BY2
+ -- : BFD_RELOC_SH_PCDISP12BY2
+ -- : BFD_RELOC_SH_IMM3
+ -- : BFD_RELOC_SH_IMM3U
+ -- : BFD_RELOC_SH_DISP12
+ -- : BFD_RELOC_SH_DISP12BY2
+ -- : BFD_RELOC_SH_DISP12BY4
+ -- : BFD_RELOC_SH_DISP12BY8
+ -- : BFD_RELOC_SH_DISP20
+ -- : BFD_RELOC_SH_DISP20BY8
+ -- : BFD_RELOC_SH_IMM4
+ -- : BFD_RELOC_SH_IMM4BY2
+ -- : BFD_RELOC_SH_IMM4BY4
+ -- : BFD_RELOC_SH_IMM8
+ -- : BFD_RELOC_SH_IMM8BY2
+ -- : BFD_RELOC_SH_IMM8BY4
+ -- : BFD_RELOC_SH_PCRELIMM8BY2
+ -- : BFD_RELOC_SH_PCRELIMM8BY4
+ -- : BFD_RELOC_SH_SWITCH16
+ -- : BFD_RELOC_SH_SWITCH32
+ -- : BFD_RELOC_SH_USES
+ -- : BFD_RELOC_SH_COUNT
+ -- : BFD_RELOC_SH_ALIGN
+ -- : BFD_RELOC_SH_CODE
+ -- : BFD_RELOC_SH_DATA
+ -- : BFD_RELOC_SH_LABEL
+ -- : BFD_RELOC_SH_LOOP_START
+ -- : BFD_RELOC_SH_LOOP_END
+ -- : BFD_RELOC_SH_COPY
+ -- : BFD_RELOC_SH_GLOB_DAT
+ -- : BFD_RELOC_SH_JMP_SLOT
+ -- : BFD_RELOC_SH_RELATIVE
+ -- : BFD_RELOC_SH_GOTPC
+ -- : BFD_RELOC_SH_GOT_LOW16
+ -- : BFD_RELOC_SH_GOT_MEDLOW16
+ -- : BFD_RELOC_SH_GOT_MEDHI16
+ -- : BFD_RELOC_SH_GOT_HI16
+ -- : BFD_RELOC_SH_GOTPLT_LOW16
+ -- : BFD_RELOC_SH_GOTPLT_MEDLOW16
+ -- : BFD_RELOC_SH_GOTPLT_MEDHI16
+ -- : BFD_RELOC_SH_GOTPLT_HI16
+ -- : BFD_RELOC_SH_PLT_LOW16
+ -- : BFD_RELOC_SH_PLT_MEDLOW16
+ -- : BFD_RELOC_SH_PLT_MEDHI16
+ -- : BFD_RELOC_SH_PLT_HI16
+ -- : BFD_RELOC_SH_GOTOFF_LOW16
+ -- : BFD_RELOC_SH_GOTOFF_MEDLOW16
+ -- : BFD_RELOC_SH_GOTOFF_MEDHI16
+ -- : BFD_RELOC_SH_GOTOFF_HI16
+ -- : BFD_RELOC_SH_GOTPC_LOW16
+ -- : BFD_RELOC_SH_GOTPC_MEDLOW16
+ -- : BFD_RELOC_SH_GOTPC_MEDHI16
+ -- : BFD_RELOC_SH_GOTPC_HI16
+ -- : BFD_RELOC_SH_COPY64
+ -- : BFD_RELOC_SH_GLOB_DAT64
+ -- : BFD_RELOC_SH_JMP_SLOT64
+ -- : BFD_RELOC_SH_RELATIVE64
+ -- : BFD_RELOC_SH_GOT10BY4
+ -- : BFD_RELOC_SH_GOT10BY8
+ -- : BFD_RELOC_SH_GOTPLT10BY4
+ -- : BFD_RELOC_SH_GOTPLT10BY8
+ -- : BFD_RELOC_SH_GOTPLT32
+ -- : BFD_RELOC_SH_SHMEDIA_CODE
+ -- : BFD_RELOC_SH_IMMU5
+ -- : BFD_RELOC_SH_IMMS6
+ -- : BFD_RELOC_SH_IMMS6BY32
+ -- : BFD_RELOC_SH_IMMU6
+ -- : BFD_RELOC_SH_IMMS10
+ -- : BFD_RELOC_SH_IMMS10BY2
+ -- : BFD_RELOC_SH_IMMS10BY4
+ -- : BFD_RELOC_SH_IMMS10BY8
+ -- : BFD_RELOC_SH_IMMS16
+ -- : BFD_RELOC_SH_IMMU16
+ -- : BFD_RELOC_SH_IMM_LOW16
+ -- : BFD_RELOC_SH_IMM_LOW16_PCREL
+ -- : BFD_RELOC_SH_IMM_MEDLOW16
+ -- : BFD_RELOC_SH_IMM_MEDLOW16_PCREL
+ -- : BFD_RELOC_SH_IMM_MEDHI16
+ -- : BFD_RELOC_SH_IMM_MEDHI16_PCREL
+ -- : BFD_RELOC_SH_IMM_HI16
+ -- : BFD_RELOC_SH_IMM_HI16_PCREL
+ -- : BFD_RELOC_SH_PT_16
+ -- : BFD_RELOC_SH_TLS_GD_32
+ -- : BFD_RELOC_SH_TLS_LD_32
+ -- : BFD_RELOC_SH_TLS_LDO_32
+ -- : BFD_RELOC_SH_TLS_IE_32
+ -- : BFD_RELOC_SH_TLS_LE_32
+ -- : BFD_RELOC_SH_TLS_DTPMOD32
+ -- : BFD_RELOC_SH_TLS_DTPOFF32
+ -- : BFD_RELOC_SH_TLS_TPOFF32
+     Renesas / SuperH SH relocs.  Not all of these appear in object
+     files.
+
+ -- : BFD_RELOC_ARC_B22_PCREL
+     ARC Cores relocs.  ARC 22 bit pc-relative branch.  The lowest two
+     bits must be zero and are not stored in the instruction.  The high
+     20 bits are installed in bits 26 through 7 of the instruction.
+
+ -- : BFD_RELOC_ARC_B26
+     ARC 26 bit absolute branch.  The lowest two bits must be zero and
+     are not stored in the instruction.  The high 24 bits are installed
+     in bits 23 through 0.
+
+ -- : BFD_RELOC_BFIN_16_IMM
+     ADI Blackfin 16 bit immediate absolute reloc.
+
+ -- : BFD_RELOC_BFIN_16_HIGH
+     ADI Blackfin 16 bit immediate absolute reloc higher 16 bits.
+
+ -- : BFD_RELOC_BFIN_4_PCREL
+     ADI Blackfin 'a' part of LSETUP.
+
+ -- : BFD_RELOC_BFIN_5_PCREL
+     ADI Blackfin.
+
+ -- : BFD_RELOC_BFIN_16_LOW
+     ADI Blackfin 16 bit immediate absolute reloc lower 16 bits.
+
+ -- : BFD_RELOC_BFIN_10_PCREL
+     ADI Blackfin.
+
+ -- : BFD_RELOC_BFIN_11_PCREL
+     ADI Blackfin 'b' part of LSETUP.
+
+ -- : BFD_RELOC_BFIN_12_PCREL_JUMP
+     ADI Blackfin.
+
+ -- : BFD_RELOC_BFIN_12_PCREL_JUMP_S
+     ADI Blackfin Short jump, pcrel.
+
+ -- : BFD_RELOC_BFIN_24_PCREL_CALL_X
+     ADI Blackfin Call.x not implemented.
+
+ -- : BFD_RELOC_BFIN_24_PCREL_JUMP_L
+     ADI Blackfin Long Jump pcrel.
+
+ -- : BFD_RELOC_BFIN_GOT
+     ADI Blackfin GOT relocation.
+
+ -- : BFD_RELOC_BFIN_PLTPC
+     ADI Blackfin PLTPC relocation.
+
+ -- : BFD_ARELOC_BFIN_PUSH
+     ADI Blackfin arithmetic relocation.
+
+ -- : BFD_ARELOC_BFIN_CONST
+     ADI Blackfin arithmetic relocation.
+
+ -- : BFD_ARELOC_BFIN_ADD
+     ADI Blackfin arithmetic relocation.
+
+ -- : BFD_ARELOC_BFIN_SUB
+     ADI Blackfin arithmetic relocation.
+
+ -- : BFD_ARELOC_BFIN_MULT
+     ADI Blackfin arithmetic relocation.
+
+ -- : BFD_ARELOC_BFIN_DIV
+     ADI Blackfin arithmetic relocation.
+
+ -- : BFD_ARELOC_BFIN_MOD
+     ADI Blackfin arithmetic relocation.
+
+ -- : BFD_ARELOC_BFIN_LSHIFT
+     ADI Blackfin arithmetic relocation.
+
+ -- : BFD_ARELOC_BFIN_RSHIFT
+     ADI Blackfin arithmetic relocation.
+
+ -- : BFD_ARELOC_BFIN_AND
+     ADI Blackfin arithmetic relocation.
+
+ -- : BFD_ARELOC_BFIN_OR
+     ADI Blackfin arithmetic relocation.
+
+ -- : BFD_ARELOC_BFIN_XOR
+     ADI Blackfin arithmetic relocation.
+
+ -- : BFD_ARELOC_BFIN_LAND
+     ADI Blackfin arithmetic relocation.
+
+ -- : BFD_ARELOC_BFIN_LOR
+     ADI Blackfin arithmetic relocation.
+
+ -- : BFD_ARELOC_BFIN_LEN
+     ADI Blackfin arithmetic relocation.
+
+ -- : BFD_ARELOC_BFIN_NEG
+     ADI Blackfin arithmetic relocation.
+
+ -- : BFD_ARELOC_BFIN_COMP
+     ADI Blackfin arithmetic relocation.
+
+ -- : BFD_ARELOC_BFIN_PAGE
+     ADI Blackfin arithmetic relocation.
+
+ -- : BFD_ARELOC_BFIN_HWPAGE
+     ADI Blackfin arithmetic relocation.
+
+ -- : BFD_ARELOC_BFIN_ADDR
+     ADI Blackfin arithmetic relocation.
+
+ -- : BFD_RELOC_D10V_10_PCREL_R
+     Mitsubishi D10V relocs.  This is a 10-bit reloc with the right 2
+     bits assumed to be 0.
+
+ -- : BFD_RELOC_D10V_10_PCREL_L
+     Mitsubishi D10V relocs.  This is a 10-bit reloc with the right 2
+     bits assumed to be 0.  This is the same as the previous reloc
+     except it is in the left container, i.e., shifted left 15 bits.
+
+ -- : BFD_RELOC_D10V_18
+     This is an 18-bit reloc with the right 2 bits assumed to be 0.
+
+ -- : BFD_RELOC_D10V_18_PCREL
+     This is an 18-bit reloc with the right 2 bits assumed to be 0.
+
+ -- : BFD_RELOC_D30V_6
+     Mitsubishi D30V relocs.  This is a 6-bit absolute reloc.
+
+ -- : BFD_RELOC_D30V_9_PCREL
+     This is a 6-bit pc-relative reloc with the right 3 bits assumed to
+     be 0.
+
+ -- : BFD_RELOC_D30V_9_PCREL_R
+     This is a 6-bit pc-relative reloc with the right 3 bits assumed to
+     be 0. Same as the previous reloc but on the right side of the
+     container.
+
+ -- : BFD_RELOC_D30V_15
+     This is a 12-bit absolute reloc with the right 3 bitsassumed to be
+     0.
+
+ -- : BFD_RELOC_D30V_15_PCREL
+     This is a 12-bit pc-relative reloc with the right 3 bits assumed
+     to be 0.
+
+ -- : BFD_RELOC_D30V_15_PCREL_R
+     This is a 12-bit pc-relative reloc with the right 3 bits assumed
+     to be 0. Same as the previous reloc but on the right side of the
+     container.
+
+ -- : BFD_RELOC_D30V_21
+     This is an 18-bit absolute reloc with the right 3 bits assumed to
+     be 0.
+
+ -- : BFD_RELOC_D30V_21_PCREL
+     This is an 18-bit pc-relative reloc with the right 3 bits assumed
+     to be 0.
+
+ -- : BFD_RELOC_D30V_21_PCREL_R
+     This is an 18-bit pc-relative reloc with the right 3 bits assumed
+     to be 0. Same as the previous reloc but on the right side of the
+     container.
+
+ -- : BFD_RELOC_D30V_32
+     This is a 32-bit absolute reloc.
+
+ -- : BFD_RELOC_D30V_32_PCREL
+     This is a 32-bit pc-relative reloc.
+
+ -- : BFD_RELOC_DLX_HI16_S
+     DLX relocs
+
+ -- : BFD_RELOC_DLX_LO16
+     DLX relocs
+
+ -- : BFD_RELOC_DLX_JMP26
+     DLX relocs
+
+ -- : BFD_RELOC_M32C_HI8
+     Renesas M16C/M32C Relocations.
+
+ -- : BFD_RELOC_M32R_24
+     Renesas M32R (formerly Mitsubishi M32R) relocs.  This is a 24 bit
+     absolute address.
+
+ -- : BFD_RELOC_M32R_10_PCREL
+     This is a 10-bit pc-relative reloc with the right 2 bits assumed
+     to be 0.
+
+ -- : BFD_RELOC_M32R_18_PCREL
+     This is an 18-bit reloc with the right 2 bits assumed to be 0.
+
+ -- : BFD_RELOC_M32R_26_PCREL
+     This is a 26-bit reloc with the right 2 bits assumed to be 0.
+
+ -- : BFD_RELOC_M32R_HI16_ULO
+     This is a 16-bit reloc containing the high 16 bits of an address
+     used when the lower 16 bits are treated as unsigned.
+
+ -- : BFD_RELOC_M32R_HI16_SLO
+     This is a 16-bit reloc containing the high 16 bits of an address
+     used when the lower 16 bits are treated as signed.
+
+ -- : BFD_RELOC_M32R_LO16
+     This is a 16-bit reloc containing the lower 16 bits of an address.
+
+ -- : BFD_RELOC_M32R_SDA16
+     This is a 16-bit reloc containing the small data area offset for
+     use in add3, load, and store instructions.
+
+ -- : BFD_RELOC_M32R_GOT24
+ -- : BFD_RELOC_M32R_26_PLTREL
+ -- : BFD_RELOC_M32R_COPY
+ -- : BFD_RELOC_M32R_GLOB_DAT
+ -- : BFD_RELOC_M32R_JMP_SLOT
+ -- : BFD_RELOC_M32R_RELATIVE
+ -- : BFD_RELOC_M32R_GOTOFF
+ -- : BFD_RELOC_M32R_GOTOFF_HI_ULO
+ -- : BFD_RELOC_M32R_GOTOFF_HI_SLO
+ -- : BFD_RELOC_M32R_GOTOFF_LO
+ -- : BFD_RELOC_M32R_GOTPC24
+ -- : BFD_RELOC_M32R_GOT16_HI_ULO
+ -- : BFD_RELOC_M32R_GOT16_HI_SLO
+ -- : BFD_RELOC_M32R_GOT16_LO
+ -- : BFD_RELOC_M32R_GOTPC_HI_ULO
+ -- : BFD_RELOC_M32R_GOTPC_HI_SLO
+ -- : BFD_RELOC_M32R_GOTPC_LO
+     For PIC.
+
+ -- : BFD_RELOC_V850_9_PCREL
+     This is a 9-bit reloc
+
+ -- : BFD_RELOC_V850_22_PCREL
+     This is a 22-bit reloc
+
+ -- : BFD_RELOC_V850_SDA_16_16_OFFSET
+     This is a 16 bit offset from the short data area pointer.
+
+ -- : BFD_RELOC_V850_SDA_15_16_OFFSET
+     This is a 16 bit offset (of which only 15 bits are used) from the
+     short data area pointer.
+
+ -- : BFD_RELOC_V850_ZDA_16_16_OFFSET
+     This is a 16 bit offset from the zero data area pointer.
+
+ -- : BFD_RELOC_V850_ZDA_15_16_OFFSET
+     This is a 16 bit offset (of which only 15 bits are used) from the
+     zero data area pointer.
+
+ -- : BFD_RELOC_V850_TDA_6_8_OFFSET
+     This is an 8 bit offset (of which only 6 bits are used) from the
+     tiny data area pointer.
+
+ -- : BFD_RELOC_V850_TDA_7_8_OFFSET
+     This is an 8bit offset (of which only 7 bits are used) from the
+     tiny data area pointer.
+
+ -- : BFD_RELOC_V850_TDA_7_7_OFFSET
+     This is a 7 bit offset from the tiny data area pointer.
+
+ -- : BFD_RELOC_V850_TDA_16_16_OFFSET
+     This is a 16 bit offset from the tiny data area pointer.
+
+ -- : BFD_RELOC_V850_TDA_4_5_OFFSET
+     This is a 5 bit offset (of which only 4 bits are used) from the
+     tiny data area pointer.
+
+ -- : BFD_RELOC_V850_TDA_4_4_OFFSET
+     This is a 4 bit offset from the tiny data area pointer.
+
+ -- : BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET
+     This is a 16 bit offset from the short data area pointer, with the
+     bits placed non-contiguously in the instruction.
+
+ -- : BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET
+     This is a 16 bit offset from the zero data area pointer, with the
+     bits placed non-contiguously in the instruction.
+
+ -- : BFD_RELOC_V850_CALLT_6_7_OFFSET
+     This is a 6 bit offset from the call table base pointer.
+
+ -- : BFD_RELOC_V850_CALLT_16_16_OFFSET
+     This is a 16 bit offset from the call table base pointer.
+
+ -- : BFD_RELOC_V850_LONGCALL
+     Used for relaxing indirect function calls.
+
+ -- : BFD_RELOC_V850_LONGJUMP
+     Used for relaxing indirect jumps.
+
+ -- : BFD_RELOC_V850_ALIGN
+     Used to maintain alignment whilst relaxing.
+
+ -- : BFD_RELOC_V850_LO16_SPLIT_OFFSET
+     This is a variation of BFD_RELOC_LO16 that can be used in v850e
+     ld.bu instructions.
+
+ -- : BFD_RELOC_MN10300_32_PCREL
+     This is a 32bit pcrel reloc for the mn10300, offset by two bytes
+     in the instruction.
+
+ -- : BFD_RELOC_MN10300_16_PCREL
+     This is a 16bit pcrel reloc for the mn10300, offset by two bytes
+     in the instruction.
+
+ -- : BFD_RELOC_TIC30_LDP
+     This is a 8bit DP reloc for the tms320c30, where the most
+     significant 8 bits of a 24 bit word are placed into the least
+     significant 8 bits of the opcode.
+
+ -- : BFD_RELOC_TIC54X_PARTLS7
+     This is a 7bit reloc for the tms320c54x, where the least
+     significant 7 bits of a 16 bit word are placed into the least
+     significant 7 bits of the opcode.
+
+ -- : BFD_RELOC_TIC54X_PARTMS9
+     This is a 9bit DP reloc for the tms320c54x, where the most
+     significant 9 bits of a 16 bit word are placed into the least
+     significant 9 bits of the opcode.
+
+ -- : BFD_RELOC_TIC54X_23
+     This is an extended address 23-bit reloc for the tms320c54x.
+
+ -- : BFD_RELOC_TIC54X_16_OF_23
+     This is a 16-bit reloc for the tms320c54x, where the least
+     significant 16 bits of a 23-bit extended address are placed into
+     the opcode.
+
+ -- : BFD_RELOC_TIC54X_MS7_OF_23
+     This is a reloc for the tms320c54x, where the most significant 7
+     bits of a 23-bit extended address are placed into the opcode.
+
+ -- : BFD_RELOC_FR30_48
+     This is a 48 bit reloc for the FR30 that stores 32 bits.
+
+ -- : BFD_RELOC_FR30_20
+     This is a 32 bit reloc for the FR30 that stores 20 bits split up
+     into two sections.
+
+ -- : BFD_RELOC_FR30_6_IN_4
+     This is a 16 bit reloc for the FR30 that stores a 6 bit word
+     offset in 4 bits.
+
+ -- : BFD_RELOC_FR30_8_IN_8
+     This is a 16 bit reloc for the FR30 that stores an 8 bit byte
+     offset into 8 bits.
+
+ -- : BFD_RELOC_FR30_9_IN_8
+     This is a 16 bit reloc for the FR30 that stores a 9 bit short
+     offset into 8 bits.
+
+ -- : BFD_RELOC_FR30_10_IN_8
+     This is a 16 bit reloc for the FR30 that stores a 10 bit word
+     offset into 8 bits.
+
+ -- : BFD_RELOC_FR30_9_PCREL
+     This is a 16 bit reloc for the FR30 that stores a 9 bit pc relative
+     short offset into 8 bits.
+
+ -- : BFD_RELOC_FR30_12_PCREL
+     This is a 16 bit reloc for the FR30 that stores a 12 bit pc
+     relative short offset into 11 bits.
+
+ -- : BFD_RELOC_MCORE_PCREL_IMM8BY4
+ -- : BFD_RELOC_MCORE_PCREL_IMM11BY2
+ -- : BFD_RELOC_MCORE_PCREL_IMM4BY2
+ -- : BFD_RELOC_MCORE_PCREL_32
+ -- : BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2
+ -- : BFD_RELOC_MCORE_RVA
+     Motorola Mcore relocations.
+
+ -- : BFD_RELOC_MMIX_GETA
+ -- : BFD_RELOC_MMIX_GETA_1
+ -- : BFD_RELOC_MMIX_GETA_2
+ -- : BFD_RELOC_MMIX_GETA_3
+     These are relocations for the GETA instruction.
+
+ -- : BFD_RELOC_MMIX_CBRANCH
+ -- : BFD_RELOC_MMIX_CBRANCH_J
+ -- : BFD_RELOC_MMIX_CBRANCH_1
+ -- : BFD_RELOC_MMIX_CBRANCH_2
+ -- : BFD_RELOC_MMIX_CBRANCH_3
+     These are relocations for a conditional branch instruction.
+
+ -- : BFD_RELOC_MMIX_PUSHJ
+ -- : BFD_RELOC_MMIX_PUSHJ_1
+ -- : BFD_RELOC_MMIX_PUSHJ_2
+ -- : BFD_RELOC_MMIX_PUSHJ_3
+ -- : BFD_RELOC_MMIX_PUSHJ_STUBBABLE
+     These are relocations for the PUSHJ instruction.
+
+ -- : BFD_RELOC_MMIX_JMP
+ -- : BFD_RELOC_MMIX_JMP_1
+ -- : BFD_RELOC_MMIX_JMP_2
+ -- : BFD_RELOC_MMIX_JMP_3
+     These are relocations for the JMP instruction.
+
+ -- : BFD_RELOC_MMIX_ADDR19
+     This is a relocation for a relative address as in a GETA
+     instruction or a branch.
+
+ -- : BFD_RELOC_MMIX_ADDR27
+     This is a relocation for a relative address as in a JMP
+     instruction.
+
+ -- : BFD_RELOC_MMIX_REG_OR_BYTE
+     This is a relocation for an instruction field that may be a general
+     register or a value 0..255.
+
+ -- : BFD_RELOC_MMIX_REG
+     This is a relocation for an instruction field that may be a general
+     register.
+
+ -- : BFD_RELOC_MMIX_BASE_PLUS_OFFSET
+     This is a relocation for two instruction fields holding a register
+     and an offset, the equivalent of the relocation.
+
+ -- : BFD_RELOC_MMIX_LOCAL
+     This relocation is an assertion that the expression is not
+     allocated as a global register.  It does not modify contents.
+
+ -- : BFD_RELOC_AVR_7_PCREL
+     This is a 16 bit reloc for the AVR that stores 8 bit pc relative
+     short offset into 7 bits.
+
+ -- : BFD_RELOC_AVR_13_PCREL
+     This is a 16 bit reloc for the AVR that stores 13 bit pc relative
+     short offset into 12 bits.
+
+ -- : BFD_RELOC_AVR_16_PM
+     This is a 16 bit reloc for the AVR that stores 17 bit value
+     (usually program memory address) into 16 bits.
+
+ -- : BFD_RELOC_AVR_LO8_LDI
+     This is a 16 bit reloc for the AVR that stores 8 bit value (usually
+     data memory address) into 8 bit immediate value of LDI insn.
+
+ -- : BFD_RELOC_AVR_HI8_LDI
+     This is a 16 bit reloc for the AVR that stores 8 bit value (high 8
+     bit of data memory address) into 8 bit immediate value of LDI insn.
+
+ -- : BFD_RELOC_AVR_HH8_LDI
+     This is a 16 bit reloc for the AVR that stores 8 bit value (most
+     high 8 bit of program memory address) into 8 bit immediate value
+     of LDI insn.
+
+ -- : BFD_RELOC_AVR_LO8_LDI_NEG
+     This is a 16 bit reloc for the AVR that stores negated 8 bit value
+     (usually data memory address) into 8 bit immediate value of SUBI
+     insn.
+
+ -- : BFD_RELOC_AVR_HI8_LDI_NEG
+     This is a 16 bit reloc for the AVR that stores negated 8 bit value
+     (high 8 bit of data memory address) into 8 bit immediate value of
+     SUBI insn.
+
+ -- : BFD_RELOC_AVR_HH8_LDI_NEG
+     This is a 16 bit reloc for the AVR that stores negated 8 bit value
+     (most high 8 bit of program memory address) into 8 bit immediate
+     value of LDI or SUBI insn.
+
+ -- : BFD_RELOC_AVR_LO8_LDI_PM
+     This is a 16 bit reloc for the AVR that stores 8 bit value (usually
+     command address) into 8 bit immediate value of LDI insn.
+
+ -- : BFD_RELOC_AVR_HI8_LDI_PM
+     This is a 16 bit reloc for the AVR that stores 8 bit value (high 8
+     bit of command address) into 8 bit immediate value of LDI insn.
+
+ -- : BFD_RELOC_AVR_HH8_LDI_PM
+     This is a 16 bit reloc for the AVR that stores 8 bit value (most
+     high 8 bit of command address) into 8 bit immediate value of LDI
+     insn.
+
+ -- : BFD_RELOC_AVR_LO8_LDI_PM_NEG
+     This is a 16 bit reloc for the AVR that stores negated 8 bit value
+     (usually command address) into 8 bit immediate value of SUBI insn.
+
+ -- : BFD_RELOC_AVR_HI8_LDI_PM_NEG
+     This is a 16 bit reloc for the AVR that stores negated 8 bit value
+     (high 8 bit of 16 bit command address) into 8 bit immediate value
+     of SUBI insn.
+
+ -- : BFD_RELOC_AVR_HH8_LDI_PM_NEG
+     This is a 16 bit reloc for the AVR that stores negated 8 bit value
+     (high 6 bit of 22 bit command address) into 8 bit immediate value
+     of SUBI insn.
+
+ -- : BFD_RELOC_AVR_CALL
+     This is a 32 bit reloc for the AVR that stores 23 bit value into
+     22 bits.
+
+ -- : BFD_RELOC_AVR_LDI
+     This is a 16 bit reloc for the AVR that stores all needed bits for
+     absolute addressing with ldi with overflow check to linktime
+
+ -- : BFD_RELOC_AVR_6
+     This is a 6 bit reloc for the AVR that stores offset for ldd/std
+     instructions
+
+ -- : BFD_RELOC_AVR_6_ADIW
+     This is a 6 bit reloc for the AVR that stores offset for adiw/sbiw
+     instructions
+
+ -- : BFD_RELOC_390_12
+     Direct 12 bit.
+
+ -- : BFD_RELOC_390_GOT12
+     12 bit GOT offset.
+
+ -- : BFD_RELOC_390_PLT32
+     32 bit PC relative PLT address.
+
+ -- : BFD_RELOC_390_COPY
+     Copy symbol at runtime.
+
+ -- : BFD_RELOC_390_GLOB_DAT
+     Create GOT entry.
+
+ -- : BFD_RELOC_390_JMP_SLOT
+     Create PLT entry.
+
+ -- : BFD_RELOC_390_RELATIVE
+     Adjust by program base.
+
+ -- : BFD_RELOC_390_GOTPC
+     32 bit PC relative offset to GOT.
+
+ -- : BFD_RELOC_390_GOT16
+     16 bit GOT offset.
+
+ -- : BFD_RELOC_390_PC16DBL
+     PC relative 16 bit shifted by 1.
+
+ -- : BFD_RELOC_390_PLT16DBL
+     16 bit PC rel. PLT shifted by 1.
+
+ -- : BFD_RELOC_390_PC32DBL
+     PC relative 32 bit shifted by 1.
+
+ -- : BFD_RELOC_390_PLT32DBL
+     32 bit PC rel. PLT shifted by 1.
+
+ -- : BFD_RELOC_390_GOTPCDBL
+     32 bit PC rel. GOT shifted by 1.
+
+ -- : BFD_RELOC_390_GOT64
+     64 bit GOT offset.
+
+ -- : BFD_RELOC_390_PLT64
+     64 bit PC relative PLT address.
+
+ -- : BFD_RELOC_390_GOTENT
+     32 bit rel. offset to GOT entry.
+
+ -- : BFD_RELOC_390_GOTOFF64
+     64 bit offset to GOT.
+
+ -- : BFD_RELOC_390_GOTPLT12
+     12-bit offset to symbol-entry within GOT, with PLT handling.
+
+ -- : BFD_RELOC_390_GOTPLT16
+     16-bit offset to symbol-entry within GOT, with PLT handling.
+
+ -- : BFD_RELOC_390_GOTPLT32
+     32-bit offset to symbol-entry within GOT, with PLT handling.
+
+ -- : BFD_RELOC_390_GOTPLT64
+     64-bit offset to symbol-entry within GOT, with PLT handling.
+
+ -- : BFD_RELOC_390_GOTPLTENT
+     32-bit rel. offset to symbol-entry within GOT, with PLT handling.
+
+ -- : BFD_RELOC_390_PLTOFF16
+     16-bit rel. offset from the GOT to a PLT entry.
+
+ -- : BFD_RELOC_390_PLTOFF32
+     32-bit rel. offset from the GOT to a PLT entry.
+
+ -- : BFD_RELOC_390_PLTOFF64
+     64-bit rel. offset from the GOT to a PLT entry.
+
+ -- : BFD_RELOC_390_TLS_LOAD
+ -- : BFD_RELOC_390_TLS_GDCALL
+ -- : BFD_RELOC_390_TLS_LDCALL
+ -- : BFD_RELOC_390_TLS_GD32
+ -- : BFD_RELOC_390_TLS_GD64
+ -- : BFD_RELOC_390_TLS_GOTIE12
+ -- : BFD_RELOC_390_TLS_GOTIE32
+ -- : BFD_RELOC_390_TLS_GOTIE64
+ -- : BFD_RELOC_390_TLS_LDM32
+ -- : BFD_RELOC_390_TLS_LDM64
+ -- : BFD_RELOC_390_TLS_IE32
+ -- : BFD_RELOC_390_TLS_IE64
+ -- : BFD_RELOC_390_TLS_IEENT
+ -- : BFD_RELOC_390_TLS_LE32
+ -- : BFD_RELOC_390_TLS_LE64
+ -- : BFD_RELOC_390_TLS_LDO32
+ -- : BFD_RELOC_390_TLS_LDO64
+ -- : BFD_RELOC_390_TLS_DTPMOD
+ -- : BFD_RELOC_390_TLS_DTPOFF
+ -- : BFD_RELOC_390_TLS_TPOFF
+     s390 tls relocations.
+
+ -- : BFD_RELOC_390_20
+ -- : BFD_RELOC_390_GOT20
+ -- : BFD_RELOC_390_GOTPLT20
+ -- : BFD_RELOC_390_TLS_GOTIE20
+     Long displacement extension.
+
+ -- : BFD_RELOC_IP2K_FR9
+     Scenix IP2K - 9-bit register number / data address
+
+ -- : BFD_RELOC_IP2K_BANK
+     Scenix IP2K - 4-bit register/data bank number
+
+ -- : BFD_RELOC_IP2K_ADDR16CJP
+     Scenix IP2K - low 13 bits of instruction word address
+
+ -- : BFD_RELOC_IP2K_PAGE3
+     Scenix IP2K - high 3 bits of instruction word address
+
+ -- : BFD_RELOC_IP2K_LO8DATA
+ -- : BFD_RELOC_IP2K_HI8DATA
+ -- : BFD_RELOC_IP2K_EX8DATA
+     Scenix IP2K - ext/low/high 8 bits of data address
+
+ -- : BFD_RELOC_IP2K_LO8INSN
+ -- : BFD_RELOC_IP2K_HI8INSN
+     Scenix IP2K - low/high 8 bits of instruction word address
+
+ -- : BFD_RELOC_IP2K_PC_SKIP
+     Scenix IP2K - even/odd PC modifier to modify snb pcl.0
+
+ -- : BFD_RELOC_IP2K_TEXT
+     Scenix IP2K - 16 bit word address in text section.
+
+ -- : BFD_RELOC_IP2K_FR_OFFSET
+     Scenix IP2K - 7-bit sp or dp offset
+
+ -- : BFD_RELOC_VPE4KMATH_DATA
+ -- : BFD_RELOC_VPE4KMATH_INSN
+     Scenix VPE4K coprocessor - data/insn-space addressing
+
+ -- : BFD_RELOC_VTABLE_INHERIT
+ -- : BFD_RELOC_VTABLE_ENTRY
+     These two relocations are used by the linker to determine which of
+     the entries in a C++ virtual function table are actually used.
+     When the -gc-sections option is given, the linker will zero out
+     the entries that are not used, so that the code for those
+     functions need not be included in the output.
+
+     VTABLE_INHERIT is a zero-space relocation used to describe to the
+     linker the inheritance tree of a C++ virtual function table.  The
+     relocation's symbol should be the parent class' vtable, and the
+     relocation should be located at the child vtable.
+
+     VTABLE_ENTRY is a zero-space relocation that describes the use of a
+     virtual function table entry.  The reloc's symbol should refer to
+     the table of the class mentioned in the code.  Off of that base,
+     an offset describes the entry that is being used.  For Rela hosts,
+     this offset is stored in the reloc's addend.  For Rel hosts, we
+     are forced to put this offset in the reloc's section offset.
+
+ -- : BFD_RELOC_IA64_IMM14
+ -- : BFD_RELOC_IA64_IMM22
+ -- : BFD_RELOC_IA64_IMM64
+ -- : BFD_RELOC_IA64_DIR32MSB
+ -- : BFD_RELOC_IA64_DIR32LSB
+ -- : BFD_RELOC_IA64_DIR64MSB
+ -- : BFD_RELOC_IA64_DIR64LSB
+ -- : BFD_RELOC_IA64_GPREL22
+ -- : BFD_RELOC_IA64_GPREL64I
+ -- : BFD_RELOC_IA64_GPREL32MSB
+ -- : BFD_RELOC_IA64_GPREL32LSB
+ -- : BFD_RELOC_IA64_GPREL64MSB
+ -- : BFD_RELOC_IA64_GPREL64LSB
+ -- : BFD_RELOC_IA64_LTOFF22
+ -- : BFD_RELOC_IA64_LTOFF64I
+ -- : BFD_RELOC_IA64_PLTOFF22
+ -- : BFD_RELOC_IA64_PLTOFF64I
+ -- : BFD_RELOC_IA64_PLTOFF64MSB
+ -- : BFD_RELOC_IA64_PLTOFF64LSB
+ -- : BFD_RELOC_IA64_FPTR64I
+ -- : BFD_RELOC_IA64_FPTR32MSB
+ -- : BFD_RELOC_IA64_FPTR32LSB
+ -- : BFD_RELOC_IA64_FPTR64MSB
+ -- : BFD_RELOC_IA64_FPTR64LSB
+ -- : BFD_RELOC_IA64_PCREL21B
+ -- : BFD_RELOC_IA64_PCREL21BI
+ -- : BFD_RELOC_IA64_PCREL21M
+ -- : BFD_RELOC_IA64_PCREL21F
+ -- : BFD_RELOC_IA64_PCREL22
+ -- : BFD_RELOC_IA64_PCREL60B
+ -- : BFD_RELOC_IA64_PCREL64I
+ -- : BFD_RELOC_IA64_PCREL32MSB
+ -- : BFD_RELOC_IA64_PCREL32LSB
+ -- : BFD_RELOC_IA64_PCREL64MSB
+ -- : BFD_RELOC_IA64_PCREL64LSB
+ -- : BFD_RELOC_IA64_LTOFF_FPTR22
+ -- : BFD_RELOC_IA64_LTOFF_FPTR64I
+ -- : BFD_RELOC_IA64_LTOFF_FPTR32MSB
+ -- : BFD_RELOC_IA64_LTOFF_FPTR32LSB
+ -- : BFD_RELOC_IA64_LTOFF_FPTR64MSB
+ -- : BFD_RELOC_IA64_LTOFF_FPTR64LSB
+ -- : BFD_RELOC_IA64_SEGREL32MSB
+ -- : BFD_RELOC_IA64_SEGREL32LSB
+ -- : BFD_RELOC_IA64_SEGREL64MSB
+ -- : BFD_RELOC_IA64_SEGREL64LSB
+ -- : BFD_RELOC_IA64_SECREL32MSB
+ -- : BFD_RELOC_IA64_SECREL32LSB
+ -- : BFD_RELOC_IA64_SECREL64MSB
+ -- : BFD_RELOC_IA64_SECREL64LSB
+ -- : BFD_RELOC_IA64_REL32MSB
+ -- : BFD_RELOC_IA64_REL32LSB
+ -- : BFD_RELOC_IA64_REL64MSB
+ -- : BFD_RELOC_IA64_REL64LSB
+ -- : BFD_RELOC_IA64_LTV32MSB
+ -- : BFD_RELOC_IA64_LTV32LSB
+ -- : BFD_RELOC_IA64_LTV64MSB
+ -- : BFD_RELOC_IA64_LTV64LSB
+ -- : BFD_RELOC_IA64_IPLTMSB
+ -- : BFD_RELOC_IA64_IPLTLSB
+ -- : BFD_RELOC_IA64_COPY
+ -- : BFD_RELOC_IA64_LTOFF22X
+ -- : BFD_RELOC_IA64_LDXMOV
+ -- : BFD_RELOC_IA64_TPREL14
+ -- : BFD_RELOC_IA64_TPREL22
+ -- : BFD_RELOC_IA64_TPREL64I
+ -- : BFD_RELOC_IA64_TPREL64MSB
+ -- : BFD_RELOC_IA64_TPREL64LSB
+ -- : BFD_RELOC_IA64_LTOFF_TPREL22
+ -- : BFD_RELOC_IA64_DTPMOD64MSB
+ -- : BFD_RELOC_IA64_DTPMOD64LSB
+ -- : BFD_RELOC_IA64_LTOFF_DTPMOD22
+ -- : BFD_RELOC_IA64_DTPREL14
+ -- : BFD_RELOC_IA64_DTPREL22
+ -- : BFD_RELOC_IA64_DTPREL64I
+ -- : BFD_RELOC_IA64_DTPREL32MSB
+ -- : BFD_RELOC_IA64_DTPREL32LSB
+ -- : BFD_RELOC_IA64_DTPREL64MSB
+ -- : BFD_RELOC_IA64_DTPREL64LSB
+ -- : BFD_RELOC_IA64_LTOFF_DTPREL22
+     Intel IA64 Relocations.
+
+ -- : BFD_RELOC_M68HC11_HI8
+     Motorola 68HC11 reloc.  This is the 8 bit high part of an absolute
+     address.
+
+ -- : BFD_RELOC_M68HC11_LO8
+     Motorola 68HC11 reloc.  This is the 8 bit low part of an absolute
+     address.
+
+ -- : BFD_RELOC_M68HC11_3B
+     Motorola 68HC11 reloc.  This is the 3 bit of a value.
+
+ -- : BFD_RELOC_M68HC11_RL_JUMP
+     Motorola 68HC11 reloc.  This reloc marks the beginning of a
+     jump/call instruction.  It is used for linker relaxation to
+     correctly identify beginning of instruction and change some
+     branches to use PC-relative addressing mode.
+
+ -- : BFD_RELOC_M68HC11_RL_GROUP
+     Motorola 68HC11 reloc.  This reloc marks a group of several
+     instructions that gcc generates and for which the linker
+     relaxation pass can modify and/or remove some of them.
+
+ -- : BFD_RELOC_M68HC11_LO16
+     Motorola 68HC11 reloc.  This is the 16-bit lower part of an
+     address.  It is used for 'call' instruction to specify the symbol
+     address without any special transformation (due to memory bank
+     window).
+
+ -- : BFD_RELOC_M68HC11_PAGE
+     Motorola 68HC11 reloc.  This is a 8-bit reloc that specifies the
+     page number of an address.  It is used by 'call' instruction to
+     specify the page number of the symbol.
+
+ -- : BFD_RELOC_M68HC11_24
+     Motorola 68HC11 reloc.  This is a 24-bit reloc that represents the
+     address with a 16-bit value and a 8-bit page number.  The symbol
+     address is transformed to follow the 16K memory bank of 68HC12
+     (seen as mapped in the window).
+
+ -- : BFD_RELOC_M68HC12_5B
+     Motorola 68HC12 reloc.  This is the 5 bits of a value.
+
+ -- : BFD_RELOC_16C_NUM08
+ -- : BFD_RELOC_16C_NUM08_C
+ -- : BFD_RELOC_16C_NUM16
+ -- : BFD_RELOC_16C_NUM16_C
+ -- : BFD_RELOC_16C_NUM32
+ -- : BFD_RELOC_16C_NUM32_C
+ -- : BFD_RELOC_16C_DISP04
+ -- : BFD_RELOC_16C_DISP04_C
+ -- : BFD_RELOC_16C_DISP08
+ -- : BFD_RELOC_16C_DISP08_C
+ -- : BFD_RELOC_16C_DISP16
+ -- : BFD_RELOC_16C_DISP16_C
+ -- : BFD_RELOC_16C_DISP24
+ -- : BFD_RELOC_16C_DISP24_C
+ -- : BFD_RELOC_16C_DISP24a
+ -- : BFD_RELOC_16C_DISP24a_C
+ -- : BFD_RELOC_16C_REG04
+ -- : BFD_RELOC_16C_REG04_C
+ -- : BFD_RELOC_16C_REG04a
+ -- : BFD_RELOC_16C_REG04a_C
+ -- : BFD_RELOC_16C_REG14
+ -- : BFD_RELOC_16C_REG14_C
+ -- : BFD_RELOC_16C_REG16
+ -- : BFD_RELOC_16C_REG16_C
+ -- : BFD_RELOC_16C_REG20
+ -- : BFD_RELOC_16C_REG20_C
+ -- : BFD_RELOC_16C_ABS20
+ -- : BFD_RELOC_16C_ABS20_C
+ -- : BFD_RELOC_16C_ABS24
+ -- : BFD_RELOC_16C_ABS24_C
+ -- : BFD_RELOC_16C_IMM04
+ -- : BFD_RELOC_16C_IMM04_C
+ -- : BFD_RELOC_16C_IMM16
+ -- : BFD_RELOC_16C_IMM16_C
+ -- : BFD_RELOC_16C_IMM20
+ -- : BFD_RELOC_16C_IMM20_C
+ -- : BFD_RELOC_16C_IMM24
+ -- : BFD_RELOC_16C_IMM24_C
+ -- : BFD_RELOC_16C_IMM32
+ -- : BFD_RELOC_16C_IMM32_C
+     NS CR16C Relocations.
+
+ -- : BFD_RELOC_CRX_REL4
+ -- : BFD_RELOC_CRX_REL8
+ -- : BFD_RELOC_CRX_REL8_CMP
+ -- : BFD_RELOC_CRX_REL16
+ -- : BFD_RELOC_CRX_REL24
+ -- : BFD_RELOC_CRX_REL32
+ -- : BFD_RELOC_CRX_REGREL12
+ -- : BFD_RELOC_CRX_REGREL22
+ -- : BFD_RELOC_CRX_REGREL28
+ -- : BFD_RELOC_CRX_REGREL32
+ -- : BFD_RELOC_CRX_ABS16
+ -- : BFD_RELOC_CRX_ABS32
+ -- : BFD_RELOC_CRX_NUM8
+ -- : BFD_RELOC_CRX_NUM16
+ -- : BFD_RELOC_CRX_NUM32
+ -- : BFD_RELOC_CRX_IMM16
+ -- : BFD_RELOC_CRX_IMM32
+ -- : BFD_RELOC_CRX_SWITCH8
+ -- : BFD_RELOC_CRX_SWITCH16
+ -- : BFD_RELOC_CRX_SWITCH32
+     NS CRX Relocations.
+
+ -- : BFD_RELOC_CRIS_BDISP8
+ -- : BFD_RELOC_CRIS_UNSIGNED_5
+ -- : BFD_RELOC_CRIS_SIGNED_6
+ -- : BFD_RELOC_CRIS_UNSIGNED_6
+ -- : BFD_RELOC_CRIS_SIGNED_8
+ -- : BFD_RELOC_CRIS_UNSIGNED_8
+ -- : BFD_RELOC_CRIS_SIGNED_16
+ -- : BFD_RELOC_CRIS_UNSIGNED_16
+ -- : BFD_RELOC_CRIS_LAPCQ_OFFSET
+ -- : BFD_RELOC_CRIS_UNSIGNED_4
+     These relocs are only used within the CRIS assembler.  They are not
+     (at present) written to any object files.
+
+ -- : BFD_RELOC_CRIS_COPY
+ -- : BFD_RELOC_CRIS_GLOB_DAT
+ -- : BFD_RELOC_CRIS_JUMP_SLOT
+ -- : BFD_RELOC_CRIS_RELATIVE
+     Relocs used in ELF shared libraries for CRIS.
+
+ -- : BFD_RELOC_CRIS_32_GOT
+     32-bit offset to symbol-entry within GOT.
+
+ -- : BFD_RELOC_CRIS_16_GOT
+     16-bit offset to symbol-entry within GOT.
+
+ -- : BFD_RELOC_CRIS_32_GOTPLT
+     32-bit offset to symbol-entry within GOT, with PLT handling.
+
+ -- : BFD_RELOC_CRIS_16_GOTPLT
+     16-bit offset to symbol-entry within GOT, with PLT handling.
+
+ -- : BFD_RELOC_CRIS_32_GOTREL
+     32-bit offset to symbol, relative to GOT.
+
+ -- : BFD_RELOC_CRIS_32_PLT_GOTREL
+     32-bit offset to symbol with PLT entry, relative to GOT.
+
+ -- : BFD_RELOC_CRIS_32_PLT_PCREL
+     32-bit offset to symbol with PLT entry, relative to this
+     relocation.
+
+ -- : BFD_RELOC_860_COPY
+ -- : BFD_RELOC_860_GLOB_DAT
+ -- : BFD_RELOC_860_JUMP_SLOT
+ -- : BFD_RELOC_860_RELATIVE
+ -- : BFD_RELOC_860_PC26
+ -- : BFD_RELOC_860_PLT26
+ -- : BFD_RELOC_860_PC16
+ -- : BFD_RELOC_860_LOW0
+ -- : BFD_RELOC_860_SPLIT0
+ -- : BFD_RELOC_860_LOW1
+ -- : BFD_RELOC_860_SPLIT1
+ -- : BFD_RELOC_860_LOW2
+ -- : BFD_RELOC_860_SPLIT2
+ -- : BFD_RELOC_860_LOW3
+ -- : BFD_RELOC_860_LOGOT0
+ -- : BFD_RELOC_860_SPGOT0
+ -- : BFD_RELOC_860_LOGOT1
+ -- : BFD_RELOC_860_SPGOT1
+ -- : BFD_RELOC_860_LOGOTOFF0
+ -- : BFD_RELOC_860_SPGOTOFF0
+ -- : BFD_RELOC_860_LOGOTOFF1
+ -- : BFD_RELOC_860_SPGOTOFF1
+ -- : BFD_RELOC_860_LOGOTOFF2
+ -- : BFD_RELOC_860_LOGOTOFF3
+ -- : BFD_RELOC_860_LOPC
+ -- : BFD_RELOC_860_HIGHADJ
+ -- : BFD_RELOC_860_HAGOT
+ -- : BFD_RELOC_860_HAGOTOFF
+ -- : BFD_RELOC_860_HAPC
+ -- : BFD_RELOC_860_HIGH
+ -- : BFD_RELOC_860_HIGOT
+ -- : BFD_RELOC_860_HIGOTOFF
+     Intel i860 Relocations.
+
+ -- : BFD_RELOC_OPENRISC_ABS_26
+ -- : BFD_RELOC_OPENRISC_REL_26
+     OpenRISC Relocations.
+
+ -- : BFD_RELOC_H8_DIR16A8
+ -- : BFD_RELOC_H8_DIR16R8
+ -- : BFD_RELOC_H8_DIR24A8
+ -- : BFD_RELOC_H8_DIR24R8
+ -- : BFD_RELOC_H8_DIR32A16
+     H8 elf Relocations.
+
+ -- : BFD_RELOC_XSTORMY16_REL_12
+ -- : BFD_RELOC_XSTORMY16_12
+ -- : BFD_RELOC_XSTORMY16_24
+ -- : BFD_RELOC_XSTORMY16_FPTR16
+     Sony Xstormy16 Relocations.
+
+ -- : BFD_RELOC_VAX_GLOB_DAT
+ -- : BFD_RELOC_VAX_JMP_SLOT
+ -- : BFD_RELOC_VAX_RELATIVE
+     Relocations used by VAX ELF.
+
+ -- : BFD_RELOC_MS1_PC16
+     Morpho MS1 - 16 bit immediate relocation.
+
+ -- : BFD_RELOC_MS1_HI16
+     Morpho MS1 - Hi 16 bits of an address.
+
+ -- : BFD_RELOC_MS1_LO16
+     Morpho MS1 - Low 16 bits of an address.
+
+ -- : BFD_RELOC_MS1_GNU_VTINHERIT
+     Morpho MS1 - Used to tell the linker which vtable entries are used.
+
+ -- : BFD_RELOC_MS1_GNU_VTENTRY
+     Morpho MS1 - Used to tell the linker which vtable entries are used.
+
+ -- : BFD_RELOC_MSP430_10_PCREL
+ -- : BFD_RELOC_MSP430_16_PCREL
+ -- : BFD_RELOC_MSP430_16
+ -- : BFD_RELOC_MSP430_16_PCREL_BYTE
+ -- : BFD_RELOC_MSP430_16_BYTE
+ -- : BFD_RELOC_MSP430_2X_PCREL
+ -- : BFD_RELOC_MSP430_RL_PCREL
+     msp430 specific relocation codes
+
+ -- : BFD_RELOC_IQ2000_OFFSET_16
+ -- : BFD_RELOC_IQ2000_OFFSET_21
+ -- : BFD_RELOC_IQ2000_UHI16
+     IQ2000 Relocations.
+
+ -- : BFD_RELOC_XTENSA_RTLD
+     Special Xtensa relocation used only by PLT entries in ELF shared
+     objects to indicate that the runtime linker should set the value
+     to one of its own internal functions or data structures.
+
+ -- : BFD_RELOC_XTENSA_GLOB_DAT
+ -- : BFD_RELOC_XTENSA_JMP_SLOT
+ -- : BFD_RELOC_XTENSA_RELATIVE
+     Xtensa relocations for ELF shared objects.
+
+ -- : BFD_RELOC_XTENSA_PLT
+     Xtensa relocation used in ELF object files for symbols that may
+     require PLT entries.  Otherwise, this is just a generic 32-bit
+     relocation.
+
+ -- : BFD_RELOC_XTENSA_DIFF8
+ -- : BFD_RELOC_XTENSA_DIFF16
+ -- : BFD_RELOC_XTENSA_DIFF32
+     Xtensa relocations to mark the difference of two local symbols.
+     These are only needed to support linker relaxation and can be
+     ignored when not relaxing.  The field is set to the value of the
+     difference assuming no relaxation.  The relocation encodes the
+     position of the first symbol so the linker can determine whether
+     to adjust the field value.
+
+ -- : BFD_RELOC_XTENSA_SLOT0_OP
+ -- : BFD_RELOC_XTENSA_SLOT1_OP
+ -- : BFD_RELOC_XTENSA_SLOT2_OP
+ -- : BFD_RELOC_XTENSA_SLOT3_OP
+ -- : BFD_RELOC_XTENSA_SLOT4_OP
+ -- : BFD_RELOC_XTENSA_SLOT5_OP
+ -- : BFD_RELOC_XTENSA_SLOT6_OP
+ -- : BFD_RELOC_XTENSA_SLOT7_OP
+ -- : BFD_RELOC_XTENSA_SLOT8_OP
+ -- : BFD_RELOC_XTENSA_SLOT9_OP
+ -- : BFD_RELOC_XTENSA_SLOT10_OP
+ -- : BFD_RELOC_XTENSA_SLOT11_OP
+ -- : BFD_RELOC_XTENSA_SLOT12_OP
+ -- : BFD_RELOC_XTENSA_SLOT13_OP
+ -- : BFD_RELOC_XTENSA_SLOT14_OP
+     Generic Xtensa relocations for instruction operands.  Only the slot
+     number is encoded in the relocation.  The relocation applies to the
+     last PC-relative immediate operand, or if there are no PC-relative
+     immediates, to the last immediate operand.
+
+ -- : BFD_RELOC_XTENSA_SLOT0_ALT
+ -- : BFD_RELOC_XTENSA_SLOT1_ALT
+ -- : BFD_RELOC_XTENSA_SLOT2_ALT
+ -- : BFD_RELOC_XTENSA_SLOT3_ALT
+ -- : BFD_RELOC_XTENSA_SLOT4_ALT
+ -- : BFD_RELOC_XTENSA_SLOT5_ALT
+ -- : BFD_RELOC_XTENSA_SLOT6_ALT
+ -- : BFD_RELOC_XTENSA_SLOT7_ALT
+ -- : BFD_RELOC_XTENSA_SLOT8_ALT
+ -- : BFD_RELOC_XTENSA_SLOT9_ALT
+ -- : BFD_RELOC_XTENSA_SLOT10_ALT
+ -- : BFD_RELOC_XTENSA_SLOT11_ALT
+ -- : BFD_RELOC_XTENSA_SLOT12_ALT
+ -- : BFD_RELOC_XTENSA_SLOT13_ALT
+ -- : BFD_RELOC_XTENSA_SLOT14_ALT
+     Alternate Xtensa relocations.  Only the slot is encoded in the
+     relocation.  The meaning of these relocations is opcode-specific.
+
+ -- : BFD_RELOC_XTENSA_OP0
+ -- : BFD_RELOC_XTENSA_OP1
+ -- : BFD_RELOC_XTENSA_OP2
+     Xtensa relocations for backward compatibility.  These have all been
+     replaced by BFD_RELOC_XTENSA_SLOT0_OP.
+
+ -- : BFD_RELOC_XTENSA_ASM_EXPAND
+     Xtensa relocation to mark that the assembler expanded the
+     instructions from an original target.  The expansion size is
+     encoded in the reloc size.
+
+ -- : BFD_RELOC_XTENSA_ASM_SIMPLIFY
+     Xtensa relocation to mark that the linker should simplify
+     assembler-expanded instructions.  This is commonly used internally
+     by the linker after analysis of a BFD_RELOC_XTENSA_ASM_EXPAND.
+
+ -- : BFD_RELOC_Z80_DISP8
+     8 bit signed offset in (ix+d) or (iy+d).
+
+ -- : BFD_RELOC_Z8K_DISP7
+     DJNZ offset.
+
+ -- : BFD_RELOC_Z8K_CALLR
+     CALR offset.
+
+ -- : BFD_RELOC_Z8K_IMM4L
+     4 bit value.
+
+
+     typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
+   
+2.10.2.2 `bfd_reloc_type_lookup'
+................................
+
+*Synopsis*
+     reloc_howto_type *bfd_reloc_type_lookup
+        (bfd *abfd, bfd_reloc_code_real_type code);
+   *Description*
+Return a pointer to a howto structure which, when invoked, will perform
+the relocation CODE on data from the architecture noted.
+
+2.10.2.3 `bfd_default_reloc_type_lookup'
+........................................
+
+*Synopsis*
+     reloc_howto_type *bfd_default_reloc_type_lookup
+        (bfd *abfd, bfd_reloc_code_real_type  code);
+   *Description*
+Provides a default relocation lookup routine for any architecture.
+
+2.10.2.4 `bfd_get_reloc_code_name'
+..................................
+
+*Synopsis*
+     const char *bfd_get_reloc_code_name (bfd_reloc_code_real_type code);
+   *Description*
+Provides a printable name for the supplied relocation code.  Useful
+mainly for printing error messages.
+
+2.10.2.5 `bfd_generic_relax_section'
+....................................
+
+*Synopsis*
+     bfd_boolean bfd_generic_relax_section
+        (bfd *abfd,
+         asection *section,
+         struct bfd_link_info *,
+         bfd_boolean *);
+   *Description*
+Provides default handling for relaxing for back ends which don't do
+relaxing.
+
+2.10.2.6 `bfd_generic_gc_sections'
+..................................
+
+*Synopsis*
+     bfd_boolean bfd_generic_gc_sections
+        (bfd *, struct bfd_link_info *);
+   *Description*
+Provides default handling for relaxing for back ends which don't do
+section gc - i.e., does nothing.
+
+2.10.2.7 `bfd_generic_merge_sections'
+.....................................
+
+*Synopsis*
+     bfd_boolean bfd_generic_merge_sections
+        (bfd *, struct bfd_link_info *);
+   *Description*
+Provides default handling for SEC_MERGE section merging for back ends
+which don't have SEC_MERGE support - i.e., does nothing.
+
+2.10.2.8 `bfd_generic_get_relocated_section_contents'
+.....................................................
+
+*Synopsis*
+     bfd_byte *bfd_generic_get_relocated_section_contents
+        (bfd *abfd,
+         struct bfd_link_info *link_info,
+         struct bfd_link_order *link_order,
+         bfd_byte *data,
+         bfd_boolean relocatable,
+         asymbol **symbols);
+   *Description*
+Provides default handling of relocation effort for back ends which
+can't be bothered to do it efficiently.
+
+
+File: bfd.info,  Node: Core Files,  Next: Targets,  Prev: Relocations,  Up: BFD front end
+
+2.11 Core files
+===============
+
+2.11.1 Core file functions
+--------------------------
+
+*Description*
+These are functions pertaining to core files.
+
+2.11.1.1 `bfd_core_file_failing_command'
+........................................
+
+*Synopsis*
+     const char *bfd_core_file_failing_command (bfd *abfd);
+   *Description*
+Return a read-only string explaining which program was running when it
+failed and produced the core file ABFD.
+
+2.11.1.2 `bfd_core_file_failing_signal'
+.......................................
+
+*Synopsis*
+     int bfd_core_file_failing_signal (bfd *abfd);
+   *Description*
+Returns the signal number which caused the core dump which generated
+the file the BFD ABFD is attached to.
+
+2.11.1.3 `core_file_matches_executable_p'
+.........................................
+
+*Synopsis*
+     bfd_boolean core_file_matches_executable_p
+        (bfd *core_bfd, bfd *exec_bfd);
+   *Description*
+Return `TRUE' if the core file attached to CORE_BFD was generated by a
+run of the executable file attached to EXEC_BFD, `FALSE' otherwise.
+
+
+File: bfd.info,  Node: Targets,  Next: Architectures,  Prev: Core Files,  Up: BFD front end
+
+2.12 Targets
+============
+
+*Description*
+Each port of BFD to a different machine requires the creation of a
+target back end. All the back end provides to the root part of BFD is a
+structure containing pointers to functions which perform certain low
+level operations on files. BFD translates the applications's requests
+through a pointer into calls to the back end routines.
+
+   When a file is opened with `bfd_openr', its format and target are
+unknown. BFD uses various mechanisms to determine how to interpret the
+file. The operations performed are:
+
+   * Create a BFD by calling the internal routine `_bfd_new_bfd', then
+     call `bfd_find_target' with the target string supplied to
+     `bfd_openr' and the new BFD pointer.
+
+   * If a null target string was provided to `bfd_find_target', look up
+     the environment variable `GNUTARGET' and use that as the target
+     string.
+
+   * If the target string is still `NULL', or the target string is
+     `default', then use the first item in the target vector as the
+     target type, and set `target_defaulted' in the BFD to cause
+     `bfd_check_format' to loop through all the targets.  *Note
+     bfd_target::.  *Note Formats::.
+
+   * Otherwise, inspect the elements in the target vector one by one,
+     until a match on target name is found. When found, use it.
+
+   * Otherwise return the error `bfd_error_invalid_target' to
+     `bfd_openr'.
+
+   * `bfd_openr' attempts to open the file using `bfd_open_file', and
+     returns the BFD.
+   Once the BFD has been opened and the target selected, the file
+format may be determined. This is done by calling `bfd_check_format' on
+the BFD with a suggested format.  If `target_defaulted' has been set,
+each possible target type is tried to see if it recognizes the
+specified format.  `bfd_check_format' returns `TRUE' when the caller
+guesses right.
+
+* Menu:
+
+* bfd_target::
+
+
+File: bfd.info,  Node: bfd_target,  Prev: Targets,  Up: Targets
+
+2.12.1 bfd_target
+-----------------
+
+*Description*
+This structure contains everything that BFD knows about a target. It
+includes things like its byte order, name, and which routines to call
+to do various operations.
+
+   Every BFD points to a target structure with its `xvec' member.
+
+   The macros below are used to dispatch to functions through the
+`bfd_target' vector. They are used in a number of macros further down
+in `bfd.h', and are also used when calling various routines by hand
+inside the BFD implementation.  The ARGLIST argument must be
+parenthesized; it contains all the arguments to the called function.
+
+   They make the documentation (more) unpleasant to read, so if someone
+wants to fix this and not break the above, please do.
+     #define BFD_SEND(bfd, message, arglist) \
+       ((*((bfd)->xvec->message)) arglist)
+
+     #ifdef DEBUG_BFD_SEND
+     #undef BFD_SEND
+     #define BFD_SEND(bfd, message, arglist) \
+       (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
+         ((*((bfd)->xvec->message)) arglist) : \
+         (bfd_assert (__FILE__,__LINE__), NULL))
+     #endif
+   For operations which index on the BFD format:
+     #define BFD_SEND_FMT(bfd, message, arglist) \
+       (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist)
+
+     #ifdef DEBUG_BFD_SEND
+     #undef BFD_SEND_FMT
+     #define BFD_SEND_FMT(bfd, message, arglist) \
+       (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
+        (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist) : \
+        (bfd_assert (__FILE__,__LINE__), NULL))
+     #endif
+   This is the structure which defines the type of BFD this is.  The
+`xvec' member of the struct `bfd' itself points here.  Each module that
+implements access to a different target under BFD, defines one of these.
+
+   FIXME, these names should be rationalised with the names of the
+entry points which call them. Too bad we can't have one macro to define
+them both!
+     enum bfd_flavour
+     {
+       bfd_target_unknown_flavour,
+       bfd_target_aout_flavour,
+       bfd_target_coff_flavour,
+       bfd_target_ecoff_flavour,
+       bfd_target_xcoff_flavour,
+       bfd_target_elf_flavour,
+       bfd_target_ieee_flavour,
+       bfd_target_nlm_flavour,
+       bfd_target_oasys_flavour,
+       bfd_target_tekhex_flavour,
+       bfd_target_srec_flavour,
+       bfd_target_ihex_flavour,
+       bfd_target_som_flavour,
+       bfd_target_os9k_flavour,
+       bfd_target_versados_flavour,
+       bfd_target_msdos_flavour,
+       bfd_target_ovax_flavour,
+       bfd_target_evax_flavour,
+       bfd_target_mmo_flavour,
+       bfd_target_mach_o_flavour,
+       bfd_target_pef_flavour,
+       bfd_target_pef_xlib_flavour,
+       bfd_target_sym_flavour
+     };
+
+     enum bfd_endian { BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN };
+
+     /* Forward declaration.  */
+     typedef struct bfd_link_info _bfd_link_info;
+
+     typedef struct bfd_target
+     {
+       /* Identifies the kind of target, e.g., SunOS4, Ultrix, etc.  */
+       char *name;
+
+      /* The "flavour" of a back end is a general indication about
+         the contents of a file.  */
+       enum bfd_flavour flavour;
+
+       /* The order of bytes within the data area of a file.  */
+       enum bfd_endian byteorder;
+
+      /* The order of bytes within the header parts of a file.  */
+       enum bfd_endian header_byteorder;
+
+       /* A mask of all the flags which an executable may have set -
+          from the set `BFD_NO_FLAGS', `HAS_RELOC', ...`D_PAGED'.  */
+       flagword object_flags;
+
+      /* A mask of all the flags which a section may have set - from
+         the set `SEC_NO_FLAGS', `SEC_ALLOC', ...`SET_NEVER_LOAD'.  */
+       flagword section_flags;
+
+      /* The character normally found at the front of a symbol.
+         (if any), perhaps `_'.  */
+       char symbol_leading_char;
+
+      /* The pad character for file names within an archive header.  */
+       char ar_pad_char;
+
+       /* The maximum number of characters in an archive header.  */
+       unsigned short ar_max_namelen;
+
+       /* Entries for byte swapping for data. These are different from the
+          other entry points, since they don't take a BFD as the first argument.
+          Certain other handlers could do the same.  */
+       bfd_uint64_t   (*bfd_getx64) (const void *);
+       bfd_int64_t    (*bfd_getx_signed_64) (const void *);
+       void           (*bfd_putx64) (bfd_uint64_t, void *);
+       bfd_vma        (*bfd_getx32) (const void *);
+       bfd_signed_vma (*bfd_getx_signed_32) (const void *);
+       void           (*bfd_putx32) (bfd_vma, void *);
+       bfd_vma        (*bfd_getx16) (const void *);
+       bfd_signed_vma (*bfd_getx_signed_16) (const void *);
+       void           (*bfd_putx16) (bfd_vma, void *);
+
+       /* Byte swapping for the headers.  */
+       bfd_uint64_t   (*bfd_h_getx64) (const void *);
+       bfd_int64_t    (*bfd_h_getx_signed_64) (const void *);
+       void           (*bfd_h_putx64) (bfd_uint64_t, void *);
+       bfd_vma        (*bfd_h_getx32) (const void *);
+       bfd_signed_vma (*bfd_h_getx_signed_32) (const void *);
+       void           (*bfd_h_putx32) (bfd_vma, void *);
+       bfd_vma        (*bfd_h_getx16) (const void *);
+       bfd_signed_vma (*bfd_h_getx_signed_16) (const void *);
+       void           (*bfd_h_putx16) (bfd_vma, void *);
+
+       /* Format dependent routines: these are vectors of entry points
+          within the target vector structure, one for each format to check.  */
+
+       /* Check the format of a file being read.  Return a `bfd_target *' or zero.  */
+       const struct bfd_target *(*_bfd_check_format[bfd_type_end]) (bfd *);
+
+       /* Set the format of a file being written.  */
+       bfd_boolean (*_bfd_set_format[bfd_type_end]) (bfd *);
+
+       /* Write cached information into a file being written, at `bfd_close'.  */
+       bfd_boolean (*_bfd_write_contents[bfd_type_end]) (bfd *);
+   The general target vector.  These vectors are initialized using the
+BFD_JUMP_TABLE macros.
+
+       /* Generic entry points.  */
+     #define BFD_JUMP_TABLE_GENERIC(NAME) \
+       NAME##_close_and_cleanup, \
+       NAME##_bfd_free_cached_info, \
+       NAME##_new_section_hook, \
+       NAME##_get_section_contents, \
+       NAME##_get_section_contents_in_window
+
+       /* Called when the BFD is being closed to do any necessary cleanup.  */
+       bfd_boolean (*_close_and_cleanup) (bfd *);
+       /* Ask the BFD to free all cached information.  */
+       bfd_boolean (*_bfd_free_cached_info) (bfd *);
+       /* Called when a new section is created.  */
+       bfd_boolean (*_new_section_hook) (bfd *, sec_ptr);
+       /* Read the contents of a section.  */
+       bfd_boolean (*_bfd_get_section_contents)
+         (bfd *, sec_ptr, void *, file_ptr, bfd_size_type);
+       bfd_boolean (*_bfd_get_section_contents_in_window)
+         (bfd *, sec_ptr, bfd_window *, file_ptr, bfd_size_type);
+
+       /* Entry points to copy private data.  */
+     #define BFD_JUMP_TABLE_COPY(NAME) \
+       NAME##_bfd_copy_private_bfd_data, \
+       NAME##_bfd_merge_private_bfd_data, \
+       _bfd_generic_init_private_section_data, \
+       NAME##_bfd_copy_private_section_data, \
+       NAME##_bfd_copy_private_symbol_data, \
+       NAME##_bfd_copy_private_header_data, \
+       NAME##_bfd_set_private_flags, \
+       NAME##_bfd_print_private_bfd_data
+
+       /* Called to copy BFD general private data from one object file
+          to another.  */
+       bfd_boolean (*_bfd_copy_private_bfd_data) (bfd *, bfd *);
+       /* Called to merge BFD general private data from one object file
+          to a common output file when linking.  */
+       bfd_boolean (*_bfd_merge_private_bfd_data) (bfd *, bfd *);
+       /* Called to initialize BFD private section data from one object file
+          to another.  */
+     #define bfd_init_private_section_data(ibfd, isec, obfd, osec, link_info) \
+       BFD_SEND (obfd, _bfd_init_private_section_data, (ibfd, isec, obfd, osec, link_info))
+       bfd_boolean (*_bfd_init_private_section_data)
+         (bfd *, sec_ptr, bfd *, sec_ptr, struct bfd_link_info *);
+       /* Called to copy BFD private section data from one object file
+          to another.  */
+       bfd_boolean (*_bfd_copy_private_section_data)
+         (bfd *, sec_ptr, bfd *, sec_ptr);
+       /* Called to copy BFD private symbol data from one symbol
+          to another.  */
+       bfd_boolean (*_bfd_copy_private_symbol_data)
+         (bfd *, asymbol *, bfd *, asymbol *);
+       /* Called to copy BFD private header data from one object file
+          to another.  */
+       bfd_boolean (*_bfd_copy_private_header_data)
+         (bfd *, bfd *);
+       /* Called to set private backend flags.  */
+       bfd_boolean (*_bfd_set_private_flags) (bfd *, flagword);
+
+       /* Called to print private BFD data.  */
+       bfd_boolean (*_bfd_print_private_bfd_data) (bfd *, void *);
+
+       /* Core file entry points.  */
+     #define BFD_JUMP_TABLE_CORE(NAME) \
+       NAME##_core_file_failing_command, \
+       NAME##_core_file_failing_signal, \
+       NAME##_core_file_matches_executable_p
+
+       char *      (*_core_file_failing_command) (bfd *);
+       int         (*_core_file_failing_signal) (bfd *);
+       bfd_boolean (*_core_file_matches_executable_p) (bfd *, bfd *);
+
+       /* Archive entry points.  */
+     #define BFD_JUMP_TABLE_ARCHIVE(NAME) \
+       NAME##_slurp_armap, \
+       NAME##_slurp_extended_name_table, \
+       NAME##_construct_extended_name_table, \
+       NAME##_truncate_arname, \
+       NAME##_write_armap, \
+       NAME##_read_ar_hdr, \
+       NAME##_openr_next_archived_file, \
+       NAME##_get_elt_at_index, \
+       NAME##_generic_stat_arch_elt, \
+       NAME##_update_armap_timestamp
+
+       bfd_boolean (*_bfd_slurp_armap) (bfd *);
+       bfd_boolean (*_bfd_slurp_extended_name_table) (bfd *);
+       bfd_boolean (*_bfd_construct_extended_name_table)
+         (bfd *, char **, bfd_size_type *, const char **);
+       void        (*_bfd_truncate_arname) (bfd *, const char *, char *);
+       bfd_boolean (*write_armap)
+         (bfd *, unsigned int, struct orl *, unsigned int, int);
+       void *      (*_bfd_read_ar_hdr_fn) (bfd *);
+       bfd *       (*openr_next_archived_file) (bfd *, bfd *);
+     #define bfd_get_elt_at_index(b,i) BFD_SEND (b, _bfd_get_elt_at_index, (b,i))
+       bfd *       (*_bfd_get_elt_at_index) (bfd *, symindex);
+       int         (*_bfd_stat_arch_elt) (bfd *, struct stat *);
+       bfd_boolean (*_bfd_update_armap_timestamp) (bfd *);
+
+       /* Entry points used for symbols.  */
+     #define BFD_JUMP_TABLE_SYMBOLS(NAME) \
+       NAME##_get_symtab_upper_bound, \
+       NAME##_canonicalize_symtab, \
+       NAME##_make_empty_symbol, \
+       NAME##_print_symbol, \
+       NAME##_get_symbol_info, \
+       NAME##_bfd_is_local_label_name, \
+       NAME##_bfd_is_target_special_symbol, \
+       NAME##_get_lineno, \
+       NAME##_find_nearest_line, \
+       _bfd_generic_find_line, \
+       NAME##_find_inliner_info, \
+       NAME##_bfd_make_debug_symbol, \
+       NAME##_read_minisymbols, \
+       NAME##_minisymbol_to_symbol
+
+       long        (*_bfd_get_symtab_upper_bound) (bfd *);
+       long        (*_bfd_canonicalize_symtab)
+         (bfd *, struct bfd_symbol **);
+       struct bfd_symbol *
+                   (*_bfd_make_empty_symbol) (bfd *);
+       void        (*_bfd_print_symbol)
+         (bfd *, void *, struct bfd_symbol *, bfd_print_symbol_type);
+     #define bfd_print_symbol(b,p,s,e) BFD_SEND (b, _bfd_print_symbol, (b,p,s,e))
+       void        (*_bfd_get_symbol_info)
+         (bfd *, struct bfd_symbol *, symbol_info *);
+     #define bfd_get_symbol_info(b,p,e) BFD_SEND (b, _bfd_get_symbol_info, (b,p,e))
+       bfd_boolean (*_bfd_is_local_label_name) (bfd *, const char *);
+       bfd_boolean (*_bfd_is_target_special_symbol) (bfd *, asymbol *);
+       alent *     (*_get_lineno) (bfd *, struct bfd_symbol *);
+       bfd_boolean (*_bfd_find_nearest_line)
+         (bfd *, struct bfd_section *, struct bfd_symbol **, bfd_vma,
+          const char **, const char **, unsigned int *);
+       bfd_boolean (*_bfd_find_line)
+         (bfd *, struct bfd_symbol **, struct bfd_symbol *,
+          const char **, unsigned int *);
+       bfd_boolean (*_bfd_find_inliner_info)
+         (bfd *, const char **, const char **, unsigned int *);
+      /* Back-door to allow format-aware applications to create debug symbols
+         while using BFD for everything else.  Currently used by the assembler
+         when creating COFF files.  */
+       asymbol *   (*_bfd_make_debug_symbol)
+         (bfd *, void *, unsigned long size);
+     #define bfd_read_minisymbols(b, d, m, s) \
+       BFD_SEND (b, _read_minisymbols, (b, d, m, s))
+       long        (*_read_minisymbols)
+         (bfd *, bfd_boolean, void **, unsigned int *);
+     #define bfd_minisymbol_to_symbol(b, d, m, f) \
+       BFD_SEND (b, _minisymbol_to_symbol, (b, d, m, f))
+       asymbol *   (*_minisymbol_to_symbol)
+         (bfd *, bfd_boolean, const void *, asymbol *);
+
+       /* Routines for relocs.  */
+     #define BFD_JUMP_TABLE_RELOCS(NAME) \
+       NAME##_get_reloc_upper_bound, \
+       NAME##_canonicalize_reloc, \
+       NAME##_bfd_reloc_type_lookup
+
+       long        (*_get_reloc_upper_bound) (bfd *, sec_ptr);
+       long        (*_bfd_canonicalize_reloc)
+         (bfd *, sec_ptr, arelent **, struct bfd_symbol **);
+       /* See documentation on reloc types.  */
+       reloc_howto_type *
+                   (*reloc_type_lookup) (bfd *, bfd_reloc_code_real_type);
+
+       /* Routines used when writing an object file.  */
+     #define BFD_JUMP_TABLE_WRITE(NAME) \
+       NAME##_set_arch_mach, \
+       NAME##_set_section_contents
+
+       bfd_boolean (*_bfd_set_arch_mach)
+         (bfd *, enum bfd_architecture, unsigned long);
+       bfd_boolean (*_bfd_set_section_contents)
+         (bfd *, sec_ptr, const void *, file_ptr, bfd_size_type);
+
+       /* Routines used by the linker.  */
+     #define BFD_JUMP_TABLE_LINK(NAME) \
+       NAME##_sizeof_headers, \
+       NAME##_bfd_get_relocated_section_contents, \
+       NAME##_bfd_relax_section, \
+       NAME##_bfd_link_hash_table_create, \
+       NAME##_bfd_link_hash_table_free, \
+       NAME##_bfd_link_add_symbols, \
+       NAME##_bfd_link_just_syms, \
+       NAME##_bfd_final_link, \
+       NAME##_bfd_link_split_section, \
+       NAME##_bfd_gc_sections, \
+       NAME##_bfd_merge_sections, \
+       _bfd_generic_match_sections_by_type, \
+       NAME##_bfd_is_group_section, \
+       NAME##_bfd_discard_group, \
+       NAME##_section_already_linked \
+
+       int         (*_bfd_sizeof_headers) (bfd *, bfd_boolean);
+       bfd_byte *  (*_bfd_get_relocated_section_contents)
+         (bfd *, struct bfd_link_info *, struct bfd_link_order *,
+          bfd_byte *, bfd_boolean, struct bfd_symbol **);
+
+       bfd_boolean (*_bfd_relax_section)
+         (bfd *, struct bfd_section *, struct bfd_link_info *, bfd_boolean *);
+
+       /* Create a hash table for the linker.  Different backends store
+          different information in this table.  */
+       struct bfd_link_hash_table *
+                   (*_bfd_link_hash_table_create) (bfd *);
+
+       /* Release the memory associated with the linker hash table.  */
+       void        (*_bfd_link_hash_table_free) (struct bfd_link_hash_table *);
+
+       /* Add symbols from this object file into the hash table.  */
+       bfd_boolean (*_bfd_link_add_symbols) (bfd *, struct bfd_link_info *);
+
+       /* Indicate that we are only retrieving symbol values from this section.  */
+       void        (*_bfd_link_just_syms) (asection *, struct bfd_link_info *);
+
+       /* Do a link based on the link_order structures attached to each
+          section of the BFD.  */
+       bfd_boolean (*_bfd_final_link) (bfd *, struct bfd_link_info *);
+
+       /* Should this section be split up into smaller pieces during linking.  */
+       bfd_boolean (*_bfd_link_split_section) (bfd *, struct bfd_section *);
+
+       /* Remove sections that are not referenced from the output.  */
+       bfd_boolean (*_bfd_gc_sections) (bfd *, struct bfd_link_info *);
+
+       /* Attempt to merge SEC_MERGE sections.  */
+       bfd_boolean (*_bfd_merge_sections) (bfd *, struct bfd_link_info *);
+
+     #define bfd_match_sections_by_type(abfd, asec, bbfd, bsec) \
+       BFD_SEND (abfd, _bfd_match_sections_by_type, (abfd, asec, bbfd, bsec))
+       /* Return TRUE if 2 section types are compatible.  */
+       bfd_boolean (*_bfd_match_sections_by_type)
+         (bfd *, const asection *, bfd *, const asection *);
+
+       /* Is this section a member of a group?  */
+       bfd_boolean (*_bfd_is_group_section) (bfd *, const struct bfd_section *);
+
+       /* Discard members of a group.  */
+       bfd_boolean (*_bfd_discard_group) (bfd *, struct bfd_section *);
+
+       /* Check if SEC has been already linked during a reloceatable or
+          final link.  */
+       void (*_section_already_linked) (bfd *, struct bfd_section *);
+
+       /* Routines to handle dynamic symbols and relocs.  */
+     #define BFD_JUMP_TABLE_DYNAMIC(NAME) \
+       NAME##_get_dynamic_symtab_upper_bound, \
+       NAME##_canonicalize_dynamic_symtab, \
+       NAME##_get_synthetic_symtab, \
+       NAME##_get_dynamic_reloc_upper_bound, \
+       NAME##_canonicalize_dynamic_reloc
+
+       /* Get the amount of memory required to hold the dynamic symbols.  */
+       long        (*_bfd_get_dynamic_symtab_upper_bound) (bfd *);
+       /* Read in the dynamic symbols.  */
+       long        (*_bfd_canonicalize_dynamic_symtab)
+         (bfd *, struct bfd_symbol **);
+       /* Create synthetized symbols.  */
+       long        (*_bfd_get_synthetic_symtab)
+         (bfd *, long, struct bfd_symbol **, long, struct bfd_symbol **,
+          struct bfd_symbol **);
+       /* Get the amount of memory required to hold the dynamic relocs.  */
+       long        (*_bfd_get_dynamic_reloc_upper_bound) (bfd *);
+       /* Read in the dynamic relocs.  */
+       long        (*_bfd_canonicalize_dynamic_reloc)
+         (bfd *, arelent **, struct bfd_symbol **);
+   A pointer to an alternative bfd_target in case the current one is not
+satisfactory.  This can happen when the target cpu supports both big
+and little endian code, and target chosen by the linker has the wrong
+endianness.  The function open_output() in ld/ldlang.c uses this field
+to find an alternative output format that is suitable.
+       /* Opposite endian version of this target.  */
+       const struct bfd_target * alternative_target;
+
+       /* Data for use by back-end routines, which isn't
+          generic enough to belong in this structure.  */
+       const void *backend_data;
+
+     } bfd_target;
+
+2.12.1.1 `bfd_set_default_target'
+.................................
+
+*Synopsis*
+     bfd_boolean bfd_set_default_target (const char *name);
+   *Description*
+Set the default target vector to use when recognizing a BFD.  This
+takes the name of the target, which may be a BFD target name or a
+configuration triplet.
+
+2.12.1.2 `bfd_find_target'
+..........................
+
+*Synopsis*
+     const bfd_target *bfd_find_target (const char *target_name, bfd *abfd);
+   *Description*
+Return a pointer to the transfer vector for the object target named
+TARGET_NAME.  If TARGET_NAME is `NULL', choose the one in the
+environment variable `GNUTARGET'; if that is null or not defined, then
+choose the first entry in the target list.  Passing in the string
+"default" or setting the environment variable to "default" will cause
+the first entry in the target list to be returned, and
+"target_defaulted" will be set in the BFD.  This causes
+`bfd_check_format' to loop over all the targets to find the one that
+matches the file being read.
+
+2.12.1.3 `bfd_target_list'
+..........................
+
+*Synopsis*
+     const char ** bfd_target_list (void);
+   *Description*
+Return a freshly malloced NULL-terminated vector of the names of all
+the valid BFD targets. Do not modify the names.
+
+2.12.1.4 `bfd_seach_for_target'
+...............................
+
+*Synopsis*
+     const bfd_target *bfd_search_for_target
+        (int (*search_func) (const bfd_target *, void *),
+         void *);
+   *Description*
+Return a pointer to the first transfer vector in the list of transfer
+vectors maintained by BFD that produces a non-zero result when passed
+to the function SEARCH_FUNC.  The parameter DATA is passed, unexamined,
+to the search function.
+
+
+File: bfd.info,  Node: Architectures,  Next: Opening and Closing,  Prev: Targets,  Up: BFD front end
+
+2.13 Architectures
+==================
+
+BFD keeps one atom in a BFD describing the architecture of the data
+attached to the BFD: a pointer to a `bfd_arch_info_type'.
+
+   Pointers to structures can be requested independently of a BFD so
+that an architecture's information can be interrogated without access
+to an open BFD.
+
+   The architecture information is provided by each architecture
+package.  The set of default architectures is selected by the macro
+`SELECT_ARCHITECTURES'.  This is normally set up in the
+`config/TARGET.mt' file of your choice.  If the name is not defined,
+then all the architectures supported are included.
+
+   When BFD starts up, all the architectures are called with an
+initialize method.  It is up to the architecture back end to insert as
+many items into the list of architectures as it wants to; generally
+this would be one for each machine and one for the default case (an
+item with a machine field of 0).
+
+   BFD's idea of an architecture is implemented in `archures.c'.
+
+2.13.1 bfd_architecture
+-----------------------
+
+*Description*
+This enum gives the object file's CPU architecture, in a global
+sense--i.e., what processor family does it belong to?  Another field
+indicates which processor within the family is in use.  The machine
+gives a number which distinguishes different versions of the
+architecture, containing, for example, 2 and 3 for Intel i960 KA and
+i960 KB, and 68020 and 68030 for Motorola 68020 and 68030.
+     enum bfd_architecture
+     {
+       bfd_arch_unknown,   /* File arch not known.  */
+       bfd_arch_obscure,   /* Arch known, not one of these.  */
+       bfd_arch_m68k,      /* Motorola 68xxx */
+     #define bfd_mach_m68000 1
+     #define bfd_mach_m68008 2
+     #define bfd_mach_m68010 3
+     #define bfd_mach_m68020 4
+     #define bfd_mach_m68030 5
+     #define bfd_mach_m68040 6
+     #define bfd_mach_m68060 7
+     #define bfd_mach_cpu32  8
+     #define bfd_mach_mcf5200  9
+     #define bfd_mach_mcf5206e 10
+     #define bfd_mach_mcf5307  11
+     #define bfd_mach_mcf5407  12
+     #define bfd_mach_mcf528x  13
+     #define bfd_mach_mcfv4e   14
+     #define bfd_mach_mcf521x   15
+     #define bfd_mach_mcf5249   16
+     #define bfd_mach_mcf547x   17
+     #define bfd_mach_mcf548x   18
+       bfd_arch_vax,       /* DEC Vax */
+       bfd_arch_i960,      /* Intel 960 */
+         /* The order of the following is important.
+            lower number indicates a machine type that
+            only accepts a subset of the instructions
+            available to machines with higher numbers.
+            The exception is the "ca", which is
+            incompatible with all other machines except
+            "core".  */
+
+     #define bfd_mach_i960_core      1
+     #define bfd_mach_i960_ka_sa     2
+     #define bfd_mach_i960_kb_sb     3
+     #define bfd_mach_i960_mc        4
+     #define bfd_mach_i960_xa        5
+     #define bfd_mach_i960_ca        6
+     #define bfd_mach_i960_jx        7
+     #define bfd_mach_i960_hx        8
+
+       bfd_arch_or32,      /* OpenRISC 32 */
+
+       bfd_arch_sparc,     /* SPARC */
+     #define bfd_mach_sparc                 1
+     /* The difference between v8plus and v9 is that v9 is a true 64 bit env.  */
+     #define bfd_mach_sparc_sparclet        2
+     #define bfd_mach_sparc_sparclite       3
+     #define bfd_mach_sparc_v8plus          4
+     #define bfd_mach_sparc_v8plusa         5 /* with ultrasparc add'ns.  */
+     #define bfd_mach_sparc_sparclite_le    6
+     #define bfd_mach_sparc_v9              7
+     #define bfd_mach_sparc_v9a             8 /* with ultrasparc add'ns.  */
+     #define bfd_mach_sparc_v8plusb         9 /* with cheetah add'ns.  */
+     #define bfd_mach_sparc_v9b             10 /* with cheetah add'ns.  */
+     /* Nonzero if MACH has the v9 instruction set.  */
+     #define bfd_mach_sparc_v9_p(mach) \
+       ((mach) >= bfd_mach_sparc_v8plus && (mach) <= bfd_mach_sparc_v9b \
+        && (mach) != bfd_mach_sparc_sparclite_le)
+     /* Nonzero if MACH is a 64 bit sparc architecture.  */
+     #define bfd_mach_sparc_64bit_p(mach) \
+       ((mach) >= bfd_mach_sparc_v9 && (mach) != bfd_mach_sparc_v8plusb)
+       bfd_arch_mips,      /* MIPS Rxxxx */
+     #define bfd_mach_mips3000              3000
+     #define bfd_mach_mips3900              3900
+     #define bfd_mach_mips4000              4000
+     #define bfd_mach_mips4010              4010
+     #define bfd_mach_mips4100              4100
+     #define bfd_mach_mips4111              4111
+     #define bfd_mach_mips4120              4120
+     #define bfd_mach_mips4300              4300
+     #define bfd_mach_mips4400              4400
+     #define bfd_mach_mips4600              4600
+     #define bfd_mach_mips4650              4650
+     #define bfd_mach_mips5000              5000
+     #define bfd_mach_mips5400              5400
+     #define bfd_mach_mips5500              5500
+     #define bfd_mach_mips6000              6000
+     #define bfd_mach_mips7000              7000
+     #define bfd_mach_mips8000              8000
+     #define bfd_mach_mips9000              9000
+     #define bfd_mach_mips10000             10000
+     #define bfd_mach_mips12000             12000
+     #define bfd_mach_mips16                16
+     #define bfd_mach_mips5                 5
+     #define bfd_mach_mips_sb1              12310201 /* octal 'SB', 01 */
+     #define bfd_mach_mipsisa32             32
+     #define bfd_mach_mipsisa32r2           33
+     #define bfd_mach_mipsisa64             64
+     #define bfd_mach_mipsisa64r2           65
+       bfd_arch_i386,      /* Intel 386 */
+     #define bfd_mach_i386_i386 1
+     #define bfd_mach_i386_i8086 2
+     #define bfd_mach_i386_i386_intel_syntax 3
+     #define bfd_mach_x86_64 64
+     #define bfd_mach_x86_64_intel_syntax 65
+       bfd_arch_we32k,     /* AT&T WE32xxx */
+       bfd_arch_tahoe,     /* CCI/Harris Tahoe */
+       bfd_arch_i860,      /* Intel 860 */
+       bfd_arch_i370,      /* IBM 360/370 Mainframes */
+       bfd_arch_romp,      /* IBM ROMP PC/RT */
+       bfd_arch_convex,    /* Convex */
+       bfd_arch_m88k,      /* Motorola 88xxx */
+       bfd_arch_m98k,      /* Motorola 98xxx */
+       bfd_arch_pyramid,   /* Pyramid Technology */
+       bfd_arch_h8300,     /* Renesas H8/300 (formerly Hitachi H8/300) */
+     #define bfd_mach_h8300    1
+     #define bfd_mach_h8300h   2
+     #define bfd_mach_h8300s   3
+     #define bfd_mach_h8300hn  4
+     #define bfd_mach_h8300sn  5
+     #define bfd_mach_h8300sx  6
+     #define bfd_mach_h8300sxn 7
+       bfd_arch_pdp11,     /* DEC PDP-11 */
+       bfd_arch_powerpc,   /* PowerPC */
+     #define bfd_mach_ppc           32
+     #define bfd_mach_ppc64         64
+     #define bfd_mach_ppc_403       403
+     #define bfd_mach_ppc_403gc     4030
+     #define bfd_mach_ppc_505       505
+     #define bfd_mach_ppc_601       601
+     #define bfd_mach_ppc_602       602
+     #define bfd_mach_ppc_603       603
+     #define bfd_mach_ppc_ec603e    6031
+     #define bfd_mach_ppc_604       604
+     #define bfd_mach_ppc_620       620
+     #define bfd_mach_ppc_630       630
+     #define bfd_mach_ppc_750       750
+     #define bfd_mach_ppc_860       860
+     #define bfd_mach_ppc_a35       35
+     #define bfd_mach_ppc_rs64ii    642
+     #define bfd_mach_ppc_rs64iii   643
+     #define bfd_mach_ppc_7400      7400
+     #define bfd_mach_ppc_e500      500
+       bfd_arch_rs6000,    /* IBM RS/6000 */
+     #define bfd_mach_rs6k          6000
+     #define bfd_mach_rs6k_rs1      6001
+     #define bfd_mach_rs6k_rsc      6003
+     #define bfd_mach_rs6k_rs2      6002
+       bfd_arch_hppa,      /* HP PA RISC */
+     #define bfd_mach_hppa10        10
+     #define bfd_mach_hppa11        11
+     #define bfd_mach_hppa20        20
+     #define bfd_mach_hppa20w       25
+       bfd_arch_d10v,      /* Mitsubishi D10V */
+     #define bfd_mach_d10v          1
+     #define bfd_mach_d10v_ts2      2
+     #define bfd_mach_d10v_ts3      3
+       bfd_arch_d30v,      /* Mitsubishi D30V */
+       bfd_arch_dlx,       /* DLX */
+       bfd_arch_m68hc11,   /* Motorola 68HC11 */
+       bfd_arch_m68hc12,   /* Motorola 68HC12 */
+     #define bfd_mach_m6812_default 0
+     #define bfd_mach_m6812         1
+     #define bfd_mach_m6812s        2
+       bfd_arch_z8k,       /* Zilog Z8000 */
+     #define bfd_mach_z8001         1
+     #define bfd_mach_z8002         2
+       bfd_arch_h8500,     /* Renesas H8/500 (formerly Hitachi H8/500) */
+       bfd_arch_sh,        /* Renesas / SuperH SH (formerly Hitachi SH) */
+     #define bfd_mach_sh            1
+     #define bfd_mach_sh2        0x20
+     #define bfd_mach_sh_dsp     0x2d
+     #define bfd_mach_sh2a       0x2a
+     #define bfd_mach_sh2a_nofpu 0x2b
+     #define bfd_mach_sh2a_nofpu_or_sh4_nommu_nofpu 0x2a1
+     #define bfd_mach_sh2a_nofpu_or_sh3_nommu 0x2a2
+     #define bfd_mach_sh2a_or_sh4  0x2a3
+     #define bfd_mach_sh2a_or_sh3e 0x2a4
+     #define bfd_mach_sh2e       0x2e
+     #define bfd_mach_sh3        0x30
+     #define bfd_mach_sh3_nommu  0x31
+     #define bfd_mach_sh3_dsp    0x3d
+     #define bfd_mach_sh3e       0x3e
+     #define bfd_mach_sh4        0x40
+     #define bfd_mach_sh4_nofpu  0x41
+     #define bfd_mach_sh4_nommu_nofpu  0x42
+     #define bfd_mach_sh4a       0x4a
+     #define bfd_mach_sh4a_nofpu 0x4b
+     #define bfd_mach_sh4al_dsp  0x4d
+     #define bfd_mach_sh5        0x50
+       bfd_arch_alpha,     /* Dec Alpha */
+     #define bfd_mach_alpha_ev4  0x10
+     #define bfd_mach_alpha_ev5  0x20
+     #define bfd_mach_alpha_ev6  0x30
+       bfd_arch_arm,       /* Advanced Risc Machines ARM.  */
+     #define bfd_mach_arm_unknown   0
+     #define bfd_mach_arm_2         1
+     #define bfd_mach_arm_2a        2
+     #define bfd_mach_arm_3         3
+     #define bfd_mach_arm_3M        4
+     #define bfd_mach_arm_4         5
+     #define bfd_mach_arm_4T        6
+     #define bfd_mach_arm_5         7
+     #define bfd_mach_arm_5T        8
+     #define bfd_mach_arm_5TE       9
+     #define bfd_mach_arm_XScale    10
+     #define bfd_mach_arm_ep9312    11
+     #define bfd_mach_arm_iWMMXt    12
+       bfd_arch_ns32k,     /* National Semiconductors ns32000 */
+       bfd_arch_w65,       /* WDC 65816 */
+       bfd_arch_tic30,     /* Texas Instruments TMS320C30 */
+       bfd_arch_tic4x,     /* Texas Instruments TMS320C3X/4X */
+     #define bfd_mach_tic3x         30
+     #define bfd_mach_tic4x         40
+       bfd_arch_tic54x,    /* Texas Instruments TMS320C54X */
+       bfd_arch_tic80,     /* TI TMS320c80 (MVP) */
+       bfd_arch_v850,      /* NEC V850 */
+     #define bfd_mach_v850          1
+     #define bfd_mach_v850e         'E'
+     #define bfd_mach_v850e1        '1'
+       bfd_arch_arc,       /* ARC Cores */
+     #define bfd_mach_arc_5         5
+     #define bfd_mach_arc_6         6
+     #define bfd_mach_arc_7         7
+     #define bfd_mach_arc_8         8
+      bfd_arch_m32c,     /* Renesas M16C/M32C.  */
+     #define bfd_mach_m16c        0x75
+     #define bfd_mach_m32c        0x78
+       bfd_arch_m32r,      /* Renesas M32R (formerly Mitsubishi M32R/D) */
+     #define bfd_mach_m32r          1 /* For backwards compatibility.  */
+     #define bfd_mach_m32rx         'x'
+     #define bfd_mach_m32r2         '2'
+       bfd_arch_mn10200,   /* Matsushita MN10200 */
+       bfd_arch_mn10300,   /* Matsushita MN10300 */
+     #define bfd_mach_mn10300               300
+     #define bfd_mach_am33          330
+     #define bfd_mach_am33_2        332
+       bfd_arch_fr30,
+     #define bfd_mach_fr30          0x46523330
+       bfd_arch_frv,
+     #define bfd_mach_frv           1
+     #define bfd_mach_frvsimple     2
+     #define bfd_mach_fr300         300
+     #define bfd_mach_fr400         400
+     #define bfd_mach_fr450         450
+     #define bfd_mach_frvtomcat     499     /* fr500 prototype */
+     #define bfd_mach_fr500         500
+     #define bfd_mach_fr550         550
+       bfd_arch_mcore,
+       bfd_arch_ia64,      /* HP/Intel ia64 */
+     #define bfd_mach_ia64_elf64    64
+     #define bfd_mach_ia64_elf32    32
+       bfd_arch_ip2k,      /* Ubicom IP2K microcontrollers. */
+     #define bfd_mach_ip2022        1
+     #define bfd_mach_ip2022ext     2
+      bfd_arch_iq2000,     /* Vitesse IQ2000.  */
+     #define bfd_mach_iq2000        1
+     #define bfd_mach_iq10          2
+       bfd_arch_ms1,
+     #define bfd_mach_ms1           1
+     #define bfd_mach_mrisc2        2
+       bfd_arch_pj,
+       bfd_arch_avr,       /* Atmel AVR microcontrollers.  */
+     #define bfd_mach_avr1          1
+     #define bfd_mach_avr2          2
+     #define bfd_mach_avr3          3
+     #define bfd_mach_avr4          4
+     #define bfd_mach_avr5          5
+       bfd_arch_bfin,        /* ADI Blackfin */
+     #define bfd_mach_bfin          1
+       bfd_arch_cr16c,       /* National Semiconductor CompactRISC. */
+     #define bfd_mach_cr16c         1
+       bfd_arch_crx,       /*  National Semiconductor CRX.  */
+     #define bfd_mach_crx           1
+       bfd_arch_cris,      /* Axis CRIS */
+     #define bfd_mach_cris_v0_v10   255
+     #define bfd_mach_cris_v32      32
+     #define bfd_mach_cris_v10_v32  1032
+       bfd_arch_s390,      /* IBM s390 */
+     #define bfd_mach_s390_31       31
+     #define bfd_mach_s390_64       64
+       bfd_arch_openrisc,  /* OpenRISC */
+       bfd_arch_mmix,      /* Donald Knuth's educational processor.  */
+       bfd_arch_xstormy16,
+     #define bfd_mach_xstormy16     1
+       bfd_arch_msp430,    /* Texas Instruments MSP430 architecture.  */
+     #define bfd_mach_msp11          11
+     #define bfd_mach_msp110         110
+     #define bfd_mach_msp12          12
+     #define bfd_mach_msp13          13
+     #define bfd_mach_msp14          14
+     #define bfd_mach_msp15          15
+     #define bfd_mach_msp16          16
+     #define bfd_mach_msp21          21
+     #define bfd_mach_msp31          31
+     #define bfd_mach_msp32          32
+     #define bfd_mach_msp33          33
+     #define bfd_mach_msp41          41
+     #define bfd_mach_msp42          42
+     #define bfd_mach_msp43          43
+     #define bfd_mach_msp44          44
+       bfd_arch_xtensa,    /* Tensilica's Xtensa cores.  */
+     #define bfd_mach_xtensa        1
+        bfd_arch_maxq,     /* Dallas MAXQ 10/20 */
+     #define bfd_mach_maxq10    10
+     #define bfd_mach_maxq20    20
+       bfd_arch_z80,
+     #define bfd_mach_z80strict      1 /* No undocumented opcodes.  */
+     #define bfd_mach_z80            3 /* With ixl, ixh, iyl, and iyh.  */
+     #define bfd_mach_z80full        7 /* All undocumented instructions.  */
+     #define bfd_mach_r800           11 /* R800: successor with multiplication.  */
+       bfd_arch_last
+       };
+
+2.13.2 bfd_arch_info
+--------------------
+
+*Description*
+This structure contains information on architectures for use within BFD.
+
+     typedef struct bfd_arch_info
+     {
+       int bits_per_word;
+       int bits_per_address;
+       int bits_per_byte;
+       enum bfd_architecture arch;
+       unsigned long mach;
+       const char *arch_name;
+       const char *printable_name;
+       unsigned int section_align_power;
+       /* TRUE if this is the default machine for the architecture.
+          The default arch should be the first entry for an arch so that
+          all the entries for that arch can be accessed via `next'.  */
+       bfd_boolean the_default;
+       const struct bfd_arch_info * (*compatible)
+         (const struct bfd_arch_info *a, const struct bfd_arch_info *b);
+
+       bfd_boolean (*scan) (const struct bfd_arch_info *, const char *);
+
+       const struct bfd_arch_info *next;
+     }
+     bfd_arch_info_type;
+
+2.13.2.1 `bfd_printable_name'
+.............................
+
+*Synopsis*
+     const char *bfd_printable_name (bfd *abfd);
+   *Description*
+Return a printable string representing the architecture and machine
+from the pointer to the architecture info structure.
+
+2.13.2.2 `bfd_scan_arch'
+........................
+
+*Synopsis*
+     const bfd_arch_info_type *bfd_scan_arch (const char *string);
+   *Description*
+Figure out if BFD supports any cpu which could be described with the
+name STRING.  Return a pointer to an `arch_info' structure if a machine
+is found, otherwise NULL.
+
+2.13.2.3 `bfd_arch_list'
+........................
+
+*Synopsis*
+     const char **bfd_arch_list (void);
+   *Description*
+Return a freshly malloced NULL-terminated vector of the names of all
+the valid BFD architectures.  Do not modify the names.
+
+2.13.2.4 `bfd_arch_get_compatible'
+..................................
+
+*Synopsis*
+     const bfd_arch_info_type *bfd_arch_get_compatible
+        (const bfd *abfd, const bfd *bbfd, bfd_boolean accept_unknowns);
+   *Description*
+Determine whether two BFDs' architectures and machine types are
+compatible.  Calculates the lowest common denominator between the two
+architectures and machine types implied by the BFDs and returns a
+pointer to an `arch_info' structure describing the compatible machine.
+
+2.13.2.5 `bfd_default_arch_struct'
+..................................
+
+*Description*
+The `bfd_default_arch_struct' is an item of `bfd_arch_info_type' which
+has been initialized to a fairly generic state.  A BFD starts life by
+pointing to this structure, until the correct back end has determined
+the real architecture of the file.
+     extern const bfd_arch_info_type bfd_default_arch_struct;
+
+2.13.2.6 `bfd_set_arch_info'
+............................
+
+*Synopsis*
+     void bfd_set_arch_info (bfd *abfd, const bfd_arch_info_type *arg);
+   *Description*
+Set the architecture info of ABFD to ARG.
+
+2.13.2.7 `bfd_default_set_arch_mach'
+....................................
+
+*Synopsis*
+     bfd_boolean bfd_default_set_arch_mach
+        (bfd *abfd, enum bfd_architecture arch, unsigned long mach);
+   *Description*
+Set the architecture and machine type in BFD ABFD to ARCH and MACH.
+Find the correct pointer to a structure and insert it into the
+`arch_info' pointer.
+
+2.13.2.8 `bfd_get_arch'
+.......................
+
+*Synopsis*
+     enum bfd_architecture bfd_get_arch (bfd *abfd);
+   *Description*
+Return the enumerated type which describes the BFD ABFD's architecture.
+
+2.13.2.9 `bfd_get_mach'
+.......................
+
+*Synopsis*
+     unsigned long bfd_get_mach (bfd *abfd);
+   *Description*
+Return the long type which describes the BFD ABFD's machine.
+
+2.13.2.10 `bfd_arch_bits_per_byte'
+..................................
+
+*Synopsis*
+     unsigned int bfd_arch_bits_per_byte (bfd *abfd);
+   *Description*
+Return the number of bits in one of the BFD ABFD's architecture's bytes.
+
+2.13.2.11 `bfd_arch_bits_per_address'
+.....................................
+
+*Synopsis*
+     unsigned int bfd_arch_bits_per_address (bfd *abfd);
+   *Description*
+Return the number of bits in one of the BFD ABFD's architecture's
+addresses.
+
+2.13.2.12 `bfd_default_compatible'
+..................................
+
+*Synopsis*
+     const bfd_arch_info_type *bfd_default_compatible
+        (const bfd_arch_info_type *a, const bfd_arch_info_type *b);
+   *Description*
+The default function for testing for compatibility.
+
+2.13.2.13 `bfd_default_scan'
+............................
+
+*Synopsis*
+     bfd_boolean bfd_default_scan
+        (const struct bfd_arch_info *info, const char *string);
+   *Description*
+The default function for working out whether this is an architecture
+hit and a machine hit.
+
+2.13.2.14 `bfd_get_arch_info'
+.............................
+
+*Synopsis*
+     const bfd_arch_info_type *bfd_get_arch_info (bfd *abfd);
+   *Description*
+Return the architecture info struct in ABFD.
+
+2.13.2.15 `bfd_lookup_arch'
+...........................
+
+*Synopsis*
+     const bfd_arch_info_type *bfd_lookup_arch
+        (enum bfd_architecture arch, unsigned long machine);
+   *Description*
+Look for the architecture info structure which matches the arguments
+ARCH and MACHINE. A machine of 0 matches the machine/architecture
+structure which marks itself as the default.
+
+2.13.2.16 `bfd_printable_arch_mach'
+...................................
+
+*Synopsis*
+     const char *bfd_printable_arch_mach
+        (enum bfd_architecture arch, unsigned long machine);
+   *Description*
+Return a printable string representing the architecture and machine
+type.
+
+   This routine is depreciated.
+
+2.13.2.17 `bfd_octets_per_byte'
+...............................
+
+*Synopsis*
+     unsigned int bfd_octets_per_byte (bfd *abfd);
+   *Description*
+Return the number of octets (8-bit quantities) per target byte (minimum
+addressable unit).  In most cases, this will be one, but some DSP
+targets have 16, 32, or even 48 bits per byte.
+
+2.13.2.18 `bfd_arch_mach_octets_per_byte'
+.........................................
+
+*Synopsis*
+     unsigned int bfd_arch_mach_octets_per_byte
+        (enum bfd_architecture arch, unsigned long machine);
+   *Description*
+See bfd_octets_per_byte.
+
+   This routine is provided for those cases where a bfd * is not
+available
+
+
+File: bfd.info,  Node: Opening and Closing,  Next: Internal,  Prev: Architectures,  Up: BFD front end
+
+2.14 Opening and closing BFDs
+=============================
+
+2.14.1 Functions for opening and closing
+----------------------------------------
+
+2.14.1.1 `bfd_fopen'
+....................
+
+*Synopsis*
+     bfd *bfd_fopen (const char *filename, const char *target,
+         const char *mode, int fd);
+   *Description*
+Open the file FILENAME with the target TARGET.  Return a pointer to the
+created BFD.  If FD is not -1, then `fdopen' is used to open the file;
+otherwise, `fopen' is used.  MODE is passed directly to `fopen' or
+`fdopen'.
+
+   Calls `bfd_find_target', so TARGET is interpreted as by that
+function.
+
+   The new BFD is marked as cacheable iff FD is -1.
+
+   If `NULL' is returned then an error has occured.   Possible errors
+are `bfd_error_no_memory', `bfd_error_invalid_target' or `system_call'
+error.
+
+2.14.1.2 `bfd_openr'
+....................
+
+*Synopsis*
+     bfd *bfd_openr (const char *filename, const char *target);
+   *Description*
+Open the file FILENAME (using `fopen') with the target TARGET.  Return
+a pointer to the created BFD.
+
+   Calls `bfd_find_target', so TARGET is interpreted as by that
+function.
+
+   If `NULL' is returned then an error has occured.   Possible errors
+are `bfd_error_no_memory', `bfd_error_invalid_target' or `system_call'
+error.
+
+2.14.1.3 `bfd_fdopenr'
+......................
+
+*Synopsis*
+     bfd *bfd_fdopenr (const char *filename, const char *target, int fd);
+   *Description*
+`bfd_fdopenr' is to `bfd_fopenr' much like `fdopen' is to `fopen'.  It
+opens a BFD on a file already described by the FD supplied.
+
+   When the file is later `bfd_close'd, the file descriptor will be
+closed.  If the caller desires that this file descriptor be cached by
+BFD (opened as needed, closed as needed to free descriptors for other
+opens), with the supplied FD used as an initial file descriptor (but
+subject to closure at any time), call bfd_set_cacheable(bfd, 1) on the
+returned BFD.  The default is to assume no caching; the file descriptor
+will remain open until `bfd_close', and will not be affected by BFD
+operations on other files.
+
+   Possible errors are `bfd_error_no_memory',
+`bfd_error_invalid_target' and `bfd_error_system_call'.
+
+2.14.1.4 `bfd_openstreamr'
+..........................
+
+*Synopsis*
+     bfd *bfd_openstreamr (const char *, const char *, void *);
+   *Description*
+Open a BFD for read access on an existing stdio stream.  When the BFD
+is passed to `bfd_close', the stream will be closed.
+
+2.14.1.5 `bfd_openr_iovec'
+..........................
+
+*Synopsis*
+     bfd *bfd_openr_iovec (const char *filename, const char *target,
+         void *(*open) (struct bfd *nbfd,
+         void *open_closure),
+         void *open_closure,
+         file_ptr (*pread) (struct bfd *nbfd,
+         void *stream,
+         void *buf,
+         file_ptr nbytes,
+         file_ptr offset),
+         int (*close) (struct bfd *nbfd,
+         void *stream));
+   *Description*
+Create and return a BFD backed by a read-only STREAM.  The STREAM is
+created using OPEN, accessed using PREAD and destroyed using CLOSE.
+
+   Calls `bfd_find_target', so TARGET is interpreted as by that
+function.
+
+   Calls OPEN (which can call `bfd_zalloc' and `bfd_get_filename') to
+obtain the read-only stream backing the BFD.  OPEN either succeeds
+returning the non-`NULL' STREAM, or fails returning `NULL' (setting
+`bfd_error').
+
+   Calls PREAD to request NBYTES of data from STREAM starting at OFFSET
+(e.g., via a call to `bfd_read').  PREAD either succeeds returning the
+number of bytes read (which can be less than NBYTES when end-of-file),
+or fails returning -1 (setting `bfd_error').
+
+   Calls CLOSE when the BFD is later closed using `bfd_close'.  CLOSE
+either succeeds returning 0, or fails returning -1 (setting
+`bfd_error').
+
+   If `bfd_openr_iovec' returns `NULL' then an error has occurred.
+Possible errors are `bfd_error_no_memory', `bfd_error_invalid_target'
+and `bfd_error_system_call'.
+
+2.14.1.6 `bfd_openw'
+....................
+
+*Synopsis*
+     bfd *bfd_openw (const char *filename, const char *target);
+   *Description*
+Create a BFD, associated with file FILENAME, using the file format
+TARGET, and return a pointer to it.
+
+   Possible errors are `bfd_error_system_call', `bfd_error_no_memory',
+`bfd_error_invalid_target'.
+
+2.14.1.7 `bfd_close'
+....................
+
+*Synopsis*
+     bfd_boolean bfd_close (bfd *abfd);
+   *Description*
+Close a BFD. If the BFD was open for writing, then pending operations
+are completed and the file written out and closed.  If the created file
+is executable, then `chmod' is called to mark it as such.
+
+   All memory attached to the BFD is released.
+
+   The file descriptor associated with the BFD is closed (even if it
+was passed in to BFD by `bfd_fdopenr').
+
+   *Returns*
+`TRUE' is returned if all is ok, otherwise `FALSE'.
+
+2.14.1.8 `bfd_close_all_done'
+.............................
+
+*Synopsis*
+     bfd_boolean bfd_close_all_done (bfd *);
+   *Description*
+Close a BFD.  Differs from `bfd_close' since it does not complete any
+pending operations.  This routine would be used if the application had
+just used BFD for swapping and didn't want to use any of the writing
+code.
+
+   If the created file is executable, then `chmod' is called to mark it
+as such.
+
+   All memory attached to the BFD is released.
+
+   *Returns*
+`TRUE' is returned if all is ok, otherwise `FALSE'.
+
+2.14.1.9 `bfd_create'
+.....................
+
+*Synopsis*
+     bfd *bfd_create (const char *filename, bfd *templ);
+   *Description*
+Create a new BFD in the manner of `bfd_openw', but without opening a
+file. The new BFD takes the target from the target used by TEMPLATE.
+The format is always set to `bfd_object'.
+
+2.14.1.10 `bfd_make_writable'
+.............................
+
+*Synopsis*
+     bfd_boolean bfd_make_writable (bfd *abfd);
+   *Description*
+Takes a BFD as created by `bfd_create' and converts it into one like as
+returned by `bfd_openw'.  It does this by converting the BFD to
+BFD_IN_MEMORY.  It's assumed that you will call `bfd_make_readable' on
+this bfd later.
+
+   *Returns*
+`TRUE' is returned if all is ok, otherwise `FALSE'.
+
+2.14.1.11 `bfd_make_readable'
+.............................
+
+*Synopsis*
+     bfd_boolean bfd_make_readable (bfd *abfd);
+   *Description*
+Takes a BFD as created by `bfd_create' and `bfd_make_writable' and
+converts it into one like as returned by `bfd_openr'.  It does this by
+writing the contents out to the memory buffer, then reversing the
+direction.
+
+   *Returns*
+`TRUE' is returned if all is ok, otherwise `FALSE'.
+
+2.14.1.12 `bfd_alloc'
+.....................
+
+*Synopsis*
+     void *bfd_alloc (bfd *abfd, bfd_size_type wanted);
+   *Description*
+Allocate a block of WANTED bytes of memory attached to `abfd' and
+return a pointer to it.
+
+2.14.1.13 `bfd_alloc2'
+......................
+
+*Synopsis*
+     void *bfd_alloc2 (bfd *abfd, bfd_size_type nmemb, bfd_size_type size);
+   *Description*
+Allocate a block of NMEMB elements of SIZE bytes each of memory
+attached to `abfd' and return a pointer to it.
+
+2.14.1.14 `bfd_zalloc'
+......................
+
+*Synopsis*
+     void *bfd_zalloc (bfd *abfd, bfd_size_type wanted);
+   *Description*
+Allocate a block of WANTED bytes of zeroed memory attached to `abfd'
+and return a pointer to it.
+
+2.14.1.15 `bfd_zalloc2'
+.......................
+
+*Synopsis*
+     void *bfd_zalloc2 (bfd *abfd, bfd_size_type nmemb, bfd_size_type size);
+   *Description*
+Allocate a block of NMEMB elements of SIZE bytes each of zeroed memory
+attached to `abfd' and return a pointer to it.
+
+2.14.1.16 `bfd_calc_gnu_debuglink_crc32'
+........................................
+
+*Synopsis*
+     unsigned long bfd_calc_gnu_debuglink_crc32
+        (unsigned long crc, const unsigned char *buf, bfd_size_type len);
+   *Description*
+Computes a CRC value as used in the .gnu_debuglink section.  Advances
+the previously computed CRC value by computing and adding in the crc32
+for LEN bytes of BUF.
+
+   *Returns*
+Return the updated CRC32 value.
+
+2.14.1.17 `get_debug_link_info'
+...............................
+
+*Synopsis*
+     char *get_debug_link_info (bfd *abfd, unsigned long *crc32_out);
+   *Description*
+fetch the filename and CRC32 value for any separate debuginfo
+associated with ABFD. Return NULL if no such info found, otherwise
+return filename and update CRC32_OUT.
+
+2.14.1.18 `separate_debug_file_exists'
+......................................
+
+*Synopsis*
+     bfd_boolean separate_debug_file_exists
+        (char *name, unsigned long crc32);
+   *Description*
+Checks to see if NAME is a file and if its contents match CRC32.
+
+2.14.1.19 `find_separate_debug_file'
+....................................
+
+*Synopsis*
+     char *find_separate_debug_file (bfd *abfd);
+   *Description*
+Searches ABFD for a reference to separate debugging information, scans
+various locations in the filesystem, including the file tree rooted at
+DEBUG_FILE_DIRECTORY, and returns a filename of such debugging
+information if the file is found and has matching CRC32.  Returns NULL
+if no reference to debugging file exists, or file cannot be found.
+
+2.14.1.20 `bfd_follow_gnu_debuglink'
+....................................
+
+*Synopsis*
+     char *bfd_follow_gnu_debuglink (bfd *abfd, const char *dir);
+   *Description*
+Takes a BFD and searches it for a .gnu_debuglink section.  If this
+section is found, it examines the section for the name and checksum of
+a '.debug' file containing auxiliary debugging information.  It then
+searches the filesystem for this .debug file in some standard
+locations, including the directory tree rooted at DIR, and if found
+returns the full filename.
+
+   If DIR is NULL, it will search a default path configured into libbfd
+at build time.  [XXX this feature is not currently implemented].
+
+   *Returns*
+`NULL' on any errors or failure to locate the .debug file, otherwise a
+pointer to a heap-allocated string containing the filename.  The caller
+is responsible for freeing this string.
+
+2.14.1.21 `bfd_create_gnu_debuglink_section'
+............................................
+
+*Synopsis*
+     struct bfd_section *bfd_create_gnu_debuglink_section
+        (bfd *abfd, const char *filename);
+   *Description*
+Takes a BFD and adds a .gnu_debuglink section to it.  The section is
+sized to be big enough to contain a link to the specified FILENAME.
+
+   *Returns*
+A pointer to the new section is returned if all is ok.  Otherwise
+`NULL' is returned and bfd_error is set.
+
+2.14.1.22 `bfd_fill_in_gnu_debuglink_section'
+.............................................
+
+*Synopsis*
+     bfd_boolean bfd_fill_in_gnu_debuglink_section
+        (bfd *abfd, struct bfd_section *sect, const char *filename);
+   *Description*
+Takes a BFD and containing a .gnu_debuglink section SECT and fills in
+the contents of the section to contain a link to the specified
+FILENAME.  The filename should be relative to the current directory.
+
+   *Returns*
+`TRUE' is returned if all is ok.  Otherwise `FALSE' is returned and
+bfd_error is set.
+
+
+File: bfd.info,  Node: Internal,  Next: File Caching,  Prev: Opening and Closing,  Up: BFD front end
+
+2.15 Implementation details
+===========================
+
+2.15.1 Internal functions
+-------------------------
+
+*Description*
+These routines are used within BFD.  They are not intended for export,
+but are documented here for completeness.
+
+2.15.1.1 `bfd_write_bigendian_4byte_int'
+........................................
+
+*Synopsis*
+     bfd_boolean bfd_write_bigendian_4byte_int (bfd *, unsigned int);
+   *Description*
+Write a 4 byte integer I to the output BFD ABFD, in big endian order
+regardless of what else is going on.  This is useful in archives.
+
+2.15.1.2 `bfd_put_size'
+.......................
+
+2.15.1.3 `bfd_get_size'
+.......................
+
+*Description*
+These macros as used for reading and writing raw data in sections; each
+access (except for bytes) is vectored through the target format of the
+BFD and mangled accordingly. The mangling performs any necessary endian
+translations and removes alignment restrictions.  Note that types
+accepted and returned by these macros are identical so they can be
+swapped around in macros--for example, `libaout.h' defines `GET_WORD'
+to either `bfd_get_32' or `bfd_get_64'.
+
+   In the put routines, VAL must be a `bfd_vma'.  If we are on a system
+without prototypes, the caller is responsible for making sure that is
+true, with a cast if necessary.  We don't cast them in the macro
+definitions because that would prevent `lint' or `gcc -Wall' from
+detecting sins such as passing a pointer.  To detect calling these with
+less than a `bfd_vma', use `gcc -Wconversion' on a host with 64 bit
+`bfd_vma''s.
+
+     /* Byte swapping macros for user section data.  */
+
+     #define bfd_put_8(abfd, val, ptr) \
+       ((void) (*((unsigned char *) (ptr)) = (val) & 0xff))
+     #define bfd_put_signed_8 \
+       bfd_put_8
+     #define bfd_get_8(abfd, ptr) \
+       (*(unsigned char *) (ptr) & 0xff)
+     #define bfd_get_signed_8(abfd, ptr) \
+       (((*(unsigned char *) (ptr) & 0xff) ^ 0x80) - 0x80)
+
+     #define bfd_put_16(abfd, val, ptr) \
+       BFD_SEND (abfd, bfd_putx16, ((val),(ptr)))
+     #define bfd_put_signed_16 \
+       bfd_put_16
+     #define bfd_get_16(abfd, ptr) \
+       BFD_SEND (abfd, bfd_getx16, (ptr))
+     #define bfd_get_signed_16(abfd, ptr) \
+       BFD_SEND (abfd, bfd_getx_signed_16, (ptr))
+
+     #define bfd_put_32(abfd, val, ptr) \
+       BFD_SEND (abfd, bfd_putx32, ((val),(ptr)))
+     #define bfd_put_signed_32 \
+       bfd_put_32
+     #define bfd_get_32(abfd, ptr) \
+       BFD_SEND (abfd, bfd_getx32, (ptr))
+     #define bfd_get_signed_32(abfd, ptr) \
+       BFD_SEND (abfd, bfd_getx_signed_32, (ptr))
+
+     #define bfd_put_64(abfd, val, ptr) \
+       BFD_SEND (abfd, bfd_putx64, ((val), (ptr)))
+     #define bfd_put_signed_64 \
+       bfd_put_64
+     #define bfd_get_64(abfd, ptr) \
+       BFD_SEND (abfd, bfd_getx64, (ptr))
+     #define bfd_get_signed_64(abfd, ptr) \
+       BFD_SEND (abfd, bfd_getx_signed_64, (ptr))
+
+     #define bfd_get(bits, abfd, ptr)                       \
+       ((bits) == 8 ? (bfd_vma) bfd_get_8 (abfd, ptr)       \
+        : (bits) == 16 ? bfd_get_16 (abfd, ptr)             \
+        : (bits) == 32 ? bfd_get_32 (abfd, ptr)             \
+        : (bits) == 64 ? bfd_get_64 (abfd, ptr)             \
+        : (abort (), (bfd_vma) - 1))
+
+     #define bfd_put(bits, abfd, val, ptr)                  \
+       ((bits) == 8 ? bfd_put_8  (abfd, val, ptr)           \
+        : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)                \
+        : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)                \
+        : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)                \
+        : (abort (), (void) 0))
+
+2.15.1.4 `bfd_h_put_size'
+.........................
+
+*Description*
+These macros have the same function as their `bfd_get_x' brethren,
+except that they are used for removing information for the header
+records of object files. Believe it or not, some object files keep
+their header records in big endian order and their data in little
+endian order.
+
+     /* Byte swapping macros for file header data.  */
+
+     #define bfd_h_put_8(abfd, val, ptr) \
+       bfd_put_8 (abfd, val, ptr)
+     #define bfd_h_put_signed_8(abfd, val, ptr) \
+       bfd_put_8 (abfd, val, ptr)
+     #define bfd_h_get_8(abfd, ptr) \
+       bfd_get_8 (abfd, ptr)
+     #define bfd_h_get_signed_8(abfd, ptr) \
+       bfd_get_signed_8 (abfd, ptr)
+
+     #define bfd_h_put_16(abfd, val, ptr) \
+       BFD_SEND (abfd, bfd_h_putx16, (val, ptr))
+     #define bfd_h_put_signed_16 \
+       bfd_h_put_16
+     #define bfd_h_get_16(abfd, ptr) \
+       BFD_SEND (abfd, bfd_h_getx16, (ptr))
+     #define bfd_h_get_signed_16(abfd, ptr) \
+       BFD_SEND (abfd, bfd_h_getx_signed_16, (ptr))
+
+     #define bfd_h_put_32(abfd, val, ptr) \
+       BFD_SEND (abfd, bfd_h_putx32, (val, ptr))
+     #define bfd_h_put_signed_32 \
+       bfd_h_put_32
+     #define bfd_h_get_32(abfd, ptr) \
+       BFD_SEND (abfd, bfd_h_getx32, (ptr))
+     #define bfd_h_get_signed_32(abfd, ptr) \
+       BFD_SEND (abfd, bfd_h_getx_signed_32, (ptr))
+
+     #define bfd_h_put_64(abfd, val, ptr) \
+       BFD_SEND (abfd, bfd_h_putx64, (val, ptr))
+     #define bfd_h_put_signed_64 \
+       bfd_h_put_64
+     #define bfd_h_get_64(abfd, ptr) \
+       BFD_SEND (abfd, bfd_h_getx64, (ptr))
+     #define bfd_h_get_signed_64(abfd, ptr) \
+       BFD_SEND (abfd, bfd_h_getx_signed_64, (ptr))
+
+     /* Aliases for the above, which should eventually go away.  */
+
+     #define H_PUT_64  bfd_h_put_64
+     #define H_PUT_32  bfd_h_put_32
+     #define H_PUT_16  bfd_h_put_16
+     #define H_PUT_8   bfd_h_put_8
+     #define H_PUT_S64 bfd_h_put_signed_64
+     #define H_PUT_S32 bfd_h_put_signed_32
+     #define H_PUT_S16 bfd_h_put_signed_16
+     #define H_PUT_S8  bfd_h_put_signed_8
+     #define H_GET_64  bfd_h_get_64
+     #define H_GET_32  bfd_h_get_32
+     #define H_GET_16  bfd_h_get_16
+     #define H_GET_8   bfd_h_get_8
+     #define H_GET_S64 bfd_h_get_signed_64
+     #define H_GET_S32 bfd_h_get_signed_32
+     #define H_GET_S16 bfd_h_get_signed_16
+     #define H_GET_S8  bfd_h_get_signed_8
+
+2.15.1.5 `bfd_log2'
+...................
+
+*Synopsis*
+     unsigned int bfd_log2 (bfd_vma x);
+   *Description*
+Return the log base 2 of the value supplied, rounded up.  E.g., an X of
+1025 returns 11.  A X of 0 returns 0.
+
+
+File: bfd.info,  Node: File Caching,  Next: Linker Functions,  Prev: Internal,  Up: BFD front end
+
+2.16 File caching
+=================
+
+The file caching mechanism is embedded within BFD and allows the
+application to open as many BFDs as it wants without regard to the
+underlying operating system's file descriptor limit (often as low as 20
+open files).  The module in `cache.c' maintains a least recently used
+list of `BFD_CACHE_MAX_OPEN' files, and exports the name
+`bfd_cache_lookup', which runs around and makes sure that the required
+BFD is open. If not, then it chooses a file to close, closes it and
+opens the one wanted, returning its file handle.
+
+2.16.1 Caching functions
+------------------------
+
+2.16.1.1 `bfd_cache_init'
+.........................
+
+*Synopsis*
+     bfd_boolean bfd_cache_init (bfd *abfd);
+   *Description*
+Add a newly opened BFD to the cache.
+
+2.16.1.2 `bfd_cache_close'
+..........................
+
+*Synopsis*
+     bfd_boolean bfd_cache_close (bfd *abfd);
+   *Description*
+Remove the BFD ABFD from the cache. If the attached file is open, then
+close it too.
+
+   *Returns*
+`FALSE' is returned if closing the file fails, `TRUE' is returned if
+all is well.
+
+2.16.1.3 `bfd_cache_close_all'
+..............................
+
+*Synopsis*
+     bfd_boolean bfd_cache_close_all (void);
+   *Description*
+Remove all BFDs from the cache. If the attached file is open, then
+close it too.
+
+   *Returns*
+`FALSE' is returned if closing one of the file fails, `TRUE' is
+returned if all is well.
+
+2.16.1.4 `bfd_open_file'
+........................
+
+*Synopsis*
+     FILE* bfd_open_file (bfd *abfd);
+   *Description*
+Call the OS to open a file for ABFD.  Return the `FILE *' (possibly
+`NULL') that results from this operation.  Set up the BFD so that
+future accesses know the file is open. If the `FILE *' returned is
+`NULL', then it won't have been put in the cache, so it won't have to
+be removed from it.
+
+
+File: bfd.info,  Node: Linker Functions,  Next: Hash Tables,  Prev: File Caching,  Up: BFD front end
+
+2.17 Linker Functions
+=====================
+
+The linker uses three special entry points in the BFD target vector.
+It is not necessary to write special routines for these entry points
+when creating a new BFD back end, since generic versions are provided.
+However, writing them can speed up linking and make it use
+significantly less runtime memory.
+
+   The first routine creates a hash table used by the other routines.
+The second routine adds the symbols from an object file to the hash
+table.  The third routine takes all the object files and links them
+together to create the output file.  These routines are designed so
+that the linker proper does not need to know anything about the symbols
+in the object files that it is linking.  The linker merely arranges the
+sections as directed by the linker script and lets BFD handle the
+details of symbols and relocs.
+
+   The second routine and third routines are passed a pointer to a
+`struct bfd_link_info' structure (defined in `bfdlink.h') which holds
+information relevant to the link, including the linker hash table
+(which was created by the first routine) and a set of callback
+functions to the linker proper.
+
+   The generic linker routines are in `linker.c', and use the header
+file `genlink.h'.  As of this writing, the only back ends which have
+implemented versions of these routines are a.out (in `aoutx.h') and
+ECOFF (in `ecoff.c').  The a.out routines are used as examples
+throughout this section.
+
+* Menu:
+
+* Creating a Linker Hash Table::
+* Adding Symbols to the Hash Table::
+* Performing the Final Link::
+
+
+File: bfd.info,  Node: Creating a Linker Hash Table,  Next: Adding Symbols to the Hash Table,  Prev: Linker Functions,  Up: Linker Functions
+
+2.17.1 Creating a linker hash table
+-----------------------------------
+
+The linker routines must create a hash table, which must be derived
+from `struct bfd_link_hash_table' described in `bfdlink.c'.  *Note Hash
+Tables::, for information on how to create a derived hash table.  This
+entry point is called using the target vector of the linker output file.
+
+   The `_bfd_link_hash_table_create' entry point must allocate and
+initialize an instance of the desired hash table.  If the back end does
+not require any additional information to be stored with the entries in
+the hash table, the entry point may simply create a `struct
+bfd_link_hash_table'.  Most likely, however, some additional
+information will be needed.
+
+   For example, with each entry in the hash table the a.out linker
+keeps the index the symbol has in the final output file (this index
+number is used so that when doing a relocatable link the symbol index
+used in the output file can be quickly filled in when copying over a
+reloc).  The a.out linker code defines the required structures and
+functions for a hash table derived from `struct bfd_link_hash_table'.
+The a.out linker hash table is created by the function
+`NAME(aout,link_hash_table_create)'; it simply allocates space for the
+hash table, initializes it, and returns a pointer to it.
+
+   When writing the linker routines for a new back end, you will
+generally not know exactly which fields will be required until you have
+finished.  You should simply create a new hash table which defines no
+additional fields, and then simply add fields as they become necessary.
+
+
+File: bfd.info,  Node: Adding Symbols to the Hash Table,  Next: Performing the Final Link,  Prev: Creating a Linker Hash Table,  Up: Linker Functions
+
+2.17.2 Adding symbols to the hash table
+---------------------------------------
+
+The linker proper will call the `_bfd_link_add_symbols' entry point for
+each object file or archive which is to be linked (typically these are
+the files named on the command line, but some may also come from the
+linker script).  The entry point is responsible for examining the file.
+For an object file, BFD must add any relevant symbol information to
+the hash table.  For an archive, BFD must determine which elements of
+the archive should be used and adding them to the link.
+
+   The a.out version of this entry point is
+`NAME(aout,link_add_symbols)'.
+
+* Menu:
+
+* Differing file formats::
+* Adding symbols from an object file::
+* Adding symbols from an archive::
+
+
+File: bfd.info,  Node: Differing file formats,  Next: Adding symbols from an object file,  Prev: Adding Symbols to the Hash Table,  Up: Adding Symbols to the Hash Table
+
+2.17.2.1 Differing file formats
+...............................
+
+Normally all the files involved in a link will be of the same format,
+but it is also possible to link together different format object files,
+and the back end must support that.  The `_bfd_link_add_symbols' entry
+point is called via the target vector of the file to be added.  This
+has an important consequence: the function may not assume that the hash
+table is the type created by the corresponding
+`_bfd_link_hash_table_create' vector.  All the `_bfd_link_add_symbols'
+function can assume about the hash table is that it is derived from
+`struct bfd_link_hash_table'.
+
+   Sometimes the `_bfd_link_add_symbols' function must store some
+information in the hash table entry to be used by the `_bfd_final_link'
+function.  In such a case the `creator' field of the hash table must be
+checked to make sure that the hash table was created by an object file
+of the same format.
+
+   The `_bfd_final_link' routine must be prepared to handle a hash
+entry without any extra information added by the
+`_bfd_link_add_symbols' function.  A hash entry without extra
+information will also occur when the linker script directs the linker
+to create a symbol.  Note that, regardless of how a hash table entry is
+added, all the fields will be initialized to some sort of null value by
+the hash table entry initialization function.
+
+   See `ecoff_link_add_externals' for an example of how to check the
+`creator' field before saving information (in this case, the ECOFF
+external symbol debugging information) in a hash table entry.
+
+
+File: bfd.info,  Node: Adding symbols from an object file,  Next: Adding symbols from an archive,  Prev: Differing file formats,  Up: Adding Symbols to the Hash Table
+
+2.17.2.2 Adding symbols from an object file
+...........................................
+
+When the `_bfd_link_add_symbols' routine is passed an object file, it
+must add all externally visible symbols in that object file to the hash
+table.  The actual work of adding the symbol to the hash table is
+normally handled by the function `_bfd_generic_link_add_one_symbol'.
+The `_bfd_link_add_symbols' routine is responsible for reading all the
+symbols from the object file and passing the correct information to
+`_bfd_generic_link_add_one_symbol'.
+
+   The `_bfd_link_add_symbols' routine should not use
+`bfd_canonicalize_symtab' to read the symbols.  The point of providing
+this routine is to avoid the overhead of converting the symbols into
+generic `asymbol' structures.
+
+   `_bfd_generic_link_add_one_symbol' handles the details of combining
+common symbols, warning about multiple definitions, and so forth.  It
+takes arguments which describe the symbol to add, notably symbol flags,
+a section, and an offset.  The symbol flags include such things as
+`BSF_WEAK' or `BSF_INDIRECT'.  The section is a section in the object
+file, or something like `bfd_und_section_ptr' for an undefined symbol
+or `bfd_com_section_ptr' for a common symbol.
+
+   If the `_bfd_final_link' routine is also going to need to read the
+symbol information, the `_bfd_link_add_symbols' routine should save it
+somewhere attached to the object file BFD.  However, the information
+should only be saved if the `keep_memory' field of the `info' argument
+is TRUE, so that the `-no-keep-memory' linker switch is effective.
+
+   The a.out function which adds symbols from an object file is
+`aout_link_add_object_symbols', and most of the interesting work is in
+`aout_link_add_symbols'.  The latter saves pointers to the hash tables
+entries created by `_bfd_generic_link_add_one_symbol' indexed by symbol
+number, so that the `_bfd_final_link' routine does not have to call the
+hash table lookup routine to locate the entry.
+
+
+File: bfd.info,  Node: Adding symbols from an archive,  Prev: Adding symbols from an object file,  Up: Adding Symbols to the Hash Table
+
+2.17.2.3 Adding symbols from an archive
+.......................................
+
+When the `_bfd_link_add_symbols' routine is passed an archive, it must
+look through the symbols defined by the archive and decide which
+elements of the archive should be included in the link.  For each such
+element it must call the `add_archive_element' linker callback, and it
+must add the symbols from the object file to the linker hash table.
+
+   In most cases the work of looking through the symbols in the archive
+should be done by the `_bfd_generic_link_add_archive_symbols' function.
+This function builds a hash table from the archive symbol table and
+looks through the list of undefined symbols to see which elements
+should be included.  `_bfd_generic_link_add_archive_symbols' is passed
+a function to call to make the final decision about adding an archive
+element to the link and to do the actual work of adding the symbols to
+the linker hash table.
+
+   The function passed to `_bfd_generic_link_add_archive_symbols' must
+read the symbols of the archive element and decide whether the archive
+element should be included in the link.  If the element is to be
+included, the `add_archive_element' linker callback routine must be
+called with the element as an argument, and the elements symbols must
+be added to the linker hash table just as though the element had itself
+been passed to the `_bfd_link_add_symbols' function.
+
+   When the a.out `_bfd_link_add_symbols' function receives an archive,
+it calls `_bfd_generic_link_add_archive_symbols' passing
+`aout_link_check_archive_element' as the function argument.
+`aout_link_check_archive_element' calls `aout_link_check_ar_symbols'.
+If the latter decides to add the element (an element is only added if
+it provides a real, non-common, definition for a previously undefined
+or common symbol) it calls the `add_archive_element' callback and then
+`aout_link_check_archive_element' calls `aout_link_add_symbols' to
+actually add the symbols to the linker hash table.
+
+   The ECOFF back end is unusual in that it does not normally call
+`_bfd_generic_link_add_archive_symbols', because ECOFF archives already
+contain a hash table of symbols.  The ECOFF back end searches the
+archive itself to avoid the overhead of creating a new hash table.
+
+
+File: bfd.info,  Node: Performing the Final Link,  Prev: Adding Symbols to the Hash Table,  Up: Linker Functions
+
+2.17.3 Performing the final link
+--------------------------------
+
+When all the input files have been processed, the linker calls the
+`_bfd_final_link' entry point of the output BFD.  This routine is
+responsible for producing the final output file, which has several
+aspects.  It must relocate the contents of the input sections and copy
+the data into the output sections.  It must build an output symbol
+table including any local symbols from the input files and the global
+symbols from the hash table.  When producing relocatable output, it must
+modify the input relocs and write them into the output file.  There may
+also be object format dependent work to be done.
+
+   The linker will also call the `write_object_contents' entry point
+when the BFD is closed.  The two entry points must work together in
+order to produce the correct output file.
+
+   The details of how this works are inevitably dependent upon the
+specific object file format.  The a.out `_bfd_final_link' routine is
+`NAME(aout,final_link)'.
+
+* Menu:
+
+* Information provided by the linker::
+* Relocating the section contents::
+* Writing the symbol table::
+
+
+File: bfd.info,  Node: Information provided by the linker,  Next: Relocating the section contents,  Prev: Performing the Final Link,  Up: Performing the Final Link
+
+2.17.3.1 Information provided by the linker
+...........................................
+
+Before the linker calls the `_bfd_final_link' entry point, it sets up
+some data structures for the function to use.
+
+   The `input_bfds' field of the `bfd_link_info' structure will point
+to a list of all the input files included in the link.  These files are
+linked through the `link_next' field of the `bfd' structure.
+
+   Each section in the output file will have a list of `link_order'
+structures attached to the `map_head.link_order' field (the
+`link_order' structure is defined in `bfdlink.h').  These structures
+describe how to create the contents of the output section in terms of
+the contents of various input sections, fill constants, and,
+eventually, other types of information.  They also describe relocs that
+must be created by the BFD backend, but do not correspond to any input
+file; this is used to support -Ur, which builds constructors while
+generating a relocatable object file.
+
+
+File: bfd.info,  Node: Relocating the section contents,  Next: Writing the symbol table,  Prev: Information provided by the linker,  Up: Performing the Final Link
+
+2.17.3.2 Relocating the section contents
+........................................
+
+The `_bfd_final_link' function should look through the `link_order'
+structures attached to each section of the output file.  Each
+`link_order' structure should either be handled specially, or it should
+be passed to the function `_bfd_default_link_order' which will do the
+right thing (`_bfd_default_link_order' is defined in `linker.c').
+
+   For efficiency, a `link_order' of type `bfd_indirect_link_order'
+whose associated section belongs to a BFD of the same format as the
+output BFD must be handled specially.  This type of `link_order'
+describes part of an output section in terms of a section belonging to
+one of the input files.  The `_bfd_final_link' function should read the
+contents of the section and any associated relocs, apply the relocs to
+the section contents, and write out the modified section contents.  If
+performing a relocatable link, the relocs themselves must also be
+modified and written out.
+
+   The functions `_bfd_relocate_contents' and
+`_bfd_final_link_relocate' provide some general support for performing
+the actual relocations, notably overflow checking.  Their arguments
+include information about the symbol the relocation is against and a
+`reloc_howto_type' argument which describes the relocation to perform.
+These functions are defined in `reloc.c'.
+
+   The a.out function which handles reading, relocating, and writing
+section contents is `aout_link_input_section'.  The actual relocation
+is done in `aout_link_input_section_std' and
+`aout_link_input_section_ext'.
+
+
+File: bfd.info,  Node: Writing the symbol table,  Prev: Relocating the section contents,  Up: Performing the Final Link
+
+2.17.3.3 Writing the symbol table
+.................................
+
+The `_bfd_final_link' function must gather all the symbols in the input
+files and write them out.  It must also write out all the symbols in
+the global hash table.  This must be controlled by the `strip' and
+`discard' fields of the `bfd_link_info' structure.
+
+   The local symbols of the input files will not have been entered into
+the linker hash table.  The `_bfd_final_link' routine must consider
+each input file and include the symbols in the output file.  It may be
+convenient to do this when looking through the `link_order' structures,
+or it may be done by stepping through the `input_bfds' list.
+
+   The `_bfd_final_link' routine must also traverse the global hash
+table to gather all the externally visible symbols.  It is possible
+that most of the externally visible symbols may be written out when
+considering the symbols of each input file, but it is still necessary
+to traverse the hash table since the linker script may have defined
+some symbols that are not in any of the input files.
+
+   The `strip' field of the `bfd_link_info' structure controls which
+symbols are written out.  The possible values are listed in
+`bfdlink.h'.  If the value is `strip_some', then the `keep_hash' field
+of the `bfd_link_info' structure is a hash table of symbols to keep;
+each symbol should be looked up in this hash table, and only symbols
+which are present should be included in the output file.
+
+   If the `strip' field of the `bfd_link_info' structure permits local
+symbols to be written out, the `discard' field is used to further
+controls which local symbols are included in the output file.  If the
+value is `discard_l', then all local symbols which begin with a certain
+prefix are discarded; this is controlled by the
+`bfd_is_local_label_name' entry point.
+
+   The a.out backend handles symbols by calling
+`aout_link_write_symbols' on each input BFD and then traversing the
+global hash table with the function `aout_link_write_other_symbol'.  It
+builds a string table while writing out the symbols, which is written
+to the output file at the end of `NAME(aout,final_link)'.
+
+2.17.3.4 `bfd_link_split_section'
+.................................
+
+*Synopsis*
+     bfd_boolean bfd_link_split_section (bfd *abfd, asection *sec);
+   *Description*
+Return nonzero if SEC should be split during a reloceatable or final
+link.
+     #define bfd_link_split_section(abfd, sec) \
+            BFD_SEND (abfd, _bfd_link_split_section, (abfd, sec))
+
+2.17.3.5 `bfd_section_already_linked'
+.....................................
+
+*Synopsis*
+     void bfd_section_already_linked (bfd *abfd, asection *sec);
+   *Description*
+Check if SEC has been already linked during a reloceatable or final
+link.
+     #define bfd_section_already_linked(abfd, sec) \
+            BFD_SEND (abfd, _section_already_linked, (abfd, sec))
+
+
+File: bfd.info,  Node: Hash Tables,  Prev: Linker Functions,  Up: BFD front end
+
+2.18 Hash Tables
+================
+
+BFD provides a simple set of hash table functions.  Routines are
+provided to initialize a hash table, to free a hash table, to look up a
+string in a hash table and optionally create an entry for it, and to
+traverse a hash table.  There is currently no routine to delete an
+string from a hash table.
+
+   The basic hash table does not permit any data to be stored with a
+string.  However, a hash table is designed to present a base class from
+which other types of hash tables may be derived.  These derived types
+may store additional information with the string.  Hash tables were
+implemented in this way, rather than simply providing a data pointer in
+a hash table entry, because they were designed for use by the linker
+back ends.  The linker may create thousands of hash table entries, and
+the overhead of allocating private data and storing and following
+pointers becomes noticeable.
+
+   The basic hash table code is in `hash.c'.
+
+* Menu:
+
+* Creating and Freeing a Hash Table::
+* Looking Up or Entering a String::
+* Traversing a Hash Table::
+* Deriving a New Hash Table Type::
+
+
+File: bfd.info,  Node: Creating and Freeing a Hash Table,  Next: Looking Up or Entering a String,  Prev: Hash Tables,  Up: Hash Tables
+
+2.18.1 Creating and freeing a hash table
+----------------------------------------
+
+To create a hash table, create an instance of a `struct bfd_hash_table'
+(defined in `bfd.h') and call `bfd_hash_table_init' (if you know
+approximately how many entries you will need, the function
+`bfd_hash_table_init_n', which takes a SIZE argument, may be used).
+`bfd_hash_table_init' returns `FALSE' if some sort of error occurs.
+
+   The function `bfd_hash_table_init' take as an argument a function to
+use to create new entries.  For a basic hash table, use the function
+`bfd_hash_newfunc'.  *Note Deriving a New Hash Table Type::, for why
+you would want to use a different value for this argument.
+
+   `bfd_hash_table_init' will create an objalloc which will be used to
+allocate new entries.  You may allocate memory on this objalloc using
+`bfd_hash_allocate'.
+
+   Use `bfd_hash_table_free' to free up all the memory that has been
+allocated for a hash table.  This will not free up the `struct
+bfd_hash_table' itself, which you must provide.
+
+   Use `bfd_hash_set_default_size' to set the default size of hash
+table to use.
+
+
+File: bfd.info,  Node: Looking Up or Entering a String,  Next: Traversing a Hash Table,  Prev: Creating and Freeing a Hash Table,  Up: Hash Tables
+
+2.18.2 Looking up or entering a string
+--------------------------------------
+
+The function `bfd_hash_lookup' is used both to look up a string in the
+hash table and to create a new entry.
+
+   If the CREATE argument is `FALSE', `bfd_hash_lookup' will look up a
+string.  If the string is found, it will returns a pointer to a `struct
+bfd_hash_entry'.  If the string is not found in the table
+`bfd_hash_lookup' will return `NULL'.  You should not modify any of the
+fields in the returns `struct bfd_hash_entry'.
+
+   If the CREATE argument is `TRUE', the string will be entered into
+the hash table if it is not already there.  Either way a pointer to a
+`struct bfd_hash_entry' will be returned, either to the existing
+structure or to a newly created one.  In this case, a `NULL' return
+means that an error occurred.
+
+   If the CREATE argument is `TRUE', and a new entry is created, the
+COPY argument is used to decide whether to copy the string onto the
+hash table objalloc or not.  If COPY is passed as `FALSE', you must be
+careful not to deallocate or modify the string as long as the hash table
+exists.
+
+
+File: bfd.info,  Node: Traversing a Hash Table,  Next: Deriving a New Hash Table Type,  Prev: Looking Up or Entering a String,  Up: Hash Tables
+
+2.18.3 Traversing a hash table
+------------------------------
+
+The function `bfd_hash_traverse' may be used to traverse a hash table,
+calling a function on each element.  The traversal is done in a random
+order.
+
+   `bfd_hash_traverse' takes as arguments a function and a generic
+`void *' pointer.  The function is called with a hash table entry (a
+`struct bfd_hash_entry *') and the generic pointer passed to
+`bfd_hash_traverse'.  The function must return a `boolean' value, which
+indicates whether to continue traversing the hash table.  If the
+function returns `FALSE', `bfd_hash_traverse' will stop the traversal
+and return immediately.
+
+
+File: bfd.info,  Node: Deriving a New Hash Table Type,  Prev: Traversing a Hash Table,  Up: Hash Tables
+
+2.18.4 Deriving a new hash table type
+-------------------------------------
+
+Many uses of hash tables want to store additional information which
+each entry in the hash table.  Some also find it convenient to store
+additional information with the hash table itself.  This may be done
+using a derived hash table.
+
+   Since C is not an object oriented language, creating a derived hash
+table requires sticking together some boilerplate routines with a few
+differences specific to the type of hash table you want to create.
+
+   An example of a derived hash table is the linker hash table.  The
+structures for this are defined in `bfdlink.h'.  The functions are in
+`linker.c'.
+
+   You may also derive a hash table from an already derived hash table.
+For example, the a.out linker backend code uses a hash table derived
+from the linker hash table.
+
+* Menu:
+
+* Define the Derived Structures::
+* Write the Derived Creation Routine::
+* Write Other Derived Routines::
+
+
+File: bfd.info,  Node: Define the Derived Structures,  Next: Write the Derived Creation Routine,  Prev: Deriving a New Hash Table Type,  Up: Deriving a New Hash Table Type
+
+2.18.4.1 Define the derived structures
+......................................
+
+You must define a structure for an entry in the hash table, and a
+structure for the hash table itself.
+
+   The first field in the structure for an entry in the hash table must
+be of the type used for an entry in the hash table you are deriving
+from.  If you are deriving from a basic hash table this is `struct
+bfd_hash_entry', which is defined in `bfd.h'.  The first field in the
+structure for the hash table itself must be of the type of the hash
+table you are deriving from itself.  If you are deriving from a basic
+hash table, this is `struct bfd_hash_table'.
+
+   For example, the linker hash table defines `struct
+bfd_link_hash_entry' (in `bfdlink.h').  The first field, `root', is of
+type `struct bfd_hash_entry'.  Similarly, the first field in `struct
+bfd_link_hash_table', `table', is of type `struct bfd_hash_table'.
+
+
+File: bfd.info,  Node: Write the Derived Creation Routine,  Next: Write Other Derived Routines,  Prev: Define the Derived Structures,  Up: Deriving a New Hash Table Type
+
+2.18.4.2 Write the derived creation routine
+...........................................
+
+You must write a routine which will create and initialize an entry in
+the hash table.  This routine is passed as the function argument to
+`bfd_hash_table_init'.
+
+   In order to permit other hash tables to be derived from the hash
+table you are creating, this routine must be written in a standard way.
+
+   The first argument to the creation routine is a pointer to a hash
+table entry.  This may be `NULL', in which case the routine should
+allocate the right amount of space.  Otherwise the space has already
+been allocated by a hash table type derived from this one.
+
+   After allocating space, the creation routine must call the creation
+routine of the hash table type it is derived from, passing in a pointer
+to the space it just allocated.  This will initialize any fields used
+by the base hash table.
+
+   Finally the creation routine must initialize any local fields for
+the new hash table type.
+
+   Here is a boilerplate example of a creation routine.  FUNCTION_NAME
+is the name of the routine.  ENTRY_TYPE is the type of an entry in the
+hash table you are creating.  BASE_NEWFUNC is the name of the creation
+routine of the hash table type your hash table is derived from.
+
+     struct bfd_hash_entry *
+     FUNCTION_NAME (struct bfd_hash_entry *entry,
+                          struct bfd_hash_table *table,
+                          const char *string)
+     {
+       struct ENTRY_TYPE *ret = (ENTRY_TYPE *) entry;
+
+      /* Allocate the structure if it has not already been allocated by a
+         derived class.  */
+       if (ret == NULL)
+         {
+           ret = bfd_hash_allocate (table, sizeof (* ret));
+           if (ret == NULL)
+             return NULL;
+         }
+
+      /* Call the allocation method of the base class.  */
+       ret = ((ENTRY_TYPE *)
+             BASE_NEWFUNC ((struct bfd_hash_entry *) ret, table, string));
+
+      /* Initialize the local fields here.  */
+
+       return (struct bfd_hash_entry *) ret;
+     }
+   *Description*
+The creation routine for the linker hash table, which is in `linker.c',
+looks just like this example.  FUNCTION_NAME is
+`_bfd_link_hash_newfunc'.  ENTRY_TYPE is `struct bfd_link_hash_entry'.
+BASE_NEWFUNC is `bfd_hash_newfunc', the creation routine for a basic
+hash table.
+
+   `_bfd_link_hash_newfunc' also initializes the local fields in a
+linker hash table entry: `type', `written' and `next'.
+
+
+File: bfd.info,  Node: Write Other Derived Routines,  Prev: Write the Derived Creation Routine,  Up: Deriving a New Hash Table Type
+
+2.18.4.3 Write other derived routines
+.....................................
+
+You will want to write other routines for your new hash table, as well.
+
+   You will want an initialization routine which calls the
+initialization routine of the hash table you are deriving from and
+initializes any other local fields.  For the linker hash table, this is
+`_bfd_link_hash_table_init' in `linker.c'.
+
+   You will want a lookup routine which calls the lookup routine of the
+hash table you are deriving from and casts the result.  The linker hash
+table uses `bfd_link_hash_lookup' in `linker.c' (this actually takes an
+additional argument which it uses to decide how to return the looked up
+value).
+
+   You may want a traversal routine.  This should just call the
+traversal routine of the hash table you are deriving from with
+appropriate casts.  The linker hash table uses `bfd_link_hash_traverse'
+in `linker.c'.
+
+   These routines may simply be defined as macros.  For example, the
+a.out backend linker hash table, which is derived from the linker hash
+table, uses macros for the lookup and traversal routines.  These are
+`aout_link_hash_lookup' and `aout_link_hash_traverse' in aoutx.h.
+
+
+File: bfd.info,  Node: BFD back ends,  Next: GNU Free Documentation License,  Prev: BFD front end,  Up: Top
+
+3 BFD back ends
+***************
+
+* Menu:
+
+* What to Put Where::
+* aout ::	a.out backends
+* coff ::	coff backends
+* elf  ::	elf backends
+* mmo  ::	mmo backend
+
+
+File: bfd.info,  Node: What to Put Where,  Next: aout,  Prev: BFD back ends,  Up: BFD back ends
+
+   All of BFD lives in one directory.
+
+
+File: bfd.info,  Node: aout,  Next: coff,  Prev: What to Put Where,  Up: BFD back ends
+
+3.1 a.out backends
+==================
+
+*Description*
+BFD supports a number of different flavours of a.out format, though the
+major differences are only the sizes of the structures on disk, and the
+shape of the relocation information.
+
+   The support is split into a basic support file `aoutx.h' and other
+files which derive functions from the base. One derivation file is
+`aoutf1.h' (for a.out flavour 1), and adds to the basic a.out functions
+support for sun3, sun4, 386 and 29k a.out files, to create a target
+jump vector for a specific target.
+
+   This information is further split out into more specific files for
+each machine, including `sunos.c' for sun3 and sun4, `newsos3.c' for
+the Sony NEWS, and `demo64.c' for a demonstration of a 64 bit a.out
+format.
+
+   The base file `aoutx.h' defines general mechanisms for reading and
+writing records to and from disk and various other methods which BFD
+requires. It is included by `aout32.c' and `aout64.c' to form the names
+`aout_32_swap_exec_header_in', `aout_64_swap_exec_header_in', etc.
+
+   As an example, this is what goes on to make the back end for a sun4,
+from `aout32.c':
+
+            #define ARCH_SIZE 32
+            #include "aoutx.h"
+
+   Which exports names:
+
+            ...
+            aout_32_canonicalize_reloc
+            aout_32_find_nearest_line
+            aout_32_get_lineno
+            aout_32_get_reloc_upper_bound
+            ...
+
+   from `sunos.c':
+
+            #define TARGET_NAME "a.out-sunos-big"
+            #define VECNAME    sunos_big_vec
+            #include "aoutf1.h"
+
+   requires all the names from `aout32.c', and produces the jump vector
+
+            sunos_big_vec
+
+   The file `host-aout.c' is a special case.  It is for a large set of
+hosts that use "more or less standard" a.out files, and for which
+cross-debugging is not interesting.  It uses the standard 32-bit a.out
+support routines, but determines the file offsets and addresses of the
+text, data, and BSS sections, the machine architecture and machine
+type, and the entry point address, in a host-dependent manner.  Once
+these values have been determined, generic code is used to handle the
+object file.
+
+   When porting it to run on a new system, you must supply:
+
+             HOST_PAGE_SIZE
+             HOST_SEGMENT_SIZE
+             HOST_MACHINE_ARCH       (optional)
+             HOST_MACHINE_MACHINE    (optional)
+             HOST_TEXT_START_ADDR
+             HOST_STACK_END_ADDR
+
+   in the file `../include/sys/h-XXX.h' (for your host).  These values,
+plus the structures and macros defined in `a.out.h' on your host
+system, will produce a BFD target that will access ordinary a.out files
+on your host. To configure a new machine to use `host-aout.c', specify:
+
+            TDEFAULTS = -DDEFAULT_VECTOR=host_aout_big_vec
+            TDEPFILES= host-aout.o trad-core.o
+
+   in the `config/XXX.mt' file, and modify `configure.in' to use the
+`XXX.mt' file (by setting "`bfd_target=XXX'") when your configuration
+is selected.
+
+3.1.1 Relocations
+-----------------
+
+*Description*
+The file `aoutx.h' provides for both the _standard_ and _extended_
+forms of a.out relocation records.
+
+   The standard records contain only an address, a symbol index, and a
+type field. The extended records (used on 29ks and sparcs) also have a
+full integer for an addend.
+
+3.1.2 Internal entry points
+---------------------------
+
+*Description*
+`aoutx.h' exports several routines for accessing the contents of an
+a.out file, which are gathered and exported in turn by various format
+specific files (eg sunos.c).
+
+3.1.2.1 `aout_SIZE_swap_exec_header_in'
+.......................................
+
+*Synopsis*
+     void aout_SIZE_swap_exec_header_in,
+        (bfd *abfd,
+         struct external_exec *bytes,
+         struct internal_exec *execp);
+   *Description*
+Swap the information in an executable header RAW_BYTES taken from a raw
+byte stream memory image into the internal exec header structure EXECP.
+
+3.1.2.2 `aout_SIZE_swap_exec_header_out'
+........................................
+
+*Synopsis*
+     void aout_SIZE_swap_exec_header_out
+        (bfd *abfd,
+         struct internal_exec *execp,
+         struct external_exec *raw_bytes);
+   *Description*
+Swap the information in an internal exec header structure EXECP into
+the buffer RAW_BYTES ready for writing to disk.
+
+3.1.2.3 `aout_SIZE_some_aout_object_p'
+......................................
+
+*Synopsis*
+     const bfd_target *aout_SIZE_some_aout_object_p
+        (bfd *abfd,
+         struct internal_exec *execp,
+         const bfd_target *(*callback_to_real_object_p) (bfd *));
+   *Description*
+Some a.out variant thinks that the file open in ABFD checking is an
+a.out file.  Do some more checking, and set up for access if it really
+is.  Call back to the calling environment's "finish up" function just
+before returning, to handle any last-minute setup.
+
+3.1.2.4 `aout_SIZE_mkobject'
+............................
+
+*Synopsis*
+     bfd_boolean aout_SIZE_mkobject, (bfd *abfd);
+   *Description*
+Initialize BFD ABFD for use with a.out files.
+
+3.1.2.5 `aout_SIZE_machine_type'
+................................
+
+*Synopsis*
+     enum machine_type  aout_SIZE_machine_type
+        (enum bfd_architecture arch,
+         unsigned long machine,
+         bfd_boolean *unknown);
+   *Description*
+Keep track of machine architecture and machine type for a.out's. Return
+the `machine_type' for a particular architecture and machine, or
+`M_UNKNOWN' if that exact architecture and machine can't be represented
+in a.out format.
+
+   If the architecture is understood, machine type 0 (default) is
+always understood.
+
+3.1.2.6 `aout_SIZE_set_arch_mach'
+.................................
+
+*Synopsis*
+     bfd_boolean aout_SIZE_set_arch_mach,
+        (bfd *,
+         enum bfd_architecture arch,
+         unsigned long machine);
+   *Description*
+Set the architecture and the machine of the BFD ABFD to the values ARCH
+and MACHINE.  Verify that ABFD's format can support the architecture
+required.
+
+3.1.2.7 `aout_SIZE_new_section_hook'
+....................................
+
+*Synopsis*
+     bfd_boolean aout_SIZE_new_section_hook,
+        (bfd *abfd,
+         asection *newsect);
+   *Description*
+Called by the BFD in response to a `bfd_make_section' request.
+
+
+File: bfd.info,  Node: coff,  Next: elf,  Prev: aout,  Up: BFD back ends
+
+3.2 coff backends
+=================
+
+BFD supports a number of different flavours of coff format.  The major
+differences between formats are the sizes and alignments of fields in
+structures on disk, and the occasional extra field.
+
+   Coff in all its varieties is implemented with a few common files and
+a number of implementation specific files. For example, The 88k bcs
+coff format is implemented in the file `coff-m88k.c'. This file
+`#include's `coff/m88k.h' which defines the external structure of the
+coff format for the 88k, and `coff/internal.h' which defines the
+internal structure. `coff-m88k.c' also defines the relocations used by
+the 88k format *Note Relocations::.
+
+   The Intel i960 processor version of coff is implemented in
+`coff-i960.c'. This file has the same structure as `coff-m88k.c',
+except that it includes `coff/i960.h' rather than `coff-m88k.h'.
+
+3.2.1 Porting to a new version of coff
+--------------------------------------
+
+The recommended method is to select from the existing implementations
+the version of coff which is most like the one you want to use.  For
+example, we'll say that i386 coff is the one you select, and that your
+coff flavour is called foo.  Copy `i386coff.c' to `foocoff.c', copy
+`../include/coff/i386.h' to `../include/coff/foo.h', and add the lines
+to `targets.c' and `Makefile.in' so that your new back end is used.
+Alter the shapes of the structures in `../include/coff/foo.h' so that
+they match what you need. You will probably also have to add `#ifdef's
+to the code in `coff/internal.h' and `coffcode.h' if your version of
+coff is too wild.
+
+   You can verify that your new BFD backend works quite simply by
+building `objdump' from the `binutils' directory, and making sure that
+its version of what's going on and your host system's idea (assuming it
+has the pretty standard coff dump utility, usually called `att-dump' or
+just `dump') are the same.  Then clean up your code, and send what
+you've done to Cygnus. Then your stuff will be in the next release, and
+you won't have to keep integrating it.
+
+3.2.2 How the coff backend works
+--------------------------------
+
+3.2.2.1 File layout
+...................
+
+The Coff backend is split into generic routines that are applicable to
+any Coff target and routines that are specific to a particular target.
+The target-specific routines are further split into ones which are
+basically the same for all Coff targets except that they use the
+external symbol format or use different values for certain constants.
+
+   The generic routines are in `coffgen.c'.  These routines work for
+any Coff target.  They use some hooks into the target specific code;
+the hooks are in a `bfd_coff_backend_data' structure, one of which
+exists for each target.
+
+   The essentially similar target-specific routines are in
+`coffcode.h'.  This header file includes executable C code.  The
+various Coff targets first include the appropriate Coff header file,
+make any special defines that are needed, and then include `coffcode.h'.
+
+   Some of the Coff targets then also have additional routines in the
+target source file itself.
+
+   For example, `coff-i960.c' includes `coff/internal.h' and
+`coff/i960.h'.  It then defines a few constants, such as `I960', and
+includes `coffcode.h'.  Since the i960 has complex relocation types,
+`coff-i960.c' also includes some code to manipulate the i960 relocs.
+This code is not in `coffcode.h' because it would not be used by any
+other target.
+
+3.2.2.2 Bit twiddling
+.....................
+
+Each flavour of coff supported in BFD has its own header file
+describing the external layout of the structures. There is also an
+internal description of the coff layout, in `coff/internal.h'. A major
+function of the coff backend is swapping the bytes and twiddling the
+bits to translate the external form of the structures into the normal
+internal form. This is all performed in the `bfd_swap'_thing_direction
+routines. Some elements are different sizes between different versions
+of coff; it is the duty of the coff version specific include file to
+override the definitions of various packing routines in `coffcode.h'.
+E.g., the size of line number entry in coff is sometimes 16 bits, and
+sometimes 32 bits. `#define'ing `PUT_LNSZ_LNNO' and `GET_LNSZ_LNNO'
+will select the correct one. No doubt, some day someone will find a
+version of coff which has a varying field size not catered to at the
+moment. To port BFD, that person will have to add more `#defines'.
+Three of the bit twiddling routines are exported to `gdb';
+`coff_swap_aux_in', `coff_swap_sym_in' and `coff_swap_lineno_in'. `GDB'
+reads the symbol table on its own, but uses BFD to fix things up.  More
+of the bit twiddlers are exported for `gas'; `coff_swap_aux_out',
+`coff_swap_sym_out', `coff_swap_lineno_out', `coff_swap_reloc_out',
+`coff_swap_filehdr_out', `coff_swap_aouthdr_out',
+`coff_swap_scnhdr_out'. `Gas' currently keeps track of all the symbol
+table and reloc drudgery itself, thereby saving the internal BFD
+overhead, but uses BFD to swap things on the way out, making cross
+ports much safer.  Doing so also allows BFD (and thus the linker) to
+use the same header files as `gas', which makes one avenue to disaster
+disappear.
+
+3.2.2.3 Symbol reading
+......................
+
+The simple canonical form for symbols used by BFD is not rich enough to
+keep all the information available in a coff symbol table. The back end
+gets around this problem by keeping the original symbol table around,
+"behind the scenes".
+
+   When a symbol table is requested (through a call to
+`bfd_canonicalize_symtab'), a request gets through to
+`coff_get_normalized_symtab'. This reads the symbol table from the coff
+file and swaps all the structures inside into the internal form. It
+also fixes up all the pointers in the table (represented in the file by
+offsets from the first symbol in the table) into physical pointers to
+elements in the new internal table. This involves some work since the
+meanings of fields change depending upon context: a field that is a
+pointer to another structure in the symbol table at one moment may be
+the size in bytes of a structure at the next.  Another pass is made
+over the table. All symbols which mark file names (`C_FILE' symbols)
+are modified so that the internal string points to the value in the
+auxent (the real filename) rather than the normal text associated with
+the symbol (`".file"').
+
+   At this time the symbol names are moved around. Coff stores all
+symbols less than nine characters long physically within the symbol
+table; longer strings are kept at the end of the file in the string
+table. This pass moves all strings into memory and replaces them with
+pointers to the strings.
+
+   The symbol table is massaged once again, this time to create the
+canonical table used by the BFD application. Each symbol is inspected
+in turn, and a decision made (using the `sclass' field) about the
+various flags to set in the `asymbol'.  *Note Symbols::. The generated
+canonical table shares strings with the hidden internal symbol table.
+
+   Any linenumbers are read from the coff file too, and attached to the
+symbols which own the functions the linenumbers belong to.
+
+3.2.2.4 Symbol writing
+......................
+
+Writing a symbol to a coff file which didn't come from a coff file will
+lose any debugging information. The `asymbol' structure remembers the
+BFD from which the symbol was taken, and on output the back end makes
+sure that the same destination target as source target is present.
+
+   When the symbols have come from a coff file then all the debugging
+information is preserved.
+
+   Symbol tables are provided for writing to the back end in a vector
+of pointers to pointers. This allows applications like the linker to
+accumulate and output large symbol tables without having to do too much
+byte copying.
+
+   This function runs through the provided symbol table and patches
+each symbol marked as a file place holder (`C_FILE') to point to the
+next file place holder in the list. It also marks each `offset' field
+in the list with the offset from the first symbol of the current symbol.
+
+   Another function of this procedure is to turn the canonical value
+form of BFD into the form used by coff. Internally, BFD expects symbol
+values to be offsets from a section base; so a symbol physically at
+0x120, but in a section starting at 0x100, would have the value 0x20.
+Coff expects symbols to contain their final value, so symbols have
+their values changed at this point to reflect their sum with their
+owning section.  This transformation uses the `output_section' field of
+the `asymbol''s `asection' *Note Sections::.
+
+   * `coff_mangle_symbols'
+   This routine runs though the provided symbol table and uses the
+offsets generated by the previous pass and the pointers generated when
+the symbol table was read in to create the structured hierarchy
+required by coff. It changes each pointer to a symbol into the index
+into the symbol table of the asymbol.
+
+   * `coff_write_symbols'
+   This routine runs through the symbol table and patches up the
+symbols from their internal form into the coff way, calls the bit
+twiddlers, and writes out the table to the file.
+
+3.2.2.5 `coff_symbol_type'
+..........................
+
+*Description*
+The hidden information for an `asymbol' is described in a
+`combined_entry_type':
+
+
+     typedef struct coff_ptr_struct
+     {
+       /* Remembers the offset from the first symbol in the file for
+          this symbol. Generated by coff_renumber_symbols. */
+       unsigned int offset;
+
+       /* Should the value of this symbol be renumbered.  Used for
+          XCOFF C_BSTAT symbols.  Set by coff_slurp_symbol_table.  */
+       unsigned int fix_value : 1;
+
+       /* Should the tag field of this symbol be renumbered.
+          Created by coff_pointerize_aux. */
+       unsigned int fix_tag : 1;
+
+       /* Should the endidx field of this symbol be renumbered.
+          Created by coff_pointerize_aux. */
+       unsigned int fix_end : 1;
+
+       /* Should the x_csect.x_scnlen field be renumbered.
+          Created by coff_pointerize_aux. */
+       unsigned int fix_scnlen : 1;
+
+       /* Fix up an XCOFF C_BINCL/C_EINCL symbol.  The value is the
+          index into the line number entries.  Set by coff_slurp_symbol_table.  */
+       unsigned int fix_line : 1;
+
+       /* The container for the symbol structure as read and translated
+          from the file. */
+       union
+       {
+         union internal_auxent auxent;
+         struct internal_syment syment;
+       } u;
+     } combined_entry_type;
+
+
+     /* Each canonical asymbol really looks like this: */
+
+     typedef struct coff_symbol_struct
+     {
+       /* The actual symbol which the rest of BFD works with */
+       asymbol symbol;
+
+       /* A pointer to the hidden information for this symbol */
+       combined_entry_type *native;
+
+       /* A pointer to the linenumber information for this symbol */
+       struct lineno_cache_entry *lineno;
+
+       /* Have the line numbers been relocated yet ? */
+       bfd_boolean done_lineno;
+     } coff_symbol_type;
+   
+3.2.2.6 `bfd_coff_backend_data'
+...............................
+
+     /* COFF symbol classifications.  */
+
+     enum coff_symbol_classification
+     {
+       /* Global symbol.  */
+       COFF_SYMBOL_GLOBAL,
+       /* Common symbol.  */
+       COFF_SYMBOL_COMMON,
+       /* Undefined symbol.  */
+       COFF_SYMBOL_UNDEFINED,
+       /* Local symbol.  */
+       COFF_SYMBOL_LOCAL,
+       /* PE section symbol.  */
+       COFF_SYMBOL_PE_SECTION
+     };
+Special entry points for gdb to swap in coff symbol table parts:
+     typedef struct
+     {
+       void (*_bfd_coff_swap_aux_in)
+         (bfd *, void *, int, int, int, int, void *);
+
+       void (*_bfd_coff_swap_sym_in)
+         (bfd *, void *, void *);
+
+       void (*_bfd_coff_swap_lineno_in)
+         (bfd *, void *, void *);
+
+       unsigned int (*_bfd_coff_swap_aux_out)
+         (bfd *, void *, int, int, int, int, void *);
+
+       unsigned int (*_bfd_coff_swap_sym_out)
+         (bfd *, void *, void *);
+
+       unsigned int (*_bfd_coff_swap_lineno_out)
+         (bfd *, void *, void *);
+
+       unsigned int (*_bfd_coff_swap_reloc_out)
+         (bfd *, void *, void *);
+
+       unsigned int (*_bfd_coff_swap_filehdr_out)
+         (bfd *, void *, void *);
+
+       unsigned int (*_bfd_coff_swap_aouthdr_out)
+         (bfd *, void *, void *);
+
+       unsigned int (*_bfd_coff_swap_scnhdr_out)
+         (bfd *, void *, void *);
+
+       unsigned int _bfd_filhsz;
+       unsigned int _bfd_aoutsz;
+       unsigned int _bfd_scnhsz;
+       unsigned int _bfd_symesz;
+       unsigned int _bfd_auxesz;
+       unsigned int _bfd_relsz;
+       unsigned int _bfd_linesz;
+       unsigned int _bfd_filnmlen;
+       bfd_boolean _bfd_coff_long_filenames;
+       bfd_boolean _bfd_coff_long_section_names;
+       unsigned int _bfd_coff_default_section_alignment_power;
+       bfd_boolean _bfd_coff_force_symnames_in_strings;
+       unsigned int _bfd_coff_debug_string_prefix_length;
+
+       void (*_bfd_coff_swap_filehdr_in)
+         (bfd *, void *, void *);
+
+       void (*_bfd_coff_swap_aouthdr_in)
+         (bfd *, void *, void *);
+
+       void (*_bfd_coff_swap_scnhdr_in)
+         (bfd *, void *, void *);
+
+       void (*_bfd_coff_swap_reloc_in)
+         (bfd *abfd, void *, void *);
+
+       bfd_boolean (*_bfd_coff_bad_format_hook)
+         (bfd *, void *);
+
+       bfd_boolean (*_bfd_coff_set_arch_mach_hook)
+         (bfd *, void *);
+
+       void * (*_bfd_coff_mkobject_hook)
+         (bfd *, void *, void *);
+
+       bfd_boolean (*_bfd_styp_to_sec_flags_hook)
+         (bfd *, void *, const char *, asection *, flagword *);
+
+       void (*_bfd_set_alignment_hook)
+         (bfd *, asection *, void *);
+
+       bfd_boolean (*_bfd_coff_slurp_symbol_table)
+         (bfd *);
+
+       bfd_boolean (*_bfd_coff_symname_in_debug)
+         (bfd *, struct internal_syment *);
+
+       bfd_boolean (*_bfd_coff_pointerize_aux_hook)
+         (bfd *, combined_entry_type *, combined_entry_type *,
+                 unsigned int, combined_entry_type *);
+
+       bfd_boolean (*_bfd_coff_print_aux)
+         (bfd *, FILE *, combined_entry_type *, combined_entry_type *,
+                 combined_entry_type *, unsigned int);
+
+       void (*_bfd_coff_reloc16_extra_cases)
+         (bfd *, struct bfd_link_info *, struct bfd_link_order *, arelent *,
+                bfd_byte *, unsigned int *, unsigned int *);
+
+       int (*_bfd_coff_reloc16_estimate)
+         (bfd *, asection *, arelent *, unsigned int,
+                 struct bfd_link_info *);
+
+       enum coff_symbol_classification (*_bfd_coff_classify_symbol)
+         (bfd *, struct internal_syment *);
+
+       bfd_boolean (*_bfd_coff_compute_section_file_positions)
+         (bfd *);
+
+       bfd_boolean (*_bfd_coff_start_final_link)
+         (bfd *, struct bfd_link_info *);
+
+       bfd_boolean (*_bfd_coff_relocate_section)
+         (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
+                 struct internal_reloc *, struct internal_syment *, asection **);
+
+       reloc_howto_type *(*_bfd_coff_rtype_to_howto)
+         (bfd *, asection *, struct internal_reloc *,
+                 struct coff_link_hash_entry *, struct internal_syment *,
+                 bfd_vma *);
+
+       bfd_boolean (*_bfd_coff_adjust_symndx)
+         (bfd *, struct bfd_link_info *, bfd *, asection *,
+                 struct internal_reloc *, bfd_boolean *);
+
+       bfd_boolean (*_bfd_coff_link_add_one_symbol)
+         (struct bfd_link_info *, bfd *, const char *, flagword,
+                 asection *, bfd_vma, const char *, bfd_boolean, bfd_boolean,
+                 struct bfd_link_hash_entry **);
+
+       bfd_boolean (*_bfd_coff_link_output_has_begun)
+         (bfd *, struct coff_final_link_info *);
+
+       bfd_boolean (*_bfd_coff_final_link_postscript)
+         (bfd *, struct coff_final_link_info *);
+
+     } bfd_coff_backend_data;
+
+     #define coff_backend_info(abfd) \
+       ((bfd_coff_backend_data *) (abfd)->xvec->backend_data)
+
+     #define bfd_coff_swap_aux_in(a,e,t,c,ind,num,i) \
+       ((coff_backend_info (a)->_bfd_coff_swap_aux_in) (a,e,t,c,ind,num,i))
+
+     #define bfd_coff_swap_sym_in(a,e,i) \
+       ((coff_backend_info (a)->_bfd_coff_swap_sym_in) (a,e,i))
+
+     #define bfd_coff_swap_lineno_in(a,e,i) \
+       ((coff_backend_info ( a)->_bfd_coff_swap_lineno_in) (a,e,i))
+
+     #define bfd_coff_swap_reloc_out(abfd, i, o) \
+       ((coff_backend_info (abfd)->_bfd_coff_swap_reloc_out) (abfd, i, o))
+
+     #define bfd_coff_swap_lineno_out(abfd, i, o) \
+       ((coff_backend_info (abfd)->_bfd_coff_swap_lineno_out) (abfd, i, o))
+
+     #define bfd_coff_swap_aux_out(a,i,t,c,ind,num,o) \
+       ((coff_backend_info (a)->_bfd_coff_swap_aux_out) (a,i,t,c,ind,num,o))
+
+     #define bfd_coff_swap_sym_out(abfd, i,o) \
+       ((coff_backend_info (abfd)->_bfd_coff_swap_sym_out) (abfd, i, o))
+
+     #define bfd_coff_swap_scnhdr_out(abfd, i,o) \
+       ((coff_backend_info (abfd)->_bfd_coff_swap_scnhdr_out) (abfd, i, o))
+
+     #define bfd_coff_swap_filehdr_out(abfd, i,o) \
+       ((coff_backend_info (abfd)->_bfd_coff_swap_filehdr_out) (abfd, i, o))
+
+     #define bfd_coff_swap_aouthdr_out(abfd, i,o) \
+       ((coff_backend_info (abfd)->_bfd_coff_swap_aouthdr_out) (abfd, i, o))
+
+     #define bfd_coff_filhsz(abfd) (coff_backend_info (abfd)->_bfd_filhsz)
+     #define bfd_coff_aoutsz(abfd) (coff_backend_info (abfd)->_bfd_aoutsz)
+     #define bfd_coff_scnhsz(abfd) (coff_backend_info (abfd)->_bfd_scnhsz)
+     #define bfd_coff_symesz(abfd) (coff_backend_info (abfd)->_bfd_symesz)
+     #define bfd_coff_auxesz(abfd) (coff_backend_info (abfd)->_bfd_auxesz)
+     #define bfd_coff_relsz(abfd)  (coff_backend_info (abfd)->_bfd_relsz)
+     #define bfd_coff_linesz(abfd) (coff_backend_info (abfd)->_bfd_linesz)
+     #define bfd_coff_filnmlen(abfd) (coff_backend_info (abfd)->_bfd_filnmlen)
+     #define bfd_coff_long_filenames(abfd) \
+       (coff_backend_info (abfd)->_bfd_coff_long_filenames)
+     #define bfd_coff_long_section_names(abfd) \
+       (coff_backend_info (abfd)->_bfd_coff_long_section_names)
+     #define bfd_coff_default_section_alignment_power(abfd) \
+       (coff_backend_info (abfd)->_bfd_coff_default_section_alignment_power)
+     #define bfd_coff_swap_filehdr_in(abfd, i,o) \
+       ((coff_backend_info (abfd)->_bfd_coff_swap_filehdr_in) (abfd, i, o))
+
+     #define bfd_coff_swap_aouthdr_in(abfd, i,o) \
+       ((coff_backend_info (abfd)->_bfd_coff_swap_aouthdr_in) (abfd, i, o))
+
+     #define bfd_coff_swap_scnhdr_in(abfd, i,o) \
+       ((coff_backend_info (abfd)->_bfd_coff_swap_scnhdr_in) (abfd, i, o))
+
+     #define bfd_coff_swap_reloc_in(abfd, i, o) \
+       ((coff_backend_info (abfd)->_bfd_coff_swap_reloc_in) (abfd, i, o))
+
+     #define bfd_coff_bad_format_hook(abfd, filehdr) \
+       ((coff_backend_info (abfd)->_bfd_coff_bad_format_hook) (abfd, filehdr))
+
+     #define bfd_coff_set_arch_mach_hook(abfd, filehdr)\
+       ((coff_backend_info (abfd)->_bfd_coff_set_arch_mach_hook) (abfd, filehdr))
+     #define bfd_coff_mkobject_hook(abfd, filehdr, aouthdr)\
+       ((coff_backend_info (abfd)->_bfd_coff_mkobject_hook)\
+        (abfd, filehdr, aouthdr))
+
+     #define bfd_coff_styp_to_sec_flags_hook(abfd, scnhdr, name, section, flags_ptr)\
+       ((coff_backend_info (abfd)->_bfd_styp_to_sec_flags_hook)\
+        (abfd, scnhdr, name, section, flags_ptr))
+
+     #define bfd_coff_set_alignment_hook(abfd, sec, scnhdr)\
+       ((coff_backend_info (abfd)->_bfd_set_alignment_hook) (abfd, sec, scnhdr))
+
+     #define bfd_coff_slurp_symbol_table(abfd)\
+       ((coff_backend_info (abfd)->_bfd_coff_slurp_symbol_table) (abfd))
+
+     #define bfd_coff_symname_in_debug(abfd, sym)\
+       ((coff_backend_info (abfd)->_bfd_coff_symname_in_debug) (abfd, sym))
+
+     #define bfd_coff_force_symnames_in_strings(abfd)\
+       (coff_backend_info (abfd)->_bfd_coff_force_symnames_in_strings)
+
+     #define bfd_coff_debug_string_prefix_length(abfd)\
+       (coff_backend_info (abfd)->_bfd_coff_debug_string_prefix_length)
+
+     #define bfd_coff_print_aux(abfd, file, base, symbol, aux, indaux)\
+       ((coff_backend_info (abfd)->_bfd_coff_print_aux)\
+        (abfd, file, base, symbol, aux, indaux))
+
+     #define bfd_coff_reloc16_extra_cases(abfd, link_info, link_order,\
+                                          reloc, data, src_ptr, dst_ptr)\
+       ((coff_backend_info (abfd)->_bfd_coff_reloc16_extra_cases)\
+        (abfd, link_info, link_order, reloc, data, src_ptr, dst_ptr))
+
+     #define bfd_coff_reloc16_estimate(abfd, section, reloc, shrink, link_info)\
+       ((coff_backend_info (abfd)->_bfd_coff_reloc16_estimate)\
+        (abfd, section, reloc, shrink, link_info))
+
+     #define bfd_coff_classify_symbol(abfd, sym)\
+       ((coff_backend_info (abfd)->_bfd_coff_classify_symbol)\
+        (abfd, sym))
+
+     #define bfd_coff_compute_section_file_positions(abfd)\
+       ((coff_backend_info (abfd)->_bfd_coff_compute_section_file_positions)\
+        (abfd))
+
+     #define bfd_coff_start_final_link(obfd, info)\
+       ((coff_backend_info (obfd)->_bfd_coff_start_final_link)\
+        (obfd, info))
+     #define bfd_coff_relocate_section(obfd,info,ibfd,o,con,rel,isyms,secs)\
+       ((coff_backend_info (ibfd)->_bfd_coff_relocate_section)\
+        (obfd, info, ibfd, o, con, rel, isyms, secs))
+     #define bfd_coff_rtype_to_howto(abfd, sec, rel, h, sym, addendp)\
+       ((coff_backend_info (abfd)->_bfd_coff_rtype_to_howto)\
+        (abfd, sec, rel, h, sym, addendp))
+     #define bfd_coff_adjust_symndx(obfd, info, ibfd, sec, rel, adjustedp)\
+       ((coff_backend_info (abfd)->_bfd_coff_adjust_symndx)\
+        (obfd, info, ibfd, sec, rel, adjustedp))
+     #define bfd_coff_link_add_one_symbol(info, abfd, name, flags, section,\
+                                          value, string, cp, coll, hashp)\
+       ((coff_backend_info (abfd)->_bfd_coff_link_add_one_symbol)\
+        (info, abfd, name, flags, section, value, string, cp, coll, hashp))
+
+     #define bfd_coff_link_output_has_begun(a,p) \
+       ((coff_backend_info (a)->_bfd_coff_link_output_has_begun) (a, p))
+     #define bfd_coff_final_link_postscript(a,p) \
+       ((coff_backend_info (a)->_bfd_coff_final_link_postscript) (a, p))
+
+3.2.2.7 Writing relocations
+...........................
+
+To write relocations, the back end steps though the canonical
+relocation table and create an `internal_reloc'. The symbol index to
+use is removed from the `offset' field in the symbol table supplied.
+The address comes directly from the sum of the section base address and
+the relocation offset; the type is dug directly from the howto field.
+Then the `internal_reloc' is swapped into the shape of an
+`external_reloc' and written out to disk.
+
+3.2.2.8 Reading linenumbers
+...........................
+
+Creating the linenumber table is done by reading in the entire coff
+linenumber table, and creating another table for internal use.
+
+   A coff linenumber table is structured so that each function is
+marked as having a line number of 0. Each line within the function is
+an offset from the first line in the function. The base of the line
+number information for the table is stored in the symbol associated
+with the function.
+
+   Note: The PE format uses line number 0 for a flag indicating a new
+source file.
+
+   The information is copied from the external to the internal table,
+and each symbol which marks a function is marked by pointing its...
+
+   How does this work ?
+
+3.2.2.9 Reading relocations
+...........................
+
+Coff relocations are easily transformed into the internal BFD form
+(`arelent').
+
+   Reading a coff relocation table is done in the following stages:
+
+   * Read the entire coff relocation table into memory.
+
+   * Process each relocation in turn; first swap it from the external
+     to the internal form.
+
+   * Turn the symbol referenced in the relocation's symbol index into a
+     pointer into the canonical symbol table.  This table is the same
+     as the one returned by a call to `bfd_canonicalize_symtab'. The
+     back end will call that routine and save the result if a
+     canonicalization hasn't been done.
+
+   * The reloc index is turned into a pointer to a howto structure, in
+     a back end specific way. For instance, the 386 and 960 use the
+     `r_type' to directly produce an index into a howto table vector;
+     the 88k subtracts a number from the `r_type' field and creates an
+     addend field.
+
+
+File: bfd.info,  Node: elf,  Next: mmo,  Prev: coff,  Up: BFD back ends
+
+3.3 ELF backends
+================
+
+BFD support for ELF formats is being worked on.  Currently, the best
+supported back ends are for sparc and i386 (running svr4 or Solaris 2).
+
+   Documentation of the internals of the support code still needs to be
+written.  The code is changing quickly enough that we haven't bothered
+yet.
+
+3.3.0.1 `bfd_elf_find_section'
+..............................
+
+*Synopsis*
+     struct elf_internal_shdr *bfd_elf_find_section (bfd *abfd, char *name);
+   *Description*
+Helper functions for GDB to locate the string tables.  Since BFD hides
+string tables from callers, GDB needs to use an internal hook to find
+them.  Sun's .stabstr, in particular, isn't even pointed to by the
+.stab section, so ordinary mechanisms wouldn't work to find it, even if
+we had some.
+
+
+File: bfd.info,  Node: mmo,  Prev: elf,  Up: BFD back ends
+
+3.4 mmo backend
+===============
+
+The mmo object format is used exclusively together with Professor
+Donald E. Knuth's educational 64-bit processor MMIX.  The simulator
+`mmix' which is available at
+`http://www-cs-faculty.stanford.edu/~knuth/programs/mmix.tar.gz'
+understands this format.  That package also includes a combined
+assembler and linker called `mmixal'.  The mmo format has no advantages
+feature-wise compared to e.g. ELF.  It is a simple non-relocatable
+object format with no support for archives or debugging information,
+except for symbol value information and line numbers (which is not yet
+implemented in BFD).  See
+`http://www-cs-faculty.stanford.edu/~knuth/mmix.html' for more
+information about MMIX.  The ELF format is used for intermediate object
+files in the BFD implementation.
+
+* Menu:
+
+* File layout::
+* Symbol-table::
+* mmo section mapping::
+
+
+File: bfd.info,  Node: File layout,  Next: Symbol-table,  Prev: mmo,  Up: mmo
+
+3.4.1 File layout
+-----------------
+
+The mmo file contents is not partitioned into named sections as with
+e.g. ELF.  Memory areas is formed by specifying the location of the
+data that follows.  Only the memory area `0x0000...00' to `0x01ff...ff'
+is executable, so it is used for code (and constants) and the area
+`0x2000...00' to `0x20ff...ff' is used for writable data.  *Note mmo
+section mapping::.
+
+   There is provision for specifying "special data" of 65536 different
+types.  We use type 80 (decimal), arbitrarily chosen the same as the
+ELF `e_machine' number for MMIX, filling it with section information
+normally found in ELF objects. *Note mmo section mapping::.
+
+   Contents is entered as 32-bit words, xor:ed over previous contents,
+always zero-initialized.  A word that starts with the byte `0x98' forms
+a command called a `lopcode', where the next byte distinguished between
+the thirteen lopcodes.  The two remaining bytes, called the `Y' and `Z'
+fields, or the `YZ' field (a 16-bit big-endian number), are used for
+various purposes different for each lopcode.  As documented in
+`http://www-cs-faculty.stanford.edu/~knuth/mmixal-intro.ps.gz', the
+lopcodes are:
+
+`lop_quote'
+     0x98000001.  The next word is contents, regardless of whether it
+     starts with 0x98 or not.
+
+`lop_loc'
+     0x9801YYZZ, where `Z' is 1 or 2.  This is a location directive,
+     setting the location for the next data to the next 32-bit word
+     (for Z = 1) or 64-bit word (for Z = 2), plus Y * 2^56.  Normally
+     `Y' is 0 for the text segment and 2 for the data segment.
+
+`lop_skip'
+     0x9802YYZZ.  Increase the current location by `YZ' bytes.
+
+`lop_fixo'
+     0x9803YYZZ, where `Z' is 1 or 2.  Store the current location as 64
+     bits into the location pointed to by the next 32-bit (Z = 1) or
+     64-bit (Z = 2) word, plus Y * 2^56.
+
+`lop_fixr'
+     0x9804YYZZ.  `YZ' is stored into the current location plus 2 - 4 *
+     YZ.
+
+`lop_fixrx'
+     0x980500ZZ.  `Z' is 16 or 24.  A value `L' derived from the
+     following 32-bit word are used in a manner similar to `YZ' in
+     lop_fixr: it is xor:ed into the current location minus 4 * L.  The
+     first byte of the word is 0 or 1.  If it is 1, then L = (LOWEST 24
+     BITS OF WORD) - 2^Z, if 0, then L = (LOWEST 24 BITS OF WORD).
+
+`lop_file'
+     0x9806YYZZ.  `Y' is the file number, `Z' is count of 32-bit words.
+     Set the file number to `Y' and the line counter to 0.  The next Z
+     * 4 bytes contain the file name, padded with zeros if the count is
+     not a multiple of four.  The same `Y' may occur multiple times,
+     but `Z' must be 0 for all but the first occurrence.
+
+`lop_line'
+     0x9807YYZZ.  `YZ' is the line number.  Together with lop_file, it
+     forms the source location for the next 32-bit word.  Note that for
+     each non-lopcode 32-bit word, line numbers are assumed incremented
+     by one.
+
+`lop_spec'
+     0x9808YYZZ.  `YZ' is the type number.  Data until the next lopcode
+     other than lop_quote forms special data of type `YZ'.  *Note mmo
+     section mapping::.
+
+     Other types than 80, (or type 80 with a content that does not
+     parse) is stored in sections named `.MMIX.spec_data.N' where N is
+     the `YZ'-type.  The flags for such a sections say not to allocate
+     or load the data.  The vma is 0.  Contents of multiple occurrences
+     of special data N is concatenated to the data of the previous
+     lop_spec Ns.  The location in data or code at which the lop_spec
+     occurred is lost.
+
+`lop_pre'
+     0x980901ZZ.  The first lopcode in a file.  The `Z' field forms the
+     length of header information in 32-bit words, where the first word
+     tells the time in seconds since `00:00:00 GMT Jan 1 1970'.
+
+`lop_post'
+     0x980a00ZZ.  Z > 32.  This lopcode follows after all
+     content-generating lopcodes in a program.  The `Z' field denotes
+     the value of `rG' at the beginning of the program.  The following
+     256 - Z big-endian 64-bit words are loaded into global registers
+     `$G' ... `$255'.
+
+`lop_stab'
+     0x980b0000.  The next-to-last lopcode in a program.  Must follow
+     immediately after the lop_post lopcode and its data.  After this
+     lopcode follows all symbols in a compressed format (*note
+     Symbol-table::).
+
+`lop_end'
+     0x980cYYZZ.  The last lopcode in a program.  It must follow the
+     lop_stab lopcode and its data.  The `YZ' field contains the number
+     of 32-bit words of symbol table information after the preceding
+     lop_stab lopcode.
+
+   Note that the lopcode "fixups"; `lop_fixr', `lop_fixrx' and
+`lop_fixo' are not generated by BFD, but are handled.  They are
+generated by `mmixal'.
+
+   This trivial one-label, one-instruction file:
+
+      :Main TRAP 1,2,3
+
+   can be represented this way in mmo:
+
+      0x98090101 - lop_pre, one 32-bit word with timestamp.
+      <timestamp>
+      0x98010002 - lop_loc, text segment, using a 64-bit address.
+                   Note that mmixal does not emit this for the file above.
+      0x00000000 - Address, high 32 bits.
+      0x00000000 - Address, low 32 bits.
+      0x98060002 - lop_file, 2 32-bit words for file-name.
+      0x74657374 - "test"
+      0x2e730000 - ".s\0\0"
+      0x98070001 - lop_line, line 1.
+      0x00010203 - TRAP 1,2,3
+      0x980a00ff - lop_post, setting $255 to 0.
+      0x00000000
+      0x00000000
+      0x980b0000 - lop_stab for ":Main" = 0, serial 1.
+      0x203a4040   *Note Symbol-table::.
+      0x10404020
+      0x4d206120
+      0x69016e00
+      0x81000000
+      0x980c0005 - lop_end; symbol table contained five 32-bit words.
+
+
+File: bfd.info,  Node: Symbol-table,  Next: mmo section mapping,  Prev: File layout,  Up: mmo
+
+3.4.2 Symbol table format
+-------------------------
+
+From mmixal.w (or really, the generated mmixal.tex) in
+`http://www-cs-faculty.stanford.edu/~knuth/programs/mmix.tar.gz'):
+"Symbols are stored and retrieved by means of a `ternary search trie',
+following ideas of Bentley and Sedgewick. (See ACM-SIAM Symp. on
+Discrete Algorithms `8' (1997), 360-369; R.Sedgewick, `Algorithms in C'
+(Reading, Mass.  Addison-Wesley, 1998), `15.4'.)  Each trie node stores
+a character, and there are branches to subtries for the cases where a
+given character is less than, equal to, or greater than the character
+in the trie.  There also is a pointer to a symbol table entry if a
+symbol ends at the current node."
+
+   So it's a tree encoded as a stream of bytes.  The stream of bytes
+acts on a single virtual global symbol, adding and removing characters
+and signalling complete symbol points.  Here, we read the stream and
+create symbols at the completion points.
+
+   First, there's a control byte `m'.  If any of the listed bits in `m'
+is nonzero, we execute what stands at the right, in the listed order:
+
+      (MMO3_LEFT)
+      0x40 - Traverse left trie.
+             (Read a new command byte and recurse.)
+
+      (MMO3_SYMBITS)
+      0x2f - Read the next byte as a character and store it in the
+             current character position; increment character position.
+             Test the bits of `m':
+
+             (MMO3_WCHAR)
+             0x80 - The character is 16-bit (so read another byte,
+                    merge into current character.
+
+             (MMO3_TYPEBITS)
+             0xf  - We have a complete symbol; parse the type, value
+                    and serial number and do what should be done
+                    with a symbol.  The type and length information
+                    is in j = (m & 0xf).
+
+                    (MMO3_REGQUAL_BITS)
+                    j == 0xf: A register variable.  The following
+                              byte tells which register.
+                    j <= 8:   An absolute symbol.  Read j bytes as the
+                              big-endian number the symbol equals.
+                              A j = 2 with two zero bytes denotes an
+                              unknown symbol.
+                    j > 8:    As with j <= 8, but add (0x20 << 56)
+                              to the value in the following j - 8
+                              bytes.
+
+                    Then comes the serial number, as a variant of
+                    uleb128, but better named ubeb128:
+                    Read bytes and shift the previous value left 7
+                    (multiply by 128).  Add in the new byte, repeat
+                    until a byte has bit 7 set.  The serial number
+                    is the computed value minus 128.
+
+             (MMO3_MIDDLE)
+             0x20 - Traverse middle trie.  (Read a new command byte
+                    and recurse.)  Decrement character position.
+
+      (MMO3_RIGHT)
+      0x10 - Traverse right trie.  (Read a new command byte and
+             recurse.)
+
+   Let's look again at the `lop_stab' for the trivial file (*note File
+layout::).
+
+      0x980b0000 - lop_stab for ":Main" = 0, serial 1.
+      0x203a4040
+      0x10404020
+      0x4d206120
+      0x69016e00
+      0x81000000
+
+   This forms the trivial trie (note that the path between ":" and "M"
+is redundant):
+
+      203a     ":"
+      40       /
+      40      /
+      10      \
+      40      /
+      40     /
+      204d  "M"
+      2061  "a"
+      2069  "i"
+      016e  "n" is the last character in a full symbol, and
+            with a value represented in one byte.
+      00    The value is 0.
+      81    The serial number is 1.
+
+
+File: bfd.info,  Node: mmo section mapping,  Prev: Symbol-table,  Up: mmo
+
+3.4.3 mmo section mapping
+-------------------------
+
+The implementation in BFD uses special data type 80 (decimal) to
+encapsulate and describe named sections, containing e.g. debug
+information.  If needed, any datum in the encapsulation will be quoted
+using lop_quote.  First comes a 32-bit word holding the number of
+32-bit words containing the zero-terminated zero-padded segment name.
+After the name there's a 32-bit word holding flags describing the
+section type.  Then comes a 64-bit big-endian word with the section
+length (in bytes), then another with the section start address.
+Depending on the type of section, the contents might follow,
+zero-padded to 32-bit boundary.  For a loadable section (such as data
+or code), the contents might follow at some later point, not
+necessarily immediately, as a lop_loc with the same start address as in
+the section description, followed by the contents.  This in effect
+forms a descriptor that must be emitted before the actual contents.
+Sections described this way must not overlap.
+
+   For areas that don't have such descriptors, synthetic sections are
+formed by BFD.  Consecutive contents in the two memory areas
+`0x0000...00' to `0x01ff...ff' and `0x2000...00' to `0x20ff...ff' are
+entered in sections named `.text' and `.data' respectively.  If an area
+is not otherwise described, but would together with a neighboring lower
+area be less than `0x40000000' bytes long, it is joined with the lower
+area and the gap is zero-filled.  For other cases, a new section is
+formed, named `.MMIX.sec.N'.  Here, N is a number, a running count
+through the mmo file, starting at 0.
+
+   A loadable section specified as:
+
+      .section secname,"ax"
+      TETRA 1,2,3,4,-1,-2009
+      BYTE 80
+
+   and linked to address `0x4', is represented by the sequence:
+
+      0x98080050 - lop_spec 80
+      0x00000002 - two 32-bit words for the section name
+      0x7365636e - "secn"
+      0x616d6500 - "ame\0"
+      0x00000033 - flags CODE, READONLY, LOAD, ALLOC
+      0x00000000 - high 32 bits of section length
+      0x0000001c - section length is 28 bytes; 6 * 4 + 1 + alignment to 32 bits
+      0x00000000 - high 32 bits of section address
+      0x00000004 - section address is 4
+      0x98010002 - 64 bits with address of following data
+      0x00000000 - high 32 bits of address
+      0x00000004 - low 32 bits: data starts at address 4
+      0x00000001 - 1
+      0x00000002 - 2
+      0x00000003 - 3
+      0x00000004 - 4
+      0xffffffff - -1
+      0xfffff827 - -2009
+      0x50000000 - 80 as a byte, padded with zeros.
+
+   Note that the lop_spec wrapping does not include the section
+contents.  Compare this to a non-loaded section specified as:
+
+      .section thirdsec
+      TETRA 200001,100002
+      BYTE 38,40
+
+   This, when linked to address `0x200000000000001c', is represented by:
+
+      0x98080050 - lop_spec 80
+      0x00000002 - two 32-bit words for the section name
+      0x7365636e - "thir"
+      0x616d6500 - "dsec"
+      0x00000010 - flag READONLY
+      0x00000000 - high 32 bits of section length
+      0x0000000c - section length is 12 bytes; 2 * 4 + 2 + alignment to 32 bits
+      0x20000000 - high 32 bits of address
+      0x0000001c - low 32 bits of address 0x200000000000001c
+      0x00030d41 - 200001
+      0x000186a2 - 100002
+      0x26280000 - 38, 40 as bytes, padded with zeros
+
+   For the latter example, the section contents must not be loaded in
+memory, and is therefore specified as part of the special data.  The
+address is usually unimportant but might provide information for e.g.
+the DWARF 2 debugging format.
+
+
+File: bfd.info,  Node: GNU Free Documentation License,  Next: Index,  Prev: BFD back ends,  Up: Top
+
+Appendix A GNU Free Documentation License
+*****************************************
+
+                        Version 1.1, March 2000
+
+     Copyright (C) 2000, 2003 Free Software Foundation, Inc.
+     51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+
+     Everyone is permitted to copy and distribute verbatim copies
+     of this license document, but changing it is not allowed.
+
+
+  0. PREAMBLE
+
+     The purpose of this License is to make a manual, textbook, or other
+     written document "free" in the sense of freedom: to assure everyone
+     the effective freedom to copy and redistribute it, with or without
+     modifying it, either commercially or noncommercially.  Secondarily,
+     this License preserves for the author and publisher a way to get
+     credit for their work, while not being considered responsible for
+     modifications made by others.
+
+     This License is a kind of "copyleft", which means that derivative
+     works of the document must themselves be free in the same sense.
+     It complements the GNU General Public License, which is a copyleft
+     license designed for free software.
+
+     We have designed this License in order to use it for manuals for
+     free software, because free software needs free documentation: a
+     free program should come with manuals providing the same freedoms
+     that the software does.  But this License is not limited to
+     software manuals; it can be used for any textual work, regardless
+     of subject matter or whether it is published as a printed book.
+     We recommend this License principally for works whose purpose is
+     instruction or reference.
+
+
+  1. APPLICABILITY AND DEFINITIONS
+
+     This License applies to any manual or other work that contains a
+     notice placed by the copyright holder saying it can be distributed
+     under the terms of this License.  The "Document", below, refers to
+     any such manual or work.  Any member of the public is a licensee,
+     and is addressed as "you."
+
+     A "Modified Version" of the Document means any work containing the
+     Document or a portion of it, either copied verbatim, or with
+     modifications and/or translated into another language.
+
+     A "Secondary Section" is a named appendix or a front-matter
+     section of the Document that deals exclusively with the
+     relationship of the publishers or authors of the Document to the
+     Document's overall subject (or to related matters) and contains
+     nothing that could fall directly within that overall subject.
+     (For example, if the Document is in part a textbook of
+     mathematics, a Secondary Section may not explain any mathematics.)
+     The relationship could be a matter of historical connection with
+     the subject or with related matters, or of legal, commercial,
+     philosophical, ethical or political position regarding them.
+
+     The "Invariant Sections" are certain Secondary Sections whose
+     titles are designated, as being those of Invariant Sections, in
+     the notice that says that the Document is released under this
+     License.
+
+     The "Cover Texts" are certain short passages of text that are
+     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
+     that says that the Document is released under this License.
+
+     A "Transparent" copy of the Document means a machine-readable copy,
+     represented in a format whose specification is available to the
+     general public, whose contents can be viewed and edited directly
+     and straightforwardly with generic text editors or (for images
+     composed of pixels) generic paint programs or (for drawings) some
+     widely available drawing editor, and that is suitable for input to
+     text formatters or for automatic translation to a variety of
+     formats suitable for input to text formatters.  A copy made in an
+     otherwise Transparent file format whose markup has been designed
+     to thwart or discourage subsequent modification by readers is not
+     Transparent.  A copy that is not "Transparent" is called "Opaque."
+
+     Examples of suitable formats for Transparent copies include plain
+     ASCII without markup, Texinfo input format, LaTeX input format,
+     SGML or XML using a publicly available DTD, and
+     standard-conforming simple HTML designed for human modification.
+     Opaque formats include PostScript, PDF, proprietary formats that
+     can be read and edited only by proprietary word processors, SGML
+     or XML for which the DTD and/or processing tools are not generally
+     available, and the machine-generated HTML produced by some word
+     processors for output purposes only.
+
+     The "Title Page" means, for a printed book, the title page itself,
+     plus such following pages as are needed to hold, legibly, the
+     material this License requires to appear in the title page.  For
+     works in formats which do not have any title page as such, "Title
+     Page" means the text near the most prominent appearance of the
+     work's title, preceding the beginning of the body of the text.
+
+  2. VERBATIM COPYING
+
+     You may copy and distribute the Document in any medium, either
+     commercially or noncommercially, provided that this License, the
+     copyright notices, and the license notice saying this License
+     applies to the Document are reproduced in all copies, and that you
+     add no other conditions whatsoever to those of this License.  You
+     may not use technical measures to obstruct or control the reading
+     or further copying of the copies you make or distribute.  However,
+     you may accept compensation in exchange for copies.  If you
+     distribute a large enough number of copies you must also follow
+     the conditions in section 3.
+
+     You may also lend copies, under the same conditions stated above,
+     and you may publicly display copies.
+
+  3. COPYING IN QUANTITY
+
+     If you publish printed copies of the Document numbering more than
+     100, and the Document's license notice requires Cover Texts, you
+     must enclose the copies in covers that carry, clearly and legibly,
+     all these Cover Texts: Front-Cover Texts on the front cover, and
+     Back-Cover Texts on the back cover.  Both covers must also clearly
+     and legibly identify you as the publisher of these copies.  The
+     front cover must present the full title with all words of the
+     title equally prominent and visible.  You may add other material
+     on the covers in addition.  Copying with changes limited to the
+     covers, as long as they preserve the title of the Document and
+     satisfy these conditions, can be treated as verbatim copying in
+     other respects.
+
+     If the required texts for either cover are too voluminous to fit
+     legibly, you should put the first ones listed (as many as fit
+     reasonably) on the actual cover, and continue the rest onto
+     adjacent pages.
+
+     If you publish or distribute Opaque copies of the Document
+     numbering more than 100, you must either include a
+     machine-readable Transparent copy along with each Opaque copy, or
+     state in or with each Opaque copy a publicly-accessible
+     computer-network location containing a complete Transparent copy
+     of the Document, free of added material, which the general
+     network-using public has access to download anonymously at no
+     charge using public-standard network protocols.  If you use the
+     latter option, you must take reasonably prudent steps, when you
+     begin distribution of Opaque copies in quantity, to ensure that
+     this Transparent copy will remain thus accessible at the stated
+     location until at least one year after the last time you
+     distribute an Opaque copy (directly or through your agents or
+     retailers) of that edition to the public.
+
+     It is requested, but not required, that you contact the authors of
+     the Document well before redistributing any large number of
+     copies, to give them a chance to provide you with an updated
+     version of the Document.
+
+  4. MODIFICATIONS
+
+     You may copy and distribute a Modified Version of the Document
+     under the conditions of sections 2 and 3 above, provided that you
+     release the Modified Version under precisely this License, with
+     the Modified Version filling the role of the Document, thus
+     licensing distribution and modification of the Modified Version to
+     whoever possesses a copy of it.  In addition, you must do these
+     things in the Modified Version:
+
+     A. Use in the Title Page (and on the covers, if any) a title
+     distinct    from that of the Document, and from those of previous
+     versions    (which should, if there were any, be listed in the
+     History section    of the Document).  You may use the same title
+     as a previous version    if the original publisher of that version
+     gives permission.
+     B. List on the Title Page, as authors, one or more persons or
+     entities    responsible for authorship of the modifications in the
+     Modified    Version, together with at least five of the principal
+     authors of the    Document (all of its principal authors, if it
+     has less than five).
+     C. State on the Title page the name of the publisher of the
+     Modified Version, as the publisher.
+     D. Preserve all the copyright notices of the Document.
+     E. Add an appropriate copyright notice for your modifications
+     adjacent to the other copyright notices.
+     F. Include, immediately after the copyright notices, a license
+     notice    giving the public permission to use the Modified Version
+     under the    terms of this License, in the form shown in the
+     Addendum below.
+     G. Preserve in that license notice the full lists of Invariant
+     Sections    and required Cover Texts given in the Document's
+     license notice.
+     H. Include an unaltered copy of this License.
+     I. Preserve the section entitled "History", and its title, and add
+     to    it an item stating at least the title, year, new authors, and
+       publisher of the Modified Version as given on the Title Page.
+     If    there is no section entitled "History" in the Document,
+     create one    stating the title, year, authors, and publisher of
+     the Document as    given on its Title Page, then add an item
+     describing the Modified    Version as stated in the previous
+     sentence.
+     J. Preserve the network location, if any, given in the Document for
+       public access to a Transparent copy of the Document, and
+     likewise    the network locations given in the Document for
+     previous versions    it was based on.  These may be placed in the
+     "History" section.     You may omit a network location for a work
+     that was published at    least four years before the Document
+     itself, or if the original    publisher of the version it refers
+     to gives permission.
+     K. In any section entitled "Acknowledgements" or "Dedications",
+     preserve the section's title, and preserve in the section all the
+      substance and tone of each of the contributor acknowledgements
+     and/or dedications given therein.
+     L. Preserve all the Invariant Sections of the Document,
+     unaltered in their text and in their titles.  Section numbers
+     or the equivalent are not considered part of the section titles.
+     M. Delete any section entitled "Endorsements."  Such a section
+     may not be included in the Modified Version.
+     N. Do not retitle any existing section as "Endorsements"    or to
+     conflict in title with any Invariant Section.
+
+     If the Modified Version includes new front-matter sections or
+     appendices that qualify as Secondary Sections and contain no
+     material copied from the Document, you may at your option
+     designate some or all of these sections as invariant.  To do this,
+     add their titles to the list of Invariant Sections in the Modified
+     Version's license notice.  These titles must be distinct from any
+     other section titles.
+
+     You may add a section entitled "Endorsements", provided it contains
+     nothing but endorsements of your Modified Version by various
+     parties-for example, statements of peer review or that the text has
+     been approved by an organization as the authoritative definition
+     of a standard.
+
+     You may add a passage of up to five words as a Front-Cover Text,
+     and a passage of up to 25 words as a Back-Cover Text, to the end
+     of the list of Cover Texts in the Modified Version.  Only one
+     passage of Front-Cover Text and one of Back-Cover Text may be
+     added by (or through arrangements made by) any one entity.  If the
+     Document already includes a cover text for the same cover,
+     previously added by you or by arrangement made by the same entity
+     you are acting on behalf of, you may not add another; but you may
+     replace the old one, on explicit permission from the previous
+     publisher that added the old one.
+
+     The author(s) and publisher(s) of the Document do not by this
+     License give permission to use their names for publicity for or to
+     assert or imply endorsement of any Modified Version.
+
+  5. COMBINING DOCUMENTS
+
+     You may combine the Document with other documents released under
+     this License, under the terms defined in section 4 above for
+     modified versions, provided that you include in the combination
+     all of the Invariant Sections of all of the original documents,
+     unmodified, and list them all as Invariant Sections of your
+     combined work in its license notice.
+
+     The combined work need only contain one copy of this License, and
+     multiple identical Invariant Sections may be replaced with a single
+     copy.  If there are multiple Invariant Sections with the same name
+     but different contents, make the title of each such section unique
+     by adding at the end of it, in parentheses, the name of the
+     original author or publisher of that section if known, or else a
+     unique number.  Make the same adjustment to the section titles in
+     the list of Invariant Sections in the license notice of the
+     combined work.
+
+     In the combination, you must combine any sections entitled
+     "History" in the various original documents, forming one section
+     entitled "History"; likewise combine any sections entitled
+     "Acknowledgements", and any sections entitled "Dedications."  You
+     must delete all sections entitled "Endorsements."
+
+  6. COLLECTIONS OF DOCUMENTS
+
+     You may make a collection consisting of the Document and other
+     documents released under this License, and replace the individual
+     copies of this License in the various documents with a single copy
+     that is included in the collection, provided that you follow the
+     rules of this License for verbatim copying of each of the
+     documents in all other respects.
+
+     You may extract a single document from such a collection, and
+     distribute it individually under this License, provided you insert
+     a copy of this License into the extracted document, and follow
+     this License in all other respects regarding verbatim copying of
+     that document.
+
+  7. AGGREGATION WITH INDEPENDENT WORKS
+
+     A compilation of the Document or its derivatives with other
+     separate and independent documents or works, in or on a volume of
+     a storage or distribution medium, does not as a whole count as a
+     Modified Version of the Document, provided no compilation
+     copyright is claimed for the compilation.  Such a compilation is
+     called an "aggregate", and this License does not apply to the
+     other self-contained works thus compiled with the Document, on
+     account of their being thus compiled, if they are not themselves
+     derivative works of the Document.
+
+     If the Cover Text requirement of section 3 is applicable to these
+     copies of the Document, then if the Document is less than one
+     quarter of the entire aggregate, the Document's Cover Texts may be
+     placed on covers that surround only the Document within the
+     aggregate.  Otherwise they must appear on covers around the whole
+     aggregate.
+
+  8. TRANSLATION
+
+     Translation is considered a kind of modification, so you may
+     distribute translations of the Document under the terms of section
+     4.  Replacing Invariant Sections with translations requires special
+     permission from their copyright holders, but you may include
+     translations of some or all Invariant Sections in addition to the
+     original versions of these Invariant Sections.  You may include a
+     translation of this License provided that you also include the
+     original English version of this License.  In case of a
+     disagreement between the translation and the original English
+     version of this License, the original English version will prevail.
+
+  9. TERMINATION
+
+     You may not copy, modify, sublicense, or distribute the Document
+     except as expressly provided for under this License.  Any other
+     attempt to copy, modify, sublicense or distribute the Document is
+     void, and will automatically terminate your rights under this
+     License.  However, parties who have received copies, or rights,
+     from you under this License will not have their licenses
+     terminated so long as such parties remain in full compliance.
+
+ 10. FUTURE REVISIONS OF THIS LICENSE
+
+     The Free Software Foundation may publish new, revised versions of
+     the GNU Free Documentation License from time to time.  Such new
+     versions will be similar in spirit to the present version, but may
+     differ in detail to address new problems or concerns.  See
+     http://www.gnu.org/copyleft/.
+
+     Each version of the License is given a distinguishing version
+     number.  If the Document specifies that a particular numbered
+     version of this License "or any later version" applies to it, you
+     have the option of following the terms and conditions either of
+     that specified version or of any later version that has been
+     published (not as a draft) by the Free Software Foundation.  If
+     the Document does not specify a version number of this License,
+     you may choose any version ever published (not as a draft) by the
+     Free Software Foundation.
+
+
+ADDENDUM: How to use this License for your documents
+====================================================
+
+To use this License in a document you have written, include a copy of
+the License in the document and put the following copyright and license
+notices just after the title page:
+
+     Copyright (C)  YEAR  YOUR NAME.
+     Permission is granted to copy, distribute and/or modify this document
+     under the terms of the GNU Free Documentation License, Version 1.1
+     or any later version published by the Free Software Foundation;
+     with the Invariant Sections being LIST THEIR TITLES, with the
+     Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
+     A copy of the license is included in the section entitled "GNU
+     Free Documentation License."
+
+   If you have no Invariant Sections, write "with no Invariant Sections"
+instead of saying which ones are invariant.  If you have no Front-Cover
+Texts, write "no Front-Cover Texts" instead of "Front-Cover Texts being
+LIST"; likewise for Back-Cover Texts.
+
+   If your document contains nontrivial examples of program code, we
+recommend releasing these examples in parallel under your choice of
+free software license, such as the GNU General Public License, to
+permit their use in free software.
+
+
+File: bfd.info,  Node: Index,  Prev: GNU Free Documentation License,  Up: Top
+
+Index
+*****
+
+ [index ]
+* Menu:
+
+* _bfd_final_link_relocate:              Relocating the section contents.
+                                                             (line   22)
+* _bfd_generic_link_add_archive_symbols: Adding symbols from an archive.
+                                                             (line   12)
+* _bfd_generic_link_add_one_symbol:      Adding symbols from an object file.
+                                                             (line   19)
+* _bfd_generic_make_empty_symbol:        symbol handling functions.
+                                                             (line   92)
+* _bfd_link_add_symbols in target vector: Adding Symbols to the Hash Table.
+                                                             (line    6)
+* _bfd_link_final_link in target vector: Performing the Final Link.
+                                                             (line    6)
+* _bfd_link_hash_table_create in target vector: Creating a Linker Hash Table.
+                                                             (line    6)
+* _bfd_relocate_contents:                Relocating the section contents.
+                                                             (line   22)
+* aout_SIZE_machine_type:                aout.               (line  147)
+* aout_SIZE_mkobject:                    aout.               (line  139)
+* aout_SIZE_new_section_hook:            aout.               (line  177)
+* aout_SIZE_set_arch_mach:               aout.               (line  164)
+* aout_SIZE_some_aout_object_p:          aout.               (line  125)
+* aout_SIZE_swap_exec_header_in:         aout.               (line  101)
+* aout_SIZE_swap_exec_header_out:        aout.               (line  113)
+* arelent_chain:                         typedef arelent.    (line  338)
+* BFD:                                   Overview.           (line    6)
+* BFD canonical format:                  Canonical format.   (line   11)
+* bfd_alloc:                             Opening and Closing.
+                                                             (line  203)
+* bfd_alloc2:                            Opening and Closing.
+                                                             (line  212)
+* bfd_alt_mach_code:                     BFD front end.      (line  599)
+* bfd_arch_bits_per_address:             Architectures.      (line  465)
+* bfd_arch_bits_per_byte:                Architectures.      (line  457)
+* bfd_arch_get_compatible:               Architectures.      (line  400)
+* bfd_arch_list:                         Architectures.      (line  391)
+* bfd_arch_mach_octets_per_byte:         Architectures.      (line  534)
+* BFD_ARELOC_BFIN_ADD:                   howto manager.      (line  849)
+* BFD_ARELOC_BFIN_ADDR:                  howto manager.      (line  900)
+* BFD_ARELOC_BFIN_AND:                   howto manager.      (line  870)
+* BFD_ARELOC_BFIN_COMP:                  howto manager.      (line  891)
+* BFD_ARELOC_BFIN_CONST:                 howto manager.      (line  846)
+* BFD_ARELOC_BFIN_DIV:                   howto manager.      (line  858)
+* BFD_ARELOC_BFIN_HWPAGE:                howto manager.      (line  897)
+* BFD_ARELOC_BFIN_LAND:                  howto manager.      (line  879)
+* BFD_ARELOC_BFIN_LEN:                   howto manager.      (line  885)
+* BFD_ARELOC_BFIN_LOR:                   howto manager.      (line  882)
+* BFD_ARELOC_BFIN_LSHIFT:                howto manager.      (line  864)
+* BFD_ARELOC_BFIN_MOD:                   howto manager.      (line  861)
+* BFD_ARELOC_BFIN_MULT:                  howto manager.      (line  855)
+* BFD_ARELOC_BFIN_NEG:                   howto manager.      (line  888)
+* BFD_ARELOC_BFIN_OR:                    howto manager.      (line  873)
+* BFD_ARELOC_BFIN_PAGE:                  howto manager.      (line  894)
+* BFD_ARELOC_BFIN_PUSH:                  howto manager.      (line  843)
+* BFD_ARELOC_BFIN_RSHIFT:                howto manager.      (line  867)
+* BFD_ARELOC_BFIN_SUB:                   howto manager.      (line  852)
+* BFD_ARELOC_BFIN_XOR:                   howto manager.      (line  876)
+* bfd_cache_close:                       File Caching.       (line   26)
+* bfd_cache_close_all:                   File Caching.       (line   39)
+* bfd_cache_init:                        File Caching.       (line   18)
+* bfd_calc_gnu_debuglink_crc32:          Opening and Closing.
+                                                             (line  239)
+* bfd_canonicalize_reloc:                BFD front end.      (line  318)
+* bfd_canonicalize_symtab:               symbol handling functions.
+                                                             (line   50)
+* bfd_check_format:                      Formats.            (line   21)
+* bfd_check_format_matches:              Formats.            (line   52)
+* bfd_check_overflow:                    typedef arelent.    (line  350)
+* bfd_close:                             Opening and Closing.
+                                                             (line  128)
+* bfd_close_all_done:                    Opening and Closing.
+                                                             (line  146)
+* bfd_coff_backend_data:                 coff.               (line  246)
+* bfd_copy_private_bfd_data:             BFD front end.      (line  457)
+* bfd_copy_private_header_data:          BFD front end.      (line  439)
+* bfd_copy_private_section_data:         section prototypes. (line  255)
+* bfd_copy_private_symbol_data:          symbol handling functions.
+                                                             (line  140)
+* bfd_core_file_failing_command:         Core Files.         (line   12)
+* bfd_core_file_failing_signal:          Core Files.         (line   21)
+* bfd_create:                            Opening and Closing.
+                                                             (line  165)
+* bfd_create_gnu_debuglink_section:      Opening and Closing.
+                                                             (line  305)
+* bfd_decode_symclass:                   symbol handling functions.
+                                                             (line  111)
+* bfd_default_arch_struct:               Architectures.      (line  412)
+* bfd_default_compatible:                Architectures.      (line  474)
+* bfd_default_reloc_type_lookup:         howto manager.      (line 1873)
+* bfd_default_scan:                      Architectures.      (line  483)
+* bfd_default_set_arch_mach:             Architectures.      (line  430)
+* bfd_elf_find_section:                  elf.                (line   13)
+* bfd_errmsg:                            BFD front end.      (line  243)
+* bfd_fdopenr:                           Opening and Closing.
+                                                             (line   46)
+* bfd_fill_in_gnu_debuglink_section:     Opening and Closing.
+                                                             (line  319)
+* bfd_find_target:                       bfd_target.         (line  441)
+* bfd_follow_gnu_debuglink:              Opening and Closing.
+                                                             (line  284)
+* bfd_fopen:                             Opening and Closing.
+                                                             (line    9)
+* bfd_format_string:                     Formats.            (line   79)
+* bfd_generic_discard_group:             section prototypes. (line  281)
+* bfd_generic_gc_sections:               howto manager.      (line 1904)
+* bfd_generic_get_relocated_section_contents: howto manager. (line 1924)
+* bfd_generic_is_group_section:          section prototypes. (line  273)
+* bfd_generic_merge_sections:            howto manager.      (line 1914)
+* bfd_generic_relax_section:             howto manager.      (line 1891)
+* bfd_get_arch:                          Architectures.      (line  441)
+* bfd_get_arch_info:                     Architectures.      (line  493)
+* bfd_get_arch_size:                     BFD front end.      (line  362)
+* bfd_get_error:                         BFD front end.      (line  226)
+* bfd_get_error_handler:                 BFD front end.      (line  294)
+* bfd_get_gp_size:                       BFD front end.      (line  403)
+* bfd_get_mach:                          Architectures.      (line  449)
+* bfd_get_mtime:                         BFD front end.      (line  698)
+* bfd_get_next_mapent:                   Archives.           (line   52)
+* bfd_get_reloc_code_name:               howto manager.      (line 1882)
+* bfd_get_reloc_size:                    typedef arelent.    (line  329)
+* bfd_get_reloc_upper_bound:             BFD front end.      (line  308)
+* bfd_get_section_by_name:               section prototypes. (line   17)
+* bfd_get_section_by_name_if:            section prototypes. (line   31)
+* bfd_get_section_contents:              section prototypes. (line  228)
+* bfd_get_sign_extend_vma:               BFD front end.      (line  375)
+* bfd_get_size <1>:                      Internal.           (line   25)
+* bfd_get_size:                          BFD front end.      (line  707)
+* bfd_get_symtab_upper_bound:            symbol handling functions.
+                                                             (line    6)
+* bfd_get_unique_section_name:           section prototypes. (line   50)
+* bfd_h_put_size:                        Internal.           (line   97)
+* bfd_hash_allocate:                     Creating and Freeing a Hash Table.
+                                                             (line   17)
+* bfd_hash_lookup:                       Looking Up or Entering a String.
+                                                             (line    6)
+* bfd_hash_newfunc:                      Creating and Freeing a Hash Table.
+                                                             (line   12)
+* bfd_hash_set_default_size:             Creating and Freeing a Hash Table.
+                                                             (line   25)
+* bfd_hash_table_free:                   Creating and Freeing a Hash Table.
+                                                             (line   21)
+* bfd_hash_table_init:                   Creating and Freeing a Hash Table.
+                                                             (line    6)
+* bfd_hash_table_init_n:                 Creating and Freeing a Hash Table.
+                                                             (line    6)
+* bfd_hash_traverse:                     Traversing a Hash Table.
+                                                             (line    6)
+* bfd_hide_symbol:                       BFD front end.      (line  657)
+* bfd_init:                              Initialization.     (line   11)
+* bfd_install_relocation:                typedef arelent.    (line  391)
+* bfd_is_local_label:                    symbol handling functions.
+                                                             (line   17)
+* bfd_is_local_label_name:               symbol handling functions.
+                                                             (line   26)
+* bfd_is_target_special_symbol:          symbol handling functions.
+                                                             (line   38)
+* bfd_is_undefined_symclass:             symbol handling functions.
+                                                             (line  120)
+* bfd_link_split_section:                Writing the symbol table.
+                                                             (line   44)
+* bfd_log2:                              Internal.           (line  164)
+* bfd_lookup_arch:                       Architectures.      (line  501)
+* bfd_make_debug_symbol:                 symbol handling functions.
+                                                             (line  102)
+* bfd_make_empty_symbol:                 symbol handling functions.
+                                                             (line   78)
+* bfd_make_readable:                     Opening and Closing.
+                                                             (line  189)
+* bfd_make_section:                      section prototypes. (line  129)
+* bfd_make_section_anyway:               section prototypes. (line  100)
+* bfd_make_section_anyway_with_flags:    section prototypes. (line   82)
+* bfd_make_section_old_way:              section prototypes. (line   62)
+* bfd_make_section_with_flags:           section prototypes. (line  116)
+* bfd_make_writable:                     Opening and Closing.
+                                                             (line  175)
+* bfd_malloc_and_get_section:            section prototypes. (line  245)
+* bfd_map_over_sections:                 section prototypes. (line  155)
+* bfd_merge_private_bfd_data:            BFD front end.      (line  473)
+* bfd_octets_per_byte:                   Architectures.      (line  524)
+* bfd_open_file:                         File Caching.       (line   52)
+* bfd_openr:                             Opening and Closing.
+                                                             (line   30)
+* bfd_openr_iovec:                       Opening and Closing.
+                                                             (line   76)
+* bfd_openr_next_archived_file:          Archives.           (line   78)
+* bfd_openstreamr:                       Opening and Closing.
+                                                             (line   67)
+* bfd_openw:                             Opening and Closing.
+                                                             (line  116)
+* bfd_perform_relocation:                typedef arelent.    (line  366)
+* bfd_perror:                            BFD front end.      (line  252)
+* bfd_preserve_finish:                   BFD front end.      (line  647)
+* bfd_preserve_restore:                  BFD front end.      (line  637)
+* bfd_preserve_save:                     BFD front end.      (line  621)
+* bfd_print_symbol_vandf:                symbol handling functions.
+                                                             (line   70)
+* bfd_printable_arch_mach:               Architectures.      (line  512)
+* bfd_printable_name:                    Architectures.      (line  372)
+* bfd_put_size:                          Internal.           (line   22)
+* BFD_RELOC_12_PCREL:                    howto manager.      (line   39)
+* BFD_RELOC_14:                          howto manager.      (line   31)
+* BFD_RELOC_16:                          howto manager.      (line   30)
+* BFD_RELOC_16_BASEREL:                  howto manager.      (line   80)
+* BFD_RELOC_16_GOT_PCREL:                howto manager.      (line   52)
+* BFD_RELOC_16_GOTOFF:                   howto manager.      (line   55)
+* BFD_RELOC_16_PCREL:                    howto manager.      (line   38)
+* BFD_RELOC_16_PCREL_S2:                 howto manager.      (line   92)
+* BFD_RELOC_16_PLT_PCREL:                howto manager.      (line   63)
+* BFD_RELOC_16_PLTOFF:                   howto manager.      (line   67)
+* BFD_RELOC_16C_ABS20:                   howto manager.      (line 1606)
+* BFD_RELOC_16C_ABS20_C:                 howto manager.      (line 1607)
+* BFD_RELOC_16C_ABS24:                   howto manager.      (line 1608)
+* BFD_RELOC_16C_ABS24_C:                 howto manager.      (line 1609)
+* BFD_RELOC_16C_DISP04:                  howto manager.      (line 1586)
+* BFD_RELOC_16C_DISP04_C:                howto manager.      (line 1587)
+* BFD_RELOC_16C_DISP08:                  howto manager.      (line 1588)
+* BFD_RELOC_16C_DISP08_C:                howto manager.      (line 1589)
+* BFD_RELOC_16C_DISP16:                  howto manager.      (line 1590)
+* BFD_RELOC_16C_DISP16_C:                howto manager.      (line 1591)
+* BFD_RELOC_16C_DISP24:                  howto manager.      (line 1592)
+* BFD_RELOC_16C_DISP24_C:                howto manager.      (line 1593)
+* BFD_RELOC_16C_DISP24a:                 howto manager.      (line 1594)
+* BFD_RELOC_16C_DISP24a_C:               howto manager.      (line 1595)
+* BFD_RELOC_16C_IMM04:                   howto manager.      (line 1610)
+* BFD_RELOC_16C_IMM04_C:                 howto manager.      (line 1611)
+* BFD_RELOC_16C_IMM16:                   howto manager.      (line 1612)
+* BFD_RELOC_16C_IMM16_C:                 howto manager.      (line 1613)
+* BFD_RELOC_16C_IMM20:                   howto manager.      (line 1614)
+* BFD_RELOC_16C_IMM20_C:                 howto manager.      (line 1615)
+* BFD_RELOC_16C_IMM24:                   howto manager.      (line 1616)
+* BFD_RELOC_16C_IMM24_C:                 howto manager.      (line 1617)
+* BFD_RELOC_16C_IMM32:                   howto manager.      (line 1618)
+* BFD_RELOC_16C_IMM32_C:                 howto manager.      (line 1619)
+* BFD_RELOC_16C_NUM08:                   howto manager.      (line 1580)
+* BFD_RELOC_16C_NUM08_C:                 howto manager.      (line 1581)
+* BFD_RELOC_16C_NUM16:                   howto manager.      (line 1582)
+* BFD_RELOC_16C_NUM16_C:                 howto manager.      (line 1583)
+* BFD_RELOC_16C_NUM32:                   howto manager.      (line 1584)
+* BFD_RELOC_16C_NUM32_C:                 howto manager.      (line 1585)
+* BFD_RELOC_16C_REG04:                   howto manager.      (line 1596)
+* BFD_RELOC_16C_REG04_C:                 howto manager.      (line 1597)
+* BFD_RELOC_16C_REG04a:                  howto manager.      (line 1598)
+* BFD_RELOC_16C_REG04a_C:                howto manager.      (line 1599)
+* BFD_RELOC_16C_REG14:                   howto manager.      (line 1600)
+* BFD_RELOC_16C_REG14_C:                 howto manager.      (line 1601)
+* BFD_RELOC_16C_REG16:                   howto manager.      (line 1602)
+* BFD_RELOC_16C_REG16_C:                 howto manager.      (line 1603)
+* BFD_RELOC_16C_REG20:                   howto manager.      (line 1604)
+* BFD_RELOC_16C_REG20_C:                 howto manager.      (line 1605)
+* BFD_RELOC_23_PCREL_S2:                 howto manager.      (line   93)
+* BFD_RELOC_24:                          howto manager.      (line   29)
+* BFD_RELOC_24_PCREL:                    howto manager.      (line   37)
+* BFD_RELOC_24_PLT_PCREL:                howto manager.      (line   62)
+* BFD_RELOC_26:                          howto manager.      (line   28)
+* BFD_RELOC_32:                          howto manager.      (line   27)
+* BFD_RELOC_32_BASEREL:                  howto manager.      (line   79)
+* BFD_RELOC_32_GOT_PCREL:                howto manager.      (line   51)
+* BFD_RELOC_32_GOTOFF:                   howto manager.      (line   54)
+* BFD_RELOC_32_PCREL:                    howto manager.      (line   36)
+* BFD_RELOC_32_PCREL_S2:                 howto manager.      (line   91)
+* BFD_RELOC_32_PLT_PCREL:                howto manager.      (line   61)
+* BFD_RELOC_32_PLTOFF:                   howto manager.      (line   66)
+* BFD_RELOC_32_SECREL:                   howto manager.      (line   48)
+* BFD_RELOC_386_COPY:                    howto manager.      (line  431)
+* BFD_RELOC_386_GLOB_DAT:                howto manager.      (line  432)
+* BFD_RELOC_386_GOT32:                   howto manager.      (line  429)
+* BFD_RELOC_386_GOTOFF:                  howto manager.      (line  435)
+* BFD_RELOC_386_GOTPC:                   howto manager.      (line  436)
+* BFD_RELOC_386_JUMP_SLOT:               howto manager.      (line  433)
+* BFD_RELOC_386_PLT32:                   howto manager.      (line  430)
+* BFD_RELOC_386_RELATIVE:                howto manager.      (line  434)
+* BFD_RELOC_386_TLS_DTPMOD32:            howto manager.      (line  446)
+* BFD_RELOC_386_TLS_DTPOFF32:            howto manager.      (line  447)
+* BFD_RELOC_386_TLS_GD:                  howto manager.      (line  441)
+* BFD_RELOC_386_TLS_GOTIE:               howto manager.      (line  439)
+* BFD_RELOC_386_TLS_IE:                  howto manager.      (line  438)
+* BFD_RELOC_386_TLS_IE_32:               howto manager.      (line  444)
+* BFD_RELOC_386_TLS_LDM:                 howto manager.      (line  442)
+* BFD_RELOC_386_TLS_LDO_32:              howto manager.      (line  443)
+* BFD_RELOC_386_TLS_LE:                  howto manager.      (line  440)
+* BFD_RELOC_386_TLS_LE_32:               howto manager.      (line  445)
+* BFD_RELOC_386_TLS_TPOFF:               howto manager.      (line  437)
+* BFD_RELOC_386_TLS_TPOFF32:             howto manager.      (line  448)
+* BFD_RELOC_390_12:                      howto manager.      (line 1297)
+* BFD_RELOC_390_20:                      howto manager.      (line 1397)
+* BFD_RELOC_390_COPY:                    howto manager.      (line 1306)
+* BFD_RELOC_390_GLOB_DAT:                howto manager.      (line 1309)
+* BFD_RELOC_390_GOT12:                   howto manager.      (line 1300)
+* BFD_RELOC_390_GOT16:                   howto manager.      (line 1321)
+* BFD_RELOC_390_GOT20:                   howto manager.      (line 1398)
+* BFD_RELOC_390_GOT64:                   howto manager.      (line 1339)
+* BFD_RELOC_390_GOTENT:                  howto manager.      (line 1345)
+* BFD_RELOC_390_GOTOFF64:                howto manager.      (line 1348)
+* BFD_RELOC_390_GOTPC:                   howto manager.      (line 1318)
+* BFD_RELOC_390_GOTPCDBL:                howto manager.      (line 1336)
+* BFD_RELOC_390_GOTPLT12:                howto manager.      (line 1351)
+* BFD_RELOC_390_GOTPLT16:                howto manager.      (line 1354)
+* BFD_RELOC_390_GOTPLT20:                howto manager.      (line 1399)
+* BFD_RELOC_390_GOTPLT32:                howto manager.      (line 1357)
+* BFD_RELOC_390_GOTPLT64:                howto manager.      (line 1360)
+* BFD_RELOC_390_GOTPLTENT:               howto manager.      (line 1363)
+* BFD_RELOC_390_JMP_SLOT:                howto manager.      (line 1312)
+* BFD_RELOC_390_PC16DBL:                 howto manager.      (line 1324)
+* BFD_RELOC_390_PC32DBL:                 howto manager.      (line 1330)
+* BFD_RELOC_390_PLT16DBL:                howto manager.      (line 1327)
+* BFD_RELOC_390_PLT32:                   howto manager.      (line 1303)
+* BFD_RELOC_390_PLT32DBL:                howto manager.      (line 1333)
+* BFD_RELOC_390_PLT64:                   howto manager.      (line 1342)
+* BFD_RELOC_390_PLTOFF16:                howto manager.      (line 1366)
+* BFD_RELOC_390_PLTOFF32:                howto manager.      (line 1369)
+* BFD_RELOC_390_PLTOFF64:                howto manager.      (line 1372)
+* BFD_RELOC_390_RELATIVE:                howto manager.      (line 1315)
+* BFD_RELOC_390_TLS_DTPMOD:              howto manager.      (line 1392)
+* BFD_RELOC_390_TLS_DTPOFF:              howto manager.      (line 1393)
+* BFD_RELOC_390_TLS_GD32:                howto manager.      (line 1378)
+* BFD_RELOC_390_TLS_GD64:                howto manager.      (line 1379)
+* BFD_RELOC_390_TLS_GDCALL:              howto manager.      (line 1376)
+* BFD_RELOC_390_TLS_GOTIE12:             howto manager.      (line 1380)
+* BFD_RELOC_390_TLS_GOTIE20:             howto manager.      (line 1400)
+* BFD_RELOC_390_TLS_GOTIE32:             howto manager.      (line 1381)
+* BFD_RELOC_390_TLS_GOTIE64:             howto manager.      (line 1382)
+* BFD_RELOC_390_TLS_IE32:                howto manager.      (line 1385)
+* BFD_RELOC_390_TLS_IE64:                howto manager.      (line 1386)
+* BFD_RELOC_390_TLS_IEENT:               howto manager.      (line 1387)
+* BFD_RELOC_390_TLS_LDCALL:              howto manager.      (line 1377)
+* BFD_RELOC_390_TLS_LDM32:               howto manager.      (line 1383)
+* BFD_RELOC_390_TLS_LDM64:               howto manager.      (line 1384)
+* BFD_RELOC_390_TLS_LDO32:               howto manager.      (line 1390)
+* BFD_RELOC_390_TLS_LDO64:               howto manager.      (line 1391)
+* BFD_RELOC_390_TLS_LE32:                howto manager.      (line 1388)
+* BFD_RELOC_390_TLS_LE64:                howto manager.      (line 1389)
+* BFD_RELOC_390_TLS_LOAD:                howto manager.      (line 1375)
+* BFD_RELOC_390_TLS_TPOFF:               howto manager.      (line 1394)
+* BFD_RELOC_64:                          howto manager.      (line   26)
+* BFD_RELOC_64_PCREL:                    howto manager.      (line   35)
+* BFD_RELOC_64_PLT_PCREL:                howto manager.      (line   60)
+* BFD_RELOC_64_PLTOFF:                   howto manager.      (line   65)
+* BFD_RELOC_68K_GLOB_DAT:                howto manager.      (line   74)
+* BFD_RELOC_68K_JMP_SLOT:                howto manager.      (line   75)
+* BFD_RELOC_68K_RELATIVE:                howto manager.      (line   76)
+* BFD_RELOC_8:                           howto manager.      (line   32)
+* BFD_RELOC_860_COPY:                    howto manager.      (line 1685)
+* BFD_RELOC_860_GLOB_DAT:                howto manager.      (line 1686)
+* BFD_RELOC_860_HAGOT:                   howto manager.      (line 1711)
+* BFD_RELOC_860_HAGOTOFF:                howto manager.      (line 1712)
+* BFD_RELOC_860_HAPC:                    howto manager.      (line 1713)
+* BFD_RELOC_860_HIGH:                    howto manager.      (line 1714)
+* BFD_RELOC_860_HIGHADJ:                 howto manager.      (line 1710)
+* BFD_RELOC_860_HIGOT:                   howto manager.      (line 1715)
+* BFD_RELOC_860_HIGOTOFF:                howto manager.      (line 1716)
+* BFD_RELOC_860_JUMP_SLOT:               howto manager.      (line 1687)
+* BFD_RELOC_860_LOGOT0:                  howto manager.      (line 1699)
+* BFD_RELOC_860_LOGOT1:                  howto manager.      (line 1701)
+* BFD_RELOC_860_LOGOTOFF0:               howto manager.      (line 1703)
+* BFD_RELOC_860_LOGOTOFF1:               howto manager.      (line 1705)
+* BFD_RELOC_860_LOGOTOFF2:               howto manager.      (line 1707)
+* BFD_RELOC_860_LOGOTOFF3:               howto manager.      (line 1708)
+* BFD_RELOC_860_LOPC:                    howto manager.      (line 1709)
+* BFD_RELOC_860_LOW0:                    howto manager.      (line 1692)
+* BFD_RELOC_860_LOW1:                    howto manager.      (line 1694)
+* BFD_RELOC_860_LOW2:                    howto manager.      (line 1696)
+* BFD_RELOC_860_LOW3:                    howto manager.      (line 1698)
+* BFD_RELOC_860_PC16:                    howto manager.      (line 1691)
+* BFD_RELOC_860_PC26:                    howto manager.      (line 1689)
+* BFD_RELOC_860_PLT26:                   howto manager.      (line 1690)
+* BFD_RELOC_860_RELATIVE:                howto manager.      (line 1688)
+* BFD_RELOC_860_SPGOT0:                  howto manager.      (line 1700)
+* BFD_RELOC_860_SPGOT1:                  howto manager.      (line 1702)
+* BFD_RELOC_860_SPGOTOFF0:               howto manager.      (line 1704)
+* BFD_RELOC_860_SPGOTOFF1:               howto manager.      (line 1706)
+* BFD_RELOC_860_SPLIT0:                  howto manager.      (line 1693)
+* BFD_RELOC_860_SPLIT1:                  howto manager.      (line 1695)
+* BFD_RELOC_860_SPLIT2:                  howto manager.      (line 1697)
+* BFD_RELOC_8_BASEREL:                   howto manager.      (line   84)
+* BFD_RELOC_8_FFnn:                      howto manager.      (line   88)
+* BFD_RELOC_8_GOT_PCREL:                 howto manager.      (line   53)
+* BFD_RELOC_8_GOTOFF:                    howto manager.      (line   59)
+* BFD_RELOC_8_PCREL:                     howto manager.      (line   40)
+* BFD_RELOC_8_PLT_PCREL:                 howto manager.      (line   64)
+* BFD_RELOC_8_PLTOFF:                    howto manager.      (line   71)
+* BFD_RELOC_ALPHA_BRSGP:                 howto manager.      (line  259)
+* BFD_RELOC_ALPHA_CODEADDR:              howto manager.      (line  250)
+* BFD_RELOC_ALPHA_DTPMOD64:              howto manager.      (line  266)
+* BFD_RELOC_ALPHA_DTPREL16:              howto manager.      (line  271)
+* BFD_RELOC_ALPHA_DTPREL64:              howto manager.      (line  268)
+* BFD_RELOC_ALPHA_DTPREL_HI16:           howto manager.      (line  269)
+* BFD_RELOC_ALPHA_DTPREL_LO16:           howto manager.      (line  270)
+* BFD_RELOC_ALPHA_ELF_LITERAL:           howto manager.      (line  215)
+* BFD_RELOC_ALPHA_GOTDTPREL16:           howto manager.      (line  267)
+* BFD_RELOC_ALPHA_GOTTPREL16:            howto manager.      (line  272)
+* BFD_RELOC_ALPHA_GPDISP:                howto manager.      (line  209)
+* BFD_RELOC_ALPHA_GPDISP_HI16:           howto manager.      (line  195)
+* BFD_RELOC_ALPHA_GPDISP_LO16:           howto manager.      (line  203)
+* BFD_RELOC_ALPHA_GPREL_HI16:            howto manager.      (line  254)
+* BFD_RELOC_ALPHA_GPREL_LO16:            howto manager.      (line  255)
+* BFD_RELOC_ALPHA_HINT:                  howto manager.      (line  241)
+* BFD_RELOC_ALPHA_LINKAGE:               howto manager.      (line  246)
+* BFD_RELOC_ALPHA_LITERAL:               howto manager.      (line  214)
+* BFD_RELOC_ALPHA_LITUSE:                howto manager.      (line  216)
+* BFD_RELOC_ALPHA_TLSGD:                 howto manager.      (line  264)
+* BFD_RELOC_ALPHA_TLSLDM:                howto manager.      (line  265)
+* BFD_RELOC_ALPHA_TPREL16:               howto manager.      (line  276)
+* BFD_RELOC_ALPHA_TPREL64:               howto manager.      (line  273)
+* BFD_RELOC_ALPHA_TPREL_HI16:            howto manager.      (line  274)
+* BFD_RELOC_ALPHA_TPREL_LO16:            howto manager.      (line  275)
+* BFD_RELOC_ARC_B22_PCREL:               howto manager.      (line  794)
+* BFD_RELOC_ARC_B26:                     howto manager.      (line  799)
+* BFD_RELOC_ARM_ADR_IMM:                 howto manager.      (line  687)
+* BFD_RELOC_ARM_ADRL_IMMEDIATE:          howto manager.      (line  675)
+* BFD_RELOC_ARM_CP_OFF_IMM:              howto manager.      (line  683)
+* BFD_RELOC_ARM_CP_OFF_IMM_S2:           howto manager.      (line  684)
+* BFD_RELOC_ARM_GLOB_DAT:                howto manager.      (line  656)
+* BFD_RELOC_ARM_GOT32:                   howto manager.      (line  657)
+* BFD_RELOC_ARM_GOTOFF:                  howto manager.      (line  660)
+* BFD_RELOC_ARM_GOTPC:                   howto manager.      (line  661)
+* BFD_RELOC_ARM_HWLITERAL:               howto manager.      (line  694)
+* BFD_RELOC_ARM_IMMEDIATE:               howto manager.      (line  674)
+* BFD_RELOC_ARM_IN_POOL:                 howto manager.      (line  690)
+* BFD_RELOC_ARM_JUMP_SLOT:               howto manager.      (line  655)
+* BFD_RELOC_ARM_LDR_IMM:                 howto manager.      (line  688)
+* BFD_RELOC_ARM_LITERAL:                 howto manager.      (line  689)
+* BFD_RELOC_ARM_MULTI:                   howto manager.      (line  682)
+* BFD_RELOC_ARM_OFFSET_IMM:              howto manager.      (line  629)
+* BFD_RELOC_ARM_OFFSET_IMM8:             howto manager.      (line  691)
+* BFD_RELOC_ARM_PCREL_BLX:               howto manager.      (line  607)
+* BFD_RELOC_ARM_PCREL_BRANCH:            howto manager.      (line  603)
+* BFD_RELOC_ARM_PLT32:                   howto manager.      (line  658)
+* BFD_RELOC_ARM_PREL31:                  howto manager.      (line  652)
+* BFD_RELOC_ARM_RELATIVE:                howto manager.      (line  659)
+* BFD_RELOC_ARM_ROSEGREL32:              howto manager.      (line  641)
+* BFD_RELOC_ARM_SBREL32:                 howto manager.      (line  644)
+* BFD_RELOC_ARM_SHIFT_IMM:               howto manager.      (line  679)
+* BFD_RELOC_ARM_SMC:                     howto manager.      (line  680)
+* BFD_RELOC_ARM_SWI:                     howto manager.      (line  681)
+* BFD_RELOC_ARM_T32_ADD_PC12:            howto manager.      (line  678)
+* BFD_RELOC_ARM_T32_CP_OFF_IMM:          howto manager.      (line  685)
+* BFD_RELOC_ARM_T32_CP_OFF_IMM_S2:       howto manager.      (line  686)
+* BFD_RELOC_ARM_T32_IMM12:               howto manager.      (line  677)
+* BFD_RELOC_ARM_T32_IMMEDIATE:           howto manager.      (line  676)
+* BFD_RELOC_ARM_T32_OFFSET_IMM:          howto manager.      (line  693)
+* BFD_RELOC_ARM_T32_OFFSET_U8:           howto manager.      (line  692)
+* BFD_RELOC_ARM_TARGET1:                 howto manager.      (line  637)
+* BFD_RELOC_ARM_TARGET2:                 howto manager.      (line  647)
+* BFD_RELOC_ARM_THUMB_ADD:               howto manager.      (line  695)
+* BFD_RELOC_ARM_THUMB_IMM:               howto manager.      (line  696)
+* BFD_RELOC_ARM_THUMB_OFFSET:            howto manager.      (line  633)
+* BFD_RELOC_ARM_THUMB_SHIFT:             howto manager.      (line  697)
+* BFD_RELOC_ARM_TLS_DTPMOD32:            howto manager.      (line  668)
+* BFD_RELOC_ARM_TLS_DTPOFF32:            howto manager.      (line  667)
+* BFD_RELOC_ARM_TLS_GD32:                howto manager.      (line  664)
+* BFD_RELOC_ARM_TLS_IE32:                howto manager.      (line  670)
+* BFD_RELOC_ARM_TLS_LDM32:               howto manager.      (line  666)
+* BFD_RELOC_ARM_TLS_LDO32:               howto manager.      (line  665)
+* BFD_RELOC_ARM_TLS_LE32:                howto manager.      (line  671)
+* BFD_RELOC_ARM_TLS_TPOFF32:             howto manager.      (line  669)
+* BFD_RELOC_AVR_13_PCREL:                howto manager.      (line 1218)
+* BFD_RELOC_AVR_16_PM:                   howto manager.      (line 1222)
+* BFD_RELOC_AVR_6:                       howto manager.      (line 1289)
+* BFD_RELOC_AVR_6_ADIW:                  howto manager.      (line 1293)
+* BFD_RELOC_AVR_7_PCREL:                 howto manager.      (line 1214)
+* BFD_RELOC_AVR_CALL:                    howto manager.      (line 1281)
+* BFD_RELOC_AVR_HH8_LDI:                 howto manager.      (line 1234)
+* BFD_RELOC_AVR_HH8_LDI_NEG:             howto manager.      (line 1249)
+* BFD_RELOC_AVR_HH8_LDI_PM:              howto manager.      (line 1262)
+* BFD_RELOC_AVR_HH8_LDI_PM_NEG:          howto manager.      (line 1276)
+* BFD_RELOC_AVR_HI8_LDI:                 howto manager.      (line 1230)
+* BFD_RELOC_AVR_HI8_LDI_NEG:             howto manager.      (line 1244)
+* BFD_RELOC_AVR_HI8_LDI_PM:              howto manager.      (line 1258)
+* BFD_RELOC_AVR_HI8_LDI_PM_NEG:          howto manager.      (line 1271)
+* BFD_RELOC_AVR_LDI:                     howto manager.      (line 1285)
+* BFD_RELOC_AVR_LO8_LDI:                 howto manager.      (line 1226)
+* BFD_RELOC_AVR_LO8_LDI_NEG:             howto manager.      (line 1239)
+* BFD_RELOC_AVR_LO8_LDI_PM:              howto manager.      (line 1254)
+* BFD_RELOC_AVR_LO8_LDI_PM_NEG:          howto manager.      (line 1267)
+* BFD_RELOC_BFIN_10_PCREL:               howto manager.      (line  819)
+* BFD_RELOC_BFIN_11_PCREL:               howto manager.      (line  822)
+* BFD_RELOC_BFIN_12_PCREL_JUMP:          howto manager.      (line  825)
+* BFD_RELOC_BFIN_12_PCREL_JUMP_S:        howto manager.      (line  828)
+* BFD_RELOC_BFIN_16_HIGH:                howto manager.      (line  807)
+* BFD_RELOC_BFIN_16_IMM:                 howto manager.      (line  804)
+* BFD_RELOC_BFIN_16_LOW:                 howto manager.      (line  816)
+* BFD_RELOC_BFIN_24_PCREL_CALL_X:        howto manager.      (line  831)
+* BFD_RELOC_BFIN_24_PCREL_JUMP_L:        howto manager.      (line  834)
+* BFD_RELOC_BFIN_4_PCREL:                howto manager.      (line  810)
+* BFD_RELOC_BFIN_5_PCREL:                howto manager.      (line  813)
+* BFD_RELOC_BFIN_GOT:                    howto manager.      (line  837)
+* BFD_RELOC_BFIN_PLTPC:                  howto manager.      (line  840)
+* bfd_reloc_code_type:                   howto manager.      (line   10)
+* BFD_RELOC_CRIS_16_GOT:                 howto manager.      (line 1666)
+* BFD_RELOC_CRIS_16_GOTPLT:              howto manager.      (line 1672)
+* BFD_RELOC_CRIS_32_GOT:                 howto manager.      (line 1663)
+* BFD_RELOC_CRIS_32_GOTPLT:              howto manager.      (line 1669)
+* BFD_RELOC_CRIS_32_GOTREL:              howto manager.      (line 1675)
+* BFD_RELOC_CRIS_32_PLT_GOTREL:          howto manager.      (line 1678)
+* BFD_RELOC_CRIS_32_PLT_PCREL:           howto manager.      (line 1681)
+* BFD_RELOC_CRIS_BDISP8:                 howto manager.      (line 1644)
+* BFD_RELOC_CRIS_COPY:                   howto manager.      (line 1657)
+* BFD_RELOC_CRIS_GLOB_DAT:               howto manager.      (line 1658)
+* BFD_RELOC_CRIS_JUMP_SLOT:              howto manager.      (line 1659)
+* BFD_RELOC_CRIS_LAPCQ_OFFSET:           howto manager.      (line 1652)
+* BFD_RELOC_CRIS_RELATIVE:               howto manager.      (line 1660)
+* BFD_RELOC_CRIS_SIGNED_16:              howto manager.      (line 1650)
+* BFD_RELOC_CRIS_SIGNED_6:               howto manager.      (line 1646)
+* BFD_RELOC_CRIS_SIGNED_8:               howto manager.      (line 1648)
+* BFD_RELOC_CRIS_UNSIGNED_16:            howto manager.      (line 1651)
+* BFD_RELOC_CRIS_UNSIGNED_4:             howto manager.      (line 1653)
+* BFD_RELOC_CRIS_UNSIGNED_5:             howto manager.      (line 1645)
+* BFD_RELOC_CRIS_UNSIGNED_6:             howto manager.      (line 1647)
+* BFD_RELOC_CRIS_UNSIGNED_8:             howto manager.      (line 1649)
+* BFD_RELOC_CRX_ABS16:                   howto manager.      (line 1632)
+* BFD_RELOC_CRX_ABS32:                   howto manager.      (line 1633)
+* BFD_RELOC_CRX_IMM16:                   howto manager.      (line 1637)
+* BFD_RELOC_CRX_IMM32:                   howto manager.      (line 1638)
+* BFD_RELOC_CRX_NUM16:                   howto manager.      (line 1635)
+* BFD_RELOC_CRX_NUM32:                   howto manager.      (line 1636)
+* BFD_RELOC_CRX_NUM8:                    howto manager.      (line 1634)
+* BFD_RELOC_CRX_REGREL12:                howto manager.      (line 1628)
+* BFD_RELOC_CRX_REGREL22:                howto manager.      (line 1629)
+* BFD_RELOC_CRX_REGREL28:                howto manager.      (line 1630)
+* BFD_RELOC_CRX_REGREL32:                howto manager.      (line 1631)
+* BFD_RELOC_CRX_REL16:                   howto manager.      (line 1625)
+* BFD_RELOC_CRX_REL24:                   howto manager.      (line 1626)
+* BFD_RELOC_CRX_REL32:                   howto manager.      (line 1627)
+* BFD_RELOC_CRX_REL4:                    howto manager.      (line 1622)
+* BFD_RELOC_CRX_REL8:                    howto manager.      (line 1623)
+* BFD_RELOC_CRX_REL8_CMP:                howto manager.      (line 1624)
+* BFD_RELOC_CRX_SWITCH16:                howto manager.      (line 1640)
+* BFD_RELOC_CRX_SWITCH32:                howto manager.      (line 1641)
+* BFD_RELOC_CRX_SWITCH8:                 howto manager.      (line 1639)
+* BFD_RELOC_CTOR:                        howto manager.      (line  597)
+* BFD_RELOC_D10V_10_PCREL_L:             howto manager.      (line  907)
+* BFD_RELOC_D10V_10_PCREL_R:             howto manager.      (line  903)
+* BFD_RELOC_D10V_18:                     howto manager.      (line  912)
+* BFD_RELOC_D10V_18_PCREL:               howto manager.      (line  915)
+* BFD_RELOC_D30V_15:                     howto manager.      (line  930)
+* BFD_RELOC_D30V_15_PCREL:               howto manager.      (line  934)
+* BFD_RELOC_D30V_15_PCREL_R:             howto manager.      (line  938)
+* BFD_RELOC_D30V_21:                     howto manager.      (line  943)
+* BFD_RELOC_D30V_21_PCREL:               howto manager.      (line  947)
+* BFD_RELOC_D30V_21_PCREL_R:             howto manager.      (line  951)
+* BFD_RELOC_D30V_32:                     howto manager.      (line  956)
+* BFD_RELOC_D30V_32_PCREL:               howto manager.      (line  959)
+* BFD_RELOC_D30V_6:                      howto manager.      (line  918)
+* BFD_RELOC_D30V_9_PCREL:                howto manager.      (line  921)
+* BFD_RELOC_D30V_9_PCREL_R:              howto manager.      (line  925)
+* BFD_RELOC_DLX_HI16_S:                  howto manager.      (line  962)
+* BFD_RELOC_DLX_JMP26:                   howto manager.      (line  968)
+* BFD_RELOC_DLX_LO16:                    howto manager.      (line  965)
+* BFD_RELOC_FR30_10_IN_8:                howto manager.      (line 1144)
+* BFD_RELOC_FR30_12_PCREL:               howto manager.      (line 1152)
+* BFD_RELOC_FR30_20:                     howto manager.      (line 1128)
+* BFD_RELOC_FR30_48:                     howto manager.      (line 1125)
+* BFD_RELOC_FR30_6_IN_4:                 howto manager.      (line 1132)
+* BFD_RELOC_FR30_8_IN_8:                 howto manager.      (line 1136)
+* BFD_RELOC_FR30_9_IN_8:                 howto manager.      (line 1140)
+* BFD_RELOC_FR30_9_PCREL:                howto manager.      (line 1148)
+* BFD_RELOC_FRV_FUNCDESC:                howto manager.      (line  373)
+* BFD_RELOC_FRV_FUNCDESC_GOT12:          howto manager.      (line  374)
+* BFD_RELOC_FRV_FUNCDESC_GOTHI:          howto manager.      (line  375)
+* BFD_RELOC_FRV_FUNCDESC_GOTLO:          howto manager.      (line  376)
+* BFD_RELOC_FRV_FUNCDESC_GOTOFF12:       howto manager.      (line  378)
+* BFD_RELOC_FRV_FUNCDESC_GOTOFFHI:       howto manager.      (line  379)
+* BFD_RELOC_FRV_FUNCDESC_GOTOFFLO:       howto manager.      (line  380)
+* BFD_RELOC_FRV_FUNCDESC_VALUE:          howto manager.      (line  377)
+* BFD_RELOC_FRV_GETTLSOFF:               howto manager.      (line  384)
+* BFD_RELOC_FRV_GETTLSOFF_RELAX:         howto manager.      (line  397)
+* BFD_RELOC_FRV_GOT12:                   howto manager.      (line  370)
+* BFD_RELOC_FRV_GOTHI:                   howto manager.      (line  371)
+* BFD_RELOC_FRV_GOTLO:                   howto manager.      (line  372)
+* BFD_RELOC_FRV_GOTOFF12:                howto manager.      (line  381)
+* BFD_RELOC_FRV_GOTOFFHI:                howto manager.      (line  382)
+* BFD_RELOC_FRV_GOTOFFLO:                howto manager.      (line  383)
+* BFD_RELOC_FRV_GOTTLSDESC12:            howto manager.      (line  386)
+* BFD_RELOC_FRV_GOTTLSDESCHI:            howto manager.      (line  387)
+* BFD_RELOC_FRV_GOTTLSDESCLO:            howto manager.      (line  388)
+* BFD_RELOC_FRV_GOTTLSOFF12:             howto manager.      (line  392)
+* BFD_RELOC_FRV_GOTTLSOFFHI:             howto manager.      (line  393)
+* BFD_RELOC_FRV_GOTTLSOFFLO:             howto manager.      (line  394)
+* BFD_RELOC_FRV_GPREL12:                 howto manager.      (line  365)
+* BFD_RELOC_FRV_GPREL32:                 howto manager.      (line  367)
+* BFD_RELOC_FRV_GPRELHI:                 howto manager.      (line  368)
+* BFD_RELOC_FRV_GPRELLO:                 howto manager.      (line  369)
+* BFD_RELOC_FRV_GPRELU12:                howto manager.      (line  366)
+* BFD_RELOC_FRV_HI16:                    howto manager.      (line  364)
+* BFD_RELOC_FRV_LABEL16:                 howto manager.      (line  361)
+* BFD_RELOC_FRV_LABEL24:                 howto manager.      (line  362)
+* BFD_RELOC_FRV_LO16:                    howto manager.      (line  363)
+* BFD_RELOC_FRV_TLSDESC_RELAX:           howto manager.      (line  396)
+* BFD_RELOC_FRV_TLSDESC_VALUE:           howto manager.      (line  385)
+* BFD_RELOC_FRV_TLSMOFF:                 howto manager.      (line  399)
+* BFD_RELOC_FRV_TLSMOFF12:               howto manager.      (line  389)
+* BFD_RELOC_FRV_TLSMOFFHI:               howto manager.      (line  390)
+* BFD_RELOC_FRV_TLSMOFFLO:               howto manager.      (line  391)
+* BFD_RELOC_FRV_TLSOFF:                  howto manager.      (line  395)
+* BFD_RELOC_FRV_TLSOFF_RELAX:            howto manager.      (line  398)
+* BFD_RELOC_GPREL16:                     howto manager.      (line  106)
+* BFD_RELOC_GPREL32:                     howto manager.      (line  107)
+* BFD_RELOC_H8_DIR16A8:                  howto manager.      (line 1723)
+* BFD_RELOC_H8_DIR16R8:                  howto manager.      (line 1724)
+* BFD_RELOC_H8_DIR24A8:                  howto manager.      (line 1725)
+* BFD_RELOC_H8_DIR24R8:                  howto manager.      (line 1726)
+* BFD_RELOC_H8_DIR32A16:                 howto manager.      (line 1727)
+* BFD_RELOC_HI16:                        howto manager.      (line  289)
+* BFD_RELOC_HI16_BASEREL:                howto manager.      (line   82)
+* BFD_RELOC_HI16_GOTOFF:                 howto manager.      (line   57)
+* BFD_RELOC_HI16_PCREL:                  howto manager.      (line  301)
+* BFD_RELOC_HI16_PLTOFF:                 howto manager.      (line   69)
+* BFD_RELOC_HI16_S:                      howto manager.      (line  292)
+* BFD_RELOC_HI16_S_BASEREL:              howto manager.      (line   83)
+* BFD_RELOC_HI16_S_GOTOFF:               howto manager.      (line   58)
+* BFD_RELOC_HI16_S_PCREL:                howto manager.      (line  304)
+* BFD_RELOC_HI16_S_PLTOFF:               howto manager.      (line   70)
+* BFD_RELOC_HI22:                        howto manager.      (line  101)
+* BFD_RELOC_I370_D12:                    howto manager.      (line  594)
+* BFD_RELOC_I960_CALLJ:                  howto manager.      (line  113)
+* BFD_RELOC_IA64_COPY:                   howto manager.      (line 1516)
+* BFD_RELOC_IA64_DIR32LSB:               howto manager.      (line 1461)
+* BFD_RELOC_IA64_DIR32MSB:               howto manager.      (line 1460)
+* BFD_RELOC_IA64_DIR64LSB:               howto manager.      (line 1463)
+* BFD_RELOC_IA64_DIR64MSB:               howto manager.      (line 1462)
+* BFD_RELOC_IA64_DTPMOD64LSB:            howto manager.      (line 1526)
+* BFD_RELOC_IA64_DTPMOD64MSB:            howto manager.      (line 1525)
+* BFD_RELOC_IA64_DTPREL14:               howto manager.      (line 1528)
+* BFD_RELOC_IA64_DTPREL22:               howto manager.      (line 1529)
+* BFD_RELOC_IA64_DTPREL32LSB:            howto manager.      (line 1532)
+* BFD_RELOC_IA64_DTPREL32MSB:            howto manager.      (line 1531)
+* BFD_RELOC_IA64_DTPREL64I:              howto manager.      (line 1530)
+* BFD_RELOC_IA64_DTPREL64LSB:            howto manager.      (line 1534)
+* BFD_RELOC_IA64_DTPREL64MSB:            howto manager.      (line 1533)
+* BFD_RELOC_IA64_FPTR32LSB:              howto manager.      (line 1478)
+* BFD_RELOC_IA64_FPTR32MSB:              howto manager.      (line 1477)
+* BFD_RELOC_IA64_FPTR64I:                howto manager.      (line 1476)
+* BFD_RELOC_IA64_FPTR64LSB:              howto manager.      (line 1480)
+* BFD_RELOC_IA64_FPTR64MSB:              howto manager.      (line 1479)
+* BFD_RELOC_IA64_GPREL22:                howto manager.      (line 1464)
+* BFD_RELOC_IA64_GPREL32LSB:             howto manager.      (line 1467)
+* BFD_RELOC_IA64_GPREL32MSB:             howto manager.      (line 1466)
+* BFD_RELOC_IA64_GPREL64I:               howto manager.      (line 1465)
+* BFD_RELOC_IA64_GPREL64LSB:             howto manager.      (line 1469)
+* BFD_RELOC_IA64_GPREL64MSB:             howto manager.      (line 1468)
+* BFD_RELOC_IA64_IMM14:                  howto manager.      (line 1457)
+* BFD_RELOC_IA64_IMM22:                  howto manager.      (line 1458)
+* BFD_RELOC_IA64_IMM64:                  howto manager.      (line 1459)
+* BFD_RELOC_IA64_IPLTLSB:                howto manager.      (line 1515)
+* BFD_RELOC_IA64_IPLTMSB:                howto manager.      (line 1514)
+* BFD_RELOC_IA64_LDXMOV:                 howto manager.      (line 1518)
+* BFD_RELOC_IA64_LTOFF22:                howto manager.      (line 1470)
+* BFD_RELOC_IA64_LTOFF22X:               howto manager.      (line 1517)
+* BFD_RELOC_IA64_LTOFF64I:               howto manager.      (line 1471)
+* BFD_RELOC_IA64_LTOFF_DTPMOD22:         howto manager.      (line 1527)
+* BFD_RELOC_IA64_LTOFF_DTPREL22:         howto manager.      (line 1535)
+* BFD_RELOC_IA64_LTOFF_FPTR22:           howto manager.      (line 1492)
+* BFD_RELOC_IA64_LTOFF_FPTR32LSB:        howto manager.      (line 1495)
+* BFD_RELOC_IA64_LTOFF_FPTR32MSB:        howto manager.      (line 1494)
+* BFD_RELOC_IA64_LTOFF_FPTR64I:          howto manager.      (line 1493)
+* BFD_RELOC_IA64_LTOFF_FPTR64LSB:        howto manager.      (line 1497)
+* BFD_RELOC_IA64_LTOFF_FPTR64MSB:        howto manager.      (line 1496)
+* BFD_RELOC_IA64_LTOFF_TPREL22:          howto manager.      (line 1524)
+* BFD_RELOC_IA64_LTV32LSB:               howto manager.      (line 1511)
+* BFD_RELOC_IA64_LTV32MSB:               howto manager.      (line 1510)
+* BFD_RELOC_IA64_LTV64LSB:               howto manager.      (line 1513)
+* BFD_RELOC_IA64_LTV64MSB:               howto manager.      (line 1512)
+* BFD_RELOC_IA64_PCREL21B:               howto manager.      (line 1481)
+* BFD_RELOC_IA64_PCREL21BI:              howto manager.      (line 1482)
+* BFD_RELOC_IA64_PCREL21F:               howto manager.      (line 1484)
+* BFD_RELOC_IA64_PCREL21M:               howto manager.      (line 1483)
+* BFD_RELOC_IA64_PCREL22:                howto manager.      (line 1485)
+* BFD_RELOC_IA64_PCREL32LSB:             howto manager.      (line 1489)
+* BFD_RELOC_IA64_PCREL32MSB:             howto manager.      (line 1488)
+* BFD_RELOC_IA64_PCREL60B:               howto manager.      (line 1486)
+* BFD_RELOC_IA64_PCREL64I:               howto manager.      (line 1487)
+* BFD_RELOC_IA64_PCREL64LSB:             howto manager.      (line 1491)
+* BFD_RELOC_IA64_PCREL64MSB:             howto manager.      (line 1490)
+* BFD_RELOC_IA64_PLTOFF22:               howto manager.      (line 1472)
+* BFD_RELOC_IA64_PLTOFF64I:              howto manager.      (line 1473)
+* BFD_RELOC_IA64_PLTOFF64LSB:            howto manager.      (line 1475)
+* BFD_RELOC_IA64_PLTOFF64MSB:            howto manager.      (line 1474)
+* BFD_RELOC_IA64_REL32LSB:               howto manager.      (line 1507)
+* BFD_RELOC_IA64_REL32MSB:               howto manager.      (line 1506)
+* BFD_RELOC_IA64_REL64LSB:               howto manager.      (line 1509)
+* BFD_RELOC_IA64_REL64MSB:               howto manager.      (line 1508)
+* BFD_RELOC_IA64_SECREL32LSB:            howto manager.      (line 1503)
+* BFD_RELOC_IA64_SECREL32MSB:            howto manager.      (line 1502)
+* BFD_RELOC_IA64_SECREL64LSB:            howto manager.      (line 1505)
+* BFD_RELOC_IA64_SECREL64MSB:            howto manager.      (line 1504)
+* BFD_RELOC_IA64_SEGREL32LSB:            howto manager.      (line 1499)
+* BFD_RELOC_IA64_SEGREL32MSB:            howto manager.      (line 1498)
+* BFD_RELOC_IA64_SEGREL64LSB:            howto manager.      (line 1501)
+* BFD_RELOC_IA64_SEGREL64MSB:            howto manager.      (line 1500)
+* BFD_RELOC_IA64_TPREL14:                howto manager.      (line 1519)
+* BFD_RELOC_IA64_TPREL22:                howto manager.      (line 1520)
+* BFD_RELOC_IA64_TPREL64I:               howto manager.      (line 1521)
+* BFD_RELOC_IA64_TPREL64LSB:             howto manager.      (line 1523)
+* BFD_RELOC_IA64_TPREL64MSB:             howto manager.      (line 1522)
+* BFD_RELOC_IP2K_ADDR16CJP:              howto manager.      (line 1409)
+* BFD_RELOC_IP2K_BANK:                   howto manager.      (line 1406)
+* BFD_RELOC_IP2K_EX8DATA:                howto manager.      (line 1417)
+* BFD_RELOC_IP2K_FR9:                    howto manager.      (line 1403)
+* BFD_RELOC_IP2K_FR_OFFSET:              howto manager.      (line 1430)
+* BFD_RELOC_IP2K_HI8DATA:                howto manager.      (line 1416)
+* BFD_RELOC_IP2K_HI8INSN:                howto manager.      (line 1421)
+* BFD_RELOC_IP2K_LO8DATA:                howto manager.      (line 1415)
+* BFD_RELOC_IP2K_LO8INSN:                howto manager.      (line 1420)
+* BFD_RELOC_IP2K_PAGE3:                  howto manager.      (line 1412)
+* BFD_RELOC_IP2K_PC_SKIP:                howto manager.      (line 1424)
+* BFD_RELOC_IP2K_TEXT:                   howto manager.      (line 1427)
+* BFD_RELOC_IQ2000_OFFSET_16:            howto manager.      (line 1765)
+* BFD_RELOC_IQ2000_OFFSET_21:            howto manager.      (line 1766)
+* BFD_RELOC_IQ2000_UHI16:                howto manager.      (line 1767)
+* BFD_RELOC_LO10:                        howto manager.      (line  102)
+* BFD_RELOC_LO16:                        howto manager.      (line  298)
+* BFD_RELOC_LO16_BASEREL:                howto manager.      (line   81)
+* BFD_RELOC_LO16_GOTOFF:                 howto manager.      (line   56)
+* BFD_RELOC_LO16_PCREL:                  howto manager.      (line  307)
+* BFD_RELOC_LO16_PLTOFF:                 howto manager.      (line   68)
+* BFD_RELOC_M32C_HI8:                    howto manager.      (line  971)
+* BFD_RELOC_M32R_10_PCREL:               howto manager.      (line  978)
+* BFD_RELOC_M32R_18_PCREL:               howto manager.      (line  982)
+* BFD_RELOC_M32R_24:                     howto manager.      (line  974)
+* BFD_RELOC_M32R_26_PCREL:               howto manager.      (line  985)
+* BFD_RELOC_M32R_26_PLTREL:              howto manager.      (line 1004)
+* BFD_RELOC_M32R_COPY:                   howto manager.      (line 1005)
+* BFD_RELOC_M32R_GLOB_DAT:               howto manager.      (line 1006)
+* BFD_RELOC_M32R_GOT16_HI_SLO:           howto manager.      (line 1015)
+* BFD_RELOC_M32R_GOT16_HI_ULO:           howto manager.      (line 1014)
+* BFD_RELOC_M32R_GOT16_LO:               howto manager.      (line 1016)
+* BFD_RELOC_M32R_GOT24:                  howto manager.      (line 1003)
+* BFD_RELOC_M32R_GOTOFF:                 howto manager.      (line 1009)
+* BFD_RELOC_M32R_GOTOFF_HI_SLO:          howto manager.      (line 1011)
+* BFD_RELOC_M32R_GOTOFF_HI_ULO:          howto manager.      (line 1010)
+* BFD_RELOC_M32R_GOTOFF_LO:              howto manager.      (line 1012)
+* BFD_RELOC_M32R_GOTPC24:                howto manager.      (line 1013)
+* BFD_RELOC_M32R_GOTPC_HI_SLO:           howto manager.      (line 1018)
+* BFD_RELOC_M32R_GOTPC_HI_ULO:           howto manager.      (line 1017)
+* BFD_RELOC_M32R_GOTPC_LO:               howto manager.      (line 1019)
+* BFD_RELOC_M32R_HI16_SLO:               howto manager.      (line  992)
+* BFD_RELOC_M32R_HI16_ULO:               howto manager.      (line  988)
+* BFD_RELOC_M32R_JMP_SLOT:               howto manager.      (line 1007)
+* BFD_RELOC_M32R_LO16:                   howto manager.      (line  996)
+* BFD_RELOC_M32R_RELATIVE:               howto manager.      (line 1008)
+* BFD_RELOC_M32R_SDA16:                  howto manager.      (line  999)
+* BFD_RELOC_M68HC11_24:                  howto manager.      (line 1571)
+* BFD_RELOC_M68HC11_3B:                  howto manager.      (line 1546)
+* BFD_RELOC_M68HC11_HI8:                 howto manager.      (line 1538)
+* BFD_RELOC_M68HC11_LO16:                howto manager.      (line 1560)
+* BFD_RELOC_M68HC11_LO8:                 howto manager.      (line 1542)
+* BFD_RELOC_M68HC11_PAGE:                howto manager.      (line 1566)
+* BFD_RELOC_M68HC11_RL_GROUP:            howto manager.      (line 1555)
+* BFD_RELOC_M68HC11_RL_JUMP:             howto manager.      (line 1549)
+* BFD_RELOC_M68HC12_5B:                  howto manager.      (line 1577)
+* BFD_RELOC_MCORE_PCREL_32:              howto manager.      (line 1159)
+* BFD_RELOC_MCORE_PCREL_IMM11BY2:        howto manager.      (line 1157)
+* BFD_RELOC_MCORE_PCREL_IMM4BY2:         howto manager.      (line 1158)
+* BFD_RELOC_MCORE_PCREL_IMM8BY4:         howto manager.      (line 1156)
+* BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2:    howto manager.      (line 1160)
+* BFD_RELOC_MCORE_RVA:                   howto manager.      (line 1161)
+* BFD_RELOC_MIPS16_GPREL:                howto manager.      (line  286)
+* BFD_RELOC_MIPS16_HI16:                 howto manager.      (line  310)
+* BFD_RELOC_MIPS16_HI16_S:               howto manager.      (line  313)
+* BFD_RELOC_MIPS16_JMP:                  howto manager.      (line  283)
+* BFD_RELOC_MIPS16_LO16:                 howto manager.      (line  319)
+* BFD_RELOC_MIPS_CALL16:                 howto manager.      (line  326)
+* BFD_RELOC_MIPS_CALL_HI16:              howto manager.      (line  329)
+* BFD_RELOC_MIPS_CALL_LO16:              howto manager.      (line  330)
+* BFD_RELOC_MIPS_DELETE:                 howto manager.      (line  339)
+* BFD_RELOC_MIPS_GOT16:                  howto manager.      (line  325)
+* BFD_RELOC_MIPS_GOT_DISP:               howto manager.      (line  334)
+* BFD_RELOC_MIPS_GOT_HI16:               howto manager.      (line  327)
+* BFD_RELOC_MIPS_GOT_LO16:               howto manager.      (line  328)
+* BFD_RELOC_MIPS_GOT_OFST:               howto manager.      (line  333)
+* BFD_RELOC_MIPS_GOT_PAGE:               howto manager.      (line  332)
+* BFD_RELOC_MIPS_HIGHER:                 howto manager.      (line  341)
+* BFD_RELOC_MIPS_HIGHEST:                howto manager.      (line  340)
+* BFD_RELOC_MIPS_INSERT_A:               howto manager.      (line  337)
+* BFD_RELOC_MIPS_INSERT_B:               howto manager.      (line  338)
+* BFD_RELOC_MIPS_JALR:                   howto manager.      (line  345)
+* BFD_RELOC_MIPS_JMP:                    howto manager.      (line  279)
+* BFD_RELOC_MIPS_LITERAL:                howto manager.      (line  322)
+* BFD_RELOC_MIPS_REL16:                  howto manager.      (line  343)
+* BFD_RELOC_MIPS_RELGOT:                 howto manager.      (line  344)
+* BFD_RELOC_MIPS_SCN_DISP:               howto manager.      (line  342)
+* BFD_RELOC_MIPS_SHIFT5:                 howto manager.      (line  335)
+* BFD_RELOC_MIPS_SHIFT6:                 howto manager.      (line  336)
+* BFD_RELOC_MIPS_SUB:                    howto manager.      (line  331)
+* BFD_RELOC_MIPS_TLS_DTPMOD32:           howto manager.      (line  346)
+* BFD_RELOC_MIPS_TLS_DTPMOD64:           howto manager.      (line  348)
+* BFD_RELOC_MIPS_TLS_DTPREL32:           howto manager.      (line  347)
+* BFD_RELOC_MIPS_TLS_DTPREL64:           howto manager.      (line  349)
+* BFD_RELOC_MIPS_TLS_DTPREL_HI16:        howto manager.      (line  352)
+* BFD_RELOC_MIPS_TLS_DTPREL_LO16:        howto manager.      (line  353)
+* BFD_RELOC_MIPS_TLS_GD:                 howto manager.      (line  350)
+* BFD_RELOC_MIPS_TLS_GOTTPREL:           howto manager.      (line  354)
+* BFD_RELOC_MIPS_TLS_LDM:                howto manager.      (line  351)
+* BFD_RELOC_MIPS_TLS_TPREL32:            howto manager.      (line  355)
+* BFD_RELOC_MIPS_TLS_TPREL64:            howto manager.      (line  356)
+* BFD_RELOC_MIPS_TLS_TPREL_HI16:         howto manager.      (line  357)
+* BFD_RELOC_MIPS_TLS_TPREL_LO16:         howto manager.      (line  358)
+* BFD_RELOC_MMIX_ADDR19:                 howto manager.      (line 1190)
+* BFD_RELOC_MMIX_ADDR27:                 howto manager.      (line 1194)
+* BFD_RELOC_MMIX_BASE_PLUS_OFFSET:       howto manager.      (line 1206)
+* BFD_RELOC_MMIX_CBRANCH:                howto manager.      (line 1170)
+* BFD_RELOC_MMIX_CBRANCH_1:              howto manager.      (line 1172)
+* BFD_RELOC_MMIX_CBRANCH_2:              howto manager.      (line 1173)
+* BFD_RELOC_MMIX_CBRANCH_3:              howto manager.      (line 1174)
+* BFD_RELOC_MMIX_CBRANCH_J:              howto manager.      (line 1171)
+* BFD_RELOC_MMIX_GETA:                   howto manager.      (line 1164)
+* BFD_RELOC_MMIX_GETA_1:                 howto manager.      (line 1165)
+* BFD_RELOC_MMIX_GETA_2:                 howto manager.      (line 1166)
+* BFD_RELOC_MMIX_GETA_3:                 howto manager.      (line 1167)
+* BFD_RELOC_MMIX_JMP:                    howto manager.      (line 1184)
+* BFD_RELOC_MMIX_JMP_1:                  howto manager.      (line 1185)
+* BFD_RELOC_MMIX_JMP_2:                  howto manager.      (line 1186)
+* BFD_RELOC_MMIX_JMP_3:                  howto manager.      (line 1187)
+* BFD_RELOC_MMIX_LOCAL:                  howto manager.      (line 1210)
+* BFD_RELOC_MMIX_PUSHJ:                  howto manager.      (line 1177)
+* BFD_RELOC_MMIX_PUSHJ_1:                howto manager.      (line 1178)
+* BFD_RELOC_MMIX_PUSHJ_2:                howto manager.      (line 1179)
+* BFD_RELOC_MMIX_PUSHJ_3:                howto manager.      (line 1180)
+* BFD_RELOC_MMIX_PUSHJ_STUBBABLE:        howto manager.      (line 1181)
+* BFD_RELOC_MMIX_REG:                    howto manager.      (line 1202)
+* BFD_RELOC_MMIX_REG_OR_BYTE:            howto manager.      (line 1198)
+* BFD_RELOC_MN10300_16_PCREL:            howto manager.      (line 1094)
+* BFD_RELOC_MN10300_32_PCREL:            howto manager.      (line 1090)
+* BFD_RELOC_MN10300_COPY:                howto manager.      (line  417)
+* BFD_RELOC_MN10300_GLOB_DAT:            howto manager.      (line  420)
+* BFD_RELOC_MN10300_GOT16:               howto manager.      (line  413)
+* BFD_RELOC_MN10300_GOT24:               howto manager.      (line  409)
+* BFD_RELOC_MN10300_GOT32:               howto manager.      (line  405)
+* BFD_RELOC_MN10300_GOTOFF24:            howto manager.      (line  402)
+* BFD_RELOC_MN10300_JMP_SLOT:            howto manager.      (line  423)
+* BFD_RELOC_MN10300_RELATIVE:            howto manager.      (line  426)
+* BFD_RELOC_MS1_GNU_VTENTRY:             howto manager.      (line 1753)
+* BFD_RELOC_MS1_GNU_VTINHERIT:           howto manager.      (line 1750)
+* BFD_RELOC_MS1_HI16:                    howto manager.      (line 1744)
+* BFD_RELOC_MS1_LO16:                    howto manager.      (line 1747)
+* BFD_RELOC_MS1_PC16:                    howto manager.      (line 1741)
+* BFD_RELOC_MSP430_10_PCREL:             howto manager.      (line 1756)
+* BFD_RELOC_MSP430_16:                   howto manager.      (line 1758)
+* BFD_RELOC_MSP430_16_BYTE:              howto manager.      (line 1760)
+* BFD_RELOC_MSP430_16_PCREL:             howto manager.      (line 1757)
+* BFD_RELOC_MSP430_16_PCREL_BYTE:        howto manager.      (line 1759)
+* BFD_RELOC_MSP430_2X_PCREL:             howto manager.      (line 1761)
+* BFD_RELOC_MSP430_RL_PCREL:             howto manager.      (line 1762)
+* BFD_RELOC_NONE:                        howto manager.      (line  116)
+* BFD_RELOC_NS32K_DISP_16:               howto manager.      (line  478)
+* BFD_RELOC_NS32K_DISP_16_PCREL:         howto manager.      (line  481)
+* BFD_RELOC_NS32K_DISP_32:               howto manager.      (line  479)
+* BFD_RELOC_NS32K_DISP_32_PCREL:         howto manager.      (line  482)
+* BFD_RELOC_NS32K_DISP_8:                howto manager.      (line  477)
+* BFD_RELOC_NS32K_DISP_8_PCREL:          howto manager.      (line  480)
+* BFD_RELOC_NS32K_IMM_16:                howto manager.      (line  472)
+* BFD_RELOC_NS32K_IMM_16_PCREL:          howto manager.      (line  475)
+* BFD_RELOC_NS32K_IMM_32:                howto manager.      (line  473)
+* BFD_RELOC_NS32K_IMM_32_PCREL:          howto manager.      (line  476)
+* BFD_RELOC_NS32K_IMM_8:                 howto manager.      (line  471)
+* BFD_RELOC_NS32K_IMM_8_PCREL:           howto manager.      (line  474)
+* BFD_RELOC_OPENRISC_ABS_26:             howto manager.      (line 1719)
+* BFD_RELOC_OPENRISC_REL_26:             howto manager.      (line 1720)
+* BFD_RELOC_PDP11_DISP_6_PCREL:          howto manager.      (line  486)
+* BFD_RELOC_PDP11_DISP_8_PCREL:          howto manager.      (line  485)
+* BFD_RELOC_PJ_CODE_DIR16:               howto manager.      (line  491)
+* BFD_RELOC_PJ_CODE_DIR32:               howto manager.      (line  492)
+* BFD_RELOC_PJ_CODE_HI16:                howto manager.      (line  489)
+* BFD_RELOC_PJ_CODE_LO16:                howto manager.      (line  490)
+* BFD_RELOC_PJ_CODE_REL16:               howto manager.      (line  493)
+* BFD_RELOC_PJ_CODE_REL32:               howto manager.      (line  494)
+* BFD_RELOC_PPC64_ADDR16_DS:             howto manager.      (line  539)
+* BFD_RELOC_PPC64_ADDR16_LO_DS:          howto manager.      (line  540)
+* BFD_RELOC_PPC64_DTPREL16_DS:           howto manager.      (line  586)
+* BFD_RELOC_PPC64_DTPREL16_HIGHER:       howto manager.      (line  588)
+* BFD_RELOC_PPC64_DTPREL16_HIGHERA:      howto manager.      (line  589)
+* BFD_RELOC_PPC64_DTPREL16_HIGHEST:      howto manager.      (line  590)
+* BFD_RELOC_PPC64_DTPREL16_HIGHESTA:     howto manager.      (line  591)
+* BFD_RELOC_PPC64_DTPREL16_LO_DS:        howto manager.      (line  587)
+* BFD_RELOC_PPC64_GOT16_DS:              howto manager.      (line  541)
+* BFD_RELOC_PPC64_GOT16_LO_DS:           howto manager.      (line  542)
+* BFD_RELOC_PPC64_HIGHER:                howto manager.      (line  527)
+* BFD_RELOC_PPC64_HIGHER_S:              howto manager.      (line  528)
+* BFD_RELOC_PPC64_HIGHEST:               howto manager.      (line  529)
+* BFD_RELOC_PPC64_HIGHEST_S:             howto manager.      (line  530)
+* BFD_RELOC_PPC64_PLT16_LO_DS:           howto manager.      (line  543)
+* BFD_RELOC_PPC64_PLTGOT16:              howto manager.      (line  535)
+* BFD_RELOC_PPC64_PLTGOT16_DS:           howto manager.      (line  548)
+* BFD_RELOC_PPC64_PLTGOT16_HA:           howto manager.      (line  538)
+* BFD_RELOC_PPC64_PLTGOT16_HI:           howto manager.      (line  537)
+* BFD_RELOC_PPC64_PLTGOT16_LO:           howto manager.      (line  536)
+* BFD_RELOC_PPC64_PLTGOT16_LO_DS:        howto manager.      (line  549)
+* BFD_RELOC_PPC64_SECTOFF_DS:            howto manager.      (line  544)
+* BFD_RELOC_PPC64_SECTOFF_LO_DS:         howto manager.      (line  545)
+* BFD_RELOC_PPC64_TOC:                   howto manager.      (line  534)
+* BFD_RELOC_PPC64_TOC16_DS:              howto manager.      (line  546)
+* BFD_RELOC_PPC64_TOC16_HA:              howto manager.      (line  533)
+* BFD_RELOC_PPC64_TOC16_HI:              howto manager.      (line  532)
+* BFD_RELOC_PPC64_TOC16_LO:              howto manager.      (line  531)
+* BFD_RELOC_PPC64_TOC16_LO_DS:           howto manager.      (line  547)
+* BFD_RELOC_PPC64_TPREL16_DS:            howto manager.      (line  580)
+* BFD_RELOC_PPC64_TPREL16_HIGHER:        howto manager.      (line  582)
+* BFD_RELOC_PPC64_TPREL16_HIGHERA:       howto manager.      (line  583)
+* BFD_RELOC_PPC64_TPREL16_HIGHEST:       howto manager.      (line  584)
+* BFD_RELOC_PPC64_TPREL16_HIGHESTA:      howto manager.      (line  585)
+* BFD_RELOC_PPC64_TPREL16_LO_DS:         howto manager.      (line  581)
+* BFD_RELOC_PPC_B16:                     howto manager.      (line  500)
+* BFD_RELOC_PPC_B16_BRNTAKEN:            howto manager.      (line  502)
+* BFD_RELOC_PPC_B16_BRTAKEN:             howto manager.      (line  501)
+* BFD_RELOC_PPC_B26:                     howto manager.      (line  497)
+* BFD_RELOC_PPC_BA16:                    howto manager.      (line  503)
+* BFD_RELOC_PPC_BA16_BRNTAKEN:           howto manager.      (line  505)
+* BFD_RELOC_PPC_BA16_BRTAKEN:            howto manager.      (line  504)
+* BFD_RELOC_PPC_BA26:                    howto manager.      (line  498)
+* BFD_RELOC_PPC_COPY:                    howto manager.      (line  506)
+* BFD_RELOC_PPC_DTPMOD:                  howto manager.      (line  553)
+* BFD_RELOC_PPC_DTPREL:                  howto manager.      (line  563)
+* BFD_RELOC_PPC_DTPREL16:                howto manager.      (line  559)
+* BFD_RELOC_PPC_DTPREL16_HA:             howto manager.      (line  562)
+* BFD_RELOC_PPC_DTPREL16_HI:             howto manager.      (line  561)
+* BFD_RELOC_PPC_DTPREL16_LO:             howto manager.      (line  560)
+* BFD_RELOC_PPC_EMB_BIT_FLD:             howto manager.      (line  525)
+* BFD_RELOC_PPC_EMB_MRKREF:              howto manager.      (line  520)
+* BFD_RELOC_PPC_EMB_NADDR16:             howto manager.      (line  512)
+* BFD_RELOC_PPC_EMB_NADDR16_HA:          howto manager.      (line  515)
+* BFD_RELOC_PPC_EMB_NADDR16_HI:          howto manager.      (line  514)
+* BFD_RELOC_PPC_EMB_NADDR16_LO:          howto manager.      (line  513)
+* BFD_RELOC_PPC_EMB_NADDR32:             howto manager.      (line  511)
+* BFD_RELOC_PPC_EMB_RELSDA:              howto manager.      (line  526)
+* BFD_RELOC_PPC_EMB_RELSEC16:            howto manager.      (line  521)
+* BFD_RELOC_PPC_EMB_RELST_HA:            howto manager.      (line  524)
+* BFD_RELOC_PPC_EMB_RELST_HI:            howto manager.      (line  523)
+* BFD_RELOC_PPC_EMB_RELST_LO:            howto manager.      (line  522)
+* BFD_RELOC_PPC_EMB_SDA21:               howto manager.      (line  519)
+* BFD_RELOC_PPC_EMB_SDA2I16:             howto manager.      (line  517)
+* BFD_RELOC_PPC_EMB_SDA2REL:             howto manager.      (line  518)
+* BFD_RELOC_PPC_EMB_SDAI16:              howto manager.      (line  516)
+* BFD_RELOC_PPC_GLOB_DAT:                howto manager.      (line  507)
+* BFD_RELOC_PPC_GOT_DTPREL16:            howto manager.      (line  576)
+* BFD_RELOC_PPC_GOT_DTPREL16_HA:         howto manager.      (line  579)
+* BFD_RELOC_PPC_GOT_DTPREL16_HI:         howto manager.      (line  578)
+* BFD_RELOC_PPC_GOT_DTPREL16_LO:         howto manager.      (line  577)
+* BFD_RELOC_PPC_GOT_TLSGD16:             howto manager.      (line  564)
+* BFD_RELOC_PPC_GOT_TLSGD16_HA:          howto manager.      (line  567)
+* BFD_RELOC_PPC_GOT_TLSGD16_HI:          howto manager.      (line  566)
+* BFD_RELOC_PPC_GOT_TLSGD16_LO:          howto manager.      (line  565)
+* BFD_RELOC_PPC_GOT_TLSLD16:             howto manager.      (line  568)
+* BFD_RELOC_PPC_GOT_TLSLD16_HA:          howto manager.      (line  571)
+* BFD_RELOC_PPC_GOT_TLSLD16_HI:          howto manager.      (line  570)
+* BFD_RELOC_PPC_GOT_TLSLD16_LO:          howto manager.      (line  569)
+* BFD_RELOC_PPC_GOT_TPREL16:             howto manager.      (line  572)
+* BFD_RELOC_PPC_GOT_TPREL16_HA:          howto manager.      (line  575)
+* BFD_RELOC_PPC_GOT_TPREL16_HI:          howto manager.      (line  574)
+* BFD_RELOC_PPC_GOT_TPREL16_LO:          howto manager.      (line  573)
+* BFD_RELOC_PPC_JMP_SLOT:                howto manager.      (line  508)
+* BFD_RELOC_PPC_LOCAL24PC:               howto manager.      (line  510)
+* BFD_RELOC_PPC_RELATIVE:                howto manager.      (line  509)
+* BFD_RELOC_PPC_TLS:                     howto manager.      (line  552)
+* BFD_RELOC_PPC_TOC16:                   howto manager.      (line  499)
+* BFD_RELOC_PPC_TPREL:                   howto manager.      (line  558)
+* BFD_RELOC_PPC_TPREL16:                 howto manager.      (line  554)
+* BFD_RELOC_PPC_TPREL16_HA:              howto manager.      (line  557)
+* BFD_RELOC_PPC_TPREL16_HI:              howto manager.      (line  556)
+* BFD_RELOC_PPC_TPREL16_LO:              howto manager.      (line  555)
+* BFD_RELOC_RVA:                         howto manager.      (line   85)
+* BFD_RELOC_SH_ALIGN:                    howto manager.      (line  723)
+* BFD_RELOC_SH_CODE:                     howto manager.      (line  724)
+* BFD_RELOC_SH_COPY:                     howto manager.      (line  729)
+* BFD_RELOC_SH_COPY64:                   howto manager.      (line  754)
+* BFD_RELOC_SH_COUNT:                    howto manager.      (line  722)
+* BFD_RELOC_SH_DATA:                     howto manager.      (line  725)
+* BFD_RELOC_SH_DISP12:                   howto manager.      (line  705)
+* BFD_RELOC_SH_DISP12BY2:                howto manager.      (line  706)
+* BFD_RELOC_SH_DISP12BY4:                howto manager.      (line  707)
+* BFD_RELOC_SH_DISP12BY8:                howto manager.      (line  708)
+* BFD_RELOC_SH_DISP20:                   howto manager.      (line  709)
+* BFD_RELOC_SH_DISP20BY8:                howto manager.      (line  710)
+* BFD_RELOC_SH_GLOB_DAT:                 howto manager.      (line  730)
+* BFD_RELOC_SH_GLOB_DAT64:               howto manager.      (line  755)
+* BFD_RELOC_SH_GOT10BY4:                 howto manager.      (line  758)
+* BFD_RELOC_SH_GOT10BY8:                 howto manager.      (line  759)
+* BFD_RELOC_SH_GOT_HI16:                 howto manager.      (line  737)
+* BFD_RELOC_SH_GOT_LOW16:                howto manager.      (line  734)
+* BFD_RELOC_SH_GOT_MEDHI16:              howto manager.      (line  736)
+* BFD_RELOC_SH_GOT_MEDLOW16:             howto manager.      (line  735)
+* BFD_RELOC_SH_GOTOFF_HI16:              howto manager.      (line  749)
+* BFD_RELOC_SH_GOTOFF_LOW16:             howto manager.      (line  746)
+* BFD_RELOC_SH_GOTOFF_MEDHI16:           howto manager.      (line  748)
+* BFD_RELOC_SH_GOTOFF_MEDLOW16:          howto manager.      (line  747)
+* BFD_RELOC_SH_GOTPC:                    howto manager.      (line  733)
+* BFD_RELOC_SH_GOTPC_HI16:               howto manager.      (line  753)
+* BFD_RELOC_SH_GOTPC_LOW16:              howto manager.      (line  750)
+* BFD_RELOC_SH_GOTPC_MEDHI16:            howto manager.      (line  752)
+* BFD_RELOC_SH_GOTPC_MEDLOW16:           howto manager.      (line  751)
+* BFD_RELOC_SH_GOTPLT10BY4:              howto manager.      (line  760)
+* BFD_RELOC_SH_GOTPLT10BY8:              howto manager.      (line  761)
+* BFD_RELOC_SH_GOTPLT32:                 howto manager.      (line  762)
+* BFD_RELOC_SH_GOTPLT_HI16:              howto manager.      (line  741)
+* BFD_RELOC_SH_GOTPLT_LOW16:             howto manager.      (line  738)
+* BFD_RELOC_SH_GOTPLT_MEDHI16:           howto manager.      (line  740)
+* BFD_RELOC_SH_GOTPLT_MEDLOW16:          howto manager.      (line  739)
+* BFD_RELOC_SH_IMM3:                     howto manager.      (line  703)
+* BFD_RELOC_SH_IMM3U:                    howto manager.      (line  704)
+* BFD_RELOC_SH_IMM4:                     howto manager.      (line  711)
+* BFD_RELOC_SH_IMM4BY2:                  howto manager.      (line  712)
+* BFD_RELOC_SH_IMM4BY4:                  howto manager.      (line  713)
+* BFD_RELOC_SH_IMM8:                     howto manager.      (line  714)
+* BFD_RELOC_SH_IMM8BY2:                  howto manager.      (line  715)
+* BFD_RELOC_SH_IMM8BY4:                  howto manager.      (line  716)
+* BFD_RELOC_SH_IMM_HI16:                 howto manager.      (line  780)
+* BFD_RELOC_SH_IMM_HI16_PCREL:           howto manager.      (line  781)
+* BFD_RELOC_SH_IMM_LOW16:                howto manager.      (line  774)
+* BFD_RELOC_SH_IMM_LOW16_PCREL:          howto manager.      (line  775)
+* BFD_RELOC_SH_IMM_MEDHI16:              howto manager.      (line  778)
+* BFD_RELOC_SH_IMM_MEDHI16_PCREL:        howto manager.      (line  779)
+* BFD_RELOC_SH_IMM_MEDLOW16:             howto manager.      (line  776)
+* BFD_RELOC_SH_IMM_MEDLOW16_PCREL:       howto manager.      (line  777)
+* BFD_RELOC_SH_IMMS10:                   howto manager.      (line  768)
+* BFD_RELOC_SH_IMMS10BY2:                howto manager.      (line  769)
+* BFD_RELOC_SH_IMMS10BY4:                howto manager.      (line  770)
+* BFD_RELOC_SH_IMMS10BY8:                howto manager.      (line  771)
+* BFD_RELOC_SH_IMMS16:                   howto manager.      (line  772)
+* BFD_RELOC_SH_IMMS6:                    howto manager.      (line  765)
+* BFD_RELOC_SH_IMMS6BY32:                howto manager.      (line  766)
+* BFD_RELOC_SH_IMMU16:                   howto manager.      (line  773)
+* BFD_RELOC_SH_IMMU5:                    howto manager.      (line  764)
+* BFD_RELOC_SH_IMMU6:                    howto manager.      (line  767)
+* BFD_RELOC_SH_JMP_SLOT:                 howto manager.      (line  731)
+* BFD_RELOC_SH_JMP_SLOT64:               howto manager.      (line  756)
+* BFD_RELOC_SH_LABEL:                    howto manager.      (line  726)
+* BFD_RELOC_SH_LOOP_END:                 howto manager.      (line  728)
+* BFD_RELOC_SH_LOOP_START:               howto manager.      (line  727)
+* BFD_RELOC_SH_PCDISP12BY2:              howto manager.      (line  702)
+* BFD_RELOC_SH_PCDISP8BY2:               howto manager.      (line  701)
+* BFD_RELOC_SH_PCRELIMM8BY2:             howto manager.      (line  717)
+* BFD_RELOC_SH_PCRELIMM8BY4:             howto manager.      (line  718)
+* BFD_RELOC_SH_PLT_HI16:                 howto manager.      (line  745)
+* BFD_RELOC_SH_PLT_LOW16:                howto manager.      (line  742)
+* BFD_RELOC_SH_PLT_MEDHI16:              howto manager.      (line  744)
+* BFD_RELOC_SH_PLT_MEDLOW16:             howto manager.      (line  743)
+* BFD_RELOC_SH_PT_16:                    howto manager.      (line  782)
+* BFD_RELOC_SH_RELATIVE:                 howto manager.      (line  732)
+* BFD_RELOC_SH_RELATIVE64:               howto manager.      (line  757)
+* BFD_RELOC_SH_SHMEDIA_CODE:             howto manager.      (line  763)
+* BFD_RELOC_SH_SWITCH16:                 howto manager.      (line  719)
+* BFD_RELOC_SH_SWITCH32:                 howto manager.      (line  720)
+* BFD_RELOC_SH_TLS_DTPMOD32:             howto manager.      (line  788)
+* BFD_RELOC_SH_TLS_DTPOFF32:             howto manager.      (line  789)
+* BFD_RELOC_SH_TLS_GD_32:                howto manager.      (line  783)
+* BFD_RELOC_SH_TLS_IE_32:                howto manager.      (line  786)
+* BFD_RELOC_SH_TLS_LD_32:                howto manager.      (line  784)
+* BFD_RELOC_SH_TLS_LDO_32:               howto manager.      (line  785)
+* BFD_RELOC_SH_TLS_LE_32:                howto manager.      (line  787)
+* BFD_RELOC_SH_TLS_TPOFF32:              howto manager.      (line  790)
+* BFD_RELOC_SH_USES:                     howto manager.      (line  721)
+* BFD_RELOC_SPARC13:                     howto manager.      (line  119)
+* BFD_RELOC_SPARC22:                     howto manager.      (line  118)
+* BFD_RELOC_SPARC_10:                    howto manager.      (line  141)
+* BFD_RELOC_SPARC_11:                    howto manager.      (line  142)
+* BFD_RELOC_SPARC_5:                     howto manager.      (line  154)
+* BFD_RELOC_SPARC_6:                     howto manager.      (line  153)
+* BFD_RELOC_SPARC_64:                    howto manager.      (line  140)
+* BFD_RELOC_SPARC_7:                     howto manager.      (line  152)
+* BFD_RELOC_SPARC_BASE13:                howto manager.      (line  136)
+* BFD_RELOC_SPARC_BASE22:                howto manager.      (line  137)
+* BFD_RELOC_SPARC_COPY:                  howto manager.      (line  126)
+* BFD_RELOC_SPARC_DISP64:                howto manager.      (line  155)
+* BFD_RELOC_SPARC_GLOB_DAT:              howto manager.      (line  127)
+* BFD_RELOC_SPARC_GOT10:                 howto manager.      (line  120)
+* BFD_RELOC_SPARC_GOT13:                 howto manager.      (line  121)
+* BFD_RELOC_SPARC_GOT22:                 howto manager.      (line  122)
+* BFD_RELOC_SPARC_H44:                   howto manager.      (line  160)
+* BFD_RELOC_SPARC_HH22:                  howto manager.      (line  144)
+* BFD_RELOC_SPARC_HIX22:                 howto manager.      (line  158)
+* BFD_RELOC_SPARC_HM10:                  howto manager.      (line  145)
+* BFD_RELOC_SPARC_JMP_SLOT:              howto manager.      (line  128)
+* BFD_RELOC_SPARC_L44:                   howto manager.      (line  162)
+* BFD_RELOC_SPARC_LM22:                  howto manager.      (line  146)
+* BFD_RELOC_SPARC_LOX10:                 howto manager.      (line  159)
+* BFD_RELOC_SPARC_M44:                   howto manager.      (line  161)
+* BFD_RELOC_SPARC_OLO10:                 howto manager.      (line  143)
+* BFD_RELOC_SPARC_PC10:                  howto manager.      (line  123)
+* BFD_RELOC_SPARC_PC22:                  howto manager.      (line  124)
+* BFD_RELOC_SPARC_PC_HH22:               howto manager.      (line  147)
+* BFD_RELOC_SPARC_PC_HM10:               howto manager.      (line  148)
+* BFD_RELOC_SPARC_PC_LM22:               howto manager.      (line  149)
+* BFD_RELOC_SPARC_PLT32:                 howto manager.      (line  156)
+* BFD_RELOC_SPARC_PLT64:                 howto manager.      (line  157)
+* BFD_RELOC_SPARC_REGISTER:              howto manager.      (line  163)
+* BFD_RELOC_SPARC_RELATIVE:              howto manager.      (line  129)
+* BFD_RELOC_SPARC_REV32:                 howto manager.      (line  166)
+* BFD_RELOC_SPARC_TLS_DTPMOD32:          howto manager.      (line  187)
+* BFD_RELOC_SPARC_TLS_DTPMOD64:          howto manager.      (line  188)
+* BFD_RELOC_SPARC_TLS_DTPOFF32:          howto manager.      (line  189)
+* BFD_RELOC_SPARC_TLS_DTPOFF64:          howto manager.      (line  190)
+* BFD_RELOC_SPARC_TLS_GD_ADD:            howto manager.      (line  171)
+* BFD_RELOC_SPARC_TLS_GD_CALL:           howto manager.      (line  172)
+* BFD_RELOC_SPARC_TLS_GD_HI22:           howto manager.      (line  169)
+* BFD_RELOC_SPARC_TLS_GD_LO10:           howto manager.      (line  170)
+* BFD_RELOC_SPARC_TLS_IE_ADD:            howto manager.      (line  184)
+* BFD_RELOC_SPARC_TLS_IE_HI22:           howto manager.      (line  180)
+* BFD_RELOC_SPARC_TLS_IE_LD:             howto manager.      (line  182)
+* BFD_RELOC_SPARC_TLS_IE_LDX:            howto manager.      (line  183)
+* BFD_RELOC_SPARC_TLS_IE_LO10:           howto manager.      (line  181)
+* BFD_RELOC_SPARC_TLS_LDM_ADD:           howto manager.      (line  175)
+* BFD_RELOC_SPARC_TLS_LDM_CALL:          howto manager.      (line  176)
+* BFD_RELOC_SPARC_TLS_LDM_HI22:          howto manager.      (line  173)
+* BFD_RELOC_SPARC_TLS_LDM_LO10:          howto manager.      (line  174)
+* BFD_RELOC_SPARC_TLS_LDO_ADD:           howto manager.      (line  179)
+* BFD_RELOC_SPARC_TLS_LDO_HIX22:         howto manager.      (line  177)
+* BFD_RELOC_SPARC_TLS_LDO_LOX10:         howto manager.      (line  178)
+* BFD_RELOC_SPARC_TLS_LE_HIX22:          howto manager.      (line  185)
+* BFD_RELOC_SPARC_TLS_LE_LOX10:          howto manager.      (line  186)
+* BFD_RELOC_SPARC_TLS_TPOFF32:           howto manager.      (line  191)
+* BFD_RELOC_SPARC_TLS_TPOFF64:           howto manager.      (line  192)
+* BFD_RELOC_SPARC_UA16:                  howto manager.      (line  130)
+* BFD_RELOC_SPARC_UA32:                  howto manager.      (line  131)
+* BFD_RELOC_SPARC_UA64:                  howto manager.      (line  132)
+* BFD_RELOC_SPARC_WDISP16:               howto manager.      (line  150)
+* BFD_RELOC_SPARC_WDISP19:               howto manager.      (line  151)
+* BFD_RELOC_SPARC_WDISP22:               howto manager.      (line  117)
+* BFD_RELOC_SPARC_WPLT30:                howto manager.      (line  125)
+* BFD_RELOC_THUMB_PCREL_BLX:             howto manager.      (line  612)
+* BFD_RELOC_THUMB_PCREL_BRANCH12:        howto manager.      (line  619)
+* BFD_RELOC_THUMB_PCREL_BRANCH20:        howto manager.      (line  620)
+* BFD_RELOC_THUMB_PCREL_BRANCH23:        howto manager.      (line  621)
+* BFD_RELOC_THUMB_PCREL_BRANCH25:        howto manager.      (line  622)
+* BFD_RELOC_THUMB_PCREL_BRANCH7:         howto manager.      (line  617)
+* BFD_RELOC_THUMB_PCREL_BRANCH9:         howto manager.      (line  618)
+* BFD_RELOC_TIC30_LDP:                   howto manager.      (line 1098)
+* BFD_RELOC_TIC54X_16_OF_23:             howto manager.      (line 1116)
+* BFD_RELOC_TIC54X_23:                   howto manager.      (line 1113)
+* BFD_RELOC_TIC54X_MS7_OF_23:            howto manager.      (line 1121)
+* BFD_RELOC_TIC54X_PARTLS7:              howto manager.      (line 1103)
+* BFD_RELOC_TIC54X_PARTMS9:              howto manager.      (line 1108)
+* bfd_reloc_type_lookup:                 howto manager.      (line 1862)
+* BFD_RELOC_V850_22_PCREL:               howto manager.      (line 1025)
+* BFD_RELOC_V850_9_PCREL:                howto manager.      (line 1022)
+* BFD_RELOC_V850_ALIGN:                  howto manager.      (line 1083)
+* BFD_RELOC_V850_CALLT_16_16_OFFSET:     howto manager.      (line 1074)
+* BFD_RELOC_V850_CALLT_6_7_OFFSET:       howto manager.      (line 1071)
+* BFD_RELOC_V850_LO16_SPLIT_OFFSET:      howto manager.      (line 1086)
+* BFD_RELOC_V850_LONGCALL:               howto manager.      (line 1077)
+* BFD_RELOC_V850_LONGJUMP:               howto manager.      (line 1080)
+* BFD_RELOC_V850_SDA_15_16_OFFSET:       howto manager.      (line 1031)
+* BFD_RELOC_V850_SDA_16_16_OFFSET:       howto manager.      (line 1028)
+* BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET: howto manager.      (line 1063)
+* BFD_RELOC_V850_TDA_16_16_OFFSET:       howto manager.      (line 1053)
+* BFD_RELOC_V850_TDA_4_4_OFFSET:         howto manager.      (line 1060)
+* BFD_RELOC_V850_TDA_4_5_OFFSET:         howto manager.      (line 1056)
+* BFD_RELOC_V850_TDA_6_8_OFFSET:         howto manager.      (line 1042)
+* BFD_RELOC_V850_TDA_7_7_OFFSET:         howto manager.      (line 1050)
+* BFD_RELOC_V850_TDA_7_8_OFFSET:         howto manager.      (line 1046)
+* BFD_RELOC_V850_ZDA_15_16_OFFSET:       howto manager.      (line 1038)
+* BFD_RELOC_V850_ZDA_16_16_OFFSET:       howto manager.      (line 1035)
+* BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET: howto manager.      (line 1067)
+* BFD_RELOC_VAX_GLOB_DAT:                howto manager.      (line 1736)
+* BFD_RELOC_VAX_JMP_SLOT:                howto manager.      (line 1737)
+* BFD_RELOC_VAX_RELATIVE:                howto manager.      (line 1738)
+* BFD_RELOC_VPE4KMATH_DATA:              howto manager.      (line 1433)
+* BFD_RELOC_VPE4KMATH_INSN:              howto manager.      (line 1434)
+* BFD_RELOC_VTABLE_ENTRY:                howto manager.      (line 1438)
+* BFD_RELOC_VTABLE_INHERIT:              howto manager.      (line 1437)
+* BFD_RELOC_X86_64_32S:                  howto manager.      (line  458)
+* BFD_RELOC_X86_64_COPY:                 howto manager.      (line  453)
+* BFD_RELOC_X86_64_DTPMOD64:             howto manager.      (line  459)
+* BFD_RELOC_X86_64_DTPOFF32:             howto manager.      (line  464)
+* BFD_RELOC_X86_64_DTPOFF64:             howto manager.      (line  460)
+* BFD_RELOC_X86_64_GLOB_DAT:             howto manager.      (line  454)
+* BFD_RELOC_X86_64_GOT32:                howto manager.      (line  451)
+* BFD_RELOC_X86_64_GOTOFF64:             howto manager.      (line  467)
+* BFD_RELOC_X86_64_GOTPC32:              howto manager.      (line  468)
+* BFD_RELOC_X86_64_GOTPCREL:             howto manager.      (line  457)
+* BFD_RELOC_X86_64_GOTTPOFF:             howto manager.      (line  465)
+* BFD_RELOC_X86_64_JUMP_SLOT:            howto manager.      (line  455)
+* BFD_RELOC_X86_64_PLT32:                howto manager.      (line  452)
+* BFD_RELOC_X86_64_RELATIVE:             howto manager.      (line  456)
+* BFD_RELOC_X86_64_TLSGD:                howto manager.      (line  462)
+* BFD_RELOC_X86_64_TLSLD:                howto manager.      (line  463)
+* BFD_RELOC_X86_64_TPOFF32:              howto manager.      (line  466)
+* BFD_RELOC_X86_64_TPOFF64:              howto manager.      (line  461)
+* BFD_RELOC_XSTORMY16_12:                howto manager.      (line 1731)
+* BFD_RELOC_XSTORMY16_24:                howto manager.      (line 1732)
+* BFD_RELOC_XSTORMY16_FPTR16:            howto manager.      (line 1733)
+* BFD_RELOC_XSTORMY16_REL_12:            howto manager.      (line 1730)
+* BFD_RELOC_XTENSA_ASM_EXPAND:           howto manager.      (line 1839)
+* BFD_RELOC_XTENSA_ASM_SIMPLIFY:         howto manager.      (line 1844)
+* BFD_RELOC_XTENSA_DIFF16:               howto manager.      (line 1786)
+* BFD_RELOC_XTENSA_DIFF32:               howto manager.      (line 1787)
+* BFD_RELOC_XTENSA_DIFF8:                howto manager.      (line 1785)
+* BFD_RELOC_XTENSA_GLOB_DAT:             howto manager.      (line 1775)
+* BFD_RELOC_XTENSA_JMP_SLOT:             howto manager.      (line 1776)
+* BFD_RELOC_XTENSA_OP0:                  howto manager.      (line 1833)
+* BFD_RELOC_XTENSA_OP1:                  howto manager.      (line 1834)
+* BFD_RELOC_XTENSA_OP2:                  howto manager.      (line 1835)
+* BFD_RELOC_XTENSA_PLT:                  howto manager.      (line 1780)
+* BFD_RELOC_XTENSA_RELATIVE:             howto manager.      (line 1777)
+* BFD_RELOC_XTENSA_RTLD:                 howto manager.      (line 1770)
+* BFD_RELOC_XTENSA_SLOT0_ALT:            howto manager.      (line 1815)
+* BFD_RELOC_XTENSA_SLOT0_OP:             howto manager.      (line 1795)
+* BFD_RELOC_XTENSA_SLOT10_ALT:           howto manager.      (line 1825)
+* BFD_RELOC_XTENSA_SLOT10_OP:            howto manager.      (line 1805)
+* BFD_RELOC_XTENSA_SLOT11_ALT:           howto manager.      (line 1826)
+* BFD_RELOC_XTENSA_SLOT11_OP:            howto manager.      (line 1806)
+* BFD_RELOC_XTENSA_SLOT12_ALT:           howto manager.      (line 1827)
+* BFD_RELOC_XTENSA_SLOT12_OP:            howto manager.      (line 1807)
+* BFD_RELOC_XTENSA_SLOT13_ALT:           howto manager.      (line 1828)
+* BFD_RELOC_XTENSA_SLOT13_OP:            howto manager.      (line 1808)
+* BFD_RELOC_XTENSA_SLOT14_ALT:           howto manager.      (line 1829)
+* BFD_RELOC_XTENSA_SLOT14_OP:            howto manager.      (line 1809)
+* BFD_RELOC_XTENSA_SLOT1_ALT:            howto manager.      (line 1816)
+* BFD_RELOC_XTENSA_SLOT1_OP:             howto manager.      (line 1796)
+* BFD_RELOC_XTENSA_SLOT2_ALT:            howto manager.      (line 1817)
+* BFD_RELOC_XTENSA_SLOT2_OP:             howto manager.      (line 1797)
+* BFD_RELOC_XTENSA_SLOT3_ALT:            howto manager.      (line 1818)
+* BFD_RELOC_XTENSA_SLOT3_OP:             howto manager.      (line 1798)
+* BFD_RELOC_XTENSA_SLOT4_ALT:            howto manager.      (line 1819)
+* BFD_RELOC_XTENSA_SLOT4_OP:             howto manager.      (line 1799)
+* BFD_RELOC_XTENSA_SLOT5_ALT:            howto manager.      (line 1820)
+* BFD_RELOC_XTENSA_SLOT5_OP:             howto manager.      (line 1800)
+* BFD_RELOC_XTENSA_SLOT6_ALT:            howto manager.      (line 1821)
+* BFD_RELOC_XTENSA_SLOT6_OP:             howto manager.      (line 1801)
+* BFD_RELOC_XTENSA_SLOT7_ALT:            howto manager.      (line 1822)
+* BFD_RELOC_XTENSA_SLOT7_OP:             howto manager.      (line 1802)
+* BFD_RELOC_XTENSA_SLOT8_ALT:            howto manager.      (line 1823)
+* BFD_RELOC_XTENSA_SLOT8_OP:             howto manager.      (line 1803)
+* BFD_RELOC_XTENSA_SLOT9_ALT:            howto manager.      (line 1824)
+* BFD_RELOC_XTENSA_SLOT9_OP:             howto manager.      (line 1804)
+* BFD_RELOC_Z80_DISP8:                   howto manager.      (line 1849)
+* BFD_RELOC_Z8K_CALLR:                   howto manager.      (line 1855)
+* BFD_RELOC_Z8K_DISP7:                   howto manager.      (line 1852)
+* BFD_RELOC_Z8K_IMM4L:                   howto manager.      (line 1858)
+* bfd_scan_arch:                         Architectures.      (line  381)
+* bfd_scan_vma:                          BFD front end.      (line  423)
+* bfd_seach_for_target:                  bfd_target.         (line  466)
+* bfd_section_already_linked:            Writing the symbol table.
+                                                             (line   55)
+* bfd_section_list_clear:                section prototypes. (line    8)
+* bfd_sections_find_if:                  section prototypes. (line  176)
+* bfd_set_arch_info:                     Architectures.      (line  422)
+* bfd_set_archive_head:                  Archives.           (line   69)
+* bfd_set_default_target:                bfd_target.         (line  431)
+* bfd_set_error:                         BFD front end.      (line  235)
+* bfd_set_error_handler:                 BFD front end.      (line  275)
+* bfd_set_error_program_name:            BFD front end.      (line  284)
+* bfd_set_file_flags:                    BFD front end.      (line  343)
+* bfd_set_format:                        Formats.            (line   68)
+* bfd_set_gp_size:                       BFD front end.      (line  413)
+* bfd_set_private_flags:                 BFD front end.      (line  490)
+* bfd_set_reloc:                         BFD front end.      (line  333)
+* bfd_set_section_contents:              section prototypes. (line  207)
+* bfd_set_section_flags:                 section prototypes. (line  140)
+* bfd_set_section_size:                  section prototypes. (line  193)
+* bfd_set_start_address:                 BFD front end.      (line  392)
+* bfd_set_symtab:                        symbol handling functions.
+                                                             (line   60)
+* bfd_symbol_info:                       symbol handling functions.
+                                                             (line  130)
+* bfd_target_list:                       bfd_target.         (line  457)
+* bfd_write_bigendian_4byte_int:         Internal.           (line   13)
+* bfd_zalloc:                            Opening and Closing.
+                                                             (line  221)
+* bfd_zalloc2:                           Opening and Closing.
+                                                             (line  230)
+* coff_symbol_type:                      coff.               (line  186)
+* core_file_matches_executable_p:        Core Files.         (line   30)
+* find_separate_debug_file:              Opening and Closing.
+                                                             (line  272)
+* get_debug_link_info:                   Opening and Closing.
+                                                             (line  253)
+* Hash tables:                           Hash Tables.        (line    6)
+* internal object-file format:           Canonical format.   (line   11)
+* Linker:                                Linker Functions.   (line    6)
+* Other functions:                       BFD front end.      (line  505)
+* separate_debug_file_exists:            Opening and Closing.
+                                                             (line  263)
+* struct bfd_iovec:                      BFD front end.      (line  668)
+* target vector (_bfd_final_link):       Performing the Final Link.
+                                                             (line    6)
+* target vector (_bfd_link_add_symbols): Adding Symbols to the Hash Table.
+                                                             (line    6)
+* target vector (_bfd_link_hash_table_create): Creating a Linker Hash Table.
+                                                             (line    6)
+* The HOWTO Macro:                       typedef arelent.    (line  290)
+* what is it?:                           Overview.           (line    6)
+
+
 
 Tag Table:
-(Indirect)
-Node: Top724
-Node: Overview1056
-Node: History2107
-Node: How It Works3053
-Node: What BFD Version 2 Can Do4595
-Node: BFD information loss5910
-Node: Canonical format8442
-Node: BFD front end12814
-Node: Memory Usage38700
-Node: Initialization39928
-Node: Sections40387
-Node: Section Input40870
-Node: Section Output42235
-Node: typedef asection44721
-Node: section prototypes69678
-Node: Symbols79358
-Node: Reading Symbols80953
-Node: Writing Symbols82060
-Node: Mini Symbols83769
-Node: typedef asymbol84743
-Node: symbol handling functions89661
-Node: Archives95003
-Node: Formats98729
-Node: Relocations101677
-Node: typedef arelent102404
-Node: howto manager118122
-Node: Core Files178580
-Node: Targets179714
-Node: bfd_target181684
-Node: Architectures202127
-Node: Opening and Closing223020
-Node: Internal234022
-Node: File Caching240355
-Node: Linker Functions242269
-Node: Creating a Linker Hash Table243942
-Node: Adding Symbols to the Hash Table245680
-Node: Differing file formats246580
-Node: Adding symbols from an object file248328
-Node: Adding symbols from an archive250479
-Node: Performing the Final Link252893
-Node: Information provided by the linker254135
-Node: Relocating the section contents255289
-Node: Writing the symbol table257040
-Node: Hash Tables260033
-Node: Creating and Freeing a Hash Table261231
-Node: Looking Up or Entering a String262481
-Node: Traversing a Hash Table263734
-Node: Deriving a New Hash Table Type264523
-Node: Define the Derived Structures265589
-Node: Write the Derived Creation Routine266670
-Node: Write Other Derived Routines269294
-Node: BFD back ends270609
-Node: What to Put Where270879
-Node: aout271017
-Node: coff277335
-Node: elf301812
-Node: mmo302675
-Node: File layout303603
-Node: Symbol-table309250
-Node: mmo section mapping313019
-Node: GNU Free Documentation License316671
-Node: Index336396
+Node: Top770
+Node: Overview1102
+Node: History2153
+Node: How It Works3099
+Node: What BFD Version 2 Can Do4641
+Node: BFD information loss5956
+Node: Canonical format8488
+Node: BFD front end12860
+Node: Memory Usage38746
+Node: Initialization39974
+Node: Sections40433
+Node: Section Input40916
+Node: Section Output42281
+Node: typedef asection44767
+Node: section prototypes69724
+Node: Symbols79404
+Node: Reading Symbols80999
+Node: Writing Symbols82106
+Node: Mini Symbols83815
+Node: typedef asymbol84789
+Node: symbol handling functions89707
+Node: Archives95049
+Node: Formats98775
+Node: Relocations101723
+Node: typedef arelent102450
+Node: howto manager118168
+Node: Core Files178626
+Node: Targets179760
+Node: bfd_target181730
+Node: Architectures202173
+Node: Opening and Closing223066
+Node: Internal234068
+Node: File Caching240401
+Node: Linker Functions242315
+Node: Creating a Linker Hash Table243988
+Node: Adding Symbols to the Hash Table245726
+Node: Differing file formats246626
+Node: Adding symbols from an object file248374
+Node: Adding symbols from an archive250525
+Node: Performing the Final Link252939
+Node: Information provided by the linker254181
+Node: Relocating the section contents255335
+Node: Writing the symbol table257086
+Node: Hash Tables260079
+Node: Creating and Freeing a Hash Table261277
+Node: Looking Up or Entering a String262527
+Node: Traversing a Hash Table263780
+Node: Deriving a New Hash Table Type264569
+Node: Define the Derived Structures265635
+Node: Write the Derived Creation Routine266716
+Node: Write Other Derived Routines269340
+Node: BFD back ends270655
+Node: What to Put Where270925
+Node: aout271063
+Node: coff277381
+Node: elf301858
+Node: mmo302721
+Node: File layout303649
+Node: Symbol-table309296
+Node: mmo section mapping313065
+Node: GNU Free Documentation License316717
+Node: Index336442
 
 End Tag Table
Index: bfd/hosts/brownie32bsd.h
===================================================================
RCS file: bfd/hosts/brownie32bsd.h
diff -N bfd/hosts/brownie32bsd.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ bfd/hosts/brownie32bsd.h	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,15 @@
+/* 
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+*/
+#include <machine/param.h>
+#include <machine/vmparam.h>
+#undef ALIGN
+
+#define	HOST_PAGE_SIZE		NBPG
+/* #define	HOST_SEGMENT_SIZE	NBPG -- we use HOST_DATA_START_ADDR */
+#define	HOST_MACHINE_ARCH	bfd_arch_brownie32
+/* #define	HOST_MACHINE_MACHINE	 */
+
+#define	HOST_TEXT_START_ADDR		USRTEXT
+#define	HOST_STACK_END_ADDR		USRSTACK
+#define NO_CORE_COMMAND
Index: bfd/hosts/brownie32mach3.h
===================================================================
RCS file: bfd/hosts/brownie32mach3.h
diff -N bfd/hosts/brownie32mach3.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ bfd/hosts/brownie32mach3.h	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,13 @@
+/*
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+*/
+#include <machine/vmparam.h>
+#include <machine/machparam.h>
+#include <sys/param.h>
+
+#define	HOST_PAGE_SIZE		NBPG
+/* #define	HOST_SEGMENT_SIZE	NBPG  */
+#define	HOST_MACHINE_ARCH	bfd_arch_brownie32
+#define	HOST_TEXT_START_ADDR	USRTEXT
+#define	HOST_DATA_START_ADDR	USRDATA
+#define	HOST_STACK_END_ADDR	USRSTACK
Index: bfd/hosts/news-brownie32.h
===================================================================
RCS file: bfd/hosts/news-brownie32.h
diff -N bfd/hosts/news-brownie32.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ bfd/hosts/news-brownie32.h	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,15 @@
+/*
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+*/
+/* Sony News running NewsOS 3.2.  */
+
+#include <sys/param.h>
+#include <machine/vmparam.h>
+
+#define HOST_PAGE_SIZE NBPG
+
+#define HOST_MACHINE_ARCH bfd_arch_brownie32
+
+#define HOST_TEXT_START_ADDR USRTEXT
+#define HOST_DATA_START_ADDR USRDATA
+#define HOST_STACK_END_ADDR USRSTACK
Index: etc/configure
===================================================================
RCS file: /home/prj/asip/cvs/gdb/etc/configure,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- etc/configure	31 Jul 2007 11:40:32 -0000	1.1.1.1
+++ etc/configure	8 Aug 2007 08:49:54 -0000	1.2
@@ -1,8 +1,9 @@
 #! /bin/sh
 
 # Guess values for system-dependent variables and create Makefiles.
-# Generated automatically using autoconf version 2.12.1 
+# Generated automatically using autoconf version 2.13 
 # Copyright (C) 1992, 93, 94, 95, 96 Free Software Foundation, Inc.
+# Copyright (C) 2005,2006  Upwind technology, Inc.
 #
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
@@ -333,7 +334,7 @@ EOF
     verbose=yes ;;
 
   -version | --version | --versio | --versi | --vers)
-    echo "configure generated by autoconf version 2.12.1"
+    echo "configure generated by autoconf version 2.13"
     exit 0 ;;
 
   -with-* | --with-*)
@@ -503,9 +504,11 @@ ac_ext=c
 # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
-ac_link='${CC-cc} -o conftest $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
+ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
 cross_compiling=$ac_cv_prog_cc_cross
 
+ac_exeext=
+ac_objext=o
 if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null; then
   # Stardent Vistra SVR4 grep lacks -e, says ghazi@caip.rutgers.edu.
   if (echo -n testing; echo 1,2,3) | sed s/-n/xn/ | grep xn >/dev/null; then
@@ -551,12 +554,12 @@ ac_configure=$ac_aux_dir/configure # Thi
 # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
 # ./install, which can be erroneously created by make from ./install.sh.
 echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
-echo "configure:555: checking for a BSD compatible install" >&5
+echo "configure:557: checking for a BSD compatible install" >&5
 if test -z "$INSTALL"; then
 if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
-    IFS="${IFS= 	}"; ac_save_IFS="$IFS"; IFS="${IFS}:"
+    IFS="${IFS= 	}"; ac_save_IFS="$IFS"; IFS=":"
   for ac_dir in $PATH; do
     # Account for people who put trailing slashes in PATH elements.
     case "$ac_dir/" in
@@ -599,6 +602,8 @@ echo "$ac_t""$INSTALL" 1>&6
 # It thinks the first close brace ends the variable substitution.
 test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
 
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL_PROGRAM}'
+
 test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
 
 
@@ -625,7 +630,7 @@ EOF
 # Ultrix sh set writes to stderr and can't be redirected directly,
 # and sets the high bit in the cache file unless we assign to the vars.
 (set) 2>&1 |
-  case `(ac_space=' '; set) 2>&1 | grep ac_space` in
+  case `(ac_space=' '; set | grep ac_space) 2>&1` in
   *ac_space=\ *)
     # `set' does not quote correctly, so add quotes (double-quote substitution
     # turns \\\\ into \\, and sed turns \\ into \).
@@ -704,7 +709,7 @@ do
     echo "running \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion"
     exec \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion ;;
   -version | --version | --versio | --versi | --vers | --ver | --ve | --v)
-    echo "$CONFIG_STATUS generated by autoconf version 2.12.1"
+    echo "$CONFIG_STATUS generated by autoconf version 2.13"
     exit 0 ;;
   -help | --help | --hel | --he | --h)
     echo "\$ac_cs_usage"; exit 0 ;;
@@ -728,6 +733,7 @@ s%@SHELL@%$SHELL%g
 s%@CFLAGS@%$CFLAGS%g
 s%@CPPFLAGS@%$CPPFLAGS%g
 s%@CXXFLAGS@%$CXXFLAGS%g
+s%@FFLAGS@%$FFLAGS%g
 s%@DEFS@%$DEFS%g
 s%@LDFLAGS@%$LDFLAGS%g
 s%@LIBS@%$LIBS%g
@@ -747,6 +753,7 @@ s%@oldincludedir@%$oldincludedir%g
 s%@infodir@%$infodir%g
 s%@mandir@%$mandir%g
 s%@INSTALL_PROGRAM@%$INSTALL_PROGRAM%g
+s%@INSTALL_SCRIPT@%$INSTALL_SCRIPT%g
 s%@INSTALL_DATA@%$INSTALL_DATA%g
 
 CEOF
Index: gdb/Makefile.in
===================================================================
RCS file: /home/prj/asip/cvs/gdb/gdb/Makefile.in,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -p -r1.1.1.1 -r1.3
--- gdb/Makefile.in	31 Jul 2007 11:40:22 -0000	1.1.1.1
+++ gdb/Makefile.in	11 Feb 2008 15:39:23 -0000	1.3
@@ -1,6 +1,7 @@
 # Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
 # 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation,
 # Inc.
+# Copyright (C) 2005,2006  Upwind technology, Inc.
 
 # This file is part of GDB.
 
@@ -534,7 +535,7 @@ SFILES = ada-exp.y ada-lang.c ada-typepr
 	language.c linespec.c \
 	m2-exp.y m2-lang.c m2-typeprint.c m2-valprint.c \
 	macrotab.c macroexp.c macrocmd.c macroscope.c main.c maint.c \
-	mdebugread.c memattr.c mem-break.c minsyms.c mipsread.c \
+	mdebugread.c memattr.c mem-break.c minsyms.c mipsread.c brownie32read.c \
 	nlmread.c \
 	objc-exp.y objc-lang.c \
 	objfiles.c osabi.c observer.c \
@@ -736,6 +737,8 @@ memattr_h = memattr.h
 mips_mdebug_tdep_h = mips-mdebug-tdep.h
 mipsnbsd_tdep_h = mipsnbsd-tdep.h
 mips_tdep_h = mips-tdep.h
+brownie32nbsd_tdep_h = brownie32nbsd-tdep.h
+brownie32_tdep_h = brownie32-tdep.h
 mn10300_tdep_h = mn10300-tdep.h
 monitor_h = monitor.h
 nbsd_tdep_h = nbsd-tdep.h
@@ -916,7 +919,7 @@ COMMON_OBS = $(DEPFILES) $(CONFIG_OBS) $
 	gdb-events.o \
 	exec.o bcache.o objfiles.o observer.o minsyms.o maint.o demangle.o \
 	dbxread.o coffread.o coff-pe-read.o elfread.o \
-	dwarfread.o dwarf2read.o mipsread.o stabsread.o corefile.o \
+	dwarfread.o dwarf2read.o mipsread.o brownie32read.o stabsread.o corefile.o \
 	dwarf2expr.o dwarf2loc.o dwarf2-frame.o \
 	ada-lang.o c-lang.o f-lang.o objc-lang.o \
 	ui-out.o cli-out.o \
@@ -1424,6 +1427,9 @@ ALLDEPFILES = \
 	mips-tdep.c mipsv4-nat.c \
 	mipsnbsd-nat.c mipsnbsd-tdep.c \
 	mips64obsd-nat.c mips64obsd-tdep.c \
+	brownie32-linux-nat.c brownie32-linux-tdep.c \
+	brownie32-tdep.c brownie32v4-nat.c \
+	brownie32nbsd-nat.c brownie32nbsd-tdep.c \
 	nbsd-tdep.c \
 	solib-osf.c \
 	somread.c solib-som.c $(HPREAD_SOURCE) \
@@ -1432,7 +1438,7 @@ ALLDEPFILES = \
 	ppcobsd-nat.c ppcobsd-tdep.c \
 	procfs.c \
 	remote-e7000.c \
-	remote-hms.c remote-m32r-sdi.c remote-mips.c \
+	remote-hms.c remote-m32r-sdi.c remote-mips.c remote-brownie32.c \
 	remote-rdp.c remote-sim.c \
 	remote-st.c remote-utils.c dcache.c \
 	rs6000-nat.c rs6000-tdep.c \
@@ -2310,6 +2316,32 @@ mips-tdep.o: mips-tdep.c $(defs_h) $(gdb
 	$(floatformat_h)
 mipsv4-nat.o: mipsv4-nat.c $(defs_h) $(inferior_h) $(gdbcore_h) $(target_h) \
 	$(regcache_h) $(gregset_h)
+brownie32-linux-nat.o: brownie32-linux-nat.c $(defs_h) $(brownie32_tdep_h) $(target_h) \
+	$(linux_nat_h)
+brownie32-linux-tdep.o: brownie32-linux-tdep.c $(defs_h) $(gdbcore_h) $(target_h) \
+	$(solib_svr4_h) $(osabi_h) $(brownie32_tdep_h) $(gdb_string_h) \
+	$(gdb_assert_h) $(frame_h) $(regcache_h) $(trad_frame_h) \
+	$(tramp_frame_h)
+brownie32nbsd-nat.o: brownie32nbsd-nat.c $(defs_h) $(inferior_h) $(regcache_h) \
+	$(target_h) $(brownie32_tdep_h) $(brownie32nbsd_tdep_h) $(inf_ptrace_h)
+brownie32nbsd-tdep.o: brownie32nbsd-tdep.c $(defs_h) $(gdbcore_h) $(regcache_h) \
+	$(regset_h) $(target_h) $(value_h) $(osabi_h) $(gdb_assert_h) \
+	$(gdb_string_h) $(nbsd_tdep_h) $(brownie32nbsd_tdep_h) $(brownie32_tdep_h) \
+	$(solib_svr4_h)
+brownie32read.o: brownie32read.c $(defs_h) $(gdb_string_h) $(bfd_h) $(symtab_h) \
+	$(objfiles_h) $(buildsym_h) $(stabsread_h) $(coff_sym_h) \
+	$(coff_internal_h) $(coff_ecoff_h) $(libcoff_h) $(libecoff_h) \
+	$(elf_common_h) $(elf_brownie32_h)
+brownie32-tdep.o: brownie32-tdep.c $(defs_h) $(gdb_string_h) $(gdb_assert_h) \
+	$(frame_h) $(inferior_h) $(symtab_h) $(value_h) $(gdbcmd_h) \
+	$(language_h) $(gdbcore_h) $(symfile_h) $(objfiles_h) $(gdbtypes_h) \
+	$(target_h) $(arch_utils_h) $(regcache_h) $(osabi_h) $(brownie32_tdep_h) \
+	$(block_h) $(reggroups_h) $(opcode_brownie32_h) $(elf_brownie32_h) \
+	$(elf_bfd_h) $(symcat_h) $(sim_regno_h) $(dis_asm_h) \
+	$(frame_unwind_h) $(frame_base_h) $(trad_frame_h) $(infcall_h) \
+	$(floatformat_h)
+brownie32v4-nat.o: brownie32v4-nat.c $(defs_h) $(inferior_h) $(gdbcore_h) $(target_h) \
+	$(regcache_h) $(gregset_h)
 mn10300-linux-tdep.o: mn10300-linux-tdep.c $(defs_h) $(gdbcore_h) \
 	$(gdb_string_h) $(regcache_h) $(mn10300_tdep_h) $(gdb_assert_h) \
 	$(bfd_h) $(elf_bfd_h) $(osabi_h) $(regset_h) $(solib_svr4_h)
@@ -2450,6 +2482,10 @@ remote-mips.o: remote-mips.c $(defs_h) $
 	$(gdbcmd_h) $(gdbcore_h) $(serial_h) $(target_h) $(exceptions_h) \
 	$(remote_utils_h) $(gdb_string_h) $(gdb_stat_h) $(regcache_h) \
 	$(mips_tdep_h)
+remote-brownie32.o: remote-brownie32.c $(defs_h) $(inferior_h) $(bfd_h) $(symfile_h) \
+	$(gdbcmd_h) $(gdbcore_h) $(serial_h) $(target_h) $(exceptions_h) \
+	$(remote_utils_h) $(gdb_string_h) $(gdb_stat_h) $(regcache_h) \
+	$(brownie32_tdep_h)
 remote-rdi.o: remote-rdi.c $(defs_h) $(gdb_string_h) $(frame_h) \
 	$(inferior_h) $(bfd_h) $(symfile_h) $(target_h) $(gdbcmd_h) \
 	$(objfiles_h) $(gdb_stabs_h) $(gdbthread_h) $(gdbcore_h) \
Index: gdb/brownie32-irix-tdep.c
===================================================================
RCS file: gdb/brownie32-irix-tdep.c
diff -N gdb/brownie32-irix-tdep.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/brownie32-irix-tdep.c	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,97 @@
+/* Target-dependent code for the BROWNIE32 architecture running on IRIX,
+   for GDB, the GNU Debugger.
+
+   Copyright 2002 Free Software Foundation, Inc.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include "defs.h"
+#include "osabi.h"
+
+#include "elf-bfd.h"
+
+static void
+brownie32_irix_elf_osabi_sniff_abi_tag_sections (bfd *abfd, asection *sect,
+                                            void *obj)
+{
+  enum gdb_osabi *os_ident_ptr = obj;
+  const char *name;
+  unsigned int sectsize;
+
+  name = bfd_get_section_name (abfd, sect);
+  sectsize = bfd_section_size (abfd, sect);
+
+  if (strncmp (name, ".BROWNIE32.", 6) == 0 && sectsize > 0)
+    {
+      /* The presence of a section named with a ".BROWNIE32." prefix is
+         indicative of an IRIX binary.  */
+      *os_ident_ptr = GDB_OSABI_IRIX;
+    }
+}
+
+static enum gdb_osabi
+brownie32_irix_elf_osabi_sniffer (bfd *abfd)
+{
+  unsigned int elfosabi;
+  enum gdb_osabi osabi = GDB_OSABI_UNKNOWN;
+
+  /* If the generic sniffer gets a hit, return and let other sniffers
+     get a crack at it.  */
+  bfd_map_over_sections (abfd,
+			 generic_elf_osabi_sniff_abi_tag_sections,
+			 &osabi);
+  if (osabi != GDB_OSABI_UNKNOWN)
+    return GDB_OSABI_UNKNOWN;
+
+  elfosabi = elf_elfheader (abfd)->e_ident[EI_OSABI];
+
+  if (elfosabi == ELFOSABI_NONE)
+    {
+      /* When elfosabi is ELFOSABI_NONE (0), then the ELF structures in the
+	 file are conforming to the base specification for that machine 
+	 (there are no OS-specific extensions).  In order to determine the 
+	 real OS in use we must look for OS notes that have been added.  
+	 
+	 For IRIX, we simply look for sections named with .BROWNIE32. as
+	 prefixes.  */
+      bfd_map_over_sections (abfd,
+			     brownie32_irix_elf_osabi_sniff_abi_tag_sections, 
+			     &osabi);
+    }
+  return osabi;
+}
+
+static void
+brownie32_irix_init_abi (struct gdbarch_info info,
+                    struct gdbarch *gdbarch)
+{
+}
+
+void
+_initialize_brownie32_irix_tdep (void)
+{
+  /* Register an ELF OS ABI sniffer for IRIX binaries.  */
+  gdbarch_register_osabi_sniffer (bfd_arch_brownie32,
+				  bfd_target_elf_flavour,
+				  brownie32_irix_elf_osabi_sniffer);
+
+  gdbarch_register_osabi (bfd_arch_brownie32, 0, GDB_OSABI_IRIX,
+			  brownie32_irix_init_abi);
+}
Index: gdb/brownie32-linux-nat.c
===================================================================
RCS file: gdb/brownie32-linux-nat.c
diff -N gdb/brownie32-linux-nat.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/brownie32-linux-nat.c	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,75 @@
+/* Native-dependent code for GNU/Linux on BROWNIE32 processors.
+
+   Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include "defs.h"
+#include "brownie32-tdep.h"
+#include "target.h"
+#include "linux-nat.h"
+
+/* Pseudo registers can not be read.  ptrace does not provide a way to
+   read (or set) BROWNIE32_PS_REGNUM, and there's no point in reading or
+   setting BROWNIE32_ZERO_REGNUM.  We also can not set BADVADDR, CAUSE, or
+   FCRIR via ptrace().  */
+
+int
+brownie32_linux_cannot_fetch_register (int regno)
+{
+  if (regno > BROWNIE32_ZERO_REGNUM && regno < BROWNIE32_ZERO_REGNUM + 32)
+    return 0;
+  else if (regno >= brownie32_regnum (current_gdbarch)->fp0
+	   && regno <= brownie32_regnum (current_gdbarch)->fp0 + 32)
+    return 0;
+  else if (regno == brownie32_regnum (current_gdbarch)->lo
+	   || regno == brownie32_regnum (current_gdbarch)->hi
+	   || regno == brownie32_regnum (current_gdbarch)->badvaddr
+	   || regno == brownie32_regnum (current_gdbarch)->cause
+	   || regno == brownie32_regnum (current_gdbarch)->pc
+	   || regno == brownie32_regnum (current_gdbarch)->fp_control_status
+	   || regno == brownie32_regnum (current_gdbarch)->fp_implementation_revision)
+    return 0;
+  else
+    return 1;
+}
+
+int
+brownie32_linux_cannot_store_register (int regno)
+{
+  if (regno > BROWNIE32_ZERO_REGNUM && regno < BROWNIE32_ZERO_REGNUM + 32)
+    return 0;
+  else if (regno >= FP0_REGNUM && regno <= FP0_REGNUM + 32)
+    return 0;
+  else if (regno == brownie32_regnum (current_gdbarch)->lo
+	   || regno == brownie32_regnum (current_gdbarch)->hi
+	   || regno == brownie32_regnum (current_gdbarch)->pc
+	   || regno == brownie32_regnum (current_gdbarch)->fp_control_status)
+    return 0;
+  else
+    return 1;
+}
+
+void _initialize_brownie32_linux_nat (void);
+
+void
+_initialize_brownie32_linux_nat (void)
+{
+  add_target (linux_target ());
+}
Index: gdb/brownie32-linux-tdep.c
===================================================================
RCS file: gdb/brownie32-linux-tdep.c
diff -N gdb/brownie32-linux-tdep.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/brownie32-linux-tdep.c	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,1240 @@
+/* Target-dependent code for GNU/Linux on BROWNIE32 processors.
+
+   Copyright 2001, 2002, 2004, 2005 Free Software Foundation, Inc.
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include "defs.h"
+#include "gdbcore.h"
+#include "target.h"
+#include "solib-svr4.h"
+#include "osabi.h"
+#include "brownie32-tdep.h"
+#include "gdb_string.h"
+#include "gdb_assert.h"
+#include "frame.h"
+#include "regcache.h"
+#include "trad-frame.h"
+#include "tramp-frame.h"
+
+/* Copied from <asm/elf.h>.  */
+#define ELF_NGREG       45
+#define ELF_NFPREG      33
+
+typedef unsigned char elf_greg_t[4];
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+typedef unsigned char elf_fpreg_t[8];
+typedef elf_fpreg_t elf_fpregset_t[ELF_NFPREG];
+
+/* 0 - 31 are integer registers, 32 - 63 are fp registers.  */
+#define FPR_BASE        32
+#define PC              64
+#define CAUSE           65
+#define BADVADDR        66
+#define MMHI            67
+#define MMLO            68
+#define FPC_CSR         69
+#define FPC_EIR         70
+
+#define EF_REG0			6
+#define EF_REG31		37
+#define EF_LO			38
+#define EF_HI			39
+#define EF_CP0_EPC		40
+#define EF_CP0_BADVADDR		41
+#define EF_CP0_STATUS		42
+#define EF_CP0_CAUSE		43
+
+#define EF_SIZE			180
+
+/* Figure out where the longjmp will land.
+   We expect the first arg to be a pointer to the jmp_buf structure
+   from which we extract the pc (BROWNIE32_LINUX_JB_PC) that we will land
+   at.  The pc is copied into PC.  This routine returns 1 on
+   success.  */
+
+#define BROWNIE32_LINUX_JB_ELEMENT_SIZE 4
+#define BROWNIE32_LINUX_JB_PC 0
+
+static int
+brownie32_linux_get_longjmp_target (CORE_ADDR *pc)
+{
+  CORE_ADDR jb_addr;
+  char buf[TARGET_PTR_BIT / TARGET_CHAR_BIT];
+
+  jb_addr = read_register (BROWNIE32_A0_REGNUM);
+
+  if (target_read_memory (jb_addr
+			  + BROWNIE32_LINUX_JB_PC * BROWNIE32_LINUX_JB_ELEMENT_SIZE,
+			  buf, TARGET_PTR_BIT / TARGET_CHAR_BIT))
+    return 0;
+
+  *pc = extract_unsigned_integer (buf, TARGET_PTR_BIT / TARGET_CHAR_BIT);
+
+  return 1;
+}
+
+/* Transform the bits comprising a 32-bit register to the right size
+   for regcache_raw_supply().  This is needed when brownie32_isa_regsize()
+   is 8.  */
+
+static void
+supply_32bit_reg (int regnum, const void *addr)
+{
+  char buf[MAX_REGISTER_SIZE];
+  store_signed_integer (buf, register_size (current_gdbarch, regnum),
+                        extract_signed_integer (addr, 4));
+  regcache_raw_supply (current_regcache, regnum, buf);
+}
+
+/* Unpack an elf_gregset_t into GDB's register cache.  */
+
+void 
+supply_gregset (elf_gregset_t *gregsetp)
+{
+  int regi;
+  elf_greg_t *regp = *gregsetp;
+  char zerobuf[MAX_REGISTER_SIZE];
+
+  memset (zerobuf, 0, MAX_REGISTER_SIZE);
+
+  for (regi = EF_REG0; regi <= EF_REG31; regi++)
+    supply_32bit_reg ((regi - EF_REG0), (char *)(regp + regi));
+
+  supply_32bit_reg (brownie32_regnum (current_gdbarch)->lo,
+		    (char *)(regp + EF_LO));
+  supply_32bit_reg (brownie32_regnum (current_gdbarch)->hi,
+		    (char *)(regp + EF_HI));
+
+  supply_32bit_reg (brownie32_regnum (current_gdbarch)->pc,
+		    (char *)(regp + EF_CP0_EPC));
+  supply_32bit_reg (brownie32_regnum (current_gdbarch)->badvaddr,
+		    (char *)(regp + EF_CP0_BADVADDR));
+  supply_32bit_reg (BROWNIE32_PS_REGNUM, (char *)(regp + EF_CP0_STATUS));
+  supply_32bit_reg (brownie32_regnum (current_gdbarch)->cause,
+		    (char *)(regp + EF_CP0_CAUSE));
+
+  /* Fill inaccessible registers with zero.  */
+  regcache_raw_supply (current_regcache, BROWNIE32_UNUSED_REGNUM, zerobuf);
+  for (regi = BROWNIE32_FIRST_EMBED_REGNUM;
+       regi < BROWNIE32_LAST_EMBED_REGNUM;
+       regi++)
+    regcache_raw_supply (current_regcache, regi, zerobuf);
+}
+
+/* Pack our registers (or one register) into an elf_gregset_t.  */
+
+void
+fill_gregset (elf_gregset_t *gregsetp, int regno)
+{
+  int regaddr, regi;
+  elf_greg_t *regp = *gregsetp;
+  void *dst;
+
+  if (regno == -1)
+    {
+      memset (regp, 0, sizeof (elf_gregset_t));
+      for (regi = 0; regi < 32; regi++)
+        fill_gregset (gregsetp, regi);
+      fill_gregset (gregsetp, brownie32_regnum (current_gdbarch)->lo);
+      fill_gregset (gregsetp, brownie32_regnum (current_gdbarch)->hi);
+      fill_gregset (gregsetp, brownie32_regnum (current_gdbarch)->pc);
+      fill_gregset (gregsetp, brownie32_regnum (current_gdbarch)->badvaddr);
+      fill_gregset (gregsetp, BROWNIE32_PS_REGNUM);
+      fill_gregset (gregsetp, brownie32_regnum (current_gdbarch)->cause);
+
+      return;
+   }
+
+  if (regno < 32)
+    {
+      dst = regp + regno + EF_REG0;
+      regcache_raw_collect (current_regcache, regno, dst);
+      return;
+    }
+
+  if (regno == brownie32_regnum (current_gdbarch)->lo)
+    regaddr = EF_LO;
+  else if (regno == brownie32_regnum (current_gdbarch)->hi)
+    regaddr = EF_HI;
+  else if (regno == brownie32_regnum (current_gdbarch)->pc)
+    regaddr = EF_CP0_EPC;
+  else if (regno == brownie32_regnum (current_gdbarch)->badvaddr)
+    regaddr = EF_CP0_BADVADDR;
+  else if (regno == BROWNIE32_PS_REGNUM)
+    regaddr = EF_CP0_STATUS;
+  else if (regno == brownie32_regnum (current_gdbarch)->cause)
+    regaddr = EF_CP0_CAUSE;
+  else
+    regaddr = -1;
+
+  if (regaddr != -1)
+    {
+      dst = regp + regaddr;
+      regcache_raw_collect (current_regcache, regno, dst);
+    }
+}
+
+/* Likewise, unpack an elf_fpregset_t.  */
+
+void
+supply_fpregset (elf_fpregset_t *fpregsetp)
+{
+  int regi;
+  char zerobuf[MAX_REGISTER_SIZE];
+
+  memset (zerobuf, 0, MAX_REGISTER_SIZE);
+
+  for (regi = 0; regi < 32; regi++)
+    regcache_raw_supply (current_regcache, FP0_REGNUM + regi,
+			 (char *)(*fpregsetp + regi));
+
+  regcache_raw_supply (current_regcache,
+		       brownie32_regnum (current_gdbarch)->fp_control_status,
+		       (char *)(*fpregsetp + 32));
+
+  /* FIXME: how can we supply FCRIR?  The ABI doesn't tell us.  */
+  regcache_raw_supply (current_regcache,
+		       brownie32_regnum (current_gdbarch)->fp_implementation_revision,
+		       zerobuf);
+}
+
+/* Likewise, pack one or all floating point registers into an
+   elf_fpregset_t.  */
+
+void
+fill_fpregset (elf_fpregset_t *fpregsetp, int regno)
+{
+  char *from, *to;
+
+  if ((regno >= FP0_REGNUM) && (regno < FP0_REGNUM + 32))
+    {
+      to = (char *) (*fpregsetp + regno - FP0_REGNUM);
+      regcache_raw_collect (current_regcache, regno, to);
+    }
+  else if (regno == brownie32_regnum (current_gdbarch)->fp_control_status)
+    {
+      to = (char *) (*fpregsetp + 32);
+      regcache_raw_collect (current_regcache, regno, to);
+    }
+  else if (regno == -1)
+    {
+      int regi;
+
+      for (regi = 0; regi < 32; regi++)
+	fill_fpregset (fpregsetp, FP0_REGNUM + regi);
+      fill_fpregset (fpregsetp,
+		     brownie32_regnum (current_gdbarch)->fp_control_status);
+    }
+}
+
+/* Map gdb internal register number to ptrace ``address''.
+   These ``addresses'' are normally defined in <asm/ptrace.h>.  */
+
+static CORE_ADDR
+brownie32_linux_register_addr (int regno, CORE_ADDR blockend)
+{
+  int regaddr;
+
+  if (regno < 0 || regno >= NUM_REGS)
+    error (_("Bogon register number %d."), regno);
+
+  if (regno < 32)
+    regaddr = regno;
+  else if ((regno >= brownie32_regnum (current_gdbarch)->fp0)
+	   && (regno < brownie32_regnum (current_gdbarch)->fp0 + 32))
+    regaddr = FPR_BASE + (regno - brownie32_regnum (current_gdbarch)->fp0);
+  else if (regno == brownie32_regnum (current_gdbarch)->pc)
+    regaddr = PC;
+  else if (regno == brownie32_regnum (current_gdbarch)->cause)
+    regaddr = CAUSE;
+  else if (regno == brownie32_regnum (current_gdbarch)->badvaddr)
+    regaddr = BADVADDR;
+  else if (regno == brownie32_regnum (current_gdbarch)->lo)
+    regaddr = MMLO;
+  else if (regno == brownie32_regnum (current_gdbarch)->hi)
+    regaddr = MMHI;
+  else if (regno == brownie32_regnum (current_gdbarch)->fp_control_status)
+    regaddr = FPC_CSR;
+  else if (regno == brownie32_regnum (current_gdbarch)->fp_implementation_revision)
+    regaddr = FPC_EIR;
+  else
+    error (_("Unknowable register number %d."), regno);
+
+  return regaddr;
+}
+
+
+/* Fetch (and possibly build) an appropriate link_map_offsets
+   structure for native GNU/Linux BROWNIE32 targets using the struct
+   offsets defined in link.h (but without actual reference to that
+   file).
+
+   This makes it possible to access GNU/Linux BROWNIE32 shared libraries
+   from a GDB that was built on a different host platform (for cross
+   debugging).  */
+
+static struct link_map_offsets *
+brownie32_linux_svr4_fetch_link_map_offsets (void)
+{
+  static struct link_map_offsets lmo;
+  static struct link_map_offsets *lmp = NULL;
+
+  if (lmp == NULL)
+    {
+      lmp = &lmo;
+
+      lmo.r_debug_size = 8;	/* The actual size is 20 bytes, but
+				   this is all we need.  */
+      lmo.r_map_offset = 4;
+      lmo.r_map_size   = 4;
+
+      lmo.link_map_size = 20;
+
+      lmo.l_addr_offset = 0;
+      lmo.l_addr_size   = 4;
+
+      lmo.l_name_offset = 4;
+      lmo.l_name_size   = 4;
+
+      lmo.l_next_offset = 12;
+      lmo.l_next_size   = 4;
+
+      lmo.l_prev_offset = 16;
+      lmo.l_prev_size   = 4;
+    }
+
+  return lmp;
+}
+
+/* Support for 64-bit ABIs.  */
+
+/* Copied from <asm/elf.h>.  */
+#define BROWNIE3264_ELF_NGREG       45
+#define BROWNIE3264_ELF_NFPREG      33
+
+typedef unsigned char brownie3264_elf_greg_t[8];
+typedef brownie3264_elf_greg_t brownie3264_elf_gregset_t[BROWNIE3264_ELF_NGREG];
+
+typedef unsigned char brownie3264_elf_fpreg_t[8];
+typedef brownie3264_elf_fpreg_t brownie3264_elf_fpregset_t[BROWNIE3264_ELF_NFPREG];
+
+/* 0 - 31 are integer registers, 32 - 63 are fp registers.  */
+#define BROWNIE3264_FPR_BASE                 32
+#define BROWNIE3264_PC                       64
+#define BROWNIE3264_CAUSE                    65
+#define BROWNIE3264_BADVADDR                 66
+#define BROWNIE3264_MMHI                     67
+#define BROWNIE3264_MMLO                     68
+#define BROWNIE3264_FPC_CSR                  69
+#define BROWNIE3264_FPC_EIR                  70
+
+#define BROWNIE3264_EF_REG0			 0
+#define BROWNIE3264_EF_REG31			31
+#define BROWNIE3264_EF_LO			32
+#define BROWNIE3264_EF_HI			33
+#define BROWNIE3264_EF_CP0_EPC		34
+#define BROWNIE3264_EF_CP0_BADVADDR		35
+#define BROWNIE3264_EF_CP0_STATUS		36
+#define BROWNIE3264_EF_CP0_CAUSE		37
+
+#define BROWNIE3264_EF_SIZE			304
+
+/* Figure out where the longjmp will land.
+   We expect the first arg to be a pointer to the jmp_buf structure
+   from which we extract the pc (BROWNIE32_LINUX_JB_PC) that we will land
+   at.  The pc is copied into PC.  This routine returns 1 on
+   success.  */
+
+/* Details about jmp_buf.  */
+
+#define BROWNIE3264_LINUX_JB_PC 0
+
+static int
+brownie3264_linux_get_longjmp_target (CORE_ADDR *pc)
+{
+  CORE_ADDR jb_addr;
+  void *buf = alloca (TARGET_PTR_BIT / TARGET_CHAR_BIT);
+  int element_size = TARGET_PTR_BIT == 32 ? 4 : 8;
+
+  jb_addr = read_register (BROWNIE32_A0_REGNUM);
+
+  if (target_read_memory (jb_addr + BROWNIE3264_LINUX_JB_PC * element_size,
+			  buf, TARGET_PTR_BIT / TARGET_CHAR_BIT))
+    return 0;
+
+  *pc = extract_unsigned_integer (buf, TARGET_PTR_BIT / TARGET_CHAR_BIT);
+
+  return 1;
+}
+
+/* Unpack an elf_gregset_t into GDB's register cache.  */
+
+static void 
+brownie3264_supply_gregset (brownie3264_elf_gregset_t *gregsetp)
+{
+  int regi;
+  brownie3264_elf_greg_t *regp = *gregsetp;
+  char zerobuf[MAX_REGISTER_SIZE];
+
+  memset (zerobuf, 0, MAX_REGISTER_SIZE);
+
+  for (regi = BROWNIE3264_EF_REG0; regi <= BROWNIE3264_EF_REG31; regi++)
+    regcache_raw_supply (current_regcache, (regi - BROWNIE3264_EF_REG0),
+			 (char *)(regp + regi));
+
+  regcache_raw_supply (current_regcache,
+		       brownie32_regnum (current_gdbarch)->lo,
+		       (char *) (regp + BROWNIE3264_EF_LO));
+  regcache_raw_supply (current_regcache,
+		       brownie32_regnum (current_gdbarch)->hi,
+		       (char *) (regp + BROWNIE3264_EF_HI));
+
+  regcache_raw_supply (current_regcache,
+		       brownie32_regnum (current_gdbarch)->pc,
+		       (char *) (regp + BROWNIE3264_EF_CP0_EPC));
+  regcache_raw_supply (current_regcache,
+		       brownie32_regnum (current_gdbarch)->badvaddr,
+		       (char *) (regp + BROWNIE3264_EF_CP0_BADVADDR));
+  regcache_raw_supply (current_regcache, BROWNIE32_PS_REGNUM,
+		       (char *) (regp + BROWNIE3264_EF_CP0_STATUS));
+  regcache_raw_supply (current_regcache,
+		       brownie32_regnum (current_gdbarch)->cause,
+		       (char *) (regp + BROWNIE3264_EF_CP0_CAUSE));
+
+  /* Fill inaccessible registers with zero.  */
+  regcache_raw_supply (current_regcache, BROWNIE32_UNUSED_REGNUM, zerobuf);
+  for (regi = BROWNIE32_FIRST_EMBED_REGNUM;
+       regi < BROWNIE32_LAST_EMBED_REGNUM;
+       regi++)
+    regcache_raw_supply (current_regcache, regi, zerobuf);
+}
+
+/* Pack our registers (or one register) into an elf_gregset_t.  */
+
+static void
+brownie3264_fill_gregset (brownie3264_elf_gregset_t *gregsetp, int regno)
+{
+  int regaddr, regi;
+  brownie3264_elf_greg_t *regp = *gregsetp;
+  void *src, *dst;
+
+  if (regno == -1)
+    {
+      memset (regp, 0, sizeof (brownie3264_elf_gregset_t));
+      for (regi = 0; regi < 32; regi++)
+        brownie3264_fill_gregset (gregsetp, regi);
+      brownie3264_fill_gregset (gregsetp, brownie32_regnum (current_gdbarch)->lo);
+      brownie3264_fill_gregset (gregsetp, brownie32_regnum (current_gdbarch)->hi);
+      brownie3264_fill_gregset (gregsetp, brownie32_regnum (current_gdbarch)->pc);
+      brownie3264_fill_gregset (gregsetp,
+			   brownie32_regnum (current_gdbarch)->badvaddr);
+      brownie3264_fill_gregset (gregsetp, BROWNIE32_PS_REGNUM);
+      brownie3264_fill_gregset (gregsetp,
+			   brownie32_regnum (current_gdbarch)->cause);
+
+      return;
+   }
+
+  if (regno < 32)
+    {
+      dst = regp + regno + BROWNIE3264_EF_REG0;
+      regcache_raw_collect (current_regcache, regno, dst);
+      return;
+    }
+
+  if (regno == brownie32_regnum (current_gdbarch)->lo)
+    regaddr = BROWNIE3264_EF_LO;
+  else if (regno == brownie32_regnum (current_gdbarch)->hi)
+    regaddr = BROWNIE3264_EF_HI;
+  else if (regno == brownie32_regnum (current_gdbarch)->pc)
+    regaddr = BROWNIE3264_EF_CP0_EPC;
+  else if (regno == brownie32_regnum (current_gdbarch)->badvaddr)
+    regaddr = BROWNIE3264_EF_CP0_BADVADDR;
+  else if (regno == BROWNIE32_PS_REGNUM)
+    regaddr = BROWNIE3264_EF_CP0_STATUS;
+  else if (regno == brownie32_regnum (current_gdbarch)->cause)
+    regaddr = BROWNIE3264_EF_CP0_CAUSE;
+  else
+    regaddr = -1;
+
+  if (regaddr != -1)
+    {
+      dst = regp + regaddr;
+      regcache_raw_collect (current_regcache, regno, dst);
+    }
+}
+
+/* Likewise, unpack an elf_fpregset_t.  */
+
+static void
+brownie3264_supply_fpregset (brownie3264_elf_fpregset_t *fpregsetp)
+{
+  int regi;
+  char zerobuf[MAX_REGISTER_SIZE];
+
+  memset (zerobuf, 0, MAX_REGISTER_SIZE);
+
+  for (regi = 0; regi < 32; regi++)
+    regcache_raw_supply (current_regcache, FP0_REGNUM + regi,
+			 (char *)(*fpregsetp + regi));
+
+  regcache_raw_supply (current_regcache,
+		       brownie32_regnum (current_gdbarch)->fp_control_status,
+		       (char *)(*fpregsetp + 32));
+
+  /* FIXME: how can we supply FCRIR?  The ABI doesn't tell us.  */
+  regcache_raw_supply (current_regcache,
+		       brownie32_regnum (current_gdbarch)->fp_implementation_revision,
+		       zerobuf);
+}
+
+/* Likewise, pack one or all floating point registers into an
+   elf_fpregset_t.  */
+
+static void
+brownie3264_fill_fpregset (brownie3264_elf_fpregset_t *fpregsetp, int regno)
+{
+  char *from, *to;
+
+  if ((regno >= FP0_REGNUM) && (regno < FP0_REGNUM + 32))
+    {
+      to = (char *) (*fpregsetp + regno - FP0_REGNUM);
+      regcache_raw_collect (current_regcache, regno, to);
+    }
+  else if (regno == brownie32_regnum (current_gdbarch)->fp_control_status)
+    {
+      to = (char *) (*fpregsetp + 32);
+      regcache_raw_collect (current_regcache, regno, to);
+    }
+  else if (regno == -1)
+    {
+      int regi;
+
+      for (regi = 0; regi < 32; regi++)
+	brownie3264_fill_fpregset (fpregsetp, FP0_REGNUM + regi);
+      brownie3264_fill_fpregset(fpregsetp,
+			   brownie32_regnum (current_gdbarch)->fp_control_status);
+    }
+}
+
+
+/* Map gdb internal register number to ptrace ``address''.
+   These ``addresses'' are normally defined in <asm/ptrace.h>.  */
+
+static CORE_ADDR
+brownie3264_linux_register_addr (int regno, CORE_ADDR blockend)
+{
+  int regaddr;
+
+  if (regno < 0 || regno >= NUM_REGS)
+    error (_("Bogon register number %d."), regno);
+
+  if (regno < 32)
+    regaddr = regno;
+  else if ((regno >= brownie32_regnum (current_gdbarch)->fp0)
+	   && (regno < brownie32_regnum (current_gdbarch)->fp0 + 32))
+    regaddr = BROWNIE3264_FPR_BASE + (regno - FP0_REGNUM);
+  else if (regno == brownie32_regnum (current_gdbarch)->pc)
+    regaddr = BROWNIE3264_PC;
+  else if (regno == brownie32_regnum (current_gdbarch)->cause)
+    regaddr = BROWNIE3264_CAUSE;
+  else if (regno == brownie32_regnum (current_gdbarch)->badvaddr)
+    regaddr = BROWNIE3264_BADVADDR;
+  else if (regno == brownie32_regnum (current_gdbarch)->lo)
+    regaddr = BROWNIE3264_MMLO;
+  else if (regno == brownie32_regnum (current_gdbarch)->hi)
+    regaddr = BROWNIE3264_MMHI;
+  else if (regno == brownie32_regnum (current_gdbarch)->fp_control_status)
+    regaddr = BROWNIE3264_FPC_CSR;
+  else if (regno == brownie32_regnum (current_gdbarch)->fp_implementation_revision)
+    regaddr = BROWNIE3264_FPC_EIR;
+  else
+    error (_("Unknowable register number %d."), regno);
+
+  return regaddr;
+}
+
+/*  Use a local version of this function to get the correct types for
+    regsets, until multi-arch core support is ready.  */
+
+static void
+fetch_core_registers (char *core_reg_sect, unsigned core_reg_size,
+		      int which, CORE_ADDR reg_addr)
+{
+  elf_gregset_t gregset;
+  elf_fpregset_t fpregset;
+  brownie3264_elf_gregset_t gregset64;
+  brownie3264_elf_fpregset_t fpregset64;
+
+  if (which == 0)
+    {
+      if (core_reg_size == sizeof (gregset))
+	{
+	  memcpy ((char *) &gregset, core_reg_sect, sizeof (gregset));
+	  supply_gregset (&gregset);
+	}
+      else if (core_reg_size == sizeof (gregset64))
+	{
+	  memcpy ((char *) &gregset64, core_reg_sect, sizeof (gregset64));
+	  brownie3264_supply_gregset (&gregset64);
+	}
+      else
+	{
+	  warning (_("wrong size gregset struct in core file"));
+	}
+    }
+  else if (which == 2)
+    {
+      if (core_reg_size == sizeof (fpregset))
+	{
+	  memcpy ((char *) &fpregset, core_reg_sect, sizeof (fpregset));
+	  supply_fpregset (&fpregset);
+	}
+      else if (core_reg_size == sizeof (fpregset64))
+	{
+	  memcpy ((char *) &fpregset64, core_reg_sect,
+		  sizeof (fpregset64));
+	  brownie3264_supply_fpregset (&fpregset64);
+	}
+      else
+	{
+	  warning (_("wrong size fpregset struct in core file"));
+	}
+    }
+}
+
+/* Register that we are able to handle ELF file formats using standard
+   procfs "regset" structures.  */
+
+static struct core_fns regset_core_fns =
+{
+  bfd_target_elf_flavour,		/* core_flavour */
+  default_check_format,			/* check_format */
+  default_core_sniffer,			/* core_sniffer */
+  fetch_core_registers,			/* core_read_registers */
+  NULL					/* next */
+};
+
+/* Fetch (and possibly build) an appropriate link_map_offsets
+   structure for native GNU/Linux BROWNIE32 targets using the struct
+   offsets defined in link.h (but without actual reference to that
+   file).
+
+   This makes it possible to access GNU/Linux BROWNIE32 shared libraries
+   from a GDB that was built on a different host platform (for cross
+   debugging).  */
+
+static struct link_map_offsets *
+brownie3264_linux_svr4_fetch_link_map_offsets (void)
+{
+  static struct link_map_offsets lmo;
+  static struct link_map_offsets *lmp = NULL;
+
+  if (lmp == NULL)
+    {
+      lmp = &lmo;
+
+      lmo.r_debug_size = 16;	/* The actual size is 40 bytes, but
+				   this is all we need.  */
+      lmo.r_map_offset = 8;
+      lmo.r_map_size   = 8;
+
+      lmo.link_map_size = 40;
+
+      lmo.l_addr_offset = 0;
+      lmo.l_addr_size   = 8;
+
+      lmo.l_name_offset = 8;
+      lmo.l_name_size   = 8;
+
+      lmo.l_next_offset = 24;
+      lmo.l_next_size   = 8;
+
+      lmo.l_prev_offset = 32;
+      lmo.l_prev_size   = 8;
+    }
+
+  return lmp;
+}
+
+/* Handle for obtaining pointer to the current register_addr()
+   function for a given architecture.  */
+static struct gdbarch_data *register_addr_data;
+
+CORE_ADDR
+register_addr (int regno, CORE_ADDR blockend)
+{
+  CORE_ADDR (*register_addr_ptr) (int, CORE_ADDR) =
+    gdbarch_data (current_gdbarch, register_addr_data);
+
+  gdb_assert (register_addr_ptr != 0);
+
+  return register_addr_ptr (regno, blockend);
+}
+
+static void
+set_brownie32_linux_register_addr (struct gdbarch *gdbarch,
+                              CORE_ADDR (*register_addr_ptr) (int,
+							      CORE_ADDR))
+{
+  deprecated_set_gdbarch_data (gdbarch, register_addr_data,
+			       register_addr_ptr);
+}
+
+static void *
+init_register_addr_data (struct gdbarch *gdbarch)
+{
+  return 0;
+}
+
+/* Check the code at PC for a dynamic linker lazy resolution stub.
+   Because they aren't in the .plt section, we pattern-match on the
+   code generated by GNU ld.  They look like this:
+
+   lw t9,0x8010(gp)
+   addu t7,ra
+   jalr t9,ra
+   addiu t8,zero,INDEX
+
+   (with the appropriate doubleword instructions for N64).  Also
+   return the dynamic symbol index used in the last instruction.  */
+
+static int
+brownie32_linux_in_dynsym_stub (CORE_ADDR pc, char *name)
+{
+  unsigned char buf[28], *p;
+  ULONGEST insn, insn1;
+  int n64 = (brownie32_abi (current_gdbarch) == BROWNIE32_ABI_N64);
+
+  read_memory (pc - 12, buf, 28);
+
+  if (n64)
+    {
+      /* ld t9,0x8010(gp) */
+      insn1 = 0xdf998010;
+    }
+  else
+    {
+      /* lw t9,0x8010(gp) */
+      insn1 = 0x8f998010;
+    }
+
+  p = buf + 12;
+  while (p >= buf)
+    {
+      insn = extract_unsigned_integer (p, 4);
+      if (insn == insn1)
+	break;
+      p -= 4;
+    }
+  if (p < buf)
+    return 0;
+
+  insn = extract_unsigned_integer (p + 4, 4);
+  if (n64)
+    {
+      /* daddu t7,ra */
+      if (insn != 0x03e0782d)
+	return 0;
+    }
+  else
+    {
+      /* addu t7,ra */
+      if (insn != 0x03e07821)
+	return 0;
+    }
+
+  insn = extract_unsigned_integer (p + 8, 4);
+  /* jalr t9,ra */
+  if (insn != 0x0320f809)
+    return 0;
+
+  insn = extract_unsigned_integer (p + 12, 4);
+  if (n64)
+    {
+      /* daddiu t8,zero,0 */
+      if ((insn & 0xffff0000) != 0x64180000)
+	return 0;
+    }
+  else
+    {
+      /* addiu t8,zero,0 */
+      if ((insn & 0xffff0000) != 0x24180000)
+	return 0;
+    }
+
+  return (insn & 0xffff);
+}
+
+/* Return non-zero iff PC belongs to the dynamic linker resolution
+   code or to a stub.  */
+
+int
+brownie32_linux_in_dynsym_resolve_code (CORE_ADDR pc)
+{
+  /* Check whether PC is in the dynamic linker.  This also checks
+     whether it is in the .plt section, which BROWNIE32 does not use.  */
+  if (in_solib_dynsym_resolve_code (pc))
+    return 1;
+
+  /* Pattern match for the stub.  It would be nice if there were a
+     more efficient way to avoid this check.  */
+  if (brownie32_linux_in_dynsym_stub (pc, NULL))
+    return 1;
+
+  return 0;
+}
+
+/* See the comments for SKIP_SOLIB_RESOLVER at the top of infrun.c,
+   and glibc_skip_solib_resolver in glibc-tdep.c.  The normal glibc
+   implementation of this triggers at "fixup" from the same objfile as
+   "_dl_runtime_resolve"; BROWNIE32 GNU/Linux can trigger at
+   "__dl_runtime_resolve" directly.  An unresolved PLT entry will
+   point to _dl_runtime_resolve, which will first call
+   __dl_runtime_resolve, and then pass control to the resolved
+   function.  */
+
+static CORE_ADDR
+brownie32_linux_skip_resolver (struct gdbarch *gdbarch, CORE_ADDR pc)
+{
+  struct minimal_symbol *resolver;
+
+  resolver = lookup_minimal_symbol ("__dl_runtime_resolve", NULL, NULL);
+
+  if (resolver && SYMBOL_VALUE_ADDRESS (resolver) == pc)
+    return frame_pc_unwind (get_current_frame ());
+
+  return 0;
+}
+
+/* Signal trampoline support.  There are four supported layouts for a
+   signal frame: o32 sigframe, o32 rt_sigframe, n32 rt_sigframe, and
+   n64 rt_sigframe.  We handle them all independently; not the most
+   efficient way, but simplest.  First, declare all the unwinders.  */
+
+static void brownie32_linux_o32_sigframe_init (const struct tramp_frame *self,
+					  struct frame_info *next_frame,
+					  struct trad_frame_cache *this_cache,
+					  CORE_ADDR func);
+
+static void brownie32_linux_n32n64_sigframe_init (const struct tramp_frame *self,
+					     struct frame_info *next_frame,
+					     struct trad_frame_cache *this_cache,
+					     CORE_ADDR func);
+
+#define BROWNIE32_NR_LINUX 4000
+#define BROWNIE32_NR_N64_LINUX 5000
+#define BROWNIE32_NR_N32_LINUX 6000
+
+#define BROWNIE32_NR_sigreturn BROWNIE32_NR_LINUX + 119
+#define BROWNIE32_NR_rt_sigreturn BROWNIE32_NR_LINUX + 193
+#define BROWNIE32_NR_N64_rt_sigreturn BROWNIE32_NR_N64_LINUX + 211
+#define BROWNIE32_NR_N32_rt_sigreturn BROWNIE32_NR_N32_LINUX + 211
+
+#define BROWNIE32_INST_LI_V0_SIGRETURN 0x24020000 + BROWNIE32_NR_sigreturn
+#define BROWNIE32_INST_LI_V0_RT_SIGRETURN 0x24020000 + BROWNIE32_NR_rt_sigreturn
+#define BROWNIE32_INST_LI_V0_N64_RT_SIGRETURN 0x24020000 + BROWNIE32_NR_N64_rt_sigreturn
+#define BROWNIE32_INST_LI_V0_N32_RT_SIGRETURN 0x24020000 + BROWNIE32_NR_N32_rt_sigreturn
+#define BROWNIE32_INST_SYSCALL 0x0000000c
+
+static const struct tramp_frame brownie32_linux_o32_sigframe = {
+  SIGTRAMP_FRAME,
+  4,
+  {
+    { BROWNIE32_INST_LI_V0_SIGRETURN, -1 },
+    { BROWNIE32_INST_SYSCALL, -1 },
+    { TRAMP_SENTINEL_INSN, -1 }
+  },
+  brownie32_linux_o32_sigframe_init
+};
+
+static const struct tramp_frame brownie32_linux_o32_rt_sigframe = {
+  SIGTRAMP_FRAME,
+  4,
+  {
+    { BROWNIE32_INST_LI_V0_RT_SIGRETURN, -1 },
+    { BROWNIE32_INST_SYSCALL, -1 },
+    { TRAMP_SENTINEL_INSN, -1 } },
+  brownie32_linux_o32_sigframe_init
+};
+
+static const struct tramp_frame brownie32_linux_n32_rt_sigframe = {
+  SIGTRAMP_FRAME,
+  4,
+  {
+    { BROWNIE32_INST_LI_V0_N32_RT_SIGRETURN, -1 },
+    { BROWNIE32_INST_SYSCALL, -1 },
+    { TRAMP_SENTINEL_INSN, -1 }
+  },
+  brownie32_linux_n32n64_sigframe_init
+};
+
+static const struct tramp_frame brownie32_linux_n64_rt_sigframe = {
+  SIGTRAMP_FRAME,
+  4,
+  { BROWNIE32_INST_LI_V0_N64_RT_SIGRETURN,
+    BROWNIE32_INST_SYSCALL,
+    TRAMP_SENTINEL_INSN },
+  brownie32_linux_n32n64_sigframe_init
+};
+
+/* *INDENT-OFF* */
+/* The unwinder for o32 signal frames.  The legacy structures look
+   like this:
+
+   struct sigframe {
+     u32 sf_ass[4];            [argument save space for o32]
+     u32 sf_code[2];           [signal trampoline]
+     struct sigcontext sf_sc;
+     sigset_t sf_mask;
+   };
+
+   struct sigcontext {
+        unsigned int       sc_regmask;          [Unused]
+        unsigned int       sc_status;
+        unsigned long long sc_pc;
+        unsigned long long sc_regs[32];
+        unsigned long long sc_fpregs[32];
+        unsigned int       sc_ownedfp;
+        unsigned int       sc_fpc_csr;
+        unsigned int       sc_fpc_eir;          [Unused]
+        unsigned int       sc_used_math;
+        unsigned int       sc_ssflags;          [Unused]
+	[Alignment hole of four bytes]
+        unsigned long long sc_mdhi;
+        unsigned long long sc_mdlo;
+
+        unsigned int       sc_cause;            [Unused]
+        unsigned int       sc_badvaddr;         [Unused]
+
+        unsigned long      sc_sigset[4];        [kernel's sigset_t]
+   };
+
+   The RT signal frames look like this:
+
+   struct rt_sigframe {
+     u32 rs_ass[4];            [argument save space for o32]
+     u32 rs_code[2]            [signal trampoline]
+     struct siginfo rs_info;
+     struct ucontext rs_uc;
+   };
+
+   struct ucontext {
+     unsigned long     uc_flags;
+     struct ucontext  *uc_link;
+     stack_t           uc_stack;
+     [Alignment hole of four bytes]
+     struct sigcontext uc_mcontext;
+     sigset_t          uc_sigmask;
+   };  */
+/* *INDENT-ON* */
+
+#define SIGFRAME_CODE_OFFSET         (4 * 4)
+#define SIGFRAME_SIGCONTEXT_OFFSET   (6 * 4)
+
+#define RTSIGFRAME_SIGINFO_SIZE      128
+#define STACK_T_SIZE                 (3 * 4)
+#define UCONTEXT_SIGCONTEXT_OFFSET   (2 * 4 + STACK_T_SIZE + 4)
+#define RTSIGFRAME_SIGCONTEXT_OFFSET (SIGFRAME_SIGCONTEXT_OFFSET \
+				      + RTSIGFRAME_SIGINFO_SIZE \
+				      + UCONTEXT_SIGCONTEXT_OFFSET)
+
+#define SIGCONTEXT_PC       (1 * 8)
+#define SIGCONTEXT_REGS     (2 * 8)
+#define SIGCONTEXT_FPREGS   (34 * 8)
+#define SIGCONTEXT_FPCSR    (66 * 8 + 4)
+#define SIGCONTEXT_HI       (69 * 8)
+#define SIGCONTEXT_LO       (70 * 8)
+#define SIGCONTEXT_CAUSE    (71 * 8 + 0)
+#define SIGCONTEXT_BADVADDR (71 * 8 + 4)
+
+#define SIGCONTEXT_REG_SIZE 8
+
+static void
+brownie32_linux_o32_sigframe_init (const struct tramp_frame *self,
+			      struct frame_info *next_frame,
+			      struct trad_frame_cache *this_cache,
+			      CORE_ADDR func)
+{
+  int ireg, reg_position;
+  CORE_ADDR sigcontext_base = func - SIGFRAME_CODE_OFFSET;
+  const struct brownie32_regnum *regs = brownie32_regnum (current_gdbarch);
+  CORE_ADDR regs_base;
+
+  if (self == &brownie32_linux_o32_sigframe)
+    sigcontext_base += SIGFRAME_SIGCONTEXT_OFFSET;
+  else
+    sigcontext_base += RTSIGFRAME_SIGCONTEXT_OFFSET;
+
+  /* I'm not proud of this hack.  Eventually we will have the
+     infrastructure to indicate the size of saved registers on a
+     per-frame basis, but right now we don't; the kernel saves eight
+     bytes but we only want four.  Use regs_base to access any
+     64-bit fields.  */
+  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
+    regs_base = sigcontext_base + 4;
+  else
+    regs_base = sigcontext_base;
+
+#if 0
+  trad_frame_set_reg_addr (this_cache, ORIG_ZERO_REGNUM + NUM_REGS,
+			   regs_base + SIGCONTEXT_REGS);
+#endif
+
+  for (ireg = 1; ireg < 32; ireg++)
+    trad_frame_set_reg_addr (this_cache,
+			     ireg + BROWNIE32_ZERO_REGNUM + NUM_REGS,
+			     regs_base + SIGCONTEXT_REGS
+			     + ireg * SIGCONTEXT_REG_SIZE);
+
+  /* The way that floating point registers are saved, unfortunately,
+     depends on the architecture the kernel is built for.  For the r3000 and
+     tx39, four bytes of each register are at the beginning of each of the
+     32 eight byte slots.  For everything else, the registers are saved
+     using double precision; only the even-numbered slots are initialized,
+     and the high bits are the odd-numbered register.  Assume the latter
+     layout, since we can't tell, and it's much more common.  Which bits are
+     the "high" bits depends on endianness.  */
+  for (ireg = 0; ireg < 32; ireg++)
+    if ((TARGET_BYTE_ORDER == BFD_ENDIAN_BIG) != (ireg & 1))
+      trad_frame_set_reg_addr (this_cache, ireg + regs->fp0 + NUM_REGS,
+			       sigcontext_base + SIGCONTEXT_FPREGS + 4
+			       + (ireg & ~1) * SIGCONTEXT_REG_SIZE);
+    else
+      trad_frame_set_reg_addr (this_cache, ireg + regs->fp0 + NUM_REGS,
+			       sigcontext_base + SIGCONTEXT_FPREGS
+			       + (ireg & ~1) * SIGCONTEXT_REG_SIZE);
+
+  trad_frame_set_reg_addr (this_cache, regs->pc + NUM_REGS,
+			   regs_base + SIGCONTEXT_PC);
+
+  trad_frame_set_reg_addr (this_cache,
+			   regs->fp_control_status + NUM_REGS,
+			   sigcontext_base + SIGCONTEXT_FPCSR);
+  trad_frame_set_reg_addr (this_cache, regs->hi + NUM_REGS,
+			   regs_base + SIGCONTEXT_HI);
+  trad_frame_set_reg_addr (this_cache, regs->lo + NUM_REGS,
+			   regs_base + SIGCONTEXT_LO);
+  trad_frame_set_reg_addr (this_cache, regs->cause + NUM_REGS,
+			   sigcontext_base + SIGCONTEXT_CAUSE);
+  trad_frame_set_reg_addr (this_cache, regs->badvaddr + NUM_REGS,
+			   sigcontext_base + SIGCONTEXT_BADVADDR);
+
+  /* Choice of the bottom of the sigframe is somewhat arbitrary.  */
+  trad_frame_set_id (this_cache,
+		     frame_id_build (func - SIGFRAME_CODE_OFFSET,
+				     func));
+}
+
+/* *INDENT-OFF* */
+/* For N32/N64 things look different.  There is no non-rt signal frame.
+
+  struct rt_sigframe_n32 {
+    u32 rs_ass[4];                  [ argument save space for o32 ]
+    u32 rs_code[2];                 [ signal trampoline ]
+    struct siginfo rs_info;
+    struct ucontextn32 rs_uc;
+  };
+
+  struct ucontextn32 {
+    u32                 uc_flags;
+    s32                 uc_link;
+    stack32_t           uc_stack;
+    struct sigcontext   uc_mcontext;
+    sigset_t            uc_sigmask;   [ mask last for extensibility ]
+  };
+
+  struct rt_sigframe_n32 {
+    u32 rs_ass[4];                  [ argument save space for o32 ]
+    u32 rs_code[2];                 [ signal trampoline ]
+    struct siginfo rs_info;
+    struct ucontext rs_uc;
+  };
+
+  struct ucontext {
+    unsigned long     uc_flags;
+    struct ucontext  *uc_link;
+    stack_t           uc_stack;
+    struct sigcontext uc_mcontext;
+    sigset_t          uc_sigmask;   [ mask last for extensibility ]
+  };
+
+  And the sigcontext is different (this is for both n32 and n64):
+
+  struct sigcontext {
+    unsigned long long sc_regs[32];
+    unsigned long long sc_fpregs[32];
+    unsigned long long sc_mdhi;
+    unsigned long long sc_mdlo;
+    unsigned long long sc_pc;
+    unsigned int       sc_status;
+    unsigned int       sc_fpc_csr;
+    unsigned int       sc_fpc_eir;
+    unsigned int       sc_used_math;
+    unsigned int       sc_cause;
+    unsigned int       sc_badvaddr;
+  };  */
+/* *INDENT-ON* */
+
+#define N32_STACK_T_SIZE		STACK_T_SIZE
+#define N64_STACK_T_SIZE		(2 * 8 + 4)
+#define N32_UCONTEXT_SIGCONTEXT_OFFSET  (2 * 4 + N32_STACK_T_SIZE + 4)
+#define N64_UCONTEXT_SIGCONTEXT_OFFSET  (2 * 8 + N64_STACK_T_SIZE + 4)
+#define N32_SIGFRAME_SIGCONTEXT_OFFSET	(SIGFRAME_SIGCONTEXT_OFFSET \
+					 + RTSIGFRAME_SIGINFO_SIZE \
+					 + N32_UCONTEXT_SIGCONTEXT_OFFSET)
+#define N64_SIGFRAME_SIGCONTEXT_OFFSET	(SIGFRAME_SIGCONTEXT_OFFSET \
+					 + RTSIGFRAME_SIGINFO_SIZE \
+					 + N64_UCONTEXT_SIGCONTEXT_OFFSET)
+
+#define N64_SIGCONTEXT_REGS     (0 * 8)
+#define N64_SIGCONTEXT_FPREGS   (32 * 8)
+#define N64_SIGCONTEXT_HI       (64 * 8)
+#define N64_SIGCONTEXT_LO       (65 * 8)
+#define N64_SIGCONTEXT_PC       (66 * 8)
+#define N64_SIGCONTEXT_FPCSR    (67 * 8 + 1 * 4)
+#define N64_SIGCONTEXT_FIR      (67 * 8 + 2 * 4)
+#define N64_SIGCONTEXT_CAUSE    (67 * 8 + 4 * 4)
+#define N64_SIGCONTEXT_BADVADDR (67 * 8 + 5 * 4)
+
+#define N64_SIGCONTEXT_REG_SIZE 8
+
+static void
+brownie32_linux_n32n64_sigframe_init (const struct tramp_frame *self,
+				 struct frame_info *next_frame,
+				 struct trad_frame_cache *this_cache,
+				 CORE_ADDR func)
+{
+  int ireg, reg_position;
+  CORE_ADDR sigcontext_base = func - SIGFRAME_CODE_OFFSET;
+  const struct brownie32_regnum *regs = brownie32_regnum (current_gdbarch);
+
+  if (self == &brownie32_linux_n32_rt_sigframe)
+    sigcontext_base += N32_SIGFRAME_SIGCONTEXT_OFFSET;
+  else
+    sigcontext_base += N64_SIGFRAME_SIGCONTEXT_OFFSET;
+
+#if 0
+  trad_frame_set_reg_addr (this_cache, ORIG_ZERO_REGNUM + NUM_REGS,
+			   sigcontext_base + N64_SIGCONTEXT_REGS);
+#endif
+
+  for (ireg = 1; ireg < 32; ireg++)
+    trad_frame_set_reg_addr (this_cache,
+			     ireg + BROWNIE32_ZERO_REGNUM + NUM_REGS,
+			     sigcontext_base + N64_SIGCONTEXT_REGS
+			     + ireg * N64_SIGCONTEXT_REG_SIZE);
+
+  for (ireg = 0; ireg < 32; ireg++)
+    trad_frame_set_reg_addr (this_cache, ireg + regs->fp0 + NUM_REGS,
+			     sigcontext_base + N64_SIGCONTEXT_FPREGS
+			     + ireg * N64_SIGCONTEXT_REG_SIZE);
+
+  trad_frame_set_reg_addr (this_cache, regs->pc + NUM_REGS,
+			   sigcontext_base + N64_SIGCONTEXT_PC);
+
+  trad_frame_set_reg_addr (this_cache,
+			   regs->fp_control_status + NUM_REGS,
+			   sigcontext_base + N64_SIGCONTEXT_FPCSR);
+  trad_frame_set_reg_addr (this_cache, regs->hi + NUM_REGS,
+			   sigcontext_base + N64_SIGCONTEXT_HI);
+  trad_frame_set_reg_addr (this_cache, regs->lo + NUM_REGS,
+			   sigcontext_base + N64_SIGCONTEXT_LO);
+  trad_frame_set_reg_addr (this_cache, regs->cause + NUM_REGS,
+			   sigcontext_base + N64_SIGCONTEXT_CAUSE);
+  trad_frame_set_reg_addr (this_cache, regs->badvaddr + NUM_REGS,
+			   sigcontext_base + N64_SIGCONTEXT_BADVADDR);
+
+  /* Choice of the bottom of the sigframe is somewhat arbitrary.  */
+  trad_frame_set_id (this_cache,
+		     frame_id_build (func - SIGFRAME_CODE_OFFSET,
+				     func));
+}
+
+/* Initialize one of the GNU/Linux OS ABIs.  */
+
+static void
+brownie32_linux_init_abi (struct gdbarch_info info,
+		     struct gdbarch *gdbarch)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  enum brownie32_abi abi = brownie32_abi (gdbarch);
+
+  switch (abi)
+    {
+      case BROWNIE32_ABI_O32:
+	set_gdbarch_get_longjmp_target (gdbarch,
+	                                brownie32_linux_get_longjmp_target);
+	set_solib_svr4_fetch_link_map_offsets
+	  (gdbarch, brownie32_linux_svr4_fetch_link_map_offsets);
+	set_brownie32_linux_register_addr (gdbarch, brownie32_linux_register_addr);
+	tramp_frame_prepend_unwinder (gdbarch, &brownie32_linux_o32_sigframe);
+	tramp_frame_prepend_unwinder (gdbarch, &brownie32_linux_o32_rt_sigframe);
+	break;
+      case BROWNIE32_ABI_N32:
+	set_gdbarch_get_longjmp_target (gdbarch,
+	                                brownie32_linux_get_longjmp_target);
+	set_solib_svr4_fetch_link_map_offsets
+	  (gdbarch, brownie32_linux_svr4_fetch_link_map_offsets);
+	set_brownie32_linux_register_addr (gdbarch, brownie3264_linux_register_addr);
+	tramp_frame_prepend_unwinder (gdbarch, &brownie32_linux_n32_rt_sigframe);
+	break;
+      case BROWNIE32_ABI_N64:
+	set_gdbarch_get_longjmp_target (gdbarch,
+	                                brownie3264_linux_get_longjmp_target);
+	set_solib_svr4_fetch_link_map_offsets
+	  (gdbarch, brownie3264_linux_svr4_fetch_link_map_offsets);
+	set_brownie32_linux_register_addr (gdbarch, brownie3264_linux_register_addr);
+	tramp_frame_prepend_unwinder (gdbarch, &brownie32_linux_n64_rt_sigframe);
+	break;
+      default:
+	internal_error (__FILE__, __LINE__, _("can't handle ABI"));
+	break;
+    }
+
+  set_gdbarch_skip_solib_resolver (gdbarch, brownie32_linux_skip_resolver);
+
+  set_gdbarch_software_single_step (gdbarch, brownie32_software_single_step);
+
+  /* Enable TLS support.  */
+  set_gdbarch_fetch_tls_load_module_address (gdbarch,
+                                             svr4_fetch_objfile_link_map);
+}
+
+void
+_initialize_brownie32_linux_tdep (void)
+{
+  const struct bfd_arch_info *arch_info;
+
+  register_addr_data =
+    gdbarch_data_register_post_init (init_register_addr_data);
+
+  for (arch_info = bfd_lookup_arch (bfd_arch_brownie32, 0);
+       arch_info != NULL;
+       arch_info = arch_info->next)
+    {
+      gdbarch_register_osabi (bfd_arch_brownie32, arch_info->mach,
+			      GDB_OSABI_LINUX,
+			      brownie32_linux_init_abi);
+    }
+
+  deprecated_add_core_fns (&regset_core_fns);
+}
Index: gdb/brownie32-mdebug-tdep.c
===================================================================
RCS file: gdb/brownie32-mdebug-tdep.c
diff -N gdb/brownie32-mdebug-tdep.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/brownie32-mdebug-tdep.c	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,491 @@
+/* Target-dependent code for the MDEBUG BROWNIE32 architecture, for GDB,
+   the GNU Debugger.
+
+   Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
+   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
+   Foundation, Inc.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+#if 0
+#include "defs.h"
+#include "frame.h"
+#include "brownie32-tdep.h"
+#include "trad-frame.h"
+#include "block.h"
+#include "symtab.h"
+#include "objfiles.h"
+#include "elf/brownie32.h"
+#include "elf-bfd.h"
+#include "gdb_assert.h"
+#include "frame-unwind.h"
+#include "frame-base.h"
+#include "brownie32-mdebug-tdep.h"
+#include "mdebugread.h"
+
+#define PROC_LOW_ADDR(proc) ((proc)->pdr.adr)	/* least address */
+#define PROC_FRAME_OFFSET(proc) ((proc)->pdr.frameoffset)
+#define PROC_FRAME_REG(proc) ((proc)->pdr.framereg)
+#define PROC_REG_MASK(proc) ((proc)->pdr.regmask)
+#define PROC_FREG_MASK(proc) ((proc)->pdr.fregmask)
+#define PROC_REG_OFFSET(proc) ((proc)->pdr.regoffset)
+#define PROC_FREG_OFFSET(proc) ((proc)->pdr.fregoffset)
+#define PROC_PC_REG(proc) ((proc)->pdr.pcreg)
+/* FIXME drow/2002-06-10: If a pointer on the host is bigger than a long,
+   this will corrupt pdr.iline.  Fortunately we don't use it.  */
+#define PROC_SYMBOL(proc) (*(struct symbol**)&(proc)->pdr.isym)
+#define _PROC_MAGIC_ 0x0F0F0F0F
+
+struct brownie32_objfile_private
+{
+  bfd_size_type size;
+  char *contents;
+};
+
+/* Global used to communicate between non_heuristic_proc_desc and
+   compare_pdr_entries within qsort ().  */
+static bfd *the_bfd;
+
+static int
+compare_pdr_entries (const void *a, const void *b)
+{
+  CORE_ADDR lhs = bfd_get_32 (the_bfd, (bfd_byte *) a);
+  CORE_ADDR rhs = bfd_get_32 (the_bfd, (bfd_byte *) b);
+
+  if (lhs < rhs)
+    return -1;
+  else if (lhs == rhs)
+    return 0;
+  else
+    return 1;
+}
+
+static const struct objfile_data *brownie32_pdr_data;
+
+static struct mdebug_extra_func_info *
+non_heuristic_proc_desc (CORE_ADDR pc, CORE_ADDR *addrptr)
+{
+  CORE_ADDR startaddr;
+  struct mdebug_extra_func_info *proc_desc;
+  struct block *b = block_for_pc (pc);
+  struct symbol *sym;
+  struct obj_section *sec;
+  struct brownie32_objfile_private *priv;
+
+  find_pc_partial_function (pc, NULL, &startaddr, NULL);
+  if (addrptr)
+    *addrptr = startaddr;
+
+  priv = NULL;
+
+  sec = find_pc_section (pc);
+  if (sec != NULL)
+    {
+      priv = (struct brownie32_objfile_private *) objfile_data (sec->objfile, brownie32_pdr_data);
+
+      /* Search the ".pdr" section generated by GAS.  This includes most of
+         the information normally found in ECOFF PDRs.  */
+
+      the_bfd = sec->objfile->obfd;
+      if (priv == NULL
+	  && (the_bfd->format == bfd_object
+	      && bfd_get_flavour (the_bfd) == bfd_target_elf_flavour
+	      && elf_elfheader (the_bfd)->e_ident[EI_CLASS] == ELFCLASS64))
+	{
+	  /* Right now GAS only outputs the address as a four-byte sequence.
+	     This means that we should not bother with this method on 64-bit
+	     targets (until that is fixed).  */
+
+	  priv = obstack_alloc (&sec->objfile->objfile_obstack,
+				sizeof (struct brownie32_objfile_private));
+	  priv->size = 0;
+	  set_objfile_data (sec->objfile, brownie32_pdr_data, priv);
+	}
+      else if (priv == NULL)
+	{
+	  asection *bfdsec;
+
+	  priv = obstack_alloc (&sec->objfile->objfile_obstack,
+				sizeof (struct brownie32_objfile_private));
+
+	  bfdsec = bfd_get_section_by_name (sec->objfile->obfd, ".pdr");
+	  if (bfdsec != NULL)
+	    {
+	      priv->size = bfd_section_size (sec->objfile->obfd, bfdsec);
+	      priv->contents = obstack_alloc (&sec->objfile->objfile_obstack,
+					      priv->size);
+	      bfd_get_section_contents (sec->objfile->obfd, bfdsec,
+					priv->contents, 0, priv->size);
+
+	      /* In general, the .pdr section is sorted.  However, in the
+	         presence of multiple code sections (and other corner cases)
+	         it can become unsorted.  Sort it so that we can use a faster
+	         binary search.  */
+	      qsort (priv->contents, priv->size / 32, 32,
+		     compare_pdr_entries);
+	    }
+	  else
+	    priv->size = 0;
+
+	  set_objfile_data (sec->objfile, brownie32_pdr_data, priv);
+	}
+      the_bfd = NULL;
+
+      if (priv->size != 0)
+	{
+	  int low, mid, high;
+	  char *ptr;
+	  CORE_ADDR pdr_pc;
+
+	  low = 0;
+	  high = priv->size / 32;
+
+	  /* We've found a .pdr section describing this objfile.  We want to
+	     find the entry which describes this code address.  The .pdr
+	     information is not very descriptive; we have only a function
+	     start address.  We have to look for the closest entry, because
+	     the local symbol at the beginning of this function may have
+	     been stripped - so if we ask the symbol table for the start
+	     address we may get a preceding global function.  */
+
+	  /* First, find the last .pdr entry starting at or before PC.  */
+	  do
+	    {
+	      mid = (low + high) / 2;
+
+	      ptr = priv->contents + mid * 32;
+	      pdr_pc = bfd_get_signed_32 (sec->objfile->obfd, ptr);
+	      pdr_pc += ANOFFSET (sec->objfile->section_offsets,
+				  SECT_OFF_TEXT (sec->objfile));
+
+	      if (pdr_pc > pc)
+		high = mid;
+	      else
+		low = mid + 1;
+	    }
+	  while (low != high);
+
+	  /* Both low and high point one past the PDR of interest.  If
+	     both are zero, that means this PC is before any region
+	     covered by a PDR, i.e. pdr_pc for the first PDR entry is
+	     greater than PC.  */
+	  if (low > 0)
+	    {
+	      ptr = priv->contents + (low - 1) * 32;
+	      pdr_pc = bfd_get_signed_32 (sec->objfile->obfd, ptr);
+	      pdr_pc += ANOFFSET (sec->objfile->section_offsets,
+				  SECT_OFF_TEXT (sec->objfile));
+	    }
+
+	  /* We don't have a range, so we have no way to know for sure
+	     whether we're in the correct PDR or a PDR for a preceding
+	     function and the current function was a stripped local
+	     symbol.  But if the PDR's PC is at least as great as the
+	     best guess from the symbol table, assume that it does cover
+	     the right area; if a .pdr section is present at all then
+	     nearly every function will have an entry.  The biggest exception
+	     will be the dynamic linker stubs; conveniently these are
+	     placed before .text instead of after.  */
+
+	  if (pc >= pdr_pc && pdr_pc >= startaddr)
+	    {
+	      struct symbol *sym = find_pc_function (pc);
+
+	      if (addrptr)
+		*addrptr = pdr_pc;
+
+	      /* Fill in what we need of the proc_desc.  */
+	      proc_desc = (struct mdebug_extra_func_info *)
+		obstack_alloc (&sec->objfile->objfile_obstack,
+			       sizeof (struct mdebug_extra_func_info));
+	      PROC_LOW_ADDR (proc_desc) = pdr_pc;
+
+	      PROC_FRAME_OFFSET (proc_desc)
+		= bfd_get_32 (sec->objfile->obfd, ptr + 20);
+	      PROC_FRAME_REG (proc_desc) = bfd_get_32 (sec->objfile->obfd,
+						       ptr + 24);
+	      PROC_REG_MASK (proc_desc) = bfd_get_32 (sec->objfile->obfd,
+						      ptr + 4);
+	      PROC_FREG_MASK (proc_desc) = bfd_get_32 (sec->objfile->obfd,
+						       ptr + 12);
+	      PROC_REG_OFFSET (proc_desc) = bfd_get_32 (sec->objfile->obfd,
+							ptr + 8);
+	      PROC_FREG_OFFSET (proc_desc)
+		= bfd_get_32 (sec->objfile->obfd, ptr + 16);
+	      PROC_PC_REG (proc_desc) = bfd_get_32 (sec->objfile->obfd,
+						    ptr + 28);
+	      proc_desc->pdr.isym = (long) sym;
+
+	      return proc_desc;
+	    }
+	}
+    }
+
+  if (b == NULL)
+    return NULL;
+
+  if (startaddr > BLOCK_START (b))
+    {
+      /* This is the "pathological" case referred to in a comment in
+         print_frame_info.  It might be better to move this check into
+         symbol reading.  */
+      return NULL;
+    }
+
+  sym = lookup_symbol (MDEBUG_EFI_SYMBOL_NAME, b, LABEL_DOMAIN, 0, NULL);
+
+  /* If we never found a PDR for this function in symbol reading, then
+     examine prologues to find the information.  */
+  if (sym)
+    {
+      proc_desc = (struct mdebug_extra_func_info *) SYMBOL_VALUE (sym);
+      if (PROC_FRAME_REG (proc_desc) == -1)
+	return NULL;
+      else
+	return proc_desc;
+    }
+  else
+    return NULL;
+}
+
+struct brownie32_frame_cache
+{
+  CORE_ADDR base;
+  struct trad_frame_saved_reg *saved_regs;
+};
+
+static struct brownie32_frame_cache *
+brownie32_mdebug_frame_cache (struct frame_info *next_frame, void **this_cache)
+{
+  CORE_ADDR startaddr = 0;
+  struct mdebug_extra_func_info *proc_desc;
+  struct brownie32_frame_cache *cache;
+  struct gdbarch *gdbarch = get_frame_arch (next_frame);
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  /* r0 bit means kernel trap */
+  int kernel_trap;
+  /* What registers have been saved?  Bitmasks.  */
+  unsigned long gen_mask, float_mask;
+
+  if ((*this_cache) != NULL)
+    return (*this_cache);
+  cache = FRAME_OBSTACK_ZALLOC (struct brownie32_frame_cache);
+  (*this_cache) = cache;
+  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);
+
+  /* Get the mdebug proc descriptor.  */
+  proc_desc = non_heuristic_proc_desc (frame_pc_unwind (next_frame),
+				       &startaddr);
+  /* Must be true.  This is only called when the sniffer detected a
+     proc descriptor.  */
+  gdb_assert (proc_desc != NULL);
+
+  /* Extract the frame's base.  */
+  cache->base = (frame_unwind_register_signed (next_frame, NUM_REGS + PROC_FRAME_REG (proc_desc))
+		 + PROC_FRAME_OFFSET (proc_desc));
+
+  kernel_trap = PROC_REG_MASK (proc_desc) & 1;
+  gen_mask = kernel_trap ? 0xFFFFFFFF : PROC_REG_MASK (proc_desc);
+  float_mask = kernel_trap ? 0xFFFFFFFF : PROC_FREG_MASK (proc_desc);
+  
+  /* Must be true.  The in_prologue case is left for the heuristic
+     unwinder.  This is always used on kernel traps.  */
+  gdb_assert (!in_prologue (frame_pc_unwind (next_frame), PROC_LOW_ADDR (proc_desc))
+	      || kernel_trap);
+
+  /* Fill in the offsets for the registers which gen_mask says were
+     saved.  */
+  {
+    CORE_ADDR reg_position = (cache->base + PROC_REG_OFFSET (proc_desc));
+    int ireg;
+
+    for (ireg = BROWNIE32_NUMREGS - 1; gen_mask; --ireg, gen_mask <<= 1)
+      if (gen_mask & 0x80000000)
+	{
+	  cache->saved_regs[NUM_REGS + ireg].addr = reg_position;
+	  reg_position -= brownie32_abi_regsize (gdbarch);
+	}
+  }
+
+  /* Fill in the offsets for the registers which float_mask says were
+     saved.  */
+  {
+    CORE_ADDR reg_position = (cache->base
+			      + PROC_FREG_OFFSET (proc_desc));
+    int ireg;
+    /* Fill in the offsets for the float registers which float_mask
+       says were saved.  */
+    for (ireg = BROWNIE32_NUMREGS - 1; float_mask; --ireg, float_mask <<= 1)
+      if (float_mask & 0x80000000)
+	{
+	  if (brownie32_abi_regsize (gdbarch) == 4
+	      && TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
+	    {
+	      /* On a big endian 32 bit ABI, floating point registers
+	         are paired to form doubles such that the most
+	         significant part is in $f[N+1] and the least
+	         significant in $f[N] vis: $f[N+1] ||| $f[N].  The
+	         registers are also spilled as a pair and stored as a
+	         double.
+
+	         When little-endian the least significant part is
+	         stored first leading to the memory order $f[N] and
+	         then $f[N+1].
+
+	         Unfortunately, when big-endian the most significant
+	         part of the double is stored first, and the least
+	         significant is stored second.  This leads to the
+	         registers being ordered in memory as firt $f[N+1] and
+	         then $f[N].
+
+	         For the big-endian case make certain that the
+	         addresses point at the correct (swapped) locations
+	         $f[N] and $f[N+1] pair (keep in mind that
+	         reg_position is decremented each time through the
+	         loop).  */
+	      if ((ireg & 1))
+		cache->saved_regs[NUM_REGS + brownie32_regnum (current_gdbarch)->fp0 + ireg]
+		  .addr = reg_position - brownie32_abi_regsize (gdbarch);
+	      else
+		cache->saved_regs[NUM_REGS + brownie32_regnum (current_gdbarch)->fp0 + ireg]
+		  .addr = reg_position + brownie32_abi_regsize (gdbarch);
+	    }
+	  else
+	    cache->saved_regs[NUM_REGS + brownie32_regnum (current_gdbarch)->fp0 + ireg]
+	      .addr = reg_position;
+	  reg_position -= brownie32_abi_regsize (gdbarch);
+	}
+
+    cache->saved_regs[NUM_REGS + brownie32_regnum (current_gdbarch)->pc]
+      = cache->saved_regs[NUM_REGS + BROWNIE32_RA_REGNUM];
+  }
+
+  /* SP_REGNUM, contains the value and not the address.  */
+  trad_frame_set_value (cache->saved_regs, NUM_REGS + BROWNIE32_SP_REGNUM, cache->base);
+
+  return (*this_cache);
+}
+
+static void
+brownie32_mdebug_frame_this_id (struct frame_info *next_frame, void **this_cache,
+			   struct frame_id *this_id)
+{
+  struct brownie32_frame_cache *info = brownie32_mdebug_frame_cache (next_frame,
+							   this_cache);
+  (*this_id) = frame_id_build (info->base, frame_func_unwind (next_frame));
+}
+
+static void
+brownie32_mdebug_frame_prev_register (struct frame_info *next_frame,
+				 void **this_cache,
+				 int regnum, int *optimizedp,
+				 enum lval_type *lvalp, CORE_ADDR *addrp,
+				 int *realnump, void *valuep)
+{
+  struct brownie32_frame_cache *info = brownie32_mdebug_frame_cache (next_frame,
+							   this_cache);
+  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
+				optimizedp, lvalp, addrp, realnump, valuep);
+}
+
+static const struct frame_unwind brownie32_mdebug_frame_unwind =
+{
+  NORMAL_FRAME,
+  brownie32_mdebug_frame_this_id,
+  brownie32_mdebug_frame_prev_register
+};
+
+static const struct frame_unwind *
+brownie32_mdebug_frame_sniffer (struct frame_info *next_frame)
+{
+  CORE_ADDR pc = frame_pc_unwind (next_frame);
+  CORE_ADDR startaddr = 0;
+  struct mdebug_extra_func_info *proc_desc;
+  int kernel_trap;
+#if 0 // C.Katano
+  /* Don't use this on BROWNIE3216.  */
+  if (brownie32_pc_is_brownie3216 (pc))
+    return NULL;
+#endif
+  /* Only use the mdebug frame unwinder on mdebug frames where all the
+     registers have been saved.  Leave hard cases such as no mdebug or
+     in prologue for the heuristic unwinders.  */
+
+  proc_desc = non_heuristic_proc_desc (pc, &startaddr);
+  if (proc_desc == NULL)
+    return NULL;
+
+  /* Not sure exactly what kernel_trap means, but if it means the
+     kernel saves the registers without a prologue doing it, we better
+     not examine the prologue to see whether registers have been saved
+     yet.  */
+  kernel_trap = PROC_REG_MASK (proc_desc) & 1;
+  if (kernel_trap)
+    return &brownie32_mdebug_frame_unwind;
+
+  /* In any frame other than the innermost or a frame interrupted by a
+     signal, we assume that all registers have been saved.  This
+     assumes that all register saves in a function happen before the
+     first function call.  */
+  if (!in_prologue (pc, PROC_LOW_ADDR (proc_desc)))
+    return &brownie32_mdebug_frame_unwind;
+
+  return NULL;
+}
+
+static CORE_ADDR
+brownie32_mdebug_frame_base_address (struct frame_info *next_frame,
+				void **this_cache)
+{
+  struct brownie32_frame_cache *info = brownie32_mdebug_frame_cache (next_frame,
+							   this_cache);
+  return info->base;
+}
+
+static const struct frame_base brownie32_mdebug_frame_base = {
+  &brownie32_mdebug_frame_unwind,
+  brownie32_mdebug_frame_base_address,
+  brownie32_mdebug_frame_base_address,
+  brownie32_mdebug_frame_base_address
+};
+
+static const struct frame_base *
+brownie32_mdebug_frame_base_sniffer (struct frame_info *next_frame)
+{
+  if (brownie32_mdebug_frame_sniffer (next_frame) != NULL)
+    return &brownie32_mdebug_frame_base;
+  else
+    return NULL;
+}
+
+void
+brownie32_mdebug_append_sniffers (struct gdbarch *gdbarch)
+{
+  frame_unwind_append_sniffer (gdbarch, brownie32_mdebug_frame_sniffer);
+  frame_base_append_sniffer (gdbarch, brownie32_mdebug_frame_base_sniffer);
+}
+
+#endif
+
+extern void _initialize_brownie32_mdebug_tdep (void);
+void
+_initialize_brownie32_mdebug_tdep (void)
+{
+//  brownie32_pdr_data = register_objfile_data ();
+}
Index: gdb/brownie32-mdebug-tdep.h
===================================================================
RCS file: gdb/brownie32-mdebug-tdep.h
diff -N gdb/brownie32-mdebug-tdep.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/brownie32-mdebug-tdep.h	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,30 @@
+/* Target-dependent code for the MDEBUG BROWNIE32 architecture, for GDB,
+   the GNU Debugger.
+
+   Copyright 2004 Free Software Foundation, Inc.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef BROWNIE32_MDEBUG_TDEP_H
+#define BROWNIE32_MDEBUG_TDEP_H
+
+extern void brownie32_mdebug_append_sniffers (struct gdbarch *gdbarch);
+
+#endif
Index: gdb/brownie32-tdep.c
===================================================================
RCS file: gdb/brownie32-tdep.c
diff -N gdb/brownie32-tdep.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/brownie32-tdep.c	11 Feb 2008 15:41:13 -0000	1.6
@@ -0,0 +1,3545 @@
+/* Target-dependent code for the BROWNIE32 architecture, for GDB, the GNU Debugger.
+
+   Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
+   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
+   Free Software Foundation, Inc.
+
+   Contributed by Alessandro Forin(af@cs.cmu.edu) at CMU
+   and by Per Bothner(bothner@cs.wisc.edu) at U.Wisconsin.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include "defs.h"
+#include "gdb_string.h"
+#include "gdb_assert.h"
+#include "frame.h"
+#include "inferior.h"
+#include "symtab.h"
+#include "value.h"
+#include "gdbcmd.h"
+#include "language.h"
+#include "gdbcore.h"
+#include "symfile.h"
+#include "objfiles.h"
+#include "gdbtypes.h"
+#include "target.h"
+#include "arch-utils.h"
+#include "regcache.h"
+#include "osabi.h"
+#include "brownie32-tdep.h"
+#include "block.h"
+#include "reggroups.h"
+#include "opcode/brownie32.h"
+#include "elf/brownie32.h"
+#include "elf-bfd.h"
+#include "symcat.h"
+#include "sim-regno.h"
+#include "dis-asm.h"
+#include "frame-unwind.h"
+#include "frame-base.h"
+#include "trad-frame.h"
+#include "infcall.h"
+#include "floatformat.h"
+
+#define DEBUGPRINT printf
+static const struct objfile_data *brownie32_pdr_data;
+
+static struct type *brownie32_register_type (struct gdbarch *gdbarch, int regnum);
+
+static const char *brownie32_abi_string;
+
+static const char *brownie32_abi_strings[] = {
+  "auto",
+  "n32",
+  "o32",
+  "n64",
+  "o64",
+  "eabi32",
+  "eabi64",
+  NULL
+};
+
+/* Various BROWNIE32 ISA options (related to stack analysis) can be
+   overridden dynamically.  Establish an enum/array for managing
+   them. */
+
+static const char size_auto[] = "auto";
+static const char size_32[] = "32";
+static const char size_64[] = "64";
+
+static const char *size_enums[] = {
+  size_auto,
+  size_32,
+  size_64,
+  0
+};
+
+/* Some BROWNIE32 boards don't support floating point while others only
+   support single-precision floating-point operations.  */
+
+enum brownie32_fpu_type
+{
+  BROWNIE32_FPU_DOUBLE,		/* Full double precision floating point.  */
+  BROWNIE32_FPU_SINGLE,		/* Single precision floating point (R4650).  */
+  BROWNIE32_FPU_NONE			/* No floating point.  */
+};
+
+#ifndef BROWNIE32_DEFAULT_FPU_TYPE
+#define BROWNIE32_DEFAULT_FPU_TYPE BROWNIE32_FPU_DOUBLE
+#endif
+static int brownie32_fpu_type_auto = 1;
+static enum brownie32_fpu_type brownie32_fpu_type = BROWNIE32_DEFAULT_FPU_TYPE;
+
+static int brownie32_debug = 0;
+
+/* BROWNIE32 specific per-architecture information */
+struct gdbarch_tdep
+{
+  /* from the elf header */
+  int elf_flags;
+
+  /* brownie32 options */
+  enum brownie32_abi brownie32_abi;
+  enum brownie32_abi found_abi;
+  enum brownie32_fpu_type brownie32_fpu_type;
+  int brownie32_first_arg_regnum;
+  int brownie32_last_arg_regnum;
+  int brownie32_last_fp_arg_regnum;
+  int default_mask_address_p;
+  /* Is the target using 64-bit raw integer registers but only
+     storing a left-aligned 32-bit value in each?  */
+  int brownie3264_transfers_32bit_regs_p;
+  /* Indexes for various registers.  IRIX and embedded have
+     different values.  This contains the "public" fields.  Don't
+     add any that do not need to be public.  */
+  const struct brownie32_regnum *regnum;
+  /* Register names table for the current register set.  */
+  const char **brownie32_processor_reg_names;
+};
+
+static int
+n32n64_floatformat_always_valid (const struct floatformat *fmt,
+                                 const void *from)
+{
+  return 1;
+}
+
+/* FIXME: brobecker/2004-08-08: Long Double values are 128 bit long.
+   They are implemented as a pair of 64bit doubles where the high
+   part holds the result of the operation rounded to double, and
+   the low double holds the difference between the exact result and
+   the rounded result.  So "high" + "low" contains the result with
+   added precision.  Unfortunately, the floatformat structure used
+   by GDB is not powerful enough to describe this format.  As a temporary
+   measure, we define a 128bit floatformat that only uses the high part.
+   We lose a bit of precision but that's probably the best we can do
+   for now with the current infrastructure.  */
+
+static const struct floatformat floatformat_n32n64_long_double_big =
+{
+  floatformat_big, 128, 0, 1, 11, 1023, 2047, 12, 52,
+  floatformat_intbit_no,
+  "floatformat_ieee_double_big",
+  n32n64_floatformat_always_valid
+};
+
+const struct brownie32_regnum *
+brownie32_regnum (struct gdbarch *gdbarch)
+{
+  return gdbarch_tdep (gdbarch)->regnum;
+}
+
+#define BROWNIE32_EABI (gdbarch_tdep (current_gdbarch)->brownie32_abi == BROWNIE32_ABI_EABI32 \
+		   || gdbarch_tdep (current_gdbarch)->brownie32_abi == BROWNIE32_ABI_EABI64)
+
+#define BROWNIE32_LAST_FP_ARG_REGNUM (gdbarch_tdep (current_gdbarch)->brownie32_last_fp_arg_regnum)
+
+#define BROWNIE32_LAST_ARG_REGNUM (gdbarch_tdep (current_gdbarch)->brownie32_last_arg_regnum)
+
+#define BROWNIE32_FPU_TYPE (gdbarch_tdep (current_gdbarch)->brownie32_fpu_type)
+
+/* Return the contents of register REGNUM as a signed integer.  */
+
+static LONGEST
+read_signed_register (int regnum)
+{
+  LONGEST val;
+  regcache_cooked_read_signed (current_regcache, regnum, &val);
+  return val;
+}
+
+static LONGEST
+read_signed_register_pid (int regnum, ptid_t ptid)
+{
+  ptid_t save_ptid;
+  LONGEST retval;
+
+  if (ptid_equal (ptid, inferior_ptid))
+  {
+    return read_signed_register (regnum);
+  }
+  save_ptid = inferior_ptid;
+
+  inferior_ptid = ptid;
+
+  retval = read_signed_register (regnum);
+
+  inferior_ptid = save_ptid;
+
+  return retval;
+}
+
+/* Return the BROWNIE32 ABI associated with GDBARCH.  */
+enum brownie32_abi
+brownie32_abi (struct gdbarch *gdbarch)
+{
+  return gdbarch_tdep (gdbarch)->brownie32_abi;
+}
+
+int
+brownie32_isa_regsize (struct gdbarch *gdbarch)
+{
+  return (gdbarch_bfd_arch_info (gdbarch)->bits_per_word
+	  / gdbarch_bfd_arch_info (gdbarch)->bits_per_byte);
+}
+
+/* Return the currently configured (or set) saved register size. */
+
+static const char *brownie32_abi_regsize_string = size_auto;
+
+unsigned int
+brownie32_abi_regsize (struct gdbarch *gdbarch)
+{
+    return 4;
+}
+
+/* Functions for setting and testing a bit in a minimal symbol that
+   marks it as 16-bit function.  The MSB of the minimal symbol's
+   "info" field is used for this purpose.
+
+   ELF_MAKE_MSYMBOL_SPECIAL tests whether an ELF symbol is "special",
+   i.e. refers to a 16-bit function, and sets a "special" bit in a
+   minimal symbol to mark it as a 16-bit function
+
+   MSYMBOL_IS_SPECIAL   tests the "special" bit in a minimal symbol  */
+
+static void
+brownie32_elf_make_msymbol_special (asymbol * sym, struct minimal_symbol *msym)
+{
+}
+
+/* The amount of space reserved on the stack for registers. This is
+   different to BROWNIE32_ABI_REGSIZE as it determines the alignment of
+   data allocated after the registers have run out. */
+
+static const char *brownie32_stack_argsize_string = size_auto;
+
+static unsigned int
+brownie32_stack_argsize (struct gdbarch *gdbarch)
+{
+  if (brownie32_stack_argsize_string == size_auto)
+    return brownie32_abi_regsize (gdbarch);
+  else if (brownie32_stack_argsize_string == size_64)
+    return 8;
+  else				/* if (brownie32_stack_argsize_string == size_32) */
+    return 4;
+}
+
+#define VM_MIN_ADDRESS (CORE_ADDR)0x400000
+
+static CORE_ADDR heuristic_proc_start (CORE_ADDR);
+
+static CORE_ADDR read_next_frame_reg (struct frame_info *, int);
+
+static void reinit_frame_cache_sfunc (char *, int, struct cmd_list_element *);
+
+/* The list of available "set brownie32 " and "show brownie32 " commands */
+
+static struct cmd_list_element *setbrownie32cmdlist = NULL;
+static struct cmd_list_element *showbrownie32cmdlist = NULL;
+
+/* Integer registers 0 thru 31 are handled explicitly by
+   brownie32_register_name().  Processor specific registers 32 and above
+   are listed in the followign tables.  */
+
+enum
+{ NUM_BROWNIE32_PROCESSOR_REGS = (90-32) };
+/* Generic BROWNIE32.  */
+
+static const char *brownie32_generic_reg_names[NUM_BROWNIE32_PROCESSOR_REGS] = {
+  "pc",  
+  "", "", "", "", "", "", "", 
+  "", "", "", "", "", "", "", 
+  "", "", "", "", "", "", "", 
+  "", "", "", "", "", "", "", 
+  "", "", "", "", "", "", "", 
+  "", "", "", "", "", "", "", 
+  "", "", "", "", "", "", "", 
+  "", "", "", "", "", "", "", 
+  ""
+};
+
+/* Return the name of the register corresponding to REGNO.  */
+static const char *
+brownie32_register_name (int regno)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
+  /* GPR names for all ABIs other than n32/n64.  */
+#if 0
+  static char *brownie32_gpr_names[] = {
+    "gpr00", "gpr01", "gpr02", "gpr03", "gpr04", "gpr05", "gpr06", "gpr07",
+    "gpr08", "gpr09", "gpr10", "gpr11", "gpr12", "gpr13", "gpr14", "gpr15",
+    "gpr16", "gpr17", "gpr18", "gpr19", "gpr20", "gpr21", "gpr22", "gpr23",
+    "gpr24", "gpr25", "gpr26", "gpr27", "gpr28", "gpr29", "gpr30", "gpr31"
+  };
+#endif
+  static char *brownie32_gpr_names[] = {
+    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
+    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
+    "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",
+    "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31"
+  };
+
+
+  enum brownie32_abi abi = brownie32_abi (current_gdbarch);
+
+  /* Map [NUM_REGS .. 2*NUM_REGS) onto the raw registers, but then
+     don't make the raw register names visible.  */
+
+  int rawnum = regno % NUM_REGS;
+//DEBUGPRINT("rawnum=%d regno=%d NUM_REGS=%d\n",rawnum,regno,NUM_REGS);
+  if (regno < NUM_REGS)
+    return "";
+
+  /* The BROWNIE32 integer registers are always mapped from 0 to 31.  The
+     names of the registers (which reflects the conventions regarding
+     register use) vary depending on the ABI.  */
+  if (0 <= rawnum && rawnum < 32)
+    {
+	return brownie32_gpr_names[rawnum];
+    }
+  else if (32 <= rawnum && rawnum < NUM_REGS)
+    {
+      gdb_assert (rawnum - 32 < NUM_BROWNIE32_PROCESSOR_REGS);
+      return tdep->brownie32_processor_reg_names[rawnum - 32];
+    }
+  else
+    internal_error (__FILE__, __LINE__,
+		    _("brownie32_register_name: bad register number %d"), rawnum);
+}
+
+/* Return the groups that a BROWNIE32 register can be categorised into.  */
+
+static int
+brownie32_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
+			  struct reggroup *reggroup)
+{
+  int vector_p;
+  int float_p;
+  int raw_p;
+  int rawnum = regnum % NUM_REGS;
+  int pseudo = regnum / NUM_REGS;
+  if (reggroup == all_reggroup)
+    return pseudo;
+  vector_p = TYPE_VECTOR (register_type (gdbarch, regnum));
+  float_p = TYPE_CODE (register_type (gdbarch, regnum)) == TYPE_CODE_FLT;
+  /* FIXME: cagney/2003-04-13: Can't yet use gdbarch_num_regs
+     (gdbarch), as not all architectures are multi-arch.  */
+  raw_p = rawnum < NUM_REGS;
+  if (REGISTER_NAME (regnum) == NULL || REGISTER_NAME (regnum)[0] == '\0')
+    return 0;
+  if (reggroup == float_reggroup)
+    return float_p && pseudo;
+  if (reggroup == vector_reggroup)
+    return vector_p && pseudo;
+  if (reggroup == general_reggroup)
+    return (!vector_p && !float_p) && pseudo;
+  /* Save the pseudo registers.  Need to make certain that any code
+     extracting register values from a saved register cache also uses
+     pseudo registers.  */
+  if (reggroup == save_reggroup)
+    return raw_p && pseudo;
+  /* Restore the same pseudo register.  */
+  if (reggroup == restore_reggroup)
+    return raw_p && pseudo;
+  return 0;
+}
+
+/* Map the symbol table registers which live in the range [1 *
+   NUM_REGS .. 2 * NUM_REGS) back onto the corresponding raw
+   registers.  Take care of alignment and size problems.  */
+
+static void
+brownie32_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
+			   int cookednum, gdb_byte *buf)
+{
+  int rawnum = cookednum % NUM_REGS;
+  gdb_assert (cookednum >= NUM_REGS && cookednum < 2 * NUM_REGS);
+  if (register_size (gdbarch, rawnum) == register_size (gdbarch, cookednum))
+    regcache_raw_read (regcache, rawnum, buf);
+  else if (register_size (gdbarch, rawnum) >
+	   register_size (gdbarch, cookednum))
+    {
+      if (gdbarch_tdep (gdbarch)->brownie3264_transfers_32bit_regs_p
+	  || TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
+	regcache_raw_read_part (regcache, rawnum, 0, 4, buf);
+      else
+	regcache_raw_read_part (regcache, rawnum, 4, 4, buf);
+    }
+  else
+    internal_error (__FILE__, __LINE__, _("bad register size"));
+}
+
+static void
+brownie32_pseudo_register_write (struct gdbarch *gdbarch,
+			    struct regcache *regcache, int cookednum,
+			    const gdb_byte *buf)
+{
+  int rawnum = cookednum % NUM_REGS;
+  gdb_assert (cookednum >= NUM_REGS && cookednum < 2 * NUM_REGS);
+  if (register_size (gdbarch, rawnum) == register_size (gdbarch, cookednum))
+    regcache_raw_write (regcache, rawnum, buf);
+  else if (register_size (gdbarch, rawnum) >
+	   register_size (gdbarch, cookednum))
+    {
+      if (gdbarch_tdep (gdbarch)->brownie3264_transfers_32bit_regs_p
+	  || TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
+	regcache_raw_write_part (regcache, rawnum, 0, 4, buf);
+      else
+	regcache_raw_write_part (regcache, rawnum, 4, 4, buf);
+    }
+  else
+    internal_error (__FILE__, __LINE__, _("bad register size"));
+}
+
+/* Heuristic_proc_start may hunt through the text section for a long
+   time across a 2400 baud serial line.  Allows the user to limit this
+   search.  */
+
+static unsigned int heuristic_fence_post = 0;
+
+/* Number of bytes of storage in the actual machine representation for
+   register N.  NOTE: This defines the pseudo register type so need to
+   rebuild the architecture vector.  */
+
+static int brownie3264_transfers_32bit_regs_p = 0;
+
+static void
+set_brownie3264_transfers_32bit_regs (char *args, int from_tty,
+				 struct cmd_list_element *c)
+{
+  struct gdbarch_info info;
+  gdbarch_info_init (&info);
+  /* FIXME: cagney/2003-11-15: Should be setting a field in "info"
+     instead of relying on globals.  Doing that would let generic code
+     handle the search for this specific architecture.  */
+  if (!gdbarch_update_p (info))
+    {
+      brownie3264_transfers_32bit_regs_p = 0;
+      error (_("32-bit compatibility mode not supported"));
+    }
+}
+
+/* Convert to/from a register and the corresponding memory value.  */
+
+static int
+brownie32_convert_register_p (int regnum, struct type *type)
+{
+#if 0
+  return (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
+	  && register_size (current_gdbarch, regnum) == 4
+	  && (regnum % NUM_REGS) >= brownie32_regnum (current_gdbarch)->fp0
+	  && (regnum % NUM_REGS) < brownie32_regnum (current_gdbarch)->fp0 + 32
+	  && TYPE_CODE (type) == TYPE_CODE_FLT && TYPE_LENGTH (type) == 8);
+#else
+return -1;
+#endif
+}
+
+static void
+brownie32_register_to_value (struct frame_info *frame, int regnum,
+			struct type *type, gdb_byte *to)
+{
+//  get_frame_register (frame, regnum + 0, to + 4);
+//  get_frame_register (frame, regnum + 1, to + 0);
+  get_frame_register (frame, regnum , to );
+}
+
+static void
+brownie32_value_to_register (struct frame_info *frame, int regnum,
+			struct type *type, const gdb_byte *from)
+{
+//  put_frame_register (frame, regnum + 0, from + 4);
+//  put_frame_register (frame, regnum + 1, from + 0);
+  put_frame_register (frame, regnum , from );
+}
+
+/* Return the GDB type object for the "standard" data type of data in
+   register REG.  */
+
+static struct type *
+brownie32_register_type (struct gdbarch *gdbarch, int regnum)
+{
+//DEBUGPRINT("---> regnum=%d\n",regnum);
+  gdb_assert (regnum >= 0 && regnum < 2 * NUM_REGS);
+  if (regnum < NUM_REGS)
+    {
+      /* The raw or ISA registers.  These are all sized according to
+	 the ISA regsize.  */
+      if (brownie32_isa_regsize (gdbarch) == 4)
+	return builtin_type_int32;
+      else
+	return builtin_type_int64;
+    }
+  else
+    {
+      /* The cooked or ABI registers.  These are sized according to
+	 the ABI (with a few complications).  */
+      if (gdbarch_tdep (gdbarch)->brownie3264_transfers_32bit_regs_p)
+	/* The target, while possibly using a 64-bit register buffer,
+	   is only transfering 32-bits of each integer register.
+	   Reflect this in the cooked/pseudo (ABI) register value.  */
+	return builtin_type_int32;
+      else if (brownie32_abi_regsize (gdbarch) == 4)
+	/* The ABI is restricted to 32-bit registers (the ISA could be
+	   32- or 64-bit).  */
+	return builtin_type_int32;
+      else
+	/* 64-bit ABI.  */
+	return builtin_type_int64;
+    }
+}
+
+/* TARGET_READ_SP -- Remove useless bits from the stack pointer.  */
+
+static CORE_ADDR
+brownie32_read_sp (void)
+{
+  return read_signed_register (BROWNIE32_SP_REGNUM);
+}
+
+/* Should the upper word of 64-bit addresses be zeroed? */
+enum auto_boolean mask_address_var = AUTO_BOOLEAN_AUTO;
+
+static int
+brownie32_mask_address_p (struct gdbarch_tdep *tdep)
+{
+  switch (mask_address_var)
+    {
+    case AUTO_BOOLEAN_TRUE:
+      return 1;
+    case AUTO_BOOLEAN_FALSE:
+      return 0;
+      break;
+    case AUTO_BOOLEAN_AUTO:
+      return tdep->default_mask_address_p;
+    default:
+      internal_error (__FILE__, __LINE__, _("brownie32_mask_address_p: bad switch"));
+      return -1;
+    }
+}
+
+static void
+show_mask_address (struct ui_file *file, int from_tty,
+		   struct cmd_list_element *c, const char *value)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
+
+  deprecated_show_value_hack (file, from_tty, c, value);
+  switch (mask_address_var)
+    {
+    case AUTO_BOOLEAN_TRUE:
+      printf_filtered ("The 32 bit brownie32 address mask is enabled\n");
+      break;
+    case AUTO_BOOLEAN_FALSE:
+      printf_filtered ("The 32 bit brownie32 address mask is disabled\n");
+      break;
+    case AUTO_BOOLEAN_AUTO:
+      printf_filtered
+	("The 32 bit address mask is set automatically.  Currently %s\n",
+	 brownie32_mask_address_p (tdep) ? "enabled" : "disabled");
+      break;
+    default:
+      internal_error (__FILE__, __LINE__, _("show_mask_address: bad switch"));
+      break;
+    }
+}
+
+/* BROWNIE32 believes that the PC has a sign extended value.  Perhaps the
+   all registers should be sign extended for simplicity? */
+
+static CORE_ADDR
+brownie32_read_pc (ptid_t ptid)
+{
+  return read_signed_register_pid (brownie32_regnum (current_gdbarch)->pc, ptid);
+}
+
+static CORE_ADDR
+brownie32_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
+{
+  return frame_unwind_register_signed (next_frame,
+				       NUM_REGS + brownie32_regnum (gdbarch)->pc);
+}
+
+/* Assuming NEXT_FRAME->prev is a dummy, return the frame ID of that
+   dummy frame.  The frame ID's base needs to match the TOS value
+   saved by save_dummy_frame_tos(), and the PC match the dummy frame's
+   breakpoint.  */
+
+static struct frame_id
+brownie32_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
+{
+  return frame_id_build (frame_unwind_register_signed (next_frame, NUM_REGS + BROWNIE32_FRM_REGNUM),
+			 frame_pc_unwind (next_frame));
+}
+
+static void
+brownie32_write_pc (CORE_ADDR pc, ptid_t ptid)
+{
+  write_register_pid (brownie32_regnum (current_gdbarch)->pc, pc, ptid);
+}
+
+/* Fetch and return instruction from the specified location.  If the PC
+   is odd, assume it's a BROWNIE3216 instruction; otherwise BROWNIE3232.  */
+
+static ULONGEST
+brownie32_fetch_instruction (CORE_ADDR addr)
+{
+  gdb_byte buf[BROWNIE32_INSN32_SIZE];
+  int instlen;
+  int status;
+  ULONGEST inst;
+  int n;
+  instlen = BROWNIE32_INSN32_SIZE;
+  status = deprecated_read_memory_nobpt (addr, buf, instlen);
+//printf ("DEBUG: sizeof(ULONGEST) = %d\n", sizeof(ULONGEST));
+//for (n = 0; n < instlen; n++)
+//{
+//printf ("DEBUG: buf[%d]=0x%x\n", n, buf[n]);
+//}
+  if (status)
+    memory_error (status, addr);
+  inst = extract_unsigned_integer (buf, instlen);
+//printf ("DEBUG: addr = 0x%lx, inst = 0x%llx\n", addr, inst);
+  return inst;
+}
+
+/* These the fields of 32 bit brownie32 instructions */
+#define brownie32_op(x) (x & 0x3f)
+#define rrtype_func(x) ((x >> 6) & 0x7ff)
+#define rrtype_rs1(x) ((x >> 27) & 0x1f)
+#define rrtype_rs2(x) ((x >> 22) & 0x1f)
+#define rrtype_rd(x) ((x >> 17) & 0x1f)
+#define ritype_immediate(x) ((x >> 16) & 0xffff)
+#define ritype_rs1(x) ((x >> 11) & 0x1f)
+#define ritype_rd(x) ((x >> 6) & 0x1f)
+#define matype_offset(x) ((x >> 16) & 0xffff)
+#define matype_rs1(x) ((x >> 11) & 0x1f)
+#define matype_rd(x) ((x >> 6) & 0x1f)
+
+#define brtype_offset(x) ((x >> 16) & 0xffff)
+#define brtype_rs1(x) ((x >> 11) & 0x1f)
+
+#define jptype_offset(x) ((x >> 6) & 0x3ffffff)
+
+#define jprtype_rs1(x) ((x >> 6) & 0x1f)
+
+#define sptype_func(x) ((x >> 6) & 0x1f)
+
+
+/* The brownie32_next_pc function supports single_step when the remote
+   target monitor or stub is not developed enough to do a single_step.
+   It works by decoding the current instruction and predicting where a
+   branch will go. This isnt hard because all the data is available.
+   The BROWNIE3232 and BROWNIE3216 variants are quite different */
+CORE_ADDR
+brownie32_next_pc (CORE_ADDR pc)
+{
+  unsigned long inst;
+  int op;
+  CORE_ADDR val;
+  int reg;
+
+//printf("DEBUG: brownie32_next_pc in pc = 0x%lx\n", pc);
+  inst = brownie32_fetch_instruction (pc);
+//printf("DEBUG: brownie32_next_pc inst = 0x%lx\n", brownie32_op (inst));
+  switch (brownie32_op (inst))
+    {
+    case 0x9:   /* BRZ */
+      reg = read_signed_register (brtype_rs1 (inst));
+      if (reg == 0)
+        {
+          val = brtype_offset (inst);
+          if ((val & 0x8000) == 0x8000)
+            {
+              val = 0xffff | val;
+            }
+          pc += BROWNIE32_INSN32_SIZE + val;
+        }
+      else
+        {
+          pc += BROWNIE32_INSN32_SIZE;
+        }
+      break;
+    case 0xa:  /* BRNZ */
+      reg = read_signed_register (brtype_rs1 (inst));
+      if (reg != 0)
+        {
+          val = brtype_offset (inst);
+          if ((val & 0x8000) == 0x8000)
+            {
+              val = 0xffff0000 | val;
+            }
+          pc += BROWNIE32_INSN32_SIZE + val;
+        }
+      else
+        {
+          pc += BROWNIE32_INSN32_SIZE;
+        }
+      break;
+    case 0xb:   /* JP */
+      val = jptype_offset (inst);
+      if ((val & 0x02000000) == 0x02000000)
+        {
+          val = 0xfc000000 | val;
+        }
+      pc += BROWNIE32_INSN32_SIZE + val;
+      break;
+    case 0xc:   /* JPL */
+      val = jptype_offset (inst);
+      if ((val & 0x02000000) == 0x02000000)
+        {
+          val = 0xfc000000 | val;
+        }
+      pc += BROWNIE32_INSN32_SIZE + val;
+      break;
+    case 0xe:   /* JPR */
+      reg = read_signed_register (jprtype_rs1 (inst));
+      pc = reg;
+      break;
+    case 0xf:   /* JPRL */
+      reg = read_signed_register (jprtype_rs1 (inst));
+      pc = reg;
+      break;
+    case 0x0:   /* SP Type */
+      switch (sptype_func (inst))
+        {
+        case 0: /* NOP */
+          pc += BROWNIE32_INSN32_SIZE;
+          break;
+        case 0x1: /* RETI */
+          reg = read_signed_register (BROWNIE32_IRR_REGNUM);
+          pc = reg;
+          break;
+        default:
+          printf ("DEBUG: SPTYPE unknown func %d\n", sptype_func(inst));
+          pc += BROWNIE32_INSN32_SIZE;
+          break;
+        }
+      break;
+    case 0xd:  /* TRAP */
+      val = jptype_offset (inst);
+      pc += BROWNIE32_INSN32_SIZE; /* FIXME */
+      break;
+    default:
+      pc += BROWNIE32_INSN32_SIZE;
+    }
+//printf("DEBUG: brownie32_next_pc out pc = 0x%lx\n", pc);
+  return pc;
+}
+
+struct brownie32_frame_cache
+{
+  CORE_ADDR base;
+  struct trad_frame_saved_reg *saved_regs;
+};
+
+#if 0
+/* Set a register's saved stack address in temp_saved_regs.  If an
+   address has already been set for this register, do nothing; this
+   way we will only recognize the first save of a given register in a
+   function prologue.
+
+   For simplicity, save the address in both [0 .. NUM_REGS) and
+   [NUM_REGS .. 2*NUM_REGS).  Strictly speaking, only the second range
+   is used as it is only second range (the ABI instead of ISA
+   registers) that comes into play when finding saved registers in a
+   frame.  */
+
+static void
+set_reg_offset (struct brownie32_frame_cache *this_cache, int regnum,
+		CORE_ADDR offset)
+{
+  if (this_cache != NULL
+      && this_cache->saved_regs[regnum].addr == -1)
+    {
+      this_cache->saved_regs[regnum + 0 * NUM_REGS].addr = offset;
+      this_cache->saved_regs[regnum + 1 * NUM_REGS].addr = offset;
+    }
+}
+#endif
+
+/* Mark all the registers as unset in the saved_regs array
+   of THIS_CACHE.  Do nothing if THIS_CACHE is null.  */
+
+void
+reset_saved_regs (struct brownie32_frame_cache *this_cache)
+{
+  if (this_cache == NULL || this_cache->saved_regs == NULL)
+    return;
+
+  {
+    const int num_regs = NUM_REGS;
+    int i;
+
+    for (i = 0; i < num_regs; i++)
+      {
+        this_cache->saved_regs[i].addr = -1;
+      }
+  }
+}
+
+/* Analyze the function prologue from START_PC to LIMIT_PC. Builds
+   the associated FRAME_CACHE if not null.  
+   Return the address of the first instruction past the prologue.  */
+
+static CORE_ADDR
+brownie32_scan_prologue (CORE_ADDR start_pc, CORE_ADDR limit_pc,
+                      struct frame_info *next_frame,
+                      struct brownie32_frame_cache *this_cache)
+{
+  CORE_ADDR cur_pc;
+  CORE_ADDR frame_addr = 0; /* Value of $r30. Used by gcc for frame-pointer */
+  CORE_ADDR sp;
+  long frame_offset;
+//  int  frame_reg = BROWNIE32_SP_REGNUM;
+  int  frame_reg = BROWNIE32_FRM_REGNUM;
+
+  CORE_ADDR end_prologue_addr = 0;
+  int seen_sp_adjust = 0;
+  int load_immediate_bytes = 0;
+
+  /* Can be called when there's no process, and hence when there's no
+     NEXT_FRAME.  */
+  if (next_frame != NULL)
+//    sp = read_next_frame_reg (next_frame, NUM_REGS + BROWNIE32_SP_REGNUM);
+    sp = read_next_frame_reg (next_frame, NUM_REGS + BROWNIE32_FRM_REGNUM);
+  else
+    sp = 0;
+
+  if (limit_pc > start_pc + 200)
+    limit_pc = start_pc + 200;
+
+  frame_offset = 0;
+//printf("DEBUG: start_pc = 0x%lx\n", start_pc);
+//printf("DEBUG: limit_pc = 0x%lx\n", limit_pc);
+  for (cur_pc = start_pc; cur_pc < limit_pc; cur_pc += BROWNIE32_INSN32_SIZE)
+    {
+      unsigned long inst;
+
+//printf("DEBUG: cur_pc = 0x%lx\n", cur_pc);
+      /* Fetch the instruction.   */
+      inst = (unsigned long) brownie32_fetch_instruction (cur_pc);
+/*
+       prologe code:
+       sw -4(SP), r3   ; push Link register
+       sw -8(SP), FP   ; push frame pointer
+       addi FP, SP, #-8 ; frame pointer = stack pointer - 8
+       addi SP, SP, #-X ; alloc local storage
+       sw Y(SP), r8   ; first arg reg. save
+       sw Y+4(SP), r9 ; second arg reg. save
+        ...
+       sw Y+M(SP), r15 ; last arg reg. save
+*/
+
+      if (brownie32_op(inst) == 0x7 
+	&& matype_rd(inst) == BROWNIE32_SP_REGNUM
+        && matype_rs1(inst) == BROWNIE32_LNK_REGNUM
+        && matype_offset(inst) == 0xfffc)  /* sw -4(SP),r3 */
+        {
+//printf ("DEBUG: cur_pc = 0x%lx, push link register - sw -4(SP),r3\n", cur_pc);
+        }
+      else if (brownie32_op(inst) == 0x7 
+	&& matype_rd(inst) == BROWNIE32_SP_REGNUM
+        && matype_rs1(inst) == BROWNIE32_FRM_REGNUM
+        && matype_offset(inst) == 0xfff8)  /* sw -8(SP),FP */
+        {
+//printf ("DEBUG: cur_pc = 0x%lx, push frame register - sw -8(SP),FP\n", cur_pc);
+        }
+      else if (brownie32_op(inst) == 0x20
+	&& ritype_rd(inst) == BROWNIE32_FRM_REGNUM
+	&& ritype_rs1(inst) == BROWNIE32_SP_REGNUM
+	&& ritype_immediate(inst) == 0xfff8) /* addi FP, SP, -8 */
+        {
+//printf ("DEBUG: cur_pc = 0x%lx, frame = SP - 8 - addi FP, -8(SP)\n", cur_pc);
+        }
+      else if (!seen_sp_adjust
+               && brownie32_op (inst) == 0x20
+               && ritype_rs1 (inst) == BROWNIE32_SP_REGNUM
+               && ritype_rd (inst) == BROWNIE32_SP_REGNUM)
+        /* addi SP, SP, X; local storage*/
+        {
+          seen_sp_adjust = 1;
+//printf ("DEBUG: cur_pc = 0x%lx, alloc local storage - addi SP, X(SP)\n", cur_pc);
+        }
+      else if (seen_sp_adjust
+               && brownie32_op (inst) == 0x7
+               && matype_rd(inst) == BROWNIE32_SP_REGNUM
+               && matype_rs1(inst) >= BROWNIE32_FIRST_ARG_REGNUM
+               && matype_rs1(inst) <= BROWNIE32_LAST_ARG_REGNUM)
+        /* sw rN, X(SP); arg register save area */
+        {
+//printf ("DEBUG: cur_pc = 0x%lx, arg register save - addi rN, X(SP)\n", cur_pc);
+        }
+      else if (seen_sp_adjust
+               && brownie32_op (inst) == 0
+               && sptype_func (inst) == 0)
+       /* NOP: bodiless function? */
+       {
+           end_prologue_addr = cur_pc - 4;
+//printf ("DEBUG: NOP found\n");
+           break;
+        }
+      else
+       {
+         /* This instruction is not an instruction typically found
+            in a prologue, so we must have reached the end of the
+            prologue.  */
+         /* FIXME: brobecker/2004-10-10: Can't we just break out of this
+            loop now?  Why would we need to continue scanning the function
+            instructions?  */
+//printf("DEBUG: other instruction = 0x%lx, ", inst);
+//printf("cur_pc = 0x%lx\n", cur_pc);
+         if (end_prologue_addr == 0)
+           end_prologue_addr = cur_pc;
+//if (brownie32_op(inst) == 0x7 )
+//printf("0x7: rd = %ld, rs1 = %ld, offset = 0x%lx\n", matype_rd(inst),
+//matype_rs1(inst),  matype_offset(inst));  /* sw -4(SP),r3 */
+//if (brownie32_op(inst) == 0x20)
+//printf("0x20: rd = %ld, rs1 = %ld, imm = 0x%lx\n", ritype_rd(inst),
+//ritype_rs1(inst),  ritype_immediate(inst));
+         break;
+       }
+    }
+
+  if (this_cache != NULL)
+    {
+//frame_offset = -8;
+//frame_reg = BROWNIE32_SP_REGNUM;
+      this_cache->base = 
+        (frame_unwind_register_signed (next_frame, NUM_REGS + frame_reg)
+         + frame_offset);
+//printf("DEBUG: this_cache->base = 0x%lx\n", this_cache->base);
+      /* FIXME: brobecker/2004-09-15: We should be able to get rid of
+         this assignment below, eventually.  But it's still needed
+         for now.  */
+
+      this_cache->saved_regs[NUM_REGS + brownie32_regnum (current_gdbarch)->pc]
+        = this_cache->saved_regs[NUM_REGS + BROWNIE32_LNK_REGNUM];
+
+    }
+
+  /* If we didn't reach the end of the prologue when scanning the function
+     instructions, then set end_prologue_addr to the address of the
+     instruction immediately after the last one we scanned.  */
+  /* brobecker/2004-10-10: I don't think this would ever happen, but
+     we may as well be careful and do our best if we have a null
+     end_prologue_addr.  */
+  if (end_prologue_addr == 0)
+    end_prologue_addr = cur_pc;
+     
+#if 000
+  /* In a frameless function, we might have incorrectly
+     skipped some load immediate instructions. Undo the skipping
+     if the load immediate was not followed by a stack adjustment.  */
+  if (load_immediate_bytes && !seen_sp_adjust)
+    end_prologue_addr -= load_immediate_bytes;
+#endif
+
+  return end_prologue_addr;
+}
+
+/* Heuristic unwinder for procedures using 32-bit instructions (covers
+   both 32-bit and 64-bit BROWNIE32 ISAs).  Procedures using 16-bit
+   instructions (a.k.a. BROWNIE3216) are handled by the brownie32_insn16
+   unwinder.  */
+
+static struct brownie32_frame_cache *
+brownie32_insn32_frame_cache (struct frame_info *next_frame, void **this_cache)
+{
+  struct brownie32_frame_cache *cache;
+
+  if ((*this_cache) != NULL)
+    return (*this_cache);
+
+  cache = FRAME_OBSTACK_ZALLOC (struct brownie32_frame_cache);
+  (*this_cache) = cache;
+  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);
+
+  /* Analyze the function prologue.  */
+  {
+    const CORE_ADDR pc = frame_pc_unwind (next_frame);
+    CORE_ADDR start_addr;
+
+    find_pc_partial_function (pc, NULL, &start_addr, NULL);
+    if (start_addr == 0)
+      start_addr = heuristic_proc_start (pc);
+    /* We can't analyze the prologue if we couldn't find the begining
+       of the function.  */
+    if (start_addr == 0)
+      return cache;
+
+    brownie32_scan_prologue (start_addr, pc, next_frame, *this_cache);
+  }
+  
+  /* SP_REGNUM, contains the value and not the address.  */
+//  trad_frame_set_value (cache->saved_regs, NUM_REGS + BROWNIE32_SP_REGNUM, cache->base);
+ trad_frame_set_value (cache->saved_regs, NUM_REGS + BROWNIE32_FRM_REGNUM, cache->base);
+
+  return (*this_cache);
+}
+
+static void
+brownie32_insn32_frame_this_id (struct frame_info *next_frame, void **this_cache,
+			   struct frame_id *this_id)
+{
+  struct brownie32_frame_cache *info = brownie32_insn32_frame_cache (next_frame,
+							   this_cache);
+  (*this_id) = frame_id_build (info->base, frame_func_unwind (next_frame));
+//printf ("DEBUG: this_id->stack_addr = 0x%lx\n", this_id->stack_addr);
+//printf ("DEBUG: this_id->code_addr = 0x%lx\n", this_id->code_addr);
+}
+
+static void
+brownie32_insn32_frame_prev_register (struct frame_info *next_frame,
+				 void **this_cache,
+				 int regnum, int *optimizedp,
+				 enum lval_type *lvalp, CORE_ADDR *addrp,
+				 int *realnump, gdb_byte *valuep)
+{
+  struct brownie32_frame_cache *info = brownie32_insn32_frame_cache (next_frame,
+							   this_cache);
+  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
+				optimizedp, lvalp, addrp, realnump, valuep);
+}
+
+static const struct frame_unwind brownie32_insn32_frame_unwind =
+{
+  NORMAL_FRAME,
+  brownie32_insn32_frame_this_id,
+  brownie32_insn32_frame_prev_register
+};
+
+static const struct frame_unwind *
+brownie32_insn32_frame_sniffer (struct frame_info *next_frame)
+{
+  return &brownie32_insn32_frame_unwind;
+}
+
+static CORE_ADDR
+brownie32_insn32_frame_base_address (struct frame_info *next_frame,
+				void **this_cache)
+{
+  struct brownie32_frame_cache *info = brownie32_insn32_frame_cache (next_frame,
+							   this_cache);
+  return info->base;
+}
+
+static const struct frame_base brownie32_insn32_frame_base =
+{
+  &brownie32_insn32_frame_unwind,
+  brownie32_insn32_frame_base_address,
+  brownie32_insn32_frame_base_address,
+  brownie32_insn32_frame_base_address
+};
+
+static const struct frame_base *
+brownie32_insn32_frame_base_sniffer (struct frame_info *next_frame)
+{
+  if (brownie32_insn32_frame_sniffer (next_frame) != NULL)
+    return &brownie32_insn32_frame_base;
+  else
+    return NULL;
+}
+
+static struct trad_frame_cache *
+brownie32_stub_frame_cache (struct frame_info *next_frame, void **this_cache)
+{
+  CORE_ADDR pc;
+  CORE_ADDR start_addr;
+  CORE_ADDR stack_addr;
+  struct trad_frame_cache *this_trad_cache;
+
+  if ((*this_cache) != NULL)
+    return (*this_cache);
+  this_trad_cache = trad_frame_cache_zalloc (next_frame);
+  (*this_cache) = this_trad_cache;
+
+  /* The return address is in the link register.  */
+  trad_frame_set_reg_realreg (this_trad_cache, PC_REGNUM, BROWNIE32_LNK_REGNUM);
+
+  /* Frame ID, since it's a frameless / stackless function, no stack
+     space is allocated and SP on entry is the current SP.  */
+  pc = frame_pc_unwind (next_frame);
+  find_pc_partial_function (pc, NULL, &start_addr, NULL);
+  stack_addr = frame_unwind_register_signed (next_frame, BROWNIE32_FRM_REGNUM);
+  trad_frame_set_id (this_trad_cache, frame_id_build (start_addr, stack_addr));
+
+  /* Assume that the frame's base is the same as the
+     stack-pointer.  */
+  trad_frame_set_this_base (this_trad_cache, stack_addr);
+
+  return this_trad_cache;
+}
+
+static void
+brownie32_stub_frame_this_id (struct frame_info *next_frame, void **this_cache,
+			 struct frame_id *this_id)
+{
+  struct trad_frame_cache *this_trad_cache
+    = brownie32_stub_frame_cache (next_frame, this_cache);
+  trad_frame_get_id (this_trad_cache, this_id);
+}
+
+static void
+brownie32_stub_frame_prev_register (struct frame_info *next_frame,
+				 void **this_cache,
+				 int regnum, int *optimizedp,
+				 enum lval_type *lvalp, CORE_ADDR *addrp,
+				 int *realnump, gdb_byte *valuep)
+{
+  struct trad_frame_cache *this_trad_cache
+    = brownie32_stub_frame_cache (next_frame, this_cache);
+  trad_frame_get_register (this_trad_cache, next_frame, regnum, optimizedp,
+			   lvalp, addrp, realnump, valuep);
+}
+
+static const struct frame_unwind brownie32_stub_frame_unwind =
+{
+  NORMAL_FRAME,
+  brownie32_stub_frame_this_id,
+  brownie32_stub_frame_prev_register
+};
+
+static const struct frame_unwind *
+brownie32_stub_frame_sniffer (struct frame_info *next_frame)
+{
+  struct obj_section *s;
+  CORE_ADDR pc = frame_pc_unwind (next_frame);
+
+  if (in_plt_section (pc, NULL))
+    return &brownie32_stub_frame_unwind;
+
+  /* Binutils for BROWNIE32 puts lazy resolution stubs into .BROWNIE32.stubs.  */
+  s = find_pc_section (pc);
+
+  if (s != NULL
+      && strcmp (bfd_get_section_name (s->objfile->obfd, s->the_bfd_section),
+		 ".BROWNIE32.stubs") == 0)
+    return &brownie32_stub_frame_unwind;
+
+  return NULL;
+}
+
+static CORE_ADDR
+brownie32_stub_frame_base_address (struct frame_info *next_frame,
+			      void **this_cache)
+{
+  struct trad_frame_cache *this_trad_cache
+    = brownie32_stub_frame_cache (next_frame, this_cache);
+  return trad_frame_get_this_base (this_trad_cache);
+}
+
+static const struct frame_base brownie32_stub_frame_base =
+{
+  &brownie32_stub_frame_unwind,
+  brownie32_stub_frame_base_address,
+  brownie32_stub_frame_base_address,
+  brownie32_stub_frame_base_address
+};
+
+static const struct frame_base *
+brownie32_stub_frame_base_sniffer (struct frame_info *next_frame)
+{
+  if (brownie32_stub_frame_sniffer (next_frame) != NULL)
+    return &brownie32_stub_frame_base;
+  else
+    return NULL;
+}
+
+static CORE_ADDR
+read_next_frame_reg (struct frame_info *fi, int regno)
+{
+  /* Always a pseudo.  */
+  gdb_assert (regno >= NUM_REGS);
+  if (fi == NULL)
+    {
+      LONGEST val;
+      regcache_cooked_read_signed (current_regcache, regno, &val);
+      return val;
+    }
+  else
+    return frame_unwind_register_signed (fi, regno);
+
+}
+
+/* brownie32_addr_bits_remove - remove useless address bits  */
+
+static CORE_ADDR
+brownie32_addr_bits_remove (CORE_ADDR addr)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
+#if 000
+  if (brownie32_mask_address_p (tdep) && (((ULONGEST) addr) >> 32 == 0xffffffffUL))
+    /* This hack is a work-around for existing boards using PMON, the
+       simulator, and any other 64-bit targets that doesn't have true
+       64-bit addressing.  On these targets, the upper 32 bits of
+       addresses are ignored by the hardware.  Thus, the PC or SP are
+       likely to have been sign extended to all 1s by instruction
+       sequences that load 32-bit addresses.  For example, a typical
+       piece of code that loads an address is this:
+
+       lui $r2, <upper 16 bits>
+       ori $r2, <lower 16 bits>
+
+       But the lui sign-extends the value such that the upper 32 bits
+       may be all 1s.  The workaround is simply to mask off these
+       bits.  In the future, gcc may be changed to support true 64-bit
+       addressing, and this masking will have to be disabled.  */
+    return addr &= 0xffffffffUL;
+  else
+    return addr;
+#endif
+  return addr & 0xffffffff;
+}
+
+/* brownie32_software_single_step() is called just before we want to resume
+   the inferior, if we want to single-step it but there is no hardware
+   or kernel single-step support (BROWNIE32 on GNU/Linux for example).  We find
+   the target of the coming instruction and breakpoint it.
+
+   single_step is also called just after the inferior stops.  If we had
+   set up a simulated single-step, we undo our damage.  */
+
+void
+brownie32_software_single_step (enum target_signal sig, int insert_breakpoints_p)
+{
+  static CORE_ADDR next_pc;
+  typedef char binsn_quantum[BREAKPOINT_MAX];
+//  static binsn_quantum break_mem;
+  static binsn_quantum break_mem = { 0, 0, 0, 0xd };
+  CORE_ADDR pc;
+
+  if (insert_breakpoints_p)
+    {
+      pc = read_register (brownie32_regnum (current_gdbarch)->pc);
+      next_pc = brownie32_next_pc (pc);
+//printf("DEBUG: insert breakpoints\n");
+//printf("DEBUG: pc = 0x%lx, ", pc);
+//printf("next_pc = 0x%lx\n", next_pc);
+
+      target_insert_breakpoint (next_pc, break_mem);
+    }
+  else
+    {
+//printf("DEBUG: remove breakpoints\n");
+//printf("DEBUG: pc = 0x%lx, ", pc);
+//printf("next_pc = 0x%lx\n", next_pc);
+      target_remove_breakpoint (next_pc, break_mem);
+    }
+}
+
+/* Test whether the PC points to the return instruction at the
+   end of a function. */
+
+static int
+brownie32_about_to_return (CORE_ADDR pc)
+{
+    return brownie32_fetch_instruction (pc) == 0xce;	/* jpr r3 */
+}
+
+
+/* This fencepost looks highly suspicious to me.  Removing it also
+   seems suspicious as it could affect remote debugging across serial
+   lines.  */
+
+static CORE_ADDR
+heuristic_proc_start (CORE_ADDR pc)
+{
+  CORE_ADDR start_pc;
+  CORE_ADDR fence;
+  int instlen;
+  int seen_adjsp = 0;
+
+  pc = ADDR_BITS_REMOVE (pc);
+  start_pc = pc;
+  fence = start_pc - heuristic_fence_post;
+  if (start_pc == 0)
+    return 0;
+
+  if (heuristic_fence_post == UINT_MAX || fence < VM_MIN_ADDRESS)
+    fence = VM_MIN_ADDRESS;
+  instlen = BROWNIE32_INSN32_SIZE;
+  /* search back for previous return */
+  for (start_pc -= instlen;; start_pc -= instlen)
+    if (start_pc < fence)
+      {
+	/* It's not clear to me why we reach this point when
+	   stop_soon, but with this test, at least we
+	   don't print out warnings for every child forked (eg, on
+	   decstation).  22apr93 rich@cygnus.com.  */
+	if (stop_soon == NO_STOP_QUIETLY)
+	  {
+	    static int blurb_printed = 0;
+
+	    warning (_("GDB can't find the start of the function at 0x%s."),
+		     paddr_nz (pc));
+
+	    if (!blurb_printed)
+	      {
+		/* This actually happens frequently in embedded
+		   development, when you first connect to a board
+		   and your stack pointer and pc are nowhere in
+		   particular.  This message needs to give people
+		   in that situation enough information to
+		   determine that it's no big deal.  */
+		printf_filtered ("\n\
+    GDB is unable to find the start of the function at 0x%s\n\
+and thus can't determine the size of that function's stack frame.\n\
+This means that GDB may be unable to access that stack frame, or\n\
+the frames below it.\n\
+    This problem is most likely caused by an invalid program counter or\n\
+stack pointer.\n\
+    However, if you think GDB should simply search farther back\n\
+from 0x%s for code which looks like the beginning of a\n\
+function, you can increase the range of the search using the `set\n\
+heuristic-fence-post' command.\n", paddr_nz (pc), paddr_nz (pc));
+		blurb_printed = 1;
+	      }
+	  }
+
+	return 0;
+      }
+    else if (brownie32_about_to_return (start_pc))
+      {
+	/* Skip return.  */
+//	start_pc += 2 * BROWNIE32_INSN32_SIZE;
+	start_pc += BROWNIE32_INSN32_SIZE;
+	break;
+      }
+
+  return start_pc;
+}
+
+struct brownie32_objfile_private
+{
+  bfd_size_type size;
+  char *contents;
+};
+
+/* According to the current ABI, should the type be passed in a
+   floating-point register (assuming that there is space)?  When there
+   is no FPU, FP are not even considered as possibile candidates for
+   FP registers and, consequently this returns false - forces FP
+   arguments into integer registers. */
+
+static int
+fp_register_arg_p (enum type_code typecode, struct type *arg_type)
+{
+  return ((typecode == TYPE_CODE_FLT
+	   || (BROWNIE32_EABI
+	       && (typecode == TYPE_CODE_STRUCT
+		   || typecode == TYPE_CODE_UNION)
+	       && TYPE_NFIELDS (arg_type) == 1
+	       && TYPE_CODE (TYPE_FIELD_TYPE (arg_type, 0)) == TYPE_CODE_FLT))
+	  && BROWNIE32_FPU_TYPE != BROWNIE32_FPU_NONE);
+}
+
+/* On o32, argument passing in GPRs depends on the alignment of the type being
+   passed.  Return 1 if this type must be aligned to a doubleword boundary. */
+
+static int
+brownie32_type_needs_double_align (struct type *type)
+{
+  enum type_code typecode = TYPE_CODE (type);
+
+  if (typecode == TYPE_CODE_FLT && TYPE_LENGTH (type) == 8)
+    return 1;
+  else if (typecode == TYPE_CODE_STRUCT)
+    {
+      if (TYPE_NFIELDS (type) < 1)
+	return 0;
+      return brownie32_type_needs_double_align (TYPE_FIELD_TYPE (type, 0));
+    }
+  else if (typecode == TYPE_CODE_UNION)
+    {
+      int i, n;
+
+      n = TYPE_NFIELDS (type);
+      for (i = 0; i < n; i++)
+	if (brownie32_type_needs_double_align (TYPE_FIELD_TYPE (type, i)))
+	  return 1;
+      return 0;
+    }
+  return 0;
+}
+
+/* Adjust the address downward (direction of stack growth) so that it
+   is correctly aligned for a new stack frame.  */
+static CORE_ADDR
+brownie32_frame_align (struct gdbarch *gdbarch, CORE_ADDR addr)
+{
+  return align_down (addr, 16);
+}
+
+static CORE_ADDR
+brownie32_eabi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
+			   struct regcache *regcache, CORE_ADDR bp_addr,
+			   int nargs, struct value **args, CORE_ADDR sp,
+			   int struct_return, CORE_ADDR struct_addr)
+{
+  int argreg;
+  int float_argreg;
+  int argnum;
+  int len = 0;
+  int stack_offset = 0;
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  CORE_ADDR func_addr = find_function_addr (function, NULL);
+
+  /* For shared libraries, "t9" needs to point at the function
+     address.  */
+//  regcache_cooked_write_signed (regcache, BROWNIE32_T9_REGNUM, func_addr);
+
+  /* Set the return address register to point to the entry point of
+     the program, where a breakpoint lies in wait.  */
+  regcache_cooked_write_signed (regcache, BROWNIE32_LNK_REGNUM, bp_addr);
+
+  /* First ensure that the stack and structure return address (if any)
+     are properly aligned.  The stack has to be at least 64-bit
+     aligned even on 32-bit machines, because doubles must be 64-bit
+     aligned.  For n32 and n64, stack frames need to be 128-bit
+     aligned, so we round to this widest known alignment.  */
+
+  sp = align_down (sp, 16);
+  struct_addr = align_down (struct_addr, 16);
+
+  /* Now make space on the stack for the args.  We allocate more
+     than necessary for EABI, because the first few arguments are
+     passed in registers, but that's OK.  */
+  for (argnum = 0; argnum < nargs; argnum++)
+    len += align_up (TYPE_LENGTH (value_type (args[argnum])),
+		     brownie32_stack_argsize (gdbarch));
+  sp -= align_up (len, 16);
+
+  if (brownie32_debug)
+    fprintf_unfiltered (gdb_stdlog,
+			"brownie32_eabi_push_dummy_call: sp=0x%s allocated %ld\n",
+			paddr_nz (sp), (long) align_up (len, 16));
+
+
+  /* The struct_return pointer occupies the first parameter-passing reg.  */
+  if (struct_return)
+    {
+      if (brownie32_debug)
+	fprintf_unfiltered (gdb_stdlog,
+			    "brownie32_eabi_push_dummy_call: struct_return reg=%d 0x%s\n",
+			    argreg, paddr_nz (struct_addr));
+      write_register (argreg++, struct_addr);
+    }
+
+  /* Now load as many as possible of the first arguments into
+     registers, and push the rest onto the stack.  Loop thru args
+     from first to last.  */
+  for (argnum = 0; argnum < nargs; argnum++)
+    {
+      const gdb_byte *val;
+      gdb_byte valbuf[MAX_REGISTER_SIZE];
+      struct value *arg = args[argnum];
+      struct type *arg_type = check_typedef (value_type (arg));
+      int len = TYPE_LENGTH (arg_type);
+      enum type_code typecode = TYPE_CODE (arg_type);
+
+      if (brownie32_debug)
+	fprintf_unfiltered (gdb_stdlog,
+			    "brownie32_eabi_push_dummy_call: %d len=%d type=%d",
+			    argnum + 1, len, (int) typecode);
+
+      /* The EABI passes structures that do not fit in a register by
+         reference.  */
+      if (len > brownie32_abi_regsize (gdbarch)
+	  && (typecode == TYPE_CODE_STRUCT || typecode == TYPE_CODE_UNION))
+	{
+	  store_unsigned_integer (valbuf, brownie32_abi_regsize (gdbarch),
+				  VALUE_ADDRESS (arg));
+	  typecode = TYPE_CODE_PTR;
+	  len = brownie32_abi_regsize (gdbarch);
+	  val = valbuf;
+	  if (brownie32_debug)
+	    fprintf_unfiltered (gdb_stdlog, " push");
+	}
+      else
+	val = value_contents (arg);
+
+      /* 32-bit ABIs always start floating point arguments in an
+         even-numbered floating point register.  Round the FP register
+         up before the check to see if there are any FP registers
+         left.  Non BROWNIE32_EABI targets also pass the FP in the integer
+         registers so also round up normal registers.  */
+      if (brownie32_abi_regsize (gdbarch) < 8
+	  && fp_register_arg_p (typecode, arg_type))
+	{
+	  if ((float_argreg & 1))
+	    float_argreg++;
+	}
+
+      /* Floating point arguments passed in registers have to be
+         treated specially.  On 32-bit architectures, doubles
+         are passed in register pairs; the even register gets
+         the low word, and the odd register gets the high word.
+         On non-EABI processors, the first two floating point arguments are
+         also copied to general registers, because BROWNIE3216 functions
+         don't use float registers for arguments.  This duplication of
+         arguments in general registers can't hurt non-BROWNIE3216 functions
+         because those registers are normally skipped.  */
+      /* BROWNIE32_EABI squeezes a struct that contains a single floating
+         point value into an FP register instead of pushing it onto the
+         stack.  */
+      if (fp_register_arg_p (typecode, arg_type)
+	  && float_argreg <= BROWNIE32_LAST_FP_ARG_REGNUM)
+	{
+	  if (brownie32_abi_regsize (gdbarch) < 8 && len == 8)
+	    {
+	      int low_offset = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? 4 : 0;
+	      unsigned long regval;
+
+	      /* Write the low word of the double to the even register(s).  */
+	      regval = extract_unsigned_integer (val + low_offset, 4);
+	      if (brownie32_debug)
+		fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
+				    float_argreg, phex (regval, 4));
+	      write_register (float_argreg++, regval);
+
+	      /* Write the high word of the double to the odd register(s).  */
+	      regval = extract_unsigned_integer (val + 4 - low_offset, 4);
+	      if (brownie32_debug)
+		fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
+				    float_argreg, phex (regval, 4));
+	      write_register (float_argreg++, regval);
+	    }
+	  else
+	    {
+	      /* This is a floating point value that fits entirely
+	         in a single register.  */
+	      /* On 32 bit ABI's the float_argreg is further adjusted
+	         above to ensure that it is even register aligned.  */
+	      LONGEST regval = extract_unsigned_integer (val, len);
+	      if (brownie32_debug)
+		fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
+				    float_argreg, phex (regval, len));
+	      write_register (float_argreg++, regval);
+	    }
+	}
+      else
+	{
+	  /* Copy the argument to general registers or the stack in
+	     register-sized pieces.  Large arguments are split between
+	     registers and stack.  */
+	  /* Note: structs whose size is not a multiple of
+	     brownie32_abi_regsize() are treated specially: Irix cc passes
+	     them in registers where gcc sometimes puts them on the
+	     stack.  For maximum compatibility, we will put them in
+	     both places.  */
+	  int odd_sized_struct = ((len > brownie32_abi_regsize (gdbarch))
+				  && (len % brownie32_abi_regsize (gdbarch) != 0));
+
+	  /* Note: Floating-point values that didn't fit into an FP
+	     register are only written to memory.  */
+	  while (len > 0)
+	    {
+	      /* Remember if the argument was written to the stack.  */
+	      int stack_used_p = 0;
+	      int partial_len = (len < brownie32_abi_regsize (gdbarch)
+				 ? len : brownie32_abi_regsize (gdbarch));
+
+	      if (brownie32_debug)
+		fprintf_unfiltered (gdb_stdlog, " -- partial=%d",
+				    partial_len);
+
+	      /* Write this portion of the argument to the stack.  */
+	      if (argreg > BROWNIE32_LAST_ARG_REGNUM
+		  || odd_sized_struct
+		  || fp_register_arg_p (typecode, arg_type))
+		{
+		  /* Should shorter than int integer values be
+		     promoted to int before being stored? */
+		  int longword_offset = 0;
+		  CORE_ADDR addr;
+		  stack_used_p = 1;
+		  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
+		    {
+		      if (brownie32_stack_argsize (gdbarch) == 8
+			  && (typecode == TYPE_CODE_INT
+			      || typecode == TYPE_CODE_PTR
+			      || typecode == TYPE_CODE_FLT) && len <= 4)
+			longword_offset = brownie32_stack_argsize (gdbarch) - len;
+		      else if ((typecode == TYPE_CODE_STRUCT
+				|| typecode == TYPE_CODE_UNION)
+			       && (TYPE_LENGTH (arg_type)
+				   < brownie32_stack_argsize (gdbarch)))
+			longword_offset = brownie32_stack_argsize (gdbarch) - len;
+		    }
+
+		  if (brownie32_debug)
+		    {
+		      fprintf_unfiltered (gdb_stdlog, " - stack_offset=0x%s",
+					  paddr_nz (stack_offset));
+		      fprintf_unfiltered (gdb_stdlog, " longword_offset=0x%s",
+					  paddr_nz (longword_offset));
+		    }
+
+		  addr = sp + stack_offset + longword_offset;
+
+		  if (brownie32_debug)
+		    {
+		      int i;
+		      fprintf_unfiltered (gdb_stdlog, " @0x%s ",
+					  paddr_nz (addr));
+		      for (i = 0; i < partial_len; i++)
+			{
+			  fprintf_unfiltered (gdb_stdlog, "%02x",
+					      val[i] & 0xff);
+			}
+		    }
+		  write_memory (addr, val, partial_len);
+		}
+
+	      /* Note!!! This is NOT an else clause.  Odd sized
+	         structs may go thru BOTH paths.  Floating point
+	         arguments will not.  */
+	      /* Write this portion of the argument to a general
+	         purpose register.  */
+	      if (argreg <= BROWNIE32_LAST_ARG_REGNUM
+		  && !fp_register_arg_p (typecode, arg_type))
+		{
+		  LONGEST regval =
+		    extract_unsigned_integer (val, partial_len);
+
+		  if (brownie32_debug)
+		    fprintf_filtered (gdb_stdlog, " - reg=%d val=%s",
+				      argreg,
+				      phex (regval,
+					    brownie32_abi_regsize (gdbarch)));
+		  write_register (argreg, regval);
+		  argreg++;
+		}
+
+	      len -= partial_len;
+	      val += partial_len;
+
+	      /* Compute the the offset into the stack at which we
+	         will copy the next parameter.
+
+	         In the new EABI (and the NABI32), the stack_offset
+	         only needs to be adjusted when it has been used.  */
+
+	      if (stack_used_p)
+		stack_offset += align_up (partial_len,
+					  brownie32_stack_argsize (gdbarch));
+	    }
+	}
+      if (brownie32_debug)
+	fprintf_unfiltered (gdb_stdlog, "\n");
+    }
+
+  regcache_cooked_write_signed (regcache, BROWNIE32_SP_REGNUM, sp);
+
+  /* Return adjusted stack pointer.  */
+  return sp;
+}
+
+/* Determin the return value convention being used.  */
+
+static enum return_value_convention
+brownie32_eabi_return_value (struct gdbarch *gdbarch,
+			struct type *type, struct regcache *regcache,
+			gdb_byte *readbuf, const gdb_byte *writebuf)
+{
+  if (TYPE_LENGTH (type) > 2 * brownie32_abi_regsize (gdbarch))
+    return RETURN_VALUE_STRUCT_CONVENTION;
+  if (readbuf)
+    memset (readbuf, 0, TYPE_LENGTH (type));
+  return RETURN_VALUE_REGISTER_CONVENTION;
+}
+
+
+/* N32/N64 ABI stuff.  */
+
+static CORE_ADDR
+brownie32_n32n64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
+			     struct regcache *regcache, CORE_ADDR bp_addr,
+			     int nargs, struct value **args, CORE_ADDR sp,
+			     int struct_return, CORE_ADDR struct_addr)
+{
+  int argreg;
+  int float_argreg;
+  int argnum;
+  int len = 0;
+  int stack_offset = 0;
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  CORE_ADDR func_addr = find_function_addr (function, NULL);
+
+  /* For shared libraries, "t9" needs to point at the function
+     address.  */
+//  regcache_cooked_write_signed (regcache, BROWNIE32_T9_REGNUM, func_addr);
+
+  /* Set the return address register to point to the entry point of
+     the program, where a breakpoint lies in wait.  */
+  regcache_cooked_write_signed (regcache, BROWNIE32_LNK_REGNUM, bp_addr);
+
+  /* First ensure that the stack and structure return address (if any)
+     are properly aligned.  The stack has to be at least 64-bit
+     aligned even on 32-bit machines, because doubles must be 64-bit
+     aligned.  For n32 and n64, stack frames need to be 128-bit
+     aligned, so we round to this widest known alignment.  */
+
+  sp = align_down (sp, 16);
+  struct_addr = align_down (struct_addr, 16);
+
+  /* Now make space on the stack for the args.  */
+  for (argnum = 0; argnum < nargs; argnum++)
+    len += align_up (TYPE_LENGTH (value_type (args[argnum])),
+		     brownie32_stack_argsize (gdbarch));
+  sp -= align_up (len, 16);
+
+  if (brownie32_debug)
+    fprintf_unfiltered (gdb_stdlog,
+			"brownie32_n32n64_push_dummy_call: sp=0x%s allocated %ld\n",
+			paddr_nz (sp), (long) align_up (len, 16));
+
+  /* The struct_return pointer occupies the first parameter-passing reg.  */
+  if (struct_return)
+    {
+      if (brownie32_debug)
+	fprintf_unfiltered (gdb_stdlog,
+			    "brownie32_n32n64_push_dummy_call: struct_return reg=%d 0x%s\n",
+			    argreg, paddr_nz (struct_addr));
+      write_register (argreg++, struct_addr);
+    }
+
+  /* Now load as many as possible of the first arguments into
+     registers, and push the rest onto the stack.  Loop thru args
+     from first to last.  */
+  for (argnum = 0; argnum < nargs; argnum++)
+    {
+      const gdb_byte *val;
+      struct value *arg = args[argnum];
+      struct type *arg_type = check_typedef (value_type (arg));
+      int len = TYPE_LENGTH (arg_type);
+      enum type_code typecode = TYPE_CODE (arg_type);
+
+      if (brownie32_debug)
+	fprintf_unfiltered (gdb_stdlog,
+			    "brownie32_n32n64_push_dummy_call: %d len=%d type=%d",
+			    argnum + 1, len, (int) typecode);
+
+      val = value_contents (arg);
+
+      if (fp_register_arg_p (typecode, arg_type)
+	  && float_argreg <= BROWNIE32_LAST_FP_ARG_REGNUM)
+	{
+	  /* This is a floating point value that fits entirely
+	     in a single register.  */
+	  /* On 32 bit ABI's the float_argreg is further adjusted
+	     above to ensure that it is even register aligned.  */
+	  LONGEST regval = extract_unsigned_integer (val, len);
+	  if (brownie32_debug)
+	    fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
+				float_argreg, phex (regval, len));
+	  write_register (float_argreg++, regval);
+
+	  if (brownie32_debug)
+	    fprintf_unfiltered (gdb_stdlog, " - reg=%d val=%s",
+				argreg, phex (regval, len));
+	  write_register (argreg, regval);
+	  argreg += 1;
+	}
+      else
+	{
+	  /* Copy the argument to general registers or the stack in
+	     register-sized pieces.  Large arguments are split between
+	     registers and stack.  */
+	  /* Note: structs whose size is not a multiple of
+	     brownie32_abi_regsize() are treated specially: Irix cc passes
+	     them in registers where gcc sometimes puts them on the
+	     stack.  For maximum compatibility, we will put them in
+	     both places.  */
+	  int odd_sized_struct = ((len > brownie32_abi_regsize (gdbarch))
+				  && (len % brownie32_abi_regsize (gdbarch) != 0));
+	  /* Note: Floating-point values that didn't fit into an FP
+	     register are only written to memory.  */
+	  while (len > 0)
+	    {
+	      /* Rememer if the argument was written to the stack.  */
+	      int stack_used_p = 0;
+	      int partial_len = (len < brownie32_abi_regsize (gdbarch)
+				 ? len : brownie32_abi_regsize (gdbarch));
+
+	      if (brownie32_debug)
+		fprintf_unfiltered (gdb_stdlog, " -- partial=%d",
+				    partial_len);
+
+	      /* Write this portion of the argument to the stack.  */
+	      if (argreg > BROWNIE32_LAST_ARG_REGNUM
+		  || odd_sized_struct
+		  || fp_register_arg_p (typecode, arg_type))
+		{
+		  /* Should shorter than int integer values be
+		     promoted to int before being stored? */
+		  int longword_offset = 0;
+		  CORE_ADDR addr;
+		  stack_used_p = 1;
+		  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
+		    {
+		      if (brownie32_stack_argsize (gdbarch) == 8
+			  && (typecode == TYPE_CODE_INT
+			      || typecode == TYPE_CODE_PTR
+			      || typecode == TYPE_CODE_FLT) && len <= 4)
+			longword_offset = brownie32_stack_argsize (gdbarch) - len;
+		    }
+
+		  if (brownie32_debug)
+		    {
+		      fprintf_unfiltered (gdb_stdlog, " - stack_offset=0x%s",
+					  paddr_nz (stack_offset));
+		      fprintf_unfiltered (gdb_stdlog, " longword_offset=0x%s",
+					  paddr_nz (longword_offset));
+		    }
+
+		  addr = sp + stack_offset + longword_offset;
+
+		  if (brownie32_debug)
+		    {
+		      int i;
+		      fprintf_unfiltered (gdb_stdlog, " @0x%s ",
+					  paddr_nz (addr));
+		      for (i = 0; i < partial_len; i++)
+			{
+			  fprintf_unfiltered (gdb_stdlog, "%02x",
+					      val[i] & 0xff);
+			}
+		    }
+		  write_memory (addr, val, partial_len);
+		}
+
+	      /* Note!!! This is NOT an else clause.  Odd sized
+	         structs may go thru BOTH paths.  Floating point
+	         arguments will not.  */
+	      /* Write this portion of the argument to a general
+	         purpose register.  */
+	      if (argreg <= BROWNIE32_LAST_ARG_REGNUM
+		  && !fp_register_arg_p (typecode, arg_type))
+		{
+		  LONGEST regval =
+		    extract_unsigned_integer (val, partial_len);
+
+		  /* A non-floating-point argument being passed in a
+		     general register.  If a struct or union, and if
+		     the remaining length is smaller than the register
+		     size, we have to adjust the register value on
+		     big endian targets.
+
+		     It does not seem to be necessary to do the
+		     same for integral types.
+
+		     cagney/2001-07-23: gdb/179: Also, GCC, when
+		     outputting LE O32 with sizeof (struct) <
+		     brownie32_abi_regsize(), generates a left shift as
+		     part of storing the argument in a register a
+		     register (the left shift isn't generated when
+		     sizeof (struct) >= brownie32_abi_regsize()).  Since
+		     it is quite possible that this is GCC
+		     contradicting the LE/O32 ABI, GDB has not been
+		     adjusted to accommodate this.  Either someone
+		     needs to demonstrate that the LE/O32 ABI
+		     specifies such a left shift OR this new ABI gets
+		     identified as such and GDB gets tweaked
+		     accordingly.  */
+
+		  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
+		      && partial_len < brownie32_abi_regsize (gdbarch)
+		      && (typecode == TYPE_CODE_STRUCT ||
+			  typecode == TYPE_CODE_UNION))
+		    regval <<= ((brownie32_abi_regsize (gdbarch) - partial_len) *
+				TARGET_CHAR_BIT);
+
+		  if (brownie32_debug)
+		    fprintf_filtered (gdb_stdlog, " - reg=%d val=%s",
+				      argreg,
+				      phex (regval,
+					    brownie32_abi_regsize (gdbarch)));
+		  write_register (argreg, regval);
+		  argreg++;
+		}
+
+	      len -= partial_len;
+	      val += partial_len;
+
+	      /* Compute the the offset into the stack at which we
+	         will copy the next parameter.
+
+	         In N32 (N64?), the stack_offset only needs to be
+	         adjusted when it has been used.  */
+
+	      if (stack_used_p)
+		stack_offset += align_up (partial_len,
+					  brownie32_stack_argsize (gdbarch));
+	    }
+	}
+      if (brownie32_debug)
+	fprintf_unfiltered (gdb_stdlog, "\n");
+    }
+
+  regcache_cooked_write_signed (regcache, BROWNIE32_SP_REGNUM, sp);
+
+  /* Return adjusted stack pointer.  */
+  return sp;
+}
+
+static enum return_value_convention
+brownie32_n32n64_return_value (struct gdbarch *gdbarch,
+			  struct type *type, struct regcache *regcache,
+			  gdb_byte *readbuf, const gdb_byte *writebuf)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
+  if (TYPE_CODE (type) == TYPE_CODE_STRUCT
+      || TYPE_CODE (type) == TYPE_CODE_UNION
+      || TYPE_CODE (type) == TYPE_CODE_ARRAY
+      || TYPE_LENGTH (type) > 2 * brownie32_abi_regsize (gdbarch))
+    return RETURN_VALUE_STRUCT_CONVENTION;
+  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT
+	   || TYPE_CODE (type) == TYPE_CODE_UNION)
+    {
+      /* A structure or union.  Extract the left justified value,
+         regardless of the byte order.  I.e. DO NOT USE
+         brownie32_xfer_lower.  */
+      int offset;
+      int regnum;
+      return RETURN_VALUE_REGISTER_CONVENTION;
+    }
+  else
+    {
+      /* A scalar extract each part but least-significant-byte
+         justified.  */
+      int offset;
+      int regnum;
+      return RETURN_VALUE_REGISTER_CONVENTION;
+    }
+}
+
+/* O32 ABI stuff.  */
+
+static CORE_ADDR
+brownie32_o32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
+			  struct regcache *regcache, CORE_ADDR bp_addr,
+			  int nargs, struct value **args, CORE_ADDR sp,
+			  int struct_return, CORE_ADDR struct_addr)
+{
+  int argreg;
+  int float_argreg;
+  int argnum;
+  int len = 0;
+  int stack_offset = 0;
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  CORE_ADDR func_addr = find_function_addr (function, NULL);
+
+  /* For shared libraries, "t9" needs to point at the function
+     address.  */
+//  regcache_cooked_write_signed (regcache, BROWNIE32_T9_REGNUM, func_addr);
+
+  /* Set the return address register to point to the entry point of
+     the program, where a breakpoint lies in wait.  */
+  regcache_cooked_write_signed (regcache, BROWNIE32_LNK_REGNUM, bp_addr);
+
+  /* First ensure that the stack and structure return address (if any)
+     are properly aligned.  The stack has to be at least 64-bit
+     aligned even on 32-bit machines, because doubles must be 64-bit
+     aligned.  For n32 and n64, stack frames need to be 128-bit
+     aligned, so we round to this widest known alignment.  */
+
+  sp = align_down (sp, 16);
+  struct_addr = align_down (struct_addr, 16);
+
+  /* Now make space on the stack for the args.  */
+  for (argnum = 0; argnum < nargs; argnum++)
+    len += align_up (TYPE_LENGTH (value_type (args[argnum])),
+		     brownie32_stack_argsize (gdbarch));
+  sp -= align_up (len, 16);
+
+  if (brownie32_debug)
+    fprintf_unfiltered (gdb_stdlog,
+			"brownie32_o32_push_dummy_call: sp=0x%s allocated %ld\n",
+			paddr_nz (sp), (long) align_up (len, 16));
+
+  /* The struct_return pointer occupies the first parameter-passing reg.  */
+  if (struct_return)
+    {
+      if (brownie32_debug)
+	fprintf_unfiltered (gdb_stdlog,
+			    "brownie32_o32_push_dummy_call: struct_return reg=%d 0x%s\n",
+			    argreg, paddr_nz (struct_addr));
+      write_register (argreg++, struct_addr);
+      stack_offset += brownie32_stack_argsize (gdbarch);
+    }
+
+  /* Now load as many as possible of the first arguments into
+     registers, and push the rest onto the stack.  Loop thru args
+     from first to last.  */
+  for (argnum = 0; argnum < nargs; argnum++)
+    {
+      const gdb_byte *val;
+      struct value *arg = args[argnum];
+      struct type *arg_type = check_typedef (value_type (arg));
+      int len = TYPE_LENGTH (arg_type);
+      enum type_code typecode = TYPE_CODE (arg_type);
+
+      if (brownie32_debug)
+	fprintf_unfiltered (gdb_stdlog,
+			    "brownie32_o32_push_dummy_call: %d len=%d type=%d",
+			    argnum + 1, len, (int) typecode);
+
+      val = value_contents (arg);
+
+      /* 32-bit ABIs always start floating point arguments in an
+         even-numbered floating point register.  Round the FP register
+         up before the check to see if there are any FP registers
+         left.  O32/O64 targets also pass the FP in the integer
+         registers so also round up normal registers.  */
+      if (brownie32_abi_regsize (gdbarch) < 8
+	  && fp_register_arg_p (typecode, arg_type))
+	{
+	  if ((float_argreg & 1))
+	    float_argreg++;
+	}
+
+      /* Floating point arguments passed in registers have to be
+         treated specially.  On 32-bit architectures, doubles
+         are passed in register pairs; the even register gets
+         the low word, and the odd register gets the high word.
+         On O32/O64, the first two floating point arguments are
+         also copied to general registers, because BROWNIE3216 functions
+         don't use float registers for arguments.  This duplication of
+         arguments in general registers can't hurt non-BROWNIE3216 functions
+         because those registers are normally skipped.  */
+
+      if (fp_register_arg_p (typecode, arg_type)
+	  && float_argreg <= BROWNIE32_LAST_FP_ARG_REGNUM)
+	{
+	  if (brownie32_abi_regsize (gdbarch) < 8 && len == 8)
+	    {
+	      int low_offset = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? 4 : 0;
+	      unsigned long regval;
+
+	      /* Write the low word of the double to the even register(s).  */
+	      regval = extract_unsigned_integer (val + low_offset, 4);
+	      if (brownie32_debug)
+		fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
+				    float_argreg, phex (regval, 4));
+	      write_register (float_argreg++, regval);
+	      if (brownie32_debug)
+		fprintf_unfiltered (gdb_stdlog, " - reg=%d val=%s",
+				    argreg, phex (regval, 4));
+	      write_register (argreg++, regval);
+
+	      /* Write the high word of the double to the odd register(s).  */
+	      regval = extract_unsigned_integer (val + 4 - low_offset, 4);
+	      if (brownie32_debug)
+		fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
+				    float_argreg, phex (regval, 4));
+	      write_register (float_argreg++, regval);
+
+	      if (brownie32_debug)
+		fprintf_unfiltered (gdb_stdlog, " - reg=%d val=%s",
+				    argreg, phex (regval, 4));
+	      write_register (argreg++, regval);
+	    }
+	  else
+	    {
+	      /* This is a floating point value that fits entirely
+	         in a single register.  */
+	      /* On 32 bit ABI's the float_argreg is further adjusted
+	         above to ensure that it is even register aligned.  */
+	      LONGEST regval = extract_unsigned_integer (val, len);
+	      if (brownie32_debug)
+		fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
+				    float_argreg, phex (regval, len));
+	      write_register (float_argreg++, regval);
+	      /* CAGNEY: 32 bit BROWNIE32 ABI's always reserve two FP
+	         registers for each argument.  The below is (my
+	         guess) to ensure that the corresponding integer
+	         register has reserved the same space.  */
+	      if (brownie32_debug)
+		fprintf_unfiltered (gdb_stdlog, " - reg=%d val=%s",
+				    argreg, phex (regval, len));
+	      write_register (argreg, regval);
+	      argreg += (brownie32_abi_regsize (gdbarch) == 8) ? 1 : 2;
+	    }
+	  /* Reserve space for the FP register.  */
+	  stack_offset += align_up (len, brownie32_stack_argsize (gdbarch));
+	}
+      else
+	{
+	  /* Copy the argument to general registers or the stack in
+	     register-sized pieces.  Large arguments are split between
+	     registers and stack.  */
+	  /* Note: structs whose size is not a multiple of
+	     brownie32_abi_regsize() are treated specially: Irix cc passes
+	     them in registers where gcc sometimes puts them on the
+	     stack.  For maximum compatibility, we will put them in
+	     both places.  */
+	  int odd_sized_struct = ((len > brownie32_abi_regsize (gdbarch))
+				  && (len % brownie32_abi_regsize (gdbarch) != 0));
+	  /* Structures should be aligned to eight bytes (even arg registers)
+	     on BROWNIE32_ABI_O32, if their first member has double precision.  */
+	  if (brownie32_abi_regsize (gdbarch) < 8
+	      && brownie32_type_needs_double_align (arg_type))
+	    {
+	      if ((argreg & 1))
+		argreg++;
+	    }
+	  /* Note: Floating-point values that didn't fit into an FP
+	     register are only written to memory.  */
+	  while (len > 0)
+	    {
+	      /* Remember if the argument was written to the stack.  */
+	      int stack_used_p = 0;
+	      int partial_len = (len < brownie32_abi_regsize (gdbarch)
+				 ? len : brownie32_abi_regsize (gdbarch));
+
+	      if (brownie32_debug)
+		fprintf_unfiltered (gdb_stdlog, " -- partial=%d",
+				    partial_len);
+
+	      /* Write this portion of the argument to the stack.  */
+	      if (argreg > BROWNIE32_LAST_ARG_REGNUM
+		  || odd_sized_struct
+		  || fp_register_arg_p (typecode, arg_type))
+		{
+		  /* Should shorter than int integer values be
+		     promoted to int before being stored? */
+		  int longword_offset = 0;
+		  CORE_ADDR addr;
+		  stack_used_p = 1;
+		  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
+		    {
+		      if (brownie32_stack_argsize (gdbarch) == 8
+			  && (typecode == TYPE_CODE_INT
+			      || typecode == TYPE_CODE_PTR
+			      || typecode == TYPE_CODE_FLT) && len <= 4)
+			longword_offset = brownie32_stack_argsize (gdbarch) - len;
+		    }
+
+		  if (brownie32_debug)
+		    {
+		      fprintf_unfiltered (gdb_stdlog, " - stack_offset=0x%s",
+					  paddr_nz (stack_offset));
+		      fprintf_unfiltered (gdb_stdlog, " longword_offset=0x%s",
+					  paddr_nz (longword_offset));
+		    }
+
+		  addr = sp + stack_offset + longword_offset;
+
+		  if (brownie32_debug)
+		    {
+		      int i;
+		      fprintf_unfiltered (gdb_stdlog, " @0x%s ",
+					  paddr_nz (addr));
+		      for (i = 0; i < partial_len; i++)
+			{
+			  fprintf_unfiltered (gdb_stdlog, "%02x",
+					      val[i] & 0xff);
+			}
+		    }
+		  write_memory (addr, val, partial_len);
+		}
+
+	      /* Note!!! This is NOT an else clause.  Odd sized
+	         structs may go thru BOTH paths.  Floating point
+	         arguments will not.  */
+	      /* Write this portion of the argument to a general
+	         purpose register.  */
+	      if (argreg <= BROWNIE32_LAST_ARG_REGNUM
+		  && !fp_register_arg_p (typecode, arg_type))
+		{
+		  LONGEST regval = extract_signed_integer (val, partial_len);
+		  /* Value may need to be sign extended, because
+		     brownie32_isa_regsize() != brownie32_abi_regsize().  */
+
+		  /* A non-floating-point argument being passed in a
+		     general register.  If a struct or union, and if
+		     the remaining length is smaller than the register
+		     size, we have to adjust the register value on
+		     big endian targets.
+
+		     It does not seem to be necessary to do the
+		     same for integral types.
+
+		     Also don't do this adjustment on O64 binaries.
+
+		     cagney/2001-07-23: gdb/179: Also, GCC, when
+		     outputting LE O32 with sizeof (struct) <
+		     brownie32_abi_regsize(), generates a left shift as
+		     part of storing the argument in a register a
+		     register (the left shift isn't generated when
+		     sizeof (struct) >= brownie32_abi_regsize()).  Since
+		     it is quite possible that this is GCC
+		     contradicting the LE/O32 ABI, GDB has not been
+		     adjusted to accommodate this.  Either someone
+		     needs to demonstrate that the LE/O32 ABI
+		     specifies such a left shift OR this new ABI gets
+		     identified as such and GDB gets tweaked
+		     accordingly.  */
+
+		  if (brownie32_abi_regsize (gdbarch) < 8
+		      && TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
+		      && partial_len < brownie32_abi_regsize (gdbarch)
+		      && (typecode == TYPE_CODE_STRUCT ||
+			  typecode == TYPE_CODE_UNION))
+		    regval <<= ((brownie32_abi_regsize (gdbarch) - partial_len) *
+				TARGET_CHAR_BIT);
+
+		  if (brownie32_debug)
+		    fprintf_filtered (gdb_stdlog, " - reg=%d val=%s",
+				      argreg,
+				      phex (regval,
+					    brownie32_abi_regsize (gdbarch)));
+		  write_register (argreg, regval);
+		  argreg++;
+
+		  /* Prevent subsequent floating point arguments from
+		     being passed in floating point registers.  */
+		  float_argreg = BROWNIE32_LAST_FP_ARG_REGNUM + 1;
+		}
+
+	      len -= partial_len;
+	      val += partial_len;
+
+	      /* Compute the the offset into the stack at which we
+	         will copy the next parameter.
+
+	         In older ABIs, the caller reserved space for
+	         registers that contained arguments.  This was loosely
+	         refered to as their "home".  Consequently, space is
+	         always allocated.  */
+
+	      stack_offset += align_up (partial_len,
+					brownie32_stack_argsize (gdbarch));
+	    }
+	}
+      if (brownie32_debug)
+	fprintf_unfiltered (gdb_stdlog, "\n");
+    }
+
+  regcache_cooked_write_signed (regcache, BROWNIE32_SP_REGNUM, sp);
+
+  /* Return adjusted stack pointer.  */
+  return sp;
+}
+
+static enum return_value_convention
+brownie32_o32_return_value (struct gdbarch *gdbarch, struct type *type,
+		       struct regcache *regcache,
+		       gdb_byte *readbuf, const gdb_byte *writebuf)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
+
+  if (TYPE_CODE (type) == TYPE_CODE_STRUCT
+      || TYPE_CODE (type) == TYPE_CODE_UNION
+      || TYPE_CODE (type) == TYPE_CODE_ARRAY)
+    return RETURN_VALUE_STRUCT_CONVENTION;
+  else
+    {
+      /* A scalar extract each part but least-significant-byte
+         justified.  o32 thinks registers are 4 byte, regardless of
+         the ISA.  brownie32_stack_argsize controls this.  */
+      int offset;
+      int regnum;
+      return RETURN_VALUE_REGISTER_CONVENTION;
+    }
+}
+
+static void
+brownie32_print_fp_register (struct ui_file *file, struct frame_info *frame,
+			int regnum)
+{				/* do values for FP (float) regs */
+  gdb_byte *raw_buffer;
+  double doub, flt1;	/* doubles extracted from raw hex data */
+  int inv1, inv2;
+}
+
+static void
+brownie32_print_register (struct ui_file *file, struct frame_info *frame,
+		     int regnum, int all)
+{
+  struct gdbarch *gdbarch = get_frame_arch (frame);
+  gdb_byte raw_buffer[MAX_REGISTER_SIZE];
+  int offset;
+  if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) == TYPE_CODE_FLT)
+    {
+      brownie32_print_fp_register (file, frame, regnum);
+      return;
+    }
+
+  /* Get the data in raw format.  */
+  if (!frame_register_read (frame, regnum, raw_buffer))
+    {
+      fprintf_filtered (file, "%s: [Invalid]", REGISTER_NAME (regnum));
+      return;
+    }
+
+  fputs_filtered (REGISTER_NAME (regnum), file);
+
+  /* The problem with printing numeric register names (r26, etc.) is that
+     the user can't use them on input.  Probably the best solution is to
+     fix it so that either the numeric or the funky (a2, etc.) names
+     are accepted on input.  */
+  if (regnum < BROWNIE32_NUMREGS)
+    fprintf_filtered (file, "(r%d): ", regnum);
+  else
+    fprintf_filtered (file, ": ");
+
+  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
+    offset =
+      register_size (current_gdbarch,
+		     regnum) - register_size (current_gdbarch, regnum);
+  else
+    offset = 0;
+
+  print_scalar_formatted (raw_buffer + offset,
+			  gdbarch_register_type (gdbarch, regnum), 'x', 0,
+			  file);
+}
+
+/* Replacement for generic do_registers_info.
+   Print regs in pretty columns.  */
+
+static int
+print_fp_register_row (struct ui_file *file, struct frame_info *frame,
+		       int regnum)
+{
+  fprintf_filtered (file, " ");
+  brownie32_print_fp_register (file, frame, regnum);
+  fprintf_filtered (file, "\n");
+  return regnum + 1;
+}
+
+
+/* Print a row's worth of GP (int) registers, with name labels above */
+
+static int
+print_gp_register_row (struct ui_file *file, struct frame_info *frame,
+		       int start_regnum)
+{
+  struct gdbarch *gdbarch = get_frame_arch (frame);
+  /* do values for GP (int) regs */
+  gdb_byte raw_buffer[MAX_REGISTER_SIZE];
+  int ncols = (brownie32_abi_regsize (gdbarch) == 8 ? 4 : 8);	/* display cols per row */
+  int col, byte;
+  int regnum;
+
+  /* For GP registers, we print a separate row of names above the vals */
+  fprintf_filtered (file, "     ");
+  for (col = 0, regnum = start_regnum;
+       col < ncols && regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
+    {
+      if (*REGISTER_NAME (regnum) == '\0')
+	continue;		/* unused register */
+      if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) ==
+	  TYPE_CODE_FLT)
+	break;			/* end the row: reached FP register */
+      fprintf_filtered (file,
+			brownie32_abi_regsize (current_gdbarch) == 8 ? "%17s" : "%9s",
+			REGISTER_NAME (regnum));
+      col++;
+    }
+  /* print the R0 to R31 names */
+  if ((start_regnum % NUM_REGS) < BROWNIE32_NUMREGS)
+    fprintf_filtered (file, "\n R%-4d", start_regnum % NUM_REGS);
+  else
+    fprintf_filtered (file, "\n      ");
+
+  /* now print the values in hex, 4 or 8 to the row */
+  for (col = 0, regnum = start_regnum;
+       col < ncols && regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
+    {
+      if (*REGISTER_NAME (regnum) == '\0')
+	continue;		/* unused register */
+      if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) ==
+	  TYPE_CODE_FLT)
+	break;			/* end row: reached FP register */
+      /* OK: get the data in raw format.  */
+      if (!frame_register_read (frame, regnum, raw_buffer))
+	error (_("can't read register %d (%s)"), regnum, REGISTER_NAME (regnum));
+      /* pad small registers */
+      for (byte = 0;
+	   byte < (brownie32_abi_regsize (current_gdbarch)
+		   - register_size (current_gdbarch, regnum)); byte++)
+	printf_filtered ("  ");
+      /* Now print the register value in hex, endian order. */
+      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
+	for (byte =
+	     register_size (current_gdbarch,
+			    regnum) - register_size (current_gdbarch, regnum);
+	     byte < register_size (current_gdbarch, regnum); byte++)
+	  fprintf_filtered (file, "%02x", raw_buffer[byte]);
+      else
+	for (byte = register_size (current_gdbarch, regnum) - 1;
+	     byte >= 0; byte--)
+	  fprintf_filtered (file, "%02x", raw_buffer[byte]);
+      fprintf_filtered (file, " ");
+      col++;
+    }
+  if (col > 0)			/* ie. if we actually printed anything... */
+    fprintf_filtered (file, "\n");
+
+  return regnum;
+}
+
+/* BROWNIE32_DO_REGISTERS_INFO(): called by "info register" command */
+
+static void
+brownie32_print_registers_info (struct gdbarch *gdbarch, struct ui_file *file,
+			   struct frame_info *frame, int regnum, int all)
+{
+  if (regnum != -1)		/* do one specified register */
+    {
+      gdb_assert (regnum >= NUM_REGS);
+      if (*(REGISTER_NAME (regnum)) == '\0')
+	error (_("Not a valid register for the current processor type"));
+
+      brownie32_print_register (file, frame, regnum, 0);
+      fprintf_filtered (file, "\n");
+    }
+  else
+    /* do all (or most) registers */
+    {
+      regnum = NUM_REGS;
+      while (regnum < NUM_REGS + NUM_PSEUDO_REGS)
+	{
+	  if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) ==
+	      TYPE_CODE_FLT)
+	    {
+	      if (all)		/* true for "INFO ALL-REGISTERS" command */
+		regnum = print_fp_register_row (file, frame, regnum);
+	      else
+		regnum += BROWNIE32_NUMREGS;	/* skip floating point regs */
+	    }
+	  else
+	    regnum = print_gp_register_row (file, frame, regnum);
+	}
+    }
+}
+
+/* Is this a branch with a delay slot?  */
+#if 0
+static int
+is_delayed (unsigned long insn)
+{
+  int i;
+  for (i = 0; i < NUMOPCODES; ++i)
+    if (brownie32_opcodes[i].pinfo != INSN_MACRO
+	&& (insn & brownie32_opcodes[i].mask) == brownie32_opcodes[i].match)
+      break;
+  return (i < NUMOPCODES
+	  && (brownie32_opcodes[i].pinfo & (INSN_UNCOND_BRANCH_DELAY
+				       | INSN_COND_BRANCH_DELAY
+				       | INSN_COND_BRANCH_LIKELY)));
+}
+#endif
+
+int
+brownie32_single_step_through_delay (struct gdbarch *gdbarch,
+				struct frame_info *frame)
+{
+    return 0;
+}
+
+/* To skip prologues, I use this predicate.  Returns either PC itself
+   if the code at PC does not look like a function prologue; otherwise
+   returns an address that (if we're lucky) follows the prologue.  If
+   LENIENT, then we must skip everything which is involved in setting
+   up the frame (it's OK to skip more, just so long as we don't skip
+   anything which might clobber the registers which are being saved.
+   We must skip more in the case where part of the prologue is in the
+   delay slot of a non-prologue instruction).  */
+
+static CORE_ADDR
+brownie32_skip_prologue (CORE_ADDR pc)
+{
+  CORE_ADDR limit_pc;
+  CORE_ADDR func_addr;
+
+  /* See if we can determine the end of the prologue via the symbol table.
+     If so, then return either PC, or the PC after the prologue, whichever
+     is greater.  */
+  if (find_pc_partial_function (pc, NULL, &func_addr, NULL))
+    {
+      CORE_ADDR post_prologue_pc = skip_prologue_using_sal (func_addr);
+      if (post_prologue_pc != 0)
+	return max (pc, post_prologue_pc);
+    }
+
+  /* Can't determine prologue from the symbol table, need to examine
+     instructions.  */
+
+  /* Find an upper limit on the function prologue using the debug
+     information.  If the debug information could not be used to provide
+     that bound, then use an arbitrary large number as the upper bound.  */
+  limit_pc = skip_prologue_using_sal (pc);
+  if (limit_pc == 0)
+    limit_pc = pc + 100;          /* Magic.  */
+
+  return brownie32_scan_prologue (pc, limit_pc, NULL, NULL);
+}
+
+/* Root of all "set brownie32 "/"show brownie32 " commands. This will eventually be
+   used for all BROWNIE32-specific commands.  */
+
+static void
+show_brownie32_command (char *args, int from_tty)
+{
+  help_list (showbrownie32cmdlist, "show brownie32 ", all_commands, gdb_stdout);
+}
+
+static void
+set_brownie32_command (char *args, int from_tty)
+{
+  printf_unfiltered
+    ("\"set brownie32\" must be followed by an appropriate subcommand.\n");
+  help_list (setbrownie32cmdlist, "set brownie32 ", all_commands, gdb_stdout);
+}
+
+/* Commands to show/set the BROWNIE32 FPU type.  */
+
+static void
+show_brownie32fpu_command (char *args, int from_tty)
+{
+  char *fpu;
+  switch (BROWNIE32_FPU_TYPE)
+    {
+    case BROWNIE32_FPU_SINGLE:
+      fpu = "single-precision";
+      break;
+    case BROWNIE32_FPU_DOUBLE:
+      fpu = "double-precision";
+      break;
+    case BROWNIE32_FPU_NONE:
+      fpu = "absent (none)";
+      break;
+    default:
+      internal_error (__FILE__, __LINE__, _("bad switch"));
+    }
+  if (brownie32_fpu_type_auto)
+    printf_unfiltered
+      ("The BROWNIE32 floating-point coprocessor is set automatically (currently %s)\n",
+       fpu);
+  else
+    printf_unfiltered
+      ("The BROWNIE32 floating-point coprocessor is assumed to be %s\n", fpu);
+}
+
+
+static void
+set_brownie32fpu_command (char *args, int from_tty)
+{
+  printf_unfiltered
+    ("\"set brownie32fpu\" must be followed by \"double\", \"single\",\"none\" or \"auto\".\n");
+  show_brownie32fpu_command (args, from_tty);
+}
+
+static void
+set_brownie32fpu_single_command (char *args, int from_tty)
+{
+  struct gdbarch_info info;
+  gdbarch_info_init (&info);
+  brownie32_fpu_type = BROWNIE32_FPU_SINGLE;
+  brownie32_fpu_type_auto = 0;
+  /* FIXME: cagney/2003-11-15: Should be setting a field in "info"
+     instead of relying on globals.  Doing that would let generic code
+     handle the search for this specific architecture.  */
+  if (!gdbarch_update_p (info))
+    internal_error (__FILE__, __LINE__, _("set brownie32fpu failed"));
+}
+
+static void
+set_brownie32fpu_double_command (char *args, int from_tty)
+{
+  struct gdbarch_info info;
+  gdbarch_info_init (&info);
+  brownie32_fpu_type = BROWNIE32_FPU_DOUBLE;
+  brownie32_fpu_type_auto = 0;
+  /* FIXME: cagney/2003-11-15: Should be setting a field in "info"
+     instead of relying on globals.  Doing that would let generic code
+     handle the search for this specific architecture.  */
+  if (!gdbarch_update_p (info))
+    internal_error (__FILE__, __LINE__, _("set brownie32fpu failed"));
+}
+
+static void
+set_brownie32fpu_none_command (char *args, int from_tty)
+{
+  struct gdbarch_info info;
+  gdbarch_info_init (&info);
+  brownie32_fpu_type = BROWNIE32_FPU_NONE;
+  brownie32_fpu_type_auto = 0;
+  /* FIXME: cagney/2003-11-15: Should be setting a field in "info"
+     instead of relying on globals.  Doing that would let generic code
+     handle the search for this specific architecture.  */
+  if (!gdbarch_update_p (info))
+    internal_error (__FILE__, __LINE__, _("set brownie32fpu failed"));
+}
+
+static void
+set_brownie32fpu_auto_command (char *args, int from_tty)
+{
+  brownie32_fpu_type_auto = 1;
+}
+
+/* Attempt to identify the particular processor model by reading the
+   processor id.  NOTE: cagney/2003-11-15: Firstly it isn't clear that
+   the relevant processor still exists (it dates back to '94) and
+   secondly this is not the way to do this.  The processor type should
+   be set by forcing an architecture change.  */
+
+void
+deprecated_brownie32_set_processor_regs_hack (void)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
+  CORE_ADDR prid;
+
+  prid = read_register (BROWNIE32_PRID_REGNUM);
+
+#if 0   //Delete C.Katano
+  if ((prid & ~0xf) == 0x700)
+    tdep->brownie32_processor_reg_names = brownie32_r3041_reg_names;
+#endif
+}
+
+/* Just like reinit_frame_cache, but with the right arguments to be
+   callable as an sfunc.  */
+
+static void
+reinit_frame_cache_sfunc (char *args, int from_tty,
+			  struct cmd_list_element *c)
+{
+  reinit_frame_cache ();
+}
+
+static int
+gdb_print_insn_brownie32 (bfd_vma memaddr, struct disassemble_info *info)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
+
+  info->disassembler_options = "gpr-names=32";
+
+  /* Call the appropriate disassembler based on the target endian-ness.  */
+  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
+    return print_insn_big_brownie32 (memaddr, info);
+  else
+    return print_insn_little_brownie32 (memaddr, info);
+}
+
+/* This function implements the BREAKPOINT_FROM_PC macro.  It uses the program
+   counter value to determine whether a 16- or 32-bit breakpoint should be
+   used.  It returns a pointer to a string of bytes that encode a breakpoint
+   instruction, stores the length of the string to *lenptr, and adjusts pc
+   (if necessary) to point to the actual memory location where the
+   breakpoint should be inserted.  */
+
+static const gdb_byte *
+brownie32_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
+{
+  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
+    {
+#if 0
+      if (brownie32_pc_is_brownie3216 (*pcptr))
+	{
+	  static gdb_byte brownie3216_big_breakpoint[] = { 0xe8, 0xa5 };
+	  *pcptr = unmake_brownie3216_addr (*pcptr);
+	  *lenptr = sizeof (brownie3216_big_breakpoint);
+	  return brownie3216_big_breakpoint;
+	}
+      else
+#endif
+	{
+	  /* The IDT board uses an unusual breakpoint value, and
+	     sometimes gets confused when it sees the usual BROWNIE32
+	     breakpoint instruction.  */
+	  static gdb_byte big_breakpoint[] = { 0, 0, 0, 0xd };
+	  static gdb_byte pmon_big_breakpoint[] = { 0, 0, 0, 0xd };
+	  static gdb_byte idt_big_breakpoint[] = { 0, 0, 0, 0xd };
+
+	  *lenptr = sizeof (big_breakpoint);
+
+/*
+	  if (strcmp (target_shortname, "brownie32") == 0)
+	    return idt_big_breakpoint;
+	  else if (strcmp (target_shortname, "ddb") == 0
+		   || strcmp (target_shortname, "pmon") == 0
+		   || strcmp (target_shortname, "lsi") == 0)
+	    return pmon_big_breakpoint;
+	  else
+*/
+	    return big_breakpoint;
+	}
+    }
+  else
+    {
+#if 0   // C.Katano
+      if (brownie32_pc_is_brownie3216 (*pcptr))
+	{
+	  static gdb_byte brownie3216_little_breakpoint[] = { 0xa5, 0xe8 };
+	  *pcptr = unmake_brownie3216_addr (*pcptr);
+	  *lenptr = sizeof (brownie3216_little_breakpoint);
+	  return brownie3216_little_breakpoint;
+	}
+      else
+#endif
+	{
+	  static gdb_byte little_breakpoint[] = { 0xd, 0, 0, 0 };
+	  static gdb_byte pmon_little_breakpoint[] = { 0xd, 0, 0, 0 };
+	  static gdb_byte idt_little_breakpoint[] = { 0xd, 0, 0, 0 };
+
+	  *lenptr = sizeof (little_breakpoint);
+
+/*
+	  if (strcmp (target_shortname, "brownie32") == 0)
+	    return idt_little_breakpoint;
+	  else if (strcmp (target_shortname, "ddb") == 0
+		   || strcmp (target_shortname, "pmon") == 0
+		   || strcmp (target_shortname, "lsi") == 0)
+	    return pmon_little_breakpoint;
+	  else
+*/
+	    return little_breakpoint;
+	}
+    }
+}
+
+/* If PC is in a brownie3216 call or return stub, return the address of the target
+   PC, which is either the callee or the caller.  There are several
+   cases which must be handled:
+
+   * If the PC is in __brownie3216_ret_{d,s}f, this is a return stub and the
+   target PC is in $31 ($ra).
+   * If the PC is in __brownie3216_call_stub_{1..10}, this is a call stub
+   and the target PC is in $2.
+   * If the PC at the start of __brownie3216_call_stub_{s,d}f_{0..10}, i.e.
+   before the jal instruction, this is effectively a call stub
+   and the the target PC is in $2.  Otherwise this is effectively
+   a return stub and the target PC is in $18.
+
+   See the source code for the stubs in gcc/config/brownie32/brownie3216.S for
+   gory details.  */
+
+static CORE_ADDR
+brownie32_skip_trampoline_code (CORE_ADDR pc)
+{
+  char *name;
+  CORE_ADDR start_addr;
+
+//printf("DEBUG: brownie32_skip_trampoline_code \n");
+  /* Find the starting address and name of the function containing the PC.  */
+  if (find_pc_partial_function (pc, &name, &start_addr, NULL) == 0)
+    return 0;
+
+  /* If the PC is in __brownie3216_ret_{d,s}f, this is a return stub and the
+     target PC is in $31 ($ra).  */
+  if (strcmp (name, "__brownie3216_ret_sf") == 0
+      || strcmp (name, "__brownie3216_ret_df") == 0)
+    return read_signed_register (BROWNIE32_LNK_REGNUM);
+
+  if (strncmp (name, "__brownie3216_call_stub_", 19) == 0)
+    {
+      /* If the PC is in __brownie3216_call_stub_{1..10}, this is a call stub
+         and the target PC is in $2.  */
+      if (name[19] >= '0' && name[19] <= '9')
+	return read_signed_register (2);
+
+      /* If the PC at the start of __brownie3216_call_stub_{s,d}f_{0..10}, i.e.
+         before the jal instruction, this is effectively a call stub
+         and the the target PC is in $2.  Otherwise this is effectively
+         a return stub and the target PC is in $18.  */
+      else if (name[19] == 's' || name[19] == 'd')
+	{
+	  if (pc == start_addr)
+	    {
+	      /* Check if the target of the stub is a compiler-generated
+	         stub.  Such a stub for a function bar might have a name
+	         like __fn_stub_bar, and might look like this:
+	         mfc1    $4,$f13
+	         mfc1    $5,$f12
+	         mfc1    $6,$f15
+	         mfc1    $7,$f14
+	         la      $1,bar   (becomes a lui/addiu pair)
+	         jr      $1
+	         So scan down to the lui/addi and extract the target
+	         address from those two instructions.  */
+
+	      CORE_ADDR target_pc = read_signed_register (2);
+	      ULONGEST inst;
+	      int i;
+
+	      /* See if the name of the target function is  __fn_stub_*.  */
+	      if (find_pc_partial_function (target_pc, &name, NULL, NULL) ==
+		  0)
+		return target_pc;
+	      if (strncmp (name, "__fn_stub_", 10) != 0
+		  && strcmp (name, "etext") != 0
+		  && strcmp (name, "_etext") != 0)
+		return target_pc;
+
+	      /* Scan through this _fn_stub_ code for the lui/addiu pair.
+	         The limit on the search is arbitrarily set to 20
+	         instructions.  FIXME.  */
+	      for (i = 0, pc = 0; i < 20; i++, target_pc += BROWNIE32_INSN32_SIZE)
+		{
+		  inst = brownie32_fetch_instruction (target_pc);
+		  if ((inst & 0xffff0000) == 0x3c010000)	/* lui $at */
+		    pc = (inst << 16) & 0xffff0000;	/* high word */
+		  else if ((inst & 0xffff0000) == 0x24210000)	/* addiu $at */
+		    return pc | (inst & 0xffff);	/* low word */
+		}
+
+	      /* Couldn't find the lui/addui pair, so return stub address.  */
+	      return target_pc;
+	    }
+	  else
+	    /* This is the 'return' part of a call stub.  The return
+	       address is in $r18.  */
+	    return read_signed_register (18);
+	}
+    }
+  return 0;			/* not a stub */
+}
+
+/* Convert a dbx stab register number (from `r' declaration) to a GDB
+   [1 * NUM_REGS .. 2 * NUM_REGS) REGNUM.  */
+
+static int
+brownie32_stab_reg_to_regnum (int num)
+{
+  int regnum;
+  if (num >= 0 && num < 32)
+    regnum = num;
+  return NUM_REGS + regnum;
+}
+
+
+/* Convert a dwarf, dwarf2, or ecoff register number to a GDB [1 *
+   NUM_REGS .. 2 * NUM_REGS) REGNUM.  */
+
+static int
+brownie32_dwarf_dwarf2_ecoff_reg_to_regnum (int num)
+{
+  int regnum;
+  if (num >= 0 && num < 32)
+    regnum = num;
+  return NUM_REGS + regnum;
+}
+
+static int
+brownie32_register_sim_regno (int regnum)
+{
+  /* Only makes sense to supply raw registers.  */
+  gdb_assert (regnum >= 0 && regnum < NUM_REGS);
+  /* FIXME: cagney/2002-05-13: Need to look at the pseudo register to
+     decide if it is valid.  Should instead define a standard sim/gdb
+     register numbering scheme.  */
+  if (REGISTER_NAME (NUM_REGS + regnum) != NULL
+      && REGISTER_NAME (NUM_REGS + regnum)[0] != '\0')
+    return regnum;
+  else
+    return LEGACY_SIM_REGNO_IGNORE;
+}
+
+
+/* Convert an integer into an address.  By first converting the value
+   into a pointer and then extracting it signed, the address is
+   guarenteed to be correctly sign extended.  */
+
+static CORE_ADDR
+brownie32_integer_to_address (struct gdbarch *gdbarch,
+			 struct type *type, const gdb_byte *buf)
+{
+  gdb_byte *tmp = alloca (TYPE_LENGTH (builtin_type_void_data_ptr));
+  LONGEST val = unpack_long (type, buf);
+  store_signed_integer (tmp, TYPE_LENGTH (builtin_type_void_data_ptr), val);
+  return extract_signed_integer (tmp,
+				 TYPE_LENGTH (builtin_type_void_data_ptr));
+}
+
+static void
+brownie32_find_abi_section (bfd *abfd, asection *sect, void *obj)
+{
+  enum brownie32_abi *abip = (enum brownie32_abi *) obj;
+  const char *name = bfd_get_section_name (abfd, sect);
+
+  if (*abip != BROWNIE32_ABI_UNKNOWN)
+    return;
+
+  if (strncmp (name, ".mdebug.", 8) != 0)
+    return;
+
+  if (strcmp (name, ".mdebug.abi32") == 0)
+    *abip = BROWNIE32_ABI_O32;
+  else if (strcmp (name, ".mdebug.abiN32") == 0)
+    *abip = BROWNIE32_ABI_N32;
+/*
+  else if (strcmp (name, ".mdebug.abi64") == 0)
+    *abip = BROWNIE32_ABI_N64;
+  else if (strcmp (name, ".mdebug.abiO64") == 0)
+    *abip = BROWNIE32_ABI_O64;
+*/
+  else if (strcmp (name, ".mdebug.eabi32") == 0)
+    *abip = BROWNIE32_ABI_EABI32;
+  else if (strcmp (name, ".mdebug.eabi64") == 0)
+    *abip = BROWNIE32_ABI_EABI64;
+  else
+    warning (_("unsupported ABI %s."), name + 8);
+}
+
+static enum brownie32_abi
+global_brownie32_abi (void)
+{
+  int i;
+
+  for (i = 0; brownie32_abi_strings[i] != NULL; i++)
+    if (brownie32_abi_strings[i] == brownie32_abi_string)
+      return (enum brownie32_abi) i;
+
+  internal_error (__FILE__, __LINE__, _("unknown ABI string"));
+}
+
+static struct gdbarch *
+brownie32_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
+{
+  struct gdbarch *gdbarch;
+  struct gdbarch_tdep *tdep;
+  int elf_flags;
+  enum brownie32_abi brownie32_abi, found_abi, wanted_abi;
+  int num_regs;
+  enum brownie32_fpu_type fpu_type;
+
+  /* First of all, extract the elf_flags, if available.  */
+  if (info.abfd && bfd_get_flavour (info.abfd) == bfd_target_elf_flavour)
+    elf_flags = elf_elfheader (info.abfd)->e_flags;
+  else if (arches != NULL)
+    elf_flags = gdbarch_tdep (arches->gdbarch)->elf_flags;
+  else
+    elf_flags = 0;
+  if (gdbarch_debug)
+    fprintf_unfiltered (gdb_stdlog,
+			"brownie32_gdbarch_init: elf_flags = 0x%08x\n", elf_flags);
+
+  /* Check ELF_FLAGS to see if it specifies the ABI being used.  */
+  switch ((elf_flags & EF_BROWNIE32_ABI))
+    {
+    case E_BROWNIE32_ABI_O32:
+      found_abi = BROWNIE32_ABI_O32;
+      break;
+/*
+    case E_BROWNIE32_ABI_O64:
+      found_abi = BROWNIE32_ABI_O64;
+      break;
+*/
+    case E_BROWNIE32_ABI_EABI32:
+      found_abi = BROWNIE32_ABI_EABI32;
+      break;
+    case E_BROWNIE32_ABI_EABI64:
+      found_abi = BROWNIE32_ABI_EABI64;
+      break;
+    default:
+      if ((elf_flags & EF_BROWNIE32_ABI2))
+	found_abi = BROWNIE32_ABI_N32;
+      else
+	found_abi = BROWNIE32_ABI_UNKNOWN;
+      break;
+    }
+
+  /* GCC creates a pseudo-section whose name describes the ABI.  */
+  if (found_abi == BROWNIE32_ABI_UNKNOWN && info.abfd != NULL)
+    bfd_map_over_sections (info.abfd, brownie32_find_abi_section, &found_abi);
+
+  /* If we have no useful BFD information, use the ABI from the last
+     BROWNIE32 architecture (if there is one).  */
+  if (found_abi == BROWNIE32_ABI_UNKNOWN && info.abfd == NULL && arches != NULL)
+    found_abi = gdbarch_tdep (arches->gdbarch)->found_abi;
+
+  /* Try the architecture for any hint of the correct ABI.  */
+  if (found_abi == BROWNIE32_ABI_UNKNOWN
+      && info.bfd_arch_info != NULL
+      && info.bfd_arch_info->arch == bfd_arch_brownie32)
+    {
+      switch (info.bfd_arch_info->mach)
+	{
+#if 1  // C.Katano
+    case bfd_mach_brownie32_std:
+	  found_abi = BROWNIE32_ABI_EABI32;
+#endif
+	}
+    }
+
+  if (gdbarch_debug)
+    fprintf_unfiltered (gdb_stdlog, "brownie32_gdbarch_init: found_abi = %d\n",
+			found_abi);
+
+  /* What has the user specified from the command line?  */
+  wanted_abi = global_brownie32_abi ();
+  if (gdbarch_debug)
+    fprintf_unfiltered (gdb_stdlog, "brownie32_gdbarch_init: wanted_abi = %d\n",
+			wanted_abi);
+
+  /* Now that we have found what the ABI for this binary would be,
+     check whether the user is overriding it.  */
+  if (wanted_abi != BROWNIE32_ABI_UNKNOWN)
+    brownie32_abi = wanted_abi;
+  else if (found_abi != BROWNIE32_ABI_UNKNOWN)
+    brownie32_abi = found_abi;
+  else
+    brownie32_abi = BROWNIE32_ABI_O32;
+  if (gdbarch_debug)
+    fprintf_unfiltered (gdb_stdlog, "brownie32_gdbarch_init: brownie32_abi = %d\n",
+			brownie32_abi);
+
+  /* Also used when doing an architecture lookup.  */
+  if (gdbarch_debug)
+    fprintf_unfiltered (gdb_stdlog,
+			"brownie32_gdbarch_init: brownie3264_transfers_32bit_regs_p = %d\n",
+			brownie3264_transfers_32bit_regs_p);
+
+  /* Determine the BROWNIE32 FPU type.  */
+#if 1  // C.Katano
+	fpu_type = BROWNIE32_FPU_NONE;
+#endif
+  if (gdbarch_debug)
+    fprintf_unfiltered (gdb_stdlog,
+			"brownie32_gdbarch_init: fpu_type = %d\n", fpu_type);
+
+  /* try to find a pre-existing architecture */
+  for (arches = gdbarch_list_lookup_by_info (arches, &info);
+       arches != NULL;
+       arches = gdbarch_list_lookup_by_info (arches->next, &info))
+    {
+      /* BROWNIE32 needs to be pedantic about which ABI the object is
+         using.  */
+      if (gdbarch_tdep (arches->gdbarch)->elf_flags != elf_flags)
+	continue;
+      if (gdbarch_tdep (arches->gdbarch)->brownie32_abi != brownie32_abi)
+	continue;
+      /* Need to be pedantic about which register virtual size is
+         used.  */
+      if (gdbarch_tdep (arches->gdbarch)->brownie3264_transfers_32bit_regs_p
+	  != brownie3264_transfers_32bit_regs_p)
+	continue;
+      /* Be pedantic about which FPU is selected.  */
+      if (gdbarch_tdep (arches->gdbarch)->brownie32_fpu_type != fpu_type)
+	continue;
+      return arches->gdbarch;
+    }
+
+  /* Need a new architecture.  Fill in a target specific vector.  */
+  tdep = (struct gdbarch_tdep *) xmalloc (sizeof (struct gdbarch_tdep));
+  gdbarch = gdbarch_alloc (&info, tdep);
+  tdep->elf_flags = elf_flags;
+  tdep->brownie3264_transfers_32bit_regs_p = brownie3264_transfers_32bit_regs_p;
+  tdep->found_abi = found_abi;
+  tdep->brownie32_abi = brownie32_abi;
+  tdep->brownie32_fpu_type = fpu_type;
+
+  /* Initially set everything according to the default ABI/ISA.  */
+  set_gdbarch_short_bit (gdbarch, 16);
+  set_gdbarch_int_bit (gdbarch, 32);
+  set_gdbarch_float_bit (gdbarch, 32);
+  set_gdbarch_double_bit (gdbarch, 64);
+  set_gdbarch_long_double_bit (gdbarch, 64);
+  set_gdbarch_register_reggroup_p (gdbarch, brownie32_register_reggroup_p);
+  set_gdbarch_pseudo_register_read (gdbarch, brownie32_pseudo_register_read);
+  set_gdbarch_pseudo_register_write (gdbarch, brownie32_pseudo_register_write);
+
+  set_gdbarch_elf_make_msymbol_special (gdbarch,
+					brownie32_elf_make_msymbol_special);
+
+  /* Fill in the OS dependant register numbers and names.  */
+  {
+    const char **reg_names;
+    struct brownie32_regnum *regnum = GDBARCH_OBSTACK_ZALLOC (gdbarch,
+							 struct brownie32_regnum);
+      {
+//	regnum->lo = BROWNIE32_EMBED_LO_REGNUM;
+//	regnum->hi = BROWNIE32_EMBED_HI_REGNUM;
+//	regnum->badvaddr = BROWNIE32_EMBED_BADVADDR_REGNUM;
+//	regnum->cause = BROWNIE32_EMBED_CAUSE_REGNUM;
+	regnum->pc = BROWNIE32_EMBED_PC_REGNUM;
+//	regnum->fp0 = BROWNIE32_EMBED_FP0_REGNUM;
+//	regnum->fp_control_status = 70;
+//	regnum->fp_implementation_revision = 71;
+	num_regs = 40;  //33;
+	  reg_names = brownie32_generic_reg_names;
+      }
+    /* FIXME: cagney/2003-11-15: For BROWNIE32, hasn't PC_REGNUM been
+       replaced by read_pc?  */
+    set_gdbarch_pc_regnum (gdbarch, regnum->pc + num_regs);
+    set_gdbarch_sp_regnum (gdbarch, BROWNIE32_SP_REGNUM + num_regs);
+    set_gdbarch_deprecated_fp_regnum (gdbarch, BROWNIE32_FRM_REGNUM + num_regs);
+//    set_gdbarch_deprecated_fp_regnum (gdbarch, BROWNIE32_FRM_REGNUM);
+//    set_gdbarch_fp0_regnum (gdbarch, regnum->fp0);
+    set_gdbarch_num_regs (gdbarch, num_regs);
+    set_gdbarch_num_pseudo_regs (gdbarch, num_regs);
+    set_gdbarch_register_name (gdbarch, brownie32_register_name);
+    tdep->brownie32_processor_reg_names = reg_names;
+    tdep->regnum = regnum;
+  }
+
+  switch (brownie32_abi)
+    {
+    case BROWNIE32_ABI_O32:
+      set_gdbarch_push_dummy_call (gdbarch, brownie32_o32_push_dummy_call);
+      set_gdbarch_return_value (gdbarch, brownie32_o32_return_value);
+//      tdep->brownie32_last_arg_regnum = BROWNIE32_A0_REGNUM + 4 - 1;
+//      tdep->brownie32_last_fp_arg_regnum = tdep->regnum->fp0 + 12 + 4 - 1;
+      tdep->default_mask_address_p = 0;
+      set_gdbarch_long_bit (gdbarch, 32);
+      set_gdbarch_ptr_bit (gdbarch, 32);
+      set_gdbarch_long_long_bit (gdbarch, 64);
+      break;
+    case BROWNIE32_ABI_EABI32:
+      set_gdbarch_push_dummy_call (gdbarch, brownie32_eabi_push_dummy_call);
+      set_gdbarch_return_value (gdbarch, brownie32_eabi_return_value);
+//      tdep->brownie32_last_arg_regnum = BROWNIE32_A0_REGNUM + 8 - 1;
+//      tdep->brownie32_last_fp_arg_regnum = tdep->regnum->fp0 + 12 + 8 - 1;
+      tdep->default_mask_address_p = 0;
+      set_gdbarch_long_bit (gdbarch, 32);
+      set_gdbarch_ptr_bit (gdbarch, 32);
+      set_gdbarch_long_long_bit (gdbarch, 64);
+      break;
+    case BROWNIE32_ABI_EABI64:
+      set_gdbarch_push_dummy_call (gdbarch, brownie32_eabi_push_dummy_call);
+      set_gdbarch_return_value (gdbarch, brownie32_eabi_return_value);
+//      tdep->brownie32_last_arg_regnum = BROWNIE32_A0_REGNUM + 8 - 1;
+//      tdep->brownie32_last_fp_arg_regnum = tdep->regnum->fp0 + 12 + 8 - 1;
+      tdep->default_mask_address_p = 0;
+      set_gdbarch_long_bit (gdbarch, 64);
+      set_gdbarch_ptr_bit (gdbarch, 64);
+      set_gdbarch_long_long_bit (gdbarch, 64);
+      break;
+    case BROWNIE32_ABI_N32:
+      set_gdbarch_push_dummy_call (gdbarch, brownie32_n32n64_push_dummy_call);
+      set_gdbarch_return_value (gdbarch, brownie32_n32n64_return_value);
+//      tdep->brownie32_last_arg_regnum = BROWNIE32_A0_REGNUM + 8 - 1;
+//      tdep->brownie32_last_fp_arg_regnum = tdep->regnum->fp0 + 12 + 8 - 1;
+      tdep->default_mask_address_p = 0;
+      set_gdbarch_long_bit (gdbarch, 32);
+      set_gdbarch_ptr_bit (gdbarch, 32);
+      set_gdbarch_long_long_bit (gdbarch, 64);
+      set_gdbarch_long_double_bit (gdbarch, 128);
+//      set_gdbarch_long_double_format (gdbarch,
+//                                      &floatformat_n32n64_long_double_big);
+      break;
+#if 000
+    case BROWNIE32_ABI_N64:
+      set_gdbarch_push_dummy_call (gdbarch, brownie32_n32n64_push_dummy_call);
+      set_gdbarch_return_value (gdbarch, brownie32_n32n64_return_value);
+//      tdep->brownie32_last_arg_regnum = BROWNIE32_A0_REGNUM + 8 - 1;
+//      tdep->brownie32_last_fp_arg_regnum = tdep->regnum->fp0 + 12 + 8 - 1;
+      tdep->default_mask_address_p = 0;
+      set_gdbarch_long_bit (gdbarch, 64);
+      set_gdbarch_ptr_bit (gdbarch, 64);
+      set_gdbarch_long_long_bit (gdbarch, 64);
+      set_gdbarch_long_double_bit (gdbarch, 128);
+//      set_gdbarch_long_double_format (gdbarch,
+//                                      &floatformat_n32n64_long_double_big);
+      break;
+#endif
+    default:
+      internal_error (__FILE__, __LINE__, _("unknown ABI in switch"));
+    }
+
+  /* FIXME: jlarmour/2000-04-07: There *is* a flag EF_BROWNIE32_32BIT_MODE
+     that could indicate -gp32 BUT gas/config/tc-brownie32.c contains the
+     comment:
+
+     ``We deliberately don't allow "-gp32" to set the BROWNIE32_32BITMODE
+     flag in object files because to do so would make it impossible to
+     link with libraries compiled without "-gp32".  This is
+     unnecessarily restrictive.
+
+     We could solve this problem by adding "-gp32" multilibs to gcc,
+     but to set this flag before gcc is built with such multilibs will
+     break too many systems.''
+
+     But even more unhelpfully, the default linker output target for
+     brownie3264-elf is elf32-bigbrownie32, and has EF_BROWNIE32_32BIT_MODE set, even
+     for 64-bit programs - you need to change the ABI to change this,
+     and not all gcc targets support that currently.  Therefore using
+     this flag to detect 32-bit mode would do the wrong thing given
+     the current gcc - it would make GDB treat these 64-bit programs
+     as 32-bit programs by default.  */
+  set_gdbarch_read_pc (gdbarch, brownie32_read_pc);
+  set_gdbarch_write_pc (gdbarch, brownie32_write_pc);
+  set_gdbarch_read_sp (gdbarch, brownie32_read_sp);
+
+  /* Add/remove bits from an address.  The BROWNIE32 needs be careful to
+     ensure that all 32 bit addresses are sign extended to 64 bits.  */
+  set_gdbarch_addr_bits_remove (gdbarch, brownie32_addr_bits_remove);
+
+  /* Unwind the frame.  */
+  set_gdbarch_unwind_pc (gdbarch, brownie32_unwind_pc);
+  set_gdbarch_unwind_dummy_id (gdbarch, brownie32_unwind_dummy_id);
+
+  /* Map debug register numbers onto internal register numbers.  */
+  set_gdbarch_stab_reg_to_regnum (gdbarch, brownie32_stab_reg_to_regnum);
+#if 000
+  set_gdbarch_ecoff_reg_to_regnum (gdbarch,
+				   brownie32_dwarf_dwarf2_ecoff_reg_to_regnum);
+#endif
+  set_gdbarch_dwarf_reg_to_regnum (gdbarch,
+				   brownie32_dwarf_dwarf2_ecoff_reg_to_regnum);
+  set_gdbarch_dwarf2_reg_to_regnum (gdbarch,
+				    brownie32_dwarf_dwarf2_ecoff_reg_to_regnum);
+  set_gdbarch_register_sim_regno (gdbarch, brownie32_register_sim_regno);
+
+  /* BROWNIE32 version of CALL_DUMMY */
+
+  /* NOTE: cagney/2003-08-05: Eventually call dummy location will be
+     replaced by a command, and all targets will default to on stack
+     (regardless of the stack's execute status).  */
+  set_gdbarch_call_dummy_location (gdbarch, AT_SYMBOL);
+  set_gdbarch_frame_align (gdbarch, brownie32_frame_align);
+
+  set_gdbarch_convert_register_p (gdbarch, brownie32_convert_register_p);
+  set_gdbarch_register_to_value (gdbarch, brownie32_register_to_value);
+  set_gdbarch_value_to_register (gdbarch, brownie32_value_to_register);
+
+  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
+  set_gdbarch_breakpoint_from_pc (gdbarch, brownie32_breakpoint_from_pc);
+
+  set_gdbarch_skip_prologue (gdbarch, brownie32_skip_prologue);
+
+  set_gdbarch_pointer_to_address (gdbarch, signed_pointer_to_address);
+  set_gdbarch_address_to_pointer (gdbarch, address_to_signed_pointer);
+  set_gdbarch_integer_to_address (gdbarch, brownie32_integer_to_address);
+
+  set_gdbarch_register_type (gdbarch, brownie32_register_type);
+
+  set_gdbarch_print_registers_info (gdbarch, brownie32_print_registers_info);
+
+  set_gdbarch_print_insn (gdbarch, gdb_print_insn_brownie32);
+
+  /* FIXME: cagney/2003-08-29: The macros HAVE_STEPPABLE_WATCHPOINT,
+     HAVE_NONSTEPPABLE_WATCHPOINT, and HAVE_CONTINUABLE_WATCHPOINT
+     need to all be folded into the target vector.  Since they are
+     being used as guards for STOPPED_BY_WATCHPOINT, why not have
+     STOPPED_BY_WATCHPOINT return the type of watchpoint that the code
+     is sitting on?  */
+  set_gdbarch_have_nonsteppable_watchpoint (gdbarch, 1);
+
+//  set_gdbarch_skip_trampoline_code (gdbarch, brownie32_skip_trampoline_code);
+
+  set_gdbarch_software_single_step (gdbarch, brownie32_software_single_step);
+//  set_gdbarch_single_step_through_delay (gdbarch, brownie32_single_step_through_delay);
+
+  /* Hook in OS ABI-specific overrides, if they have been registered.  */
+  gdbarch_init_osabi (info, gdbarch);
+
+  /* Unwind the frame.  */
+  frame_unwind_append_sniffer (gdbarch, brownie32_stub_frame_sniffer);
+  frame_unwind_append_sniffer (gdbarch, brownie32_insn32_frame_sniffer);
+  frame_base_append_sniffer (gdbarch, brownie32_stub_frame_base_sniffer);
+  frame_base_append_sniffer (gdbarch, brownie32_insn32_frame_base_sniffer);
+
+  return gdbarch;
+}
+
+static void
+brownie32_abi_update (char *ignore_args, int from_tty, struct cmd_list_element *c)
+{
+  struct gdbarch_info info;
+
+  /* Force the architecture to update, and (if it's a BROWNIE32 architecture)
+     brownie32_gdbarch_init will take care of the rest.  */
+  gdbarch_info_init (&info);
+  gdbarch_update_p (info);
+}
+
+/* Print out which BROWNIE32 ABI is in use.  */
+
+static void
+show_brownie32_abi (struct ui_file *file,
+	       int from_tty,
+	       struct cmd_list_element *ignored_cmd,
+	       const char *ignored_value)
+{
+  if (gdbarch_bfd_arch_info (current_gdbarch)->arch != bfd_arch_brownie32)
+    fprintf_filtered
+      (file, 
+       "The BROWNIE32 ABI is unknown because the current architecture "
+       "is not BROWNIE32.\n");
+  else
+    {
+      enum brownie32_abi global_abi = global_brownie32_abi ();
+      enum brownie32_abi actual_abi = brownie32_abi (current_gdbarch);
+      const char *actual_abi_str = brownie32_abi_strings[actual_abi];
+
+      if (global_abi == BROWNIE32_ABI_UNKNOWN)
+	fprintf_filtered
+	  (file, 
+	   "The BROWNIE32 ABI is set automatically (currently \"%s\").\n",
+	   actual_abi_str);
+      else if (global_abi == actual_abi)
+	fprintf_filtered
+	  (file,
+	   "The BROWNIE32 ABI is assumed to be \"%s\" (due to user setting).\n",
+	   actual_abi_str);
+      else
+	{
+	  /* Probably shouldn't happen...  */
+	  fprintf_filtered
+	    (file,
+	     "The (auto detected) BROWNIE32 ABI \"%s\" is in use even though the user setting was \"%s\".\n",
+	     actual_abi_str, brownie32_abi_strings[global_abi]);
+	}
+    }
+}
+
+static void
+brownie32_dump_tdep (struct gdbarch *current_gdbarch, struct ui_file *file)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
+  if (tdep != NULL)
+    {
+      int ef_brownie32_arch;
+      int ef_brownie32_32bitmode;
+      /* determine the ISA */
+      switch (tdep->elf_flags & EF_BROWNIE32_ARCH)
+	{
+	case E_BROWNIE32_ARCH_1:
+	  ef_brownie32_arch = 1;
+	  break;
+	case E_BROWNIE32_ARCH_2:
+	  ef_brownie32_arch = 2;
+	  break;
+	case E_BROWNIE32_ARCH_3:
+	  ef_brownie32_arch = 3;
+	  break;
+	case E_BROWNIE32_ARCH_4:
+	  ef_brownie32_arch = 4;
+	  break;
+	default:
+	  ef_brownie32_arch = 0;
+	  break;
+	}
+      /* determine the size of a pointer */
+      ef_brownie32_32bitmode = (tdep->elf_flags & EF_BROWNIE32_32BITMODE);
+      fprintf_unfiltered (file,
+			  "brownie32_dump_tdep: tdep->elf_flags = 0x%x\n",
+			  tdep->elf_flags);
+      fprintf_unfiltered (file,
+			  "brownie32_dump_tdep: ef_brownie32_32bitmode = %d\n",
+			  ef_brownie32_32bitmode);
+      fprintf_unfiltered (file,
+			  "brownie32_dump_tdep: ef_brownie32_arch = %d\n",
+			  ef_brownie32_arch);
+      fprintf_unfiltered (file,
+			  "brownie32_dump_tdep: tdep->brownie32_abi = %d (%s)\n",
+			  tdep->brownie32_abi, brownie32_abi_strings[tdep->brownie32_abi]);
+      fprintf_unfiltered (file,
+			  "brownie32_dump_tdep: brownie32_mask_address_p() %d (default %d)\n",
+			  brownie32_mask_address_p (tdep),
+			  tdep->default_mask_address_p);
+    }
+  fprintf_unfiltered (file,
+		      "brownie32_dump_tdep: BROWNIE32_DEFAULT_FPU_TYPE = %d (%s)\n",
+		      BROWNIE32_DEFAULT_FPU_TYPE,
+		      (BROWNIE32_DEFAULT_FPU_TYPE == BROWNIE32_FPU_NONE ? "none"
+		       : BROWNIE32_DEFAULT_FPU_TYPE == BROWNIE32_FPU_SINGLE ? "single"
+		       : BROWNIE32_DEFAULT_FPU_TYPE == BROWNIE32_FPU_DOUBLE ? "double"
+		       : "???"));
+  fprintf_unfiltered (file, "brownie32_dump_tdep: BROWNIE32_EABI = %d\n", BROWNIE32_EABI);
+  fprintf_unfiltered (file,
+		      "brownie32_dump_tdep: BROWNIE32_FPU_TYPE = %d (%s)\n",
+		      BROWNIE32_FPU_TYPE,
+		      (BROWNIE32_FPU_TYPE == BROWNIE32_FPU_NONE ? "none"
+		       : BROWNIE32_FPU_TYPE == BROWNIE32_FPU_SINGLE ? "single"
+		       : BROWNIE32_FPU_TYPE == BROWNIE32_FPU_DOUBLE ? "double"
+		       : "???"));
+  fprintf_unfiltered (file,
+		      "brownie32_dump_tdep: brownie32_stack_argsize() = %d\n",
+		      brownie32_stack_argsize (current_gdbarch));
+}
+
+extern initialize_file_ftype _initialize_brownie32_tdep;	/* -Wmissing-prototypes */
+
+void
+_initialize_brownie32_tdep (void)
+{
+  static struct cmd_list_element *brownie32fpulist = NULL;
+  struct cmd_list_element *c;
+
+  brownie32_abi_string = brownie32_abi_strings[BROWNIE32_ABI_UNKNOWN];
+  if (BROWNIE32_ABI_LAST + 1
+      != sizeof (brownie32_abi_strings) / sizeof (brownie32_abi_strings[0]))
+    internal_error (__FILE__, __LINE__, _("brownie32_abi_strings out of sync"));
+
+  gdbarch_register (bfd_arch_brownie32, brownie32_gdbarch_init, brownie32_dump_tdep);
+
+  brownie32_pdr_data = register_objfile_data ();
+
+  /* Add root prefix command for all "set brownie32"/"show brownie32" commands */
+  add_prefix_cmd ("brownie32", no_class, set_brownie32_command,
+		  _("Various BROWNIE32 specific commands."),
+		  &setbrownie32cmdlist, "set brownie32 ", 0, &setlist);
+
+  add_prefix_cmd ("brownie32", no_class, show_brownie32_command,
+		  _("Various BROWNIE32 specific commands."),
+		  &showbrownie32cmdlist, "show brownie32 ", 0, &showlist);
+
+  /* Allow the user to override the saved register size. */
+  add_setshow_enum_cmd ("saved-gpreg-size", class_obscure,
+			size_enums, &brownie32_abi_regsize_string, _("\
+Set size of general purpose registers saved on the stack."), _("\
+Show size of general purpose registers saved on the stack."), _("\
+This option can be set to one of:\n\
+  32    - Force GDB to treat saved GP registers as 32-bit\n\
+  64    - Force GDB to treat saved GP registers as 64-bit\n\
+  auto  - Allow GDB to use the target's default setting or autodetect the\n\
+          saved GP register size from information contained in the\n\
+          executable (default)."),
+			NULL,
+			NULL, /* FIXME: i18n: Size of general purpose registers saved on the stack is %s.  */
+			&setbrownie32cmdlist, &showbrownie32cmdlist);
+
+  /* Allow the user to override the argument stack size. */
+  add_setshow_enum_cmd ("stack-arg-size", class_obscure,
+			size_enums, &brownie32_stack_argsize_string, _("\
+Set the amount of stack space reserved for each argument."), _("\
+Show the amount of stack space reserved for each argument."), _("\
+This option can be set to one of:\n\
+  32    - Force GDB to allocate 32-bit chunks per argument\n\
+  64    - Force GDB to allocate 64-bit chunks per argument\n\
+  auto  - Allow GDB to determine the correct setting from the current\n\
+          target and executable (default)"),
+			NULL,
+			NULL, /* FIXME: i18n: The amount of stack space reserved for each argument is %s.  */
+			&setbrownie32cmdlist, &showbrownie32cmdlist);
+
+  /* Allow the user to override the ABI. */
+  add_setshow_enum_cmd ("abi", class_obscure, brownie32_abi_strings,
+			&brownie32_abi_string, _("\
+Set the BROWNIE32 ABI used by this program."), _("\
+Show the BROWNIE32 ABI used by this program."), _("\
+This option can be set to one of:\n\
+  auto  - the default ABI associated with the current binary\n\
+  o32\n\
+  o64\n\
+  n32\n\
+  n64\n\
+  eabi32\n\
+  eabi64"),
+			brownie32_abi_update,
+			show_brownie32_abi,
+			&setbrownie32cmdlist, &showbrownie32cmdlist);
+
+  /* Let the user turn off floating point and set the fence post for
+     heuristic_proc_start.  */
+
+  add_prefix_cmd ("brownie32fpu", class_support, set_brownie32fpu_command,
+		  _("Set use of BROWNIE32 floating-point coprocessor."),
+		  &brownie32fpulist, "set brownie32fpu ", 0, &setlist);
+  add_cmd ("single", class_support, set_brownie32fpu_single_command,
+	   _("Select single-precision BROWNIE32 floating-point coprocessor."),
+	   &brownie32fpulist);
+  add_cmd ("double", class_support, set_brownie32fpu_double_command,
+	   _("Select double-precision BROWNIE32 floating-point coprocessor."),
+	   &brownie32fpulist);
+  add_alias_cmd ("on", "double", class_support, 1, &brownie32fpulist);
+  add_alias_cmd ("yes", "double", class_support, 1, &brownie32fpulist);
+  add_alias_cmd ("1", "double", class_support, 1, &brownie32fpulist);
+  add_cmd ("none", class_support, set_brownie32fpu_none_command,
+	   _("Select no BROWNIE32 floating-point coprocessor."), &brownie32fpulist);
+  add_alias_cmd ("off", "none", class_support, 1, &brownie32fpulist);
+  add_alias_cmd ("no", "none", class_support, 1, &brownie32fpulist);
+  add_alias_cmd ("0", "none", class_support, 1, &brownie32fpulist);
+  add_cmd ("auto", class_support, set_brownie32fpu_auto_command,
+	   _("Select BROWNIE32 floating-point coprocessor automatically."),
+	   &brownie32fpulist);
+  add_cmd ("brownie32fpu", class_support, show_brownie32fpu_command,
+	   _("Show current use of BROWNIE32 floating-point coprocessor target."),
+	   &showlist);
+
+  /* We really would like to have both "0" and "unlimited" work, but
+     command.c doesn't deal with that.  So make it a var_zinteger
+     because the user can always use "999999" or some such for unlimited.  */
+  add_setshow_zinteger_cmd ("heuristic-fence-post", class_support,
+			    &heuristic_fence_post, _("\
+Set the distance searched for the start of a function."), _("\
+Show the distance searched for the start of a function."), _("\
+If you are debugging a stripped executable, GDB needs to search through the\n\
+program for the start of a function.  This command sets the distance of the\n\
+search.  The only need to set it is when debugging a stripped executable."),
+			    reinit_frame_cache_sfunc,
+			    NULL, /* FIXME: i18n: The distance searched for the start of a function is %s.  */
+			    &setlist, &showlist);
+
+  /* Allow the user to control whether the upper bits of 64-bit
+     addresses should be zeroed.  */
+  add_setshow_auto_boolean_cmd ("mask-address", no_class,
+				&mask_address_var, _("\
+Set zeroing of upper 32 bits of 64-bit addresses."), _("\
+Show zeroing of upper 32 bits of 64-bit addresses."), _("\
+Use \"on\" to enable the masking, \"off\" to disable it and \"auto\" to \n\
+allow GDB to determine the correct value."),
+				NULL, show_mask_address,
+				&setbrownie32cmdlist, &showbrownie32cmdlist);
+
+  /* Allow the user to control the size of 32 bit registers within the
+     raw remote packet.  */
+  add_setshow_boolean_cmd ("remote-brownie3264-transfers-32bit-regs", class_obscure,
+			   &brownie3264_transfers_32bit_regs_p, _("\
+Set compatibility with 64-bit BROWNIE32 target that transfers 32-bit quantities."),
+			   _("\
+Show compatibility with 64-bit BROWNIE32 target that transfers 32-bit quantities."),
+			   _("\
+Use \"on\" to enable backward compatibility with older BROWNIE32 64 GDB+target\n\
+that would transfer 32 bits for some registers (e.g. SR, FSR) and\n\
+64 bits for others.  Use \"off\" to disable compatibility mode"),
+			   set_brownie3264_transfers_32bit_regs,
+			   NULL, /* FIXME: i18n: Compatibility with 64-bit BROWNIE32 target that transfers 32-bit quantities is %s.  */
+			   &setlist, &showlist);
+
+  /* Debug this files internals. */
+  add_setshow_zinteger_cmd ("brownie32", class_maintenance,
+			    &brownie32_debug, _("\
+Set brownie32 debugging."), _("\
+Show brownie32 debugging."), _("\
+When non-zero, brownie32 specific debugging is enabled."),
+			    NULL,
+			    NULL, /* FIXME: i18n: Mips debugging is currently %s.  */
+			    &setdebuglist, &showdebuglist);
+}
Index: gdb/brownie32-tdep.h
===================================================================
RCS file: gdb/brownie32-tdep.h
diff -N gdb/brownie32-tdep.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/brownie32-tdep.h	11 Feb 2008 15:42:42 -0000	1.6
@@ -0,0 +1,111 @@
+/* Target-dependent header for the BROWNIE32 architecture, for GDB, the GNU Debugger.
+
+   Copyright 2002, 2003 Free Software Foundation, Inc.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef BROWNIE32_TDEP_H
+#define BROWNIE32_TDEP_H
+
+struct gdbarch;
+
+/* All the possible BROWNIE32 ABIs. */
+enum brownie32_abi
+  {
+    BROWNIE32_ABI_UNKNOWN = 0,
+    BROWNIE32_ABI_N32,
+    BROWNIE32_ABI_O32,
+    BROWNIE32_ABI_N64,
+    BROWNIE32_ABI_O64,
+    BROWNIE32_ABI_EABI32,
+    BROWNIE32_ABI_EABI64,
+    BROWNIE32_ABI_LAST
+  };
+
+/* Return the BROWNIE32 ABI associated with GDBARCH.  */
+enum brownie32_abi brownie32_abi (struct gdbarch *gdbarch);
+
+/* For wince :-(.  */
+extern CORE_ADDR brownie32_next_pc (CORE_ADDR pc);
+
+/* Return the BROWNIE32 ISA's register size.  Just a short cut to the BFD
+   architecture's word size.  */
+extern int brownie32_isa_regsize (struct gdbarch *gdbarch);
+
+/* Return the current index for various BROWNIE32 registers.  */
+struct brownie32_regnum
+{
+  int pc;
+};
+extern const struct brownie32_regnum *brownie32_regnum (struct gdbarch *gdbarch);
+
+/* Register numbers of various important registers.  Note that some of
+   these values are "real" register numbers, and correspond to the
+   general registers of the machine, and some are "phony" register
+   numbers which are too large to be actual register numbers as far as
+   the user is concerned but do serve to get the desired values when
+   passed to read_register.  */
+
+enum
+{
+  BROWNIE32_ZERO_REGNUM = 0,		/* Read-only register, always 0.  */
+  BROWNIE32_SR_REGNUM = 1,		/* Status register.  */
+  BROWNIE32_IRR_REGNUM = 2,		/* Interrupt register.  */
+  BROWNIE32_LNK_REGNUM = 3,		/* Link register.  */
+  //BROWNIE32_RET_REGNUM = 4,		/* Return value register.  */
+  //BROWNIE32_FRM_REGNUM = 5,		/* Frame pointer register.  */
+  //BROWNIE32_SP_REGNUM = 6,		/* Stack pointer register.  */
+  //BROWNIE32_FIRST_ARG_REGNUM = 7,
+  //BROWNIE32_LAST_ARG_REGNUM = 14,
+  BROWNIE32_FRM_REGNUM = 4,		/* Frame pointer register.  */
+  BROWNIE32_SP_REGNUM = 5,		/* Stack pointer register.  */
+  BROWNIE32_RET_REGNUM = 6,		/* Return value register.  */
+  BROWNIE32_FIRST_ARG_REGNUM = 8,
+  BROWNIE32_LAST_ARG_REGNUM = 15,
+  BROWNIE32_EMBED_PC_REGNUM = 32,
+  BROWNIE32_UNUSED_REGNUM =  0,	/* Never used, FIXME */
+  BROWNIE32_FIRST_EMBED_REGNUM =  0,	/* First CP0 register for embedded use.  */
+  BROWNIE32_PRID_REGNUM =  0,	/* Processor ID.  */
+  BROWNIE32_LAST_EMBED_REGNUM = 33	/* Last one.  */
+};
+
+/* Defined in brownie32-tdep.c and used in remote-brownie32.c */
+extern void deprecated_brownie32_set_processor_regs_hack (void);
+
+/* Instruction sizes and other useful constants.  */
+enum
+{
+  BROWNIE32_INSN16_SIZE = 2,
+  BROWNIE32_INSN32_SIZE = 4,
+  /* The number of floating-point or integer registers.  */
+  BROWNIE32_NUMREGS = 32
+};
+
+/* Single step based on where the current instruction will take us.  */
+extern void brownie32_software_single_step (enum target_signal, int);
+
+/* Tell if the program counter value in MEMADDR is in a BROWNIE3216
+   function.  */
+extern int brownie32_pc_is_brownie3216 (bfd_vma memaddr);
+
+/* Return the currently configured (or set) saved register size. */
+extern unsigned int brownie32_abi_regsize (struct gdbarch *gdbarch);
+
+#endif /* BROWNIE32_TDEP_H */
Index: gdb/brownie32nbsd-nat.c
===================================================================
RCS file: gdb/brownie32nbsd-nat.c
diff -N gdb/brownie32nbsd-nat.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/brownie32nbsd-nat.c	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,122 @@
+/* Native-dependent code for BROWNIE32 systems running NetBSD.
+
+   Copyright 2000, 2001, 2002, 2004 Free Software Foundation, Inc.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include "defs.h"
+#include "inferior.h"
+#include "regcache.h"
+#include "target.h"
+
+#include <sys/types.h>
+#include <sys/ptrace.h>
+#include <machine/reg.h>
+
+#include "brownie32-tdep.h"
+#include "brownie32nbsd-tdep.h"
+#include "inf-ptrace.h"
+
+/* Determine if PT_GETREGS fetches this register.  */
+static int
+getregs_supplies (int regno)
+{
+  return ((regno) >= BROWNIE32_ZERO_REGNUM && (regno) <= PC_REGNUM);
+}
+
+static void
+brownie32nbsd_fetch_inferior_registers (int regno)
+{
+  if (regno == -1 || getregs_supplies (regno))
+    {
+      struct reg regs;
+
+      if (ptrace (PT_GETREGS, PIDGET (inferior_ptid),
+		  (PTRACE_TYPE_ARG3) &regs, 0) == -1)
+	perror_with_name (_("Couldn't get registers"));
+      
+      brownie32nbsd_supply_reg ((char *) &regs, regno);
+      if (regno != -1)
+	return;
+    }
+
+  if (regno == -1 || regno >= FP0_REGNUM)
+    {
+      struct fpreg fpregs;
+
+      if (ptrace (PT_GETFPREGS, PIDGET (inferior_ptid),
+		  (PTRACE_TYPE_ARG3) &fpregs, 0) == -1)
+	perror_with_name (_("Couldn't get floating point status"));
+
+      brownie32nbsd_supply_fpreg ((char *) &fpregs, regno);
+    }
+}
+
+static void
+brownie32nbsd_store_inferior_registers (int regno)
+{
+  if (regno == -1 || getregs_supplies (regno))
+    {
+      struct reg regs;
+
+      if (ptrace (PT_GETREGS, PIDGET (inferior_ptid),
+		  (PTRACE_TYPE_ARG3) &regs, 0) == -1)
+	perror_with_name (_("Couldn't get registers"));
+
+      brownie32nbsd_fill_reg ((char *) &regs, regno);
+
+      if (ptrace (PT_SETREGS, PIDGET (inferior_ptid), 
+		  (PTRACE_TYPE_ARG3) &regs, 0) == -1)
+	perror_with_name (_("Couldn't write registers"));
+
+      if (regno != -1)
+	return;
+    }
+
+  if (regno == -1 || regno >= FP0_REGNUM)
+    {
+      struct fpreg fpregs; 
+
+      if (ptrace (PT_GETFPREGS, PIDGET (inferior_ptid),
+		  (PTRACE_TYPE_ARG3) &fpregs, 0) == -1)
+	perror_with_name (_("Couldn't get floating point status"));
+
+      brownie32nbsd_fill_fpreg ((char *) &fpregs, regno);
+
+      if (ptrace (PT_SETFPREGS, PIDGET (inferior_ptid),
+		  (PTRACE_TYPE_ARG3) &fpregs, 0) == -1)
+	perror_with_name (_("Couldn't write floating point status"));
+    }
+}
+
+
+/* Provide a prototype to silence -Wmissing-prototypes.  */
+void _initialize_brownie32nbsd_nat (void);
+
+void
+_initialize_brownie32nbsd_nat (void)
+{
+  struct target_ops *t;
+
+  t = inf_ptrace_target ();
+  t->to_fetch_registers = brownie32nbsd_fetch_inferior_registers;
+  t->to_store_registers = brownie32nbsd_store_inferior_registers;
+  add_target (t);
+}
Index: gdb/brownie32nbsd-tdep.c
===================================================================
RCS file: gdb/brownie32nbsd-tdep.c
diff -N gdb/brownie32nbsd-tdep.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/brownie32nbsd-tdep.c	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,419 @@
+/* Target-dependent code for NetBSD/brownie32.
+
+   Copyright 2002, 2003, 2004 Free Software Foundation, Inc.
+   Contributed by Wasabi Systems, Inc.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include "defs.h"
+#include "gdbcore.h"
+#include "regcache.h"
+#include "regset.h"
+#include "target.h"
+#include "value.h"
+#include "osabi.h"
+
+#include "gdb_assert.h"
+#include "gdb_string.h"
+
+#include "nbsd-tdep.h"
+#include "brownie32nbsd-tdep.h"
+#include "brownie32-tdep.h"
+
+#include "solib-svr4.h"
+
+/* Shorthand for some register numbers used below.  */
+#define BROWNIE32_PC_REGNUM  BROWNIE32_EMBED_PC_REGNUM
+#define BROWNIE32_FP0_REGNUM BROWNIE32_EMBED_FP0_REGNUM
+#define BROWNIE32_FSR_REGNUM BROWNIE32_EMBED_FP0_REGNUM + 32
+
+/* Core file support.  */
+
+/* Number of registers in `struct reg' from <machine/reg.h>.  */
+#define BROWNIE32NBSD_NUM_GREGS	38
+
+/* Number of registers in `struct fpreg' from <machine/reg.h>.  */
+#define BROWNIE32NBSD_NUM_FPREGS	33
+
+/* Supply register REGNUM from the buffer specified by FPREGS and LEN
+   in the floating-point register set REGSET to register cache
+   REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */
+
+static void
+brownie32nbsd_supply_fpregset (const struct regset *regset,
+			  struct regcache *regcache,
+			  int regnum, const void *fpregs, size_t len)
+{
+  size_t regsize = brownie32_isa_regsize (get_regcache_arch (regcache));
+  const char *regs = fpregs;
+  int i;
+
+  gdb_assert (len >= BROWNIE32NBSD_NUM_FPREGS * regsize);
+
+  for (i = BROWNIE32_FP0_REGNUM; i <= BROWNIE32_FSR_REGNUM; i++)
+    {
+      if (regnum == i || regnum == -1)
+	regcache_raw_supply (regcache, i,
+			     regs + (i - BROWNIE32_FP0_REGNUM) * regsize);
+    }
+}
+
+/* Supply register REGNUM from the buffer specified by GREGS and LEN
+   in the general-purpose register set REGSET to register cache
+   REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */
+
+static void
+brownie32nbsd_supply_gregset (const struct regset *regset,
+			 struct regcache *regcache, int regnum,
+			 const void *gregs, size_t len)
+{
+  size_t regsize = brownie32_isa_regsize (get_regcache_arch (regcache));
+  const char *regs = gregs;
+  int i;
+
+  gdb_assert (len >= BROWNIE32NBSD_NUM_GREGS * regsize);
+
+  for (i = 0; i <= BROWNIE32_PC_REGNUM; i++)
+    {
+      if (regnum == i || regnum == -1)
+	regcache_raw_supply (regcache, i, regs + i * regsize);
+    }
+
+  if (len >= (BROWNIE32NBSD_NUM_GREGS + BROWNIE32NBSD_NUM_FPREGS) * regsize)
+    {
+      regs += BROWNIE32NBSD_NUM_GREGS * regsize;
+      len -= BROWNIE32NBSD_NUM_GREGS * regsize;
+      brownie32nbsd_supply_fpregset (regset, regcache, regnum, regs, len);
+    }
+}
+
+/* NetBSD/brownie32 register sets.  */
+
+static struct regset brownie32nbsd_gregset =
+{
+  NULL,
+  brownie32nbsd_supply_gregset
+};
+
+static struct regset brownie32nbsd_fpregset =
+{
+  NULL,
+  brownie32nbsd_supply_fpregset
+};
+
+/* Return the appropriate register set for the core section identified
+   by SECT_NAME and SECT_SIZE.  */
+
+static const struct regset *
+brownie32nbsd_regset_from_core_section (struct gdbarch *gdbarch,
+				   const char *sect_name, size_t sect_size)
+{
+  size_t regsize = brownie32_isa_regsize (gdbarch);
+  
+  if (strcmp (sect_name, ".reg") == 0
+      && sect_size >= BROWNIE32NBSD_NUM_GREGS * regsize)
+    return &brownie32nbsd_gregset;
+
+  if (strcmp (sect_name, ".reg2") == 0
+      && sect_size >= BROWNIE32NBSD_NUM_FPREGS * regsize)
+    return &brownie32nbsd_fpregset;
+
+  return NULL;
+}
+
+
+/* Conveniently, GDB uses the same register numbering as the
+   ptrace register structure used by NetBSD/brownie32.  */
+
+void
+brownie32nbsd_supply_reg (char *regs, int regno)
+{
+  int i;
+
+  for (i = 0; i <= PC_REGNUM; i++)
+    {
+      if (regno == i || regno == -1)
+	{
+	  if (CANNOT_FETCH_REGISTER (i))
+	    regcache_raw_supply (current_regcache, i, NULL);
+	  else
+            regcache_raw_supply (current_regcache, i,
+				 regs + (i * brownie32_isa_regsize (current_gdbarch)));
+        }
+    }
+}
+
+void
+brownie32nbsd_fill_reg (char *regs, int regno)
+{
+  int i;
+
+  for (i = 0; i <= PC_REGNUM; i++)
+    if ((regno == i || regno == -1) && ! CANNOT_STORE_REGISTER (i))
+      regcache_raw_collect (current_regcache, i,
+			    regs + (i * brownie32_isa_regsize (current_gdbarch)));
+}
+
+void
+brownie32nbsd_supply_fpreg (char *fpregs, int regno)
+{
+  int i;
+
+  for (i = FP0_REGNUM;
+       i <= brownie32_regnum (current_gdbarch)->fp_implementation_revision;
+       i++)
+    {
+      if (regno == i || regno == -1)
+	{
+	  if (CANNOT_FETCH_REGISTER (i))
+	    regcache_raw_supply (current_regcache, i, NULL);
+	  else
+            regcache_raw_supply (current_regcache, i,
+				 fpregs + ((i - FP0_REGNUM) * brownie32_isa_regsize (current_gdbarch)));
+	}
+    }
+}
+
+void
+brownie32nbsd_fill_fpreg (char *fpregs, int regno)
+{
+  int i;
+
+  for (i = FP0_REGNUM; i <= brownie32_regnum (current_gdbarch)->fp_control_status;
+       i++)
+    if ((regno == i || regno == -1) && ! CANNOT_STORE_REGISTER (i))
+      regcache_raw_collect (current_regcache, i,
+			    fpregs + ((i - FP0_REGNUM) * brownie32_isa_regsize (current_gdbarch)));
+}
+
+/* Under NetBSD/brownie32, signal handler invocations can be identified by the
+   designated code sequence that is used to return from a signal handler.
+   In particular, the return address of a signal handler points to the
+   following code sequence:
+
+	addu	a0, sp, 16
+	li	v0, 295			# __sigreturn14
+	syscall
+   
+   Each instruction has a unique encoding, so we simply attempt to match
+   the instruction the PC is pointing to with any of the above instructions.
+   If there is a hit, we know the offset to the start of the designated
+   sequence and can then check whether we really are executing in the
+   signal trampoline.  If not, -1 is returned, otherwise the offset from the
+   start of the return sequence is returned.  */
+
+#define RETCODE_NWORDS	3
+#define RETCODE_SIZE	(RETCODE_NWORDS * 4)
+
+static const unsigned char sigtramp_retcode_brownie32el[RETCODE_SIZE] =
+{
+  0x10, 0x00, 0xa4, 0x27,	/* addu a0, sp, 16 */
+  0x27, 0x01, 0x02, 0x24,	/* li v0, 295 */
+  0x0c, 0x00, 0x00, 0x00,	/* syscall */
+};
+
+static const unsigned char sigtramp_retcode_brownie32eb[RETCODE_SIZE] =
+{
+  0x27, 0xa4, 0x00, 0x10,	/* addu a0, sp, 16 */
+  0x24, 0x02, 0x01, 0x27,	/* li v0, 295 */
+  0x00, 0x00, 0x00, 0x0c,	/* syscall */
+};
+
+static LONGEST
+brownie32nbsd_sigtramp_offset (struct frame_info *next_frame)
+{
+  CORE_ADDR pc = frame_pc_unwind (next_frame);
+  const char *retcode = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
+  	? sigtramp_retcode_brownie32eb : sigtramp_retcode_brownie32el;
+  unsigned char ret[RETCODE_SIZE], w[4];
+  LONGEST off;
+  int i;
+
+  if (!safe_frame_unwind_memory (next_frame, pc, w, sizeof (w)))
+    return -1;
+
+  for (i = 0; i < RETCODE_NWORDS; i++)
+    {
+      if (memcmp (w, retcode + (i * 4), 4) == 0)
+	break;
+    }
+  if (i == RETCODE_NWORDS)
+    return -1;
+
+  off = i * 4;
+  pc -= off;
+
+  if (!safe_frame_unwind_memory (next_frame, pc, ret, sizeof (ret)))
+    return -1;
+
+  if (memcmp (ret, retcode, RETCODE_SIZE) == 0)
+    return off;
+
+  return -1;
+}
+
+/* Figure out where the longjmp will land.  We expect that we have
+   just entered longjmp and haven't yet setup the stack frame, so the
+   args are still in the argument regs.  BROWNIE32_A0_REGNUM points at the
+   jmp_buf structure from which we extract the PC that we will land
+   at.  The PC is copied into *pc.  This routine returns true on
+   success.  */
+
+#define NBSD_BROWNIE32_JB_PC			(2 * 4)
+#define NBSD_BROWNIE32_JB_ELEMENT_SIZE	brownie32_isa_regsize (current_gdbarch)
+#define NBSD_BROWNIE32_JB_OFFSET		(NBSD_BROWNIE32_JB_PC * \
+					 NBSD_BROWNIE32_JB_ELEMENT_SIZE)
+
+static int
+brownie32nbsd_get_longjmp_target (CORE_ADDR *pc)
+{
+  CORE_ADDR jb_addr;
+  char *buf;
+
+  buf = alloca (NBSD_BROWNIE32_JB_ELEMENT_SIZE);
+
+  jb_addr = read_register (BROWNIE32_A0_REGNUM);
+
+  if (target_read_memory (jb_addr + NBSD_BROWNIE32_JB_OFFSET, buf,
+  			  NBSD_BROWNIE32_JB_ELEMENT_SIZE))
+    return 0;
+
+  *pc = extract_unsigned_integer (buf, NBSD_BROWNIE32_JB_ELEMENT_SIZE);
+
+  return 1;
+}
+
+static int
+brownie32nbsd_cannot_fetch_register (int regno)
+{
+  return (regno == BROWNIE32_ZERO_REGNUM
+	  || regno == brownie32_regnum (current_gdbarch)->fp_implementation_revision);
+}
+
+static int
+brownie32nbsd_cannot_store_register (int regno)
+{
+  return (regno == BROWNIE32_ZERO_REGNUM
+	  || regno == brownie32_regnum (current_gdbarch)->fp_implementation_revision);
+}
+
+/* Shared library support.  */
+
+/* NetBSD/brownie32 uses a slightly different `struct link_map' than the
+   other NetBSD platforms.  */
+
+static struct link_map_offsets *
+brownie32nbsd_ilp32_fetch_link_map_offsets (void)
+{
+  static struct link_map_offsets lmo;
+  static struct link_map_offsets *lmp = NULL;
+
+  if (lmp == NULL) 
+    {
+      lmp = &lmo;
+
+      /* Everything we need is in the first 8 bytes.  */
+      lmo.r_debug_size = 8;
+      lmo.r_map_offset = 4;
+      lmo.r_map_size   = 4;
+
+      /* Everything we need is in the first 24 bytes.  */
+      lmo.link_map_size = 24;
+      lmo.l_addr_offset = 4;
+      lmo.l_addr_size   = 4;
+      lmo.l_name_offset = 8;
+      lmo.l_name_size   = 4;
+      lmo.l_next_offset = 16;
+      lmo.l_next_size   = 4;
+      lmo.l_prev_offset = 20;
+      lmo.l_prev_size   = 4;
+    }
+
+  return lmp;
+}
+
+static struct link_map_offsets *
+brownie32nbsd_lp64_fetch_link_map_offsets (void)
+{
+  static struct link_map_offsets lmo;
+  static struct link_map_offsets *lmp = NULL;
+
+  if (lmp == NULL)
+    {
+      lmp = &lmo;
+
+      /* Everything we need is in the first 16 bytes.  */
+      lmo.r_debug_size = 16;
+      lmo.r_map_offset = 8;  
+      lmo.r_map_size   = 8;
+
+      /* Everything we need is in the first 40 bytes.  */
+      lmo.link_map_size = 48;
+      lmo.l_addr_offset = 0;
+      lmo.l_addr_size   = 8;
+      lmo.l_name_offset = 16; 
+      lmo.l_name_size   = 8;
+      lmo.l_next_offset = 32;
+      lmo.l_next_size   = 8;
+      lmo.l_prev_offset = 40;
+      lmo.l_prev_size   = 8;
+    }
+
+  return lmp;
+}
+
+
+static void
+brownie32nbsd_init_abi (struct gdbarch_info info,
+                   struct gdbarch *gdbarch)
+{
+  set_gdbarch_regset_from_core_section
+    (gdbarch, brownie32nbsd_regset_from_core_section);
+
+  set_gdbarch_get_longjmp_target (gdbarch, brownie32nbsd_get_longjmp_target);
+
+  set_gdbarch_cannot_fetch_register (gdbarch, brownie32nbsd_cannot_fetch_register);
+  set_gdbarch_cannot_store_register (gdbarch, brownie32nbsd_cannot_store_register);
+
+  set_gdbarch_software_single_step (gdbarch, brownie32_software_single_step);
+
+  /* NetBSD/brownie32 has SVR4-style shared libraries.  */
+  set_solib_svr4_fetch_link_map_offsets
+    (gdbarch, (gdbarch_ptr_bit (gdbarch) == 32 ?
+	       brownie32nbsd_ilp32_fetch_link_map_offsets :
+	       brownie32nbsd_lp64_fetch_link_map_offsets));
+}
+
+
+static enum gdb_osabi
+brownie32nbsd_core_osabi_sniffer (bfd *abfd)
+{
+  if (strcmp (bfd_get_target (abfd), "netbsd-core") == 0)
+    return GDB_OSABI_NETBSD_ELF;
+
+  return GDB_OSABI_UNKNOWN;
+}
+
+void
+_initialize_brownie32nbsd_tdep (void)
+{
+  gdbarch_register_osabi (bfd_arch_brownie32, 0, GDB_OSABI_NETBSD_ELF,
+			  brownie32nbsd_init_abi);
+}
Index: gdb/brownie32nbsd-tdep.h
===================================================================
RCS file: gdb/brownie32nbsd-tdep.h
diff -N gdb/brownie32nbsd-tdep.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/brownie32nbsd-tdep.h	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,36 @@
+/* Common target dependent code for GDB on BROWNIE32 systems running NetBSD.
+
+   Copyright 2002, 2004 Free Software Foundation, Inc.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef BROWNIE32NBSD_TDEP_H
+#define BROWNIE32NBSD_TDEP_H
+
+void brownie32nbsd_supply_reg (char *, int);
+void brownie32nbsd_fill_reg (char *, int);
+
+void brownie32nbsd_supply_fpreg (char *, int);
+void brownie32nbsd_fill_fpreg (char *, int);
+
+#define SIZEOF_STRUCT_REG	(38 * brownie32_isa_regsize (current_gdbarch))
+#define SIZEOF_STRUCT_FPREG	(33 * brownie32_isa_regsize (current_gdbarch))
+
+#endif /* BROWNIE32NBSD_TDEP_H */
Index: gdb/brownie32read.c
===================================================================
RCS file: gdb/brownie32read.c
diff -N gdb/brownie32read.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/brownie32read.c	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,410 @@
+/* Read a symbol table in BROWNIE32' format (Third-Eye).
+
+   Copyright 1986, 1987, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
+   1998, 1999, 2000, 2001, 2003, 2004
+   Free Software Foundation, Inc.
+
+   Contributed by Alessandro Forin (af@cs.cmu.edu) at CMU.  Major work
+   by Per Bothner, John Gilmore and Ian Lance Taylor at Cygnus Support.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* Read symbols from an ECOFF file.  Most of the work is done in
+   mdebugread.c.  */
+
+#include "defs.h"
+#include "gdb_string.h"
+#include "bfd.h"
+#include "symtab.h"
+#include "objfiles.h"
+#include "buildsym.h"
+#include "stabsread.h"
+
+#include "coff/sym.h"
+#include "coff/internal.h"
+#include "coff/ecoff.h"
+#include "libcoff.h"		/* Private BFD COFF information.  */
+#include "libecoff.h"		/* Private BFD ECOFF information.  */
+#include "elf/common.h"
+#include "elf/brownie32.h"
+
+static void
+read_alphacoff_dynamic_symtab (struct section_offsets *,
+			       struct objfile *objfile);
+
+/* Initialize anything that needs initializing when a completely new
+   symbol file is specified (not just adding some symbols from another
+   file, e.g. a shared library).  */
+
+static void
+brownie32coff_new_init (struct objfile *ignore)
+{
+  stabsread_new_init ();
+  buildsym_new_init ();
+}
+
+/* Initialize to read a symbol file (nothing to do).  */
+
+static void
+brownie32coff_symfile_init (struct objfile *objfile)
+{
+}
+
+/* Read a symbol file from a file.  */
+
+static void
+brownie32coff_symfile_read (struct objfile *objfile, int mainline)
+{
+  bfd *abfd = objfile->obfd;
+  struct cleanup *back_to;
+
+  init_minimal_symbol_collection ();
+  back_to = make_cleanup_discard_minimal_symbols ();
+
+  /* Now that the executable file is positioned at symbol table,
+     process it and define symbols accordingly.  */
+
+  if (!((*ecoff_backend (abfd)->debug_swap.read_debug_info)
+	(abfd, (asection *) NULL, &ecoff_data (abfd)->debug_info)))
+    error (_("Error reading symbol table: %s"), bfd_errmsg (bfd_get_error ()));
+
+  mdebug_build_psymtabs (objfile, &ecoff_backend (abfd)->debug_swap,
+			 &ecoff_data (abfd)->debug_info);
+
+  /* Add alpha coff dynamic symbols.  */
+
+  read_alphacoff_dynamic_symtab (objfile->section_offsets, objfile);
+
+  /* Install any minimal symbols that have been collected as the current
+     minimal symbols for this objfile. */
+
+  install_minimal_symbols (objfile);
+  do_cleanups (back_to);
+}
+
+/* Perform any local cleanups required when we are done with a
+   particular objfile.  */
+
+static void
+brownie32coff_symfile_finish (struct objfile *objfile)
+{
+}
+
+/* Alpha OSF/1 encapsulates the dynamic symbols in ELF format in a
+   standard COFF section.  The ELF format for the symbols differs from
+   the format defined in elf/external.h.  It seems that a normal ELF
+   32-bit format is used, and the representation only changes because
+   longs are 64-bit on the alpha. In addition, the handling of
+   text/data section indices for symbols is different from the ELF
+   ABI.  As the BFD linker currently does not support dynamic linking
+   on the alpha, there seems to be no reason to pollute BFD with
+   another mixture of object file formats for now.  */
+
+/* Format of an alpha external ELF symbol.  */
+
+typedef struct
+{
+  unsigned char st_name[4];	/* Symbol name, index in string table.  */
+  unsigned char st_pad[4];	/* Pad to long word boundary.  */
+  unsigned char st_value[8];	/* Value of the symbol.  */
+  unsigned char st_size[4];	/* Associated symbol size.  */
+  unsigned char st_info[1];	/* Type and binding attributes.  */
+  unsigned char st_other[1];	/* No defined meaning, 0.  */
+  unsigned char st_shndx[2];	/* Associated section index.  */
+} Elfalpha_External_Sym;
+
+/* Format of an alpha external ELF dynamic info structure.  */
+
+typedef struct
+{
+  unsigned char d_tag[4];	/* Tag.  */
+  unsigned char d_pad[4];	/* Pad to long word boundary.  */
+  union
+  {
+    unsigned char d_ptr[8];	/* Pointer value.  */
+    unsigned char d_val[4];	/* Integer value.  */
+  }
+  d_un;
+} Elfalpha_External_Dyn;
+
+/* Struct to obtain the section pointers for alpha dynamic symbol info.  */
+
+struct alphacoff_dynsecinfo
+{
+  asection *sym_sect;		/* Section pointer for .dynsym section.  */
+  asection *str_sect;		/* Section pointer for .dynstr section.  */
+  asection *dyninfo_sect;	/* Section pointer for .dynamic section.  */
+  asection *got_sect;		/* Section pointer for .got section.  */
+};
+
+/* We are called once per section from read_alphacoff_dynamic_symtab.
+   We need to examine each section we are passed, check to see if it
+   is something we are interested in processing, and if so, stash away
+   some access information for the section.  */
+
+static void
+alphacoff_locate_sections (bfd *ignore_abfd, asection *sectp, void *sip)
+{
+  struct alphacoff_dynsecinfo *si;
+
+  si = (struct alphacoff_dynsecinfo *) sip;
+
+  if (strcmp (sectp->name, ".dynsym") == 0)
+    si->sym_sect = sectp;
+  else if (strcmp (sectp->name, ".dynstr") == 0)
+    si->str_sect = sectp;
+  else if (strcmp (sectp->name, ".dynamic") == 0)
+    si->dyninfo_sect = sectp;
+  else if (strcmp (sectp->name, ".got") == 0)
+      si->got_sect = sectp;
+}
+
+/* Scan an alpha dynamic symbol table for symbols of interest and add
+   them to the minimal symbol table.  */
+
+static void
+read_alphacoff_dynamic_symtab (struct section_offsets *section_offsets,
+			       struct objfile *objfile)
+{
+  bfd *abfd = objfile->obfd;
+  struct alphacoff_dynsecinfo si;
+  char *sym_secptr;
+  char *str_secptr;
+  char *dyninfo_secptr;
+  char *got_secptr;
+  bfd_size_type sym_secsize;
+  bfd_size_type str_secsize;
+  bfd_size_type dyninfo_secsize;
+  bfd_size_type got_secsize;
+  int sym_count;
+  int i;
+  int stripped;
+  Elfalpha_External_Sym *x_symp;
+  char *dyninfo_p;
+  char *dyninfo_end;
+  int got_entry_size = 8;
+  int dt_brownie32_local_gotno = -1;
+  int dt_brownie32_gotsym = -1;
+  struct cleanup *cleanups;
+
+  /* We currently only know how to handle alpha dynamic symbols.  */
+  if (bfd_get_arch (abfd) != bfd_arch_alpha)
+    return;
+
+  /* Locate the dynamic symbols sections and read them in.  */
+  memset ((char *) &si, 0, sizeof (si));
+  bfd_map_over_sections (abfd, alphacoff_locate_sections, (void *) & si);
+  if (si.sym_sect == NULL || si.str_sect == NULL
+      || si.dyninfo_sect == NULL || si.got_sect == NULL)
+    return;
+
+  sym_secsize = bfd_get_section_size (si.sym_sect);
+  str_secsize = bfd_get_section_size (si.str_sect);
+  dyninfo_secsize = bfd_get_section_size (si.dyninfo_sect);
+  got_secsize = bfd_get_section_size (si.got_sect);
+  sym_secptr = xmalloc (sym_secsize);
+  cleanups = make_cleanup (free, sym_secptr);
+  str_secptr = xmalloc (str_secsize);
+  make_cleanup (free, str_secptr);
+  dyninfo_secptr = xmalloc (dyninfo_secsize);
+  make_cleanup (free, dyninfo_secptr);
+  got_secptr = xmalloc (got_secsize);
+  make_cleanup (free, got_secptr);
+
+  if (!bfd_get_section_contents (abfd, si.sym_sect, sym_secptr,
+				 (file_ptr) 0, sym_secsize))
+    return;
+  if (!bfd_get_section_contents (abfd, si.str_sect, str_secptr,
+				 (file_ptr) 0, str_secsize))
+    return;
+  if (!bfd_get_section_contents (abfd, si.dyninfo_sect, dyninfo_secptr,
+				 (file_ptr) 0, dyninfo_secsize))
+    return;
+  if (!bfd_get_section_contents (abfd, si.got_sect, got_secptr,
+				 (file_ptr) 0, got_secsize))
+    return;
+
+  /* Find the number of local GOT entries and the index for the the
+     first dynamic symbol in the GOT.  */
+  for (dyninfo_p = dyninfo_secptr, dyninfo_end = dyninfo_p + dyninfo_secsize;
+       dyninfo_p < dyninfo_end;
+       dyninfo_p += sizeof (Elfalpha_External_Dyn))
+    {
+      Elfalpha_External_Dyn *x_dynp = (Elfalpha_External_Dyn *) dyninfo_p;
+      long dyn_tag;
+
+      dyn_tag = bfd_h_get_32 (abfd, (bfd_byte *) x_dynp->d_tag);
+      if (dyn_tag == DT_NULL)
+	break;
+      else if (dyn_tag == DT_BROWNIE32_LOCAL_GOTNO)
+	{
+	  if (dt_brownie32_local_gotno < 0)
+	    dt_brownie32_local_gotno
+	      = bfd_h_get_32 (abfd, (bfd_byte *) x_dynp->d_un.d_val);
+	}
+      else if (dyn_tag == DT_BROWNIE32_GOTSYM)
+	{
+	  if (dt_brownie32_gotsym < 0)
+	    dt_brownie32_gotsym
+	      = bfd_h_get_32 (abfd, (bfd_byte *) x_dynp->d_un.d_val);
+	}
+    }
+  if (dt_brownie32_local_gotno < 0 || dt_brownie32_gotsym < 0)
+    return;
+
+  /* Scan all dynamic symbols and enter them into the minimal symbol
+     table if appropriate.  */
+  sym_count = sym_secsize / sizeof (Elfalpha_External_Sym);
+  stripped = (bfd_get_symcount (abfd) == 0);
+
+  /* Skip first symbol, which is a null dummy.  */
+  for (i = 1, x_symp = (Elfalpha_External_Sym *) sym_secptr + 1;
+       i < sym_count;
+       i++, x_symp++)
+    {
+      unsigned long strx;
+      char *name;
+      bfd_vma sym_value;
+      unsigned char sym_info;
+      unsigned int sym_shndx;
+      int isglobal;
+      enum minimal_symbol_type ms_type;
+
+      strx = bfd_h_get_32 (abfd, (bfd_byte *) x_symp->st_name);
+      if (strx >= str_secsize)
+	continue;
+      name = str_secptr + strx;
+      if (*name == '\0' || *name == '.')
+	continue;
+
+      sym_value = bfd_h_get_64 (abfd, (bfd_byte *) x_symp->st_value);
+      sym_info = bfd_h_get_8 (abfd, (bfd_byte *) x_symp->st_info);
+      sym_shndx = bfd_h_get_16 (abfd, (bfd_byte *) x_symp->st_shndx);
+      isglobal = (ELF_ST_BIND (sym_info) == STB_GLOBAL);
+
+      if (sym_shndx == SHN_UNDEF)
+	{
+	  /* Handle undefined functions which are defined in a shared
+	     library.  */
+	  if (ELF_ST_TYPE (sym_info) != STT_FUNC
+	      || ELF_ST_BIND (sym_info) != STB_GLOBAL)
+	    continue;
+
+	  ms_type = mst_solib_trampoline;
+
+	  /* If sym_value is nonzero, it points to the shared library
+	     trampoline entry, which is what we are looking for.
+
+	     If sym_value is zero, then we have to get the GOT entry
+	     for the symbol.
+
+	     If the GOT entry is nonzero, it represents the quickstart
+	     address of the function and we use that as the symbol
+	     value.
+
+	     If the GOT entry is zero, the function address has to be
+	     resolved by the runtime loader before the executable is
+	     started.  We are unable to find any meaningful address
+	     for these functions in the executable file, so we skip
+	     them.  */
+	  if (sym_value == 0)
+	    {
+	      int got_entry_offset =
+		(i - dt_brownie32_gotsym + dt_brownie32_local_gotno) * got_entry_size;
+
+	      if (got_entry_offset < 0 || got_entry_offset >= got_secsize)
+		continue;
+	      sym_value =
+		bfd_h_get_64 (abfd,
+			      (bfd_byte *) (got_secptr + got_entry_offset));
+	      if (sym_value == 0)
+		continue;
+	    }
+	}
+      else
+	{
+	  /* Symbols defined in the executable itself. We only care
+	     about them if this is a stripped executable, otherwise
+	     they have been retrieved from the normal symbol table
+	     already.  */
+	  if (!stripped)
+	    continue;
+
+	  if (sym_shndx == SHN_BROWNIE32_TEXT)
+	    {
+	      if (isglobal)
+		ms_type = mst_text;
+	      else
+		ms_type = mst_file_text;
+	      sym_value += ANOFFSET (section_offsets, SECT_OFF_TEXT (objfile));
+	    }
+	  else if (sym_shndx == SHN_BROWNIE32_DATA)
+	    {
+	      if (isglobal)
+		ms_type = mst_data;
+	      else
+		ms_type = mst_file_data;
+	      sym_value += ANOFFSET (section_offsets, SECT_OFF_DATA (objfile));
+	    }
+	  else if (sym_shndx == SHN_BROWNIE32_ACOMMON)
+	    {
+	      if (isglobal)
+		ms_type = mst_bss;
+	      else
+		ms_type = mst_file_bss;
+	      sym_value += ANOFFSET (section_offsets, SECT_OFF_BSS (objfile));
+	    }
+	  else if (sym_shndx == SHN_ABS)
+	    {
+	      ms_type = mst_abs;
+	    }
+	  else
+	    {
+	      continue;
+	    }
+	}
+
+      prim_record_minimal_symbol (name, sym_value, ms_type, objfile);
+    }
+
+  do_cleanups (cleanups);
+}
+
+/* Initialization.  */
+
+static struct sym_fns ecoff_sym_fns =
+{
+  bfd_target_ecoff_flavour,
+  brownie32coff_new_init,		/* sym_new_init: init anything gbl to entire symtab */
+  brownie32coff_symfile_init,	/* sym_init: read initial info, setup for sym_read() */
+  brownie32coff_symfile_read,	/* sym_read: read a symbol file into symtab */
+  brownie32coff_symfile_finish,	/* sym_finish: finished with file, cleanup */
+  default_symfile_offsets,	/* sym_offsets: dummy FIXME til implem sym reloc */
+  NULL				/* next: pointer to next struct sym_fns */
+};
+
+/* Provide a prototype to silence -Wmissing-prototypes.  */
+void _initialize_brownie32read (void);
+
+void
+_initialize_brownie32read (void)
+{
+  add_symtab_fns (&ecoff_sym_fns);
+}
Index: gdb/brownie32v4-nat.c
===================================================================
RCS file: gdb/brownie32v4-nat.c
diff -N gdb/brownie32v4-nat.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/brownie32v4-nat.c	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,175 @@
+/* Native support for BROWNIE32 running SVR4, for GDB.
+   Copyright 1994, 1995, 2000, 2001 Free Software Foundation, Inc.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include "defs.h"
+#include "inferior.h"
+#include "gdbcore.h"
+#include "target.h"
+#include "regcache.h"
+
+#include <sys/time.h>
+#include <sys/procfs.h>
+#include <setjmp.h>		/* For JB_XXX.  */
+
+/* Prototypes for supply_gregset etc. */
+#include "gregset.h"
+
+/* Size of elements in jmpbuf */
+
+#define JB_ELEMENT_SIZE 4
+
+/*
+ * See the comment in m68k-tdep.c regarding the utility of these functions.
+ *
+ * These definitions are from the BROWNIE32 SVR4 ABI, so they may work for
+ * any BROWNIE32 SVR4 target.
+ */
+
+void
+supply_gregset (gregset_t *gregsetp)
+{
+  int regi;
+  greg_t *regp = &(*gregsetp)[0];
+  char zerobuf[MAX_REGISTER_SIZE];
+  memset (zerobuf, 0, MAX_REGISTER_SIZE);
+
+  for (regi = 0; regi <= CXT_RA; regi++)
+    regcache_raw_supply (current_regcache, regi, (char *) (regp + regi));
+
+  regcache_raw_supply (current_regcache, brownie32_regnum (current_gdbarch)->pc,
+		       (char *) (regp + CXT_EPC));
+  regcache_raw_supply (current_regcache, brownie32_regnum (current_gdbarch)->hi,
+		       (char *) (regp + CXT_MDHI));
+  regcache_raw_supply (current_regcache, brownie32_regnum (current_gdbarch)->lo,
+		       (char *) (regp + CXT_MDLO));
+  regcache_raw_supply (current_regcache, brownie32_regnum (current_gdbarch)->cause,
+		       (char *) (regp + CXT_CAUSE));
+
+  /* Fill inaccessible registers with zero.  */
+  regcache_raw_supply (current_regcache, BROWNIE32_PS_REGNUM, zerobuf);
+  regcache_raw_supply (current_regcache,
+		       brownie32_regnum (current_gdbarch)->badvaddr,
+		       zerobuf);
+  regcache_raw_supply (current_regcache, DEPRECATED_FP_REGNUM, zerobuf);
+  regcache_raw_supply (current_regcache, BROWNIE32_UNUSED_REGNUM, zerobuf);
+  for (regi = BROWNIE32_FIRST_EMBED_REGNUM; regi <= BROWNIE32_LAST_EMBED_REGNUM; regi++)
+    regcache_raw_supply (current_regcache, regi, zerobuf);
+}
+
+void
+fill_gregset (gregset_t *gregsetp, int regno)
+{
+  int regi;
+  greg_t *regp = &(*gregsetp)[0];
+
+  for (regi = 0; regi <= 32; regi++)
+    if ((regno == -1) || (regno == regi))
+      *(regp + regi) = *(greg_t *) & deprecated_registers[DEPRECATED_REGISTER_BYTE (regi)];
+
+  if ((regno == -1) || (regno == brownie32_regnum (current_gdbarch)->pc))
+    *(regp + CXT_EPC) = *(greg_t *) & deprecated_registers[DEPRECATED_REGISTER_BYTE (brownie32_regnum (current_gdbarch)->pc)];
+
+  if ((regno == -1) || (regno == brownie32_regnum (current_gdbarch)->cause))
+    *(regp + CXT_CAUSE) = *(greg_t *) & deprecated_registers[DEPRECATED_REGISTER_BYTE (brownie32_regnum (current_gdbarch)->cause)];
+
+  if ((regno == -1) || (regno == brownie32_regnum (current_gdbarch)->hi))
+    *(regp + CXT_MDHI) = *(greg_t *) & deprecated_registers[DEPRECATED_REGISTER_BYTE (brownie32_regnum (current_gdbarch)->hi)];
+
+  if ((regno == -1) || (regno == brownie32_regnum (current_gdbarch)->lo))
+    *(regp + CXT_MDLO) = *(greg_t *) & deprecated_registers[DEPRECATED_REGISTER_BYTE (brownie32_regnum (current_gdbarch)->lo)];
+}
+
+/*
+ * Now we do the same thing for floating-point registers.
+ * We don't bother to condition on FP0 regnum since any
+ * reasonable BROWNIE32 configuration has an R3010 in it.
+ *
+ * Again, see the comments in m68k-tdep.c.
+ */
+
+void
+supply_fpregset (fpregset_t *fpregsetp)
+{
+  int regi;
+  char zerobuf[MAX_REGISTER_SIZE];
+  memset (zerobuf, 0, MAX_REGISTER_SIZE);
+
+  for (regi = 0; regi < 32; regi++)
+    regcache_raw_supply (current_regcache,
+			 brownie32_regnum (current_gdbarch)->fp0 + regi,
+			 (char *) &fpregsetp->fp_r.fp_regs[regi]);
+
+  regcache_raw_supply (current_regcache,
+		       brownie32_regnum (current_gdbarch)->fp_control_status,
+		       (char *) &fpregsetp->fp_csr);
+
+  /* FIXME: how can we supply FCRIR?  The ABI doesn't tell us. */
+  regcache_raw_supply (current_regcache,
+		       brownie32_regnum (current_gdbarch)->fp_implementation_revision,
+		       zerobuf);
+}
+
+void
+fill_fpregset (fpregset_t *fpregsetp, int regno)
+{
+  int regi;
+  char *from, *to;
+
+  for (regi = brownie32_regnum (current_gdbarch)->fp0;
+       regi < brownie32_regnum (current_gdbarch)->fp0 + 32; regi++)
+    {
+      if ((regno == -1) || (regno == regi))
+	{
+	  from = (char *) &deprecated_registers[DEPRECATED_REGISTER_BYTE (regi)];
+	  to = (char *) &(fpregsetp->fp_r.fp_regs[regi - brownie32_regnum (current_gdbarch)->fp0]);
+	  memcpy (to, from, register_size (current_gdbarch, regi));
+	}
+    }
+
+  if ((regno == -1)
+      || (regno == brownie32_regnum (current_gdbarch)->fp_control_status))
+    fpregsetp->fp_csr = *(unsigned *) &deprecated_registers[DEPRECATED_REGISTER_BYTE (brownie32_regnum (current_gdbarch)->fp_control_status)];
+}
+
+
+/* Figure out where the longjmp will land.
+   We expect the first arg to be a pointer to the jmp_buf structure from which
+   we extract the pc (_JB_PC) that we will land at.  The pc is copied into PC.
+   This routine returns true on success. */
+
+int
+get_longjmp_target (CORE_ADDR *pc)
+{
+  char *buf;
+  CORE_ADDR jb_addr;
+
+  buf = alloca (TARGET_PTR_BIT / TARGET_CHAR_BIT);
+  jb_addr = read_register (BROWNIE32_A0_REGNUM);
+
+  if (target_read_memory (jb_addr + _JB_PC * JB_ELEMENT_SIZE, buf,
+			  TARGET_PTR_BIT / TARGET_CHAR_BIT))
+    return 0;
+
+  *pc = extract_unsigned_integer (buf, TARGET_PTR_BIT / TARGET_CHAR_BIT);
+
+  return 1;
+}
Index: gdb/configure
===================================================================
RCS file: /home/prj/asip/cvs/gdb/gdb/configure,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- gdb/configure	31 Jul 2007 11:40:22 -0000	1.1.1.1
+++ gdb/configure	8 Aug 2007 08:49:54 -0000	1.2
@@ -5,6 +5,7 @@
 # Copyright (C) 2003 Free Software Foundation, Inc.
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
+#
 ## --------------------- ##
 ## M4sh Initialization.  ##
 ## --------------------- ##
@@ -17920,6 +17921,14 @@ cat >>confdefs.h <<\_ACEOF
 _ACEOF
 
       ;;
+  brownie32-sgi-irix5*)
+      # Work around <sys/proc.h> needing _KMEMUSER problem on IRIX 5.
+
+cat >>confdefs.h <<\_ACEOF
+#define _KMEMUSER 1
+_ACEOF
+
+      ;;
   esac
 fi
 
@@ -22169,9 +22178,10 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   # 1. Remove the extension, and $U if already installed.
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
-  # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
-  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
 
Index: gdb/configure.ac
===================================================================
RCS file: /home/prj/asip/cvs/gdb/gdb/configure.ac,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- gdb/configure.ac	31 Jul 2007 11:40:23 -0000	1.1.1.1
+++ gdb/configure.ac	8 Aug 2007 08:49:54 -0000	1.2
@@ -2,6 +2,8 @@ dnl Autoconf configure script for GDB, t
 dnl Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
 dnl Free Software Foundation, Inc.
 dnl
+dnl Copyright (C) 2005,2006  Upwind technology, Inc.
+dnl
 dnl This file is part of GDB.
 dnl 
 dnl This program is free software; you can redistribute it and/or modify
@@ -705,6 +707,12 @@ if test "${target}" = "${host}"; then
       [Define to 1 so <sys/proc.h> gets a definition of anon_hdl.  Works
        around a <sys/proc.h> problem on IRIX 5.])
       ;;
+  brownie32-sgi-irix5*)
+      # Work around <sys/proc.h> needing _KMEMUSER problem on IRIX 5.
+      AC_DEFINE([_KMEMUSER], 1,
+      [Define to 1 so <sys/proc.h> gets a definition of anon_hdl.  Works
+       around a <sys/proc.h> problem on IRIX 5.])
+      ;;
   esac
 fi
 
Index: gdb/configure.host
===================================================================
RCS file: /home/prj/asip/cvs/gdb/gdb/configure.host,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- gdb/configure.host	31 Jul 2007 11:40:22 -0000	1.1.1.1
+++ gdb/configure.host	8 Aug 2007 08:49:54 -0000	1.2
@@ -20,6 +20,7 @@ i[34567]86*)		gdb_host_cpu=i386 ;;
 m68*)			gdb_host_cpu=m68k ;;
 m88*)			gdb_host_cpu=m88k ;;
 mips*)			gdb_host_cpu=mips ;;
+brownie32*)			gdb_host_cpu=brownie32 ;;
 powerpc*)		gdb_host_cpu=powerpc ;;
 sparcv9 | sparc64)	gdb_host_cpu=sparc ;;
 s390*)			gdb_host_cpu=s390 ;;
@@ -103,6 +104,13 @@ mips*-*-netbsd* | mips*-*-knetbsd*-gnu)
 			gdb_host=nbsd ;;
 mips64*-*-openbsd*)	gdb_host=obsd64 ;;
 
+brownie32-sgi-irix5*)	gdb_host=irix5 ;;
+brownie32-sgi-irix6*)	gdb_host=irix6 ;;
+brownie32*-*-linux*)		gdb_host=linux ;;
+brownie32*-*-netbsd* | brownie32*-*-knetbsd*-gnu)
+			gdb_host=nbsd ;;
+brownie3264*-*-openbsd*)	gdb_host=obsd64 ;;
+
 powerpc-*-aix*)		gdb_host=aix ;;
 powerpc-*-linux*)	gdb_host=linux ;;
 powerpc-*-netbsd* | powerpc-*-knetbsd*-gnu)
Index: gdb/configure.tgt
===================================================================
RCS file: /home/prj/asip/cvs/gdb/gdb/configure.tgt,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- gdb/configure.tgt	31 Jul 2007 11:40:22 -0000	1.1.1.1
+++ gdb/configure.tgt	8 Aug 2007 08:49:54 -0000	1.2
@@ -20,6 +20,7 @@ m68hc11*|m6811*)	gdb_target_cpu=m68hc11 
 m68*)			gdb_target_cpu=m68k ;;
 m88*)			gdb_target_cpu=m88k ;;
 mips*)			gdb_target_cpu=mips ;;
+brownie32*)			gdb_target_cpu=brownie32 ;;
 ms1*)			gdb_target_cpu=ms1 ;;
 powerpc*)		gdb_target_cpu=powerpc ;;
 sparc*)			gdb_target_cpu=sparc ;;
@@ -143,6 +144,17 @@ mips*-*-netbsd* | mips*-*-knetbsd*-gnu)
 mips64*-*-openbsd*)	gdb_target=obsd64 ;;
 mips*-*-*)		gdb_target=embed ;;
 
+brownie32*-*-pe)		gdb_target=wince ;;
+brownie32*-sgi-irix5*)	gdb_target=irix5 ;;
+brownie32*-sgi-irix6*)	gdb_target=irix6 ;;
+brownie32*-*-linux*)		gdb_target=linux
+			build_gdbserver=yes
+			;;
+brownie32*-*-netbsd* | brownie32*-*-knetbsd*-gnu)
+			gdb_target=nbsd ;;
+brownie3264*-*-openbsd*)	gdb_target=obsd64 ;;
+brownie32*-*-*)		gdb_target=embed ;;
+
 mn10300-*-*)		gdb_target=mn10300 ;;
 
 ms1-*-*)		gdb_target=ms1 ;;
Index: gdb/infcmd.c
===================================================================
RCS file: /home/prj/asip/cvs/gdb/gdb/infcmd.c,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -p -r1.1.1.1 -r1.3
--- gdb/infcmd.c	31 Jul 2007 11:40:22 -0000	1.1.1.1
+++ gdb/infcmd.c	24 Feb 2008 16:51:52 -0000	1.3
@@ -972,7 +972,7 @@ signal_command (char *signum_exp, int fr
   if (from_tty)
     {
       if (oursig == TARGET_SIGNAL_0)
-	printf_filtered (_("Continuing with no signal.\n"));
+        printf_filtered (_("Continuing with no signal.\n"));
       else
 	printf_filtered (_("Continuing with signal %s.\n"),
 			 target_signal_to_name (oursig));
Index: gdb/remote-brownie32.c
===================================================================
RCS file: gdb/remote-brownie32.c
diff -N gdb/remote-brownie32.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/remote-brownie32.c	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,3441 @@
+/* Remote debugging interface for BROWNIE32 remote debugging protocol.
+
+   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
+   2002, 2003, 2004 Free Software Foundation, Inc.
+
+   Contributed by Cygnus Support.  Written by Ian Lance Taylor
+   <ian@cygnus.com>.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include "defs.h"
+#include "inferior.h"
+#include "bfd.h"
+#include "symfile.h"
+#include "gdbcmd.h"
+#include "gdbcore.h"
+#include "serial.h"
+#include "target.h"
+#include "exceptions.h"
+#include "remote-utils.h"
+#include "gdb_string.h"
+#include "gdb_stat.h"
+#include "regcache.h"
+#include <ctype.h>
+#include "brownie32-tdep.h"
+
+
+/* Breakpoint types.  Values 0, 1, and 2 must agree with the watch
+   types passed by breakpoint.c to target_insert_watchpoint.
+   Value 3 is our own invention, and is used for ordinary instruction
+   breakpoints.  Value 4 is used to mark an unused watchpoint in tables.  */
+enum break_type
+  {
+    BREAK_WRITE,		/* 0 */
+    BREAK_READ,			/* 1 */
+    BREAK_ACCESS,		/* 2 */
+    BREAK_FETCH,		/* 3 */
+    BREAK_UNUSED		/* 4 */
+  };
+
+/* Prototypes for local functions.  */
+
+static int brownie32_readchar (int timeout);
+
+static int brownie32_receive_header (unsigned char *hdr, int *pgarbage,
+				int ch, int timeout);
+
+static int brownie32_receive_trailer (unsigned char *trlr, int *pgarbage,
+				 int *pch, int timeout);
+
+static int brownie32_cksum (const unsigned char *hdr,
+		       const unsigned char *data, int len);
+
+static void brownie32_send_packet (const char *s, int get_ack);
+
+static void brownie32_send_command (const char *cmd, int prompt);
+
+static int brownie32_receive_packet (char *buff, int throw_error, int timeout);
+
+static ULONGEST brownie32_request (int cmd, ULONGEST addr, ULONGEST data,
+			      int *perr, int timeout, char *buff);
+
+static void brownie32_initialize (void);
+
+static void brownie32_open (char *name, int from_tty);
+
+static void pmon_open (char *name, int from_tty);
+
+static void ddb_open (char *name, int from_tty);
+
+static void lsi_open (char *name, int from_tty);
+
+static void brownie32_close (int quitting);
+
+static void brownie32_detach (char *args, int from_tty);
+
+static void brownie32_resume (ptid_t ptid, int step,
+                         enum target_signal siggnal);
+
+static ptid_t brownie32_wait (ptid_t ptid,
+                               struct target_waitstatus *status);
+
+static int brownie32_map_regno (int regno);
+
+static void brownie32_fetch_registers (int regno);
+
+static void brownie32_prepare_to_store (void);
+
+static void brownie32_store_registers (int regno);
+
+static unsigned int brownie32_fetch_word (CORE_ADDR addr);
+
+static int brownie32_store_word (CORE_ADDR addr, unsigned int value,
+			    char *old_contents);
+
+static int brownie32_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len,
+			     int write, 
+			     struct mem_attrib *attrib,
+			     struct target_ops *target);
+
+static void brownie32_files_info (struct target_ops *ignore);
+
+static void brownie32_mourn_inferior (void);
+
+static int pmon_makeb64 (unsigned long v, char *p, int n, int *chksum);
+
+static int pmon_zeroset (int recsize, char **buff, int *amount,
+			 unsigned int *chksum);
+
+static int pmon_checkset (int recsize, char **buff, int *value);
+
+static void pmon_make_fastrec (char **outbuf, unsigned char *inbuf,
+			       int *inptr, int inamount, int *recsize,
+			       unsigned int *csum, unsigned int *zerofill);
+
+static int pmon_check_ack (char *mesg);
+
+static void pmon_start_download (void);
+
+static void pmon_end_download (int final, int bintotal);
+
+static void pmon_download (char *buffer, int length);
+
+static void pmon_load_fast (char *file);
+
+static void brownie32_load (char *file, int from_tty);
+
+static int brownie32_make_srec (char *buffer, int type, CORE_ADDR memaddr,
+			   unsigned char *myaddr, int len);
+
+static int set_breakpoint (CORE_ADDR addr, int len, enum break_type type);
+
+static int clear_breakpoint (CORE_ADDR addr, int len, enum break_type type);
+
+static int common_breakpoint (int set, CORE_ADDR addr, int len,
+			      enum break_type type);
+
+/* Forward declarations.  */
+extern struct target_ops brownie32_ops;
+extern struct target_ops pmon_ops;
+extern struct target_ops ddb_ops;
+/* *INDENT-OFF* */
+/* The BROWNIE32 remote debugging interface is built on top of a simple
+   packet protocol.  Each packet is organized as follows:
+
+   SYN  The first character is always a SYN (ASCII 026, or ^V).  SYN
+   may not appear anywhere else in the packet.  Any time a SYN is
+   seen, a new packet should be assumed to have begun.
+
+   TYPE_LEN
+   This byte contains the upper five bits of the logical length
+   of the data section, plus a single bit indicating whether this
+   is a data packet or an acknowledgement.  The documentation
+   indicates that this bit is 1 for a data packet, but the actual
+   board uses 1 for an acknowledgement.  The value of the byte is
+   0x40 + (ack ? 0x20 : 0) + (len >> 6)
+   (we always have 0 <= len < 1024).  Acknowledgement packets do
+   not carry data, and must have a data length of 0.
+
+   LEN1 This byte contains the lower six bits of the logical length of
+   the data section.  The value is
+   0x40 + (len & 0x3f)
+
+   SEQ  This byte contains the six bit sequence number of the packet.
+   The value is
+   0x40 + seq
+   An acknowlegment packet contains the sequence number of the
+   packet being acknowledged plus 1 modulo 64.  Data packets are
+   transmitted in sequence.  There may only be one outstanding
+   unacknowledged data packet at a time.  The sequence numbers
+   are independent in each direction.  If an acknowledgement for
+   the previous packet is received (i.e., an acknowledgement with
+   the sequence number of the packet just sent) the packet just
+   sent should be retransmitted.  If no acknowledgement is
+   received within a timeout period, the packet should be
+   retransmitted.  This has an unfortunate failure condition on a
+   high-latency line, as a delayed acknowledgement may lead to an
+   endless series of duplicate packets.
+
+   DATA The actual data bytes follow.  The following characters are
+   escaped inline with DLE (ASCII 020, or ^P):
+   SYN (026)    DLE S
+   DLE (020)    DLE D
+   ^C  (003)    DLE C
+   ^S  (023)    DLE s
+   ^Q  (021)    DLE q
+   The additional DLE characters are not counted in the logical
+   length stored in the TYPE_LEN and LEN1 bytes.
+
+   CSUM1
+   CSUM2
+   CSUM3
+   These bytes contain an 18 bit checksum of the complete
+   contents of the packet excluding the SEQ byte and the
+   CSUM[123] bytes.  The checksum is simply the twos complement
+   addition of all the bytes treated as unsigned characters.  The
+   values of the checksum bytes are:
+   CSUM1: 0x40 + ((cksum >> 12) & 0x3f)
+   CSUM2: 0x40 + ((cksum >> 6) & 0x3f)
+   CSUM3: 0x40 + (cksum & 0x3f)
+
+   It happens that the BROWNIE32 remote debugging protocol always
+   communicates with ASCII strings.  Because of this, this
+   implementation doesn't bother to handle the DLE quoting mechanism,
+   since it will never be required.  */
+/* *INDENT-ON* */
+
+
+/* The SYN character which starts each packet.  */
+#define SYN '\026'
+
+/* The 0x40 used to offset each packet (this value ensures that all of
+   the header and trailer bytes, other than SYN, are printable ASCII
+   characters).  */
+#define HDR_OFFSET 0x40
+
+/* The indices of the bytes in the packet header.  */
+#define HDR_INDX_SYN 0
+#define HDR_INDX_TYPE_LEN 1
+#define HDR_INDX_LEN1 2
+#define HDR_INDX_SEQ 3
+#define HDR_LENGTH 4
+
+/* The data/ack bit in the TYPE_LEN header byte.  */
+#define TYPE_LEN_DA_BIT 0x20
+#define TYPE_LEN_DATA 0
+#define TYPE_LEN_ACK TYPE_LEN_DA_BIT
+
+/* How to compute the header bytes.  */
+#define HDR_SET_SYN(data, len, seq) (SYN)
+#define HDR_SET_TYPE_LEN(data, len, seq) \
+  (HDR_OFFSET \
+   + ((data) ? TYPE_LEN_DATA : TYPE_LEN_ACK) \
+   + (((len) >> 6) & 0x1f))
+#define HDR_SET_LEN1(data, len, seq) (HDR_OFFSET + ((len) & 0x3f))
+#define HDR_SET_SEQ(data, len, seq) (HDR_OFFSET + (seq))
+
+/* Check that a header byte is reasonable.  */
+#define HDR_CHECK(ch) (((ch) & HDR_OFFSET) == HDR_OFFSET)
+
+/* Get data from the header.  These macros evaluate their argument
+   multiple times.  */
+#define HDR_IS_DATA(hdr) \
+  (((hdr)[HDR_INDX_TYPE_LEN] & TYPE_LEN_DA_BIT) == TYPE_LEN_DATA)
+#define HDR_GET_LEN(hdr) \
+  ((((hdr)[HDR_INDX_TYPE_LEN] & 0x1f) << 6) + (((hdr)[HDR_INDX_LEN1] & 0x3f)))
+#define HDR_GET_SEQ(hdr) ((unsigned int)(hdr)[HDR_INDX_SEQ] & 0x3f)
+
+/* The maximum data length.  */
+#define DATA_MAXLEN 1023
+
+/* The trailer offset.  */
+#define TRLR_OFFSET HDR_OFFSET
+
+/* The indices of the bytes in the packet trailer.  */
+#define TRLR_INDX_CSUM1 0
+#define TRLR_INDX_CSUM2 1
+#define TRLR_INDX_CSUM3 2
+#define TRLR_LENGTH 3
+
+/* How to compute the trailer bytes.  */
+#define TRLR_SET_CSUM1(cksum) (TRLR_OFFSET + (((cksum) >> 12) & 0x3f))
+#define TRLR_SET_CSUM2(cksum) (TRLR_OFFSET + (((cksum) >>  6) & 0x3f))
+#define TRLR_SET_CSUM3(cksum) (TRLR_OFFSET + (((cksum)      ) & 0x3f))
+
+/* Check that a trailer byte is reasonable.  */
+#define TRLR_CHECK(ch) (((ch) & TRLR_OFFSET) == TRLR_OFFSET)
+
+/* Get data from the trailer.  This evaluates its argument multiple
+   times.  */
+#define TRLR_GET_CKSUM(trlr) \
+  ((((trlr)[TRLR_INDX_CSUM1] & 0x3f) << 12) \
+   + (((trlr)[TRLR_INDX_CSUM2] & 0x3f) <<  6) \
+   + ((trlr)[TRLR_INDX_CSUM3] & 0x3f))
+
+/* The sequence number modulos.  */
+#define SEQ_MODULOS (64)
+
+/* PMON commands to load from the serial port or UDP socket.  */
+#define LOAD_CMD	"load -b -s tty0\r"
+#define LOAD_CMD_UDP	"load -b -s udp\r"
+
+/* The target vectors for the four different remote BROWNIE32 targets.
+   These are initialized with code in _initialize_remote_brownie32 instead
+   of static initializers, to make it easier to extend the target_ops
+   vector later.  */
+struct target_ops brownie32_ops, pmon_ops, ddb_ops, lsi_ops;
+
+enum brownie32_monitor_type
+  {
+    /* IDT/SIM monitor being used: */
+    MON_IDT,
+    /* PMON monitor being used: */
+    MON_PMON,			/* 3.0.83 [COGENT,EB,FP,NET] Algorithmics Ltd. Nov  9 1995 17:19:50 */
+    MON_DDB,			/* 2.7.473 [DDBVR4300,EL,FP,NET] Risq Modular Systems,  Thu Jun 6 09:28:40 PDT 1996 */
+    MON_LSI,			/* 4.3.12 [EB,FP], LSI LOGIC Corp. Tue Feb 25 13:22:14 1997 */
+    /* Last and unused value, for sizing vectors, etc. */
+    MON_LAST
+  };
+static enum brownie32_monitor_type brownie32_monitor = MON_LAST;
+
+/* The monitor prompt text.  If the user sets the PMON prompt
+   to some new value, the GDB `set monitor-prompt' command must also
+   be used to inform GDB about the expected prompt.  Otherwise, GDB
+   will not be able to connect to PMON in brownie32_initialize().
+   If the `set monitor-prompt' command is not used, the expected
+   default prompt will be set according the target:
+   target               prompt
+   -----                -----
+   pmon         PMON> 
+   ddb          NEC010>
+   lsi          PMON>
+ */
+static char *brownie32_monitor_prompt;
+
+/* Set to 1 if the target is open.  */
+static int brownie32_is_open;
+
+/* Currently active target description (if brownie32_is_open == 1) */
+static struct target_ops *current_ops;
+
+/* Set to 1 while the connection is being initialized.  */
+static int brownie32_initializing;
+
+/* Set to 1 while the connection is being brought down.  */
+static int brownie32_exiting;
+
+/* The next sequence number to send.  */
+static unsigned int brownie32_send_seq;
+
+/* The next sequence number we expect to receive.  */
+static unsigned int brownie32_receive_seq;
+
+/* The time to wait before retransmitting a packet, in seconds.  */
+static int brownie32_retransmit_wait = 3;
+
+/* The number of times to try retransmitting a packet before giving up.  */
+static int brownie32_send_retries = 10;
+
+/* The number of garbage characters to accept when looking for an
+   SYN for the next packet.  */
+static int brownie32_syn_garbage = 10;
+
+/* The time to wait for a packet, in seconds.  */
+static int brownie32_receive_wait = 5;
+
+/* Set if we have sent a packet to the board but have not yet received
+   a reply.  */
+static int brownie32_need_reply = 0;
+
+/* Handle used to access serial I/O stream.  */
+static struct serial *brownie32_desc;
+
+/* UDP handle used to download files to target.  */
+static struct serial *udp_desc;
+static int udp_in_use;
+
+/* TFTP filename used to download files to DDB board, in the form
+   host:filename.  */
+static char *tftp_name;		/* host:filename */
+static char *tftp_localname;	/* filename portion of above */
+static int tftp_in_use;
+static FILE *tftp_file;
+
+/* Counts the number of times the user tried to interrupt the target (usually
+   via ^C.  */
+static int interrupt_count;
+
+/* If non-zero, means that the target is running. */
+static int brownie32_wait_flag = 0;
+
+/* If non-zero, monitor supports breakpoint commands. */
+static int monitor_supports_breakpoints = 0;
+
+/* Data cache header.  */
+
+#if 0				/* not used (yet?) */
+static DCACHE *brownie32_dcache;
+#endif
+
+/* Non-zero means that we've just hit a read or write watchpoint */
+static int hit_watchpoint;
+
+/* Table of breakpoints/watchpoints (used only on LSI PMON target).
+   The table is indexed by a breakpoint number, which is an integer
+   from 0 to 255 returned by the LSI PMON when a breakpoint is set.
+ */
+#define MAX_LSI_BREAKPOINTS 256
+struct lsi_breakpoint_info
+  {
+    enum break_type type;	/* type of breakpoint */
+    CORE_ADDR addr;		/* address of breakpoint */
+    int len;			/* length of region being watched */
+    unsigned long value;	/* value to watch */
+  }
+lsi_breakpoints[MAX_LSI_BREAKPOINTS];
+
+/* Error/warning codes returned by LSI PMON for breakpoint commands.
+   Warning values may be ORed together; error values may not.  */
+#define W_WARN	0x100		/* This bit is set if the error code is a warning */
+#define W_MSK   0x101		/* warning: Range feature is supported via mask */
+#define W_VAL   0x102		/* warning: Value check is not supported in hardware */
+#define W_QAL   0x104		/* warning: Requested qualifiers are not supported in hardware */
+
+#define E_ERR	0x200		/* This bit is set if the error code is an error */
+#define E_BPT   0x200		/* error: No such breakpoint number */
+#define E_RGE   0x201		/* error: Range is not supported */
+#define E_QAL   0x202		/* error: The requested qualifiers can not be used */
+#define E_OUT   0x203		/* error: Out of hardware resources */
+#define E_NON   0x204		/* error: Hardware breakpoint not supported */
+
+struct lsi_error
+  {
+    int code;			/* error code */
+    char *string;		/* string associated with this code */
+  };
+
+struct lsi_error lsi_warning_table[] =
+{
+  {W_MSK, "Range feature is supported via mask"},
+  {W_VAL, "Value check is not supported in hardware"},
+  {W_QAL, "Requested qualifiers are not supported in hardware"},
+  {0, NULL}
+};
+
+struct lsi_error lsi_error_table[] =
+{
+  {E_BPT, "No such breakpoint number"},
+  {E_RGE, "Range is not supported"},
+  {E_QAL, "The requested qualifiers can not be used"},
+  {E_OUT, "Out of hardware resources"},
+  {E_NON, "Hardware breakpoint not supported"},
+  {0, NULL}
+};
+
+/* Set to 1 with the 'set monitor-warnings' command to enable printing
+   of warnings returned by PMON when hardware breakpoints are used.  */
+static int monitor_warnings;
+
+
+static void
+close_ports (void)
+{
+  brownie32_is_open = 0;
+  serial_close (brownie32_desc);
+
+  if (udp_in_use)
+    {
+      serial_close (udp_desc);
+      udp_in_use = 0;
+    }
+  tftp_in_use = 0;
+}
+
+/* Handle low-level error that we can't recover from.  Note that just
+   error()ing out from target_wait or some such low-level place will cause
+   all hell to break loose--the rest of GDB will tend to get left in an
+   inconsistent state.  */
+
+static NORETURN void
+brownie32_error (char *string,...)
+{
+  va_list args;
+
+  va_start (args, string);
+
+  target_terminal_ours ();
+  wrap_here ("");		/* Force out any buffered output */
+  gdb_flush (gdb_stdout);
+  if (error_pre_print)
+    fputs_filtered (error_pre_print, gdb_stderr);
+  vfprintf_filtered (gdb_stderr, string, args);
+  fprintf_filtered (gdb_stderr, "\n");
+  va_end (args);
+  gdb_flush (gdb_stderr);
+
+  /* Clean up in such a way that brownie32_close won't try to talk to the
+     board (it almost surely won't work since we weren't able to talk to
+     it).  */
+  close_ports ();
+
+  printf_unfiltered ("Ending remote BROWNIE32 debugging.\n");
+  target_mourn_inferior ();
+
+  deprecated_throw_reason (RETURN_ERROR);
+}
+
+/* putc_readable - print a character, displaying non-printable chars in
+   ^x notation or in hex.  */
+
+static void
+fputc_readable (int ch, struct ui_file *file)
+{
+  if (ch == '\n')
+    fputc_unfiltered ('\n', file);
+  else if (ch == '\r')
+    fprintf_unfiltered (file, "\\r");
+  else if (ch < 0x20)		/* ASCII control character */
+    fprintf_unfiltered (file, "^%c", ch + '@');
+  else if (ch >= 0x7f)		/* non-ASCII characters (rubout or greater) */
+    fprintf_unfiltered (file, "[%02x]", ch & 0xff);
+  else
+    fputc_unfiltered (ch, file);
+}
+
+
+/* puts_readable - print a string, displaying non-printable chars in
+   ^x notation or in hex.  */
+
+static void
+fputs_readable (const char *string, struct ui_file *file)
+{
+  int c;
+
+  while ((c = *string++) != '\0')
+    fputc_readable (c, file);
+}
+
+
+/* Wait until STRING shows up in brownie32_desc.  Returns 1 if successful, else 0 if
+   timed out.  TIMEOUT specifies timeout value in seconds.
+ */
+
+static int
+brownie32_expect_timeout (const char *string, int timeout)
+{
+  const char *p = string;
+
+  if (remote_debug)
+    {
+      fprintf_unfiltered (gdb_stdlog, "Expected \"");
+      fputs_readable (string, gdb_stdlog);
+      fprintf_unfiltered (gdb_stdlog, "\", got \"");
+    }
+
+  immediate_quit++;
+  while (1)
+    {
+      int c;
+
+      /* Must use serial_readchar() here cuz brownie32_readchar would get
+	 confused if we were waiting for the brownie32_monitor_prompt... */
+
+      c = serial_readchar (brownie32_desc, timeout);
+
+      if (c == SERIAL_TIMEOUT)
+	{
+	  if (remote_debug)
+	    fprintf_unfiltered (gdb_stdlog, "\": FAIL\n");
+	  return 0;
+	}
+
+      if (remote_debug)
+	fputc_readable (c, gdb_stdlog);
+
+      if (c == *p++)
+	{
+	  if (*p == '\0')
+	    {
+	      immediate_quit--;
+	      if (remote_debug)
+		fprintf_unfiltered (gdb_stdlog, "\": OK\n");
+	      return 1;
+	    }
+	}
+      else
+	{
+	  p = string;
+	  if (c == *p)
+	    p++;
+	}
+    }
+}
+
+/* Wait until STRING shows up in brownie32_desc.  Returns 1 if successful, else 0 if
+   timed out.  The timeout value is hard-coded to 2 seconds.  Use
+   brownie32_expect_timeout if a different timeout value is needed.
+ */
+
+static int
+brownie32_expect (const char *string)
+{
+  return brownie32_expect_timeout (string, remote_timeout);
+}
+
+/* Read a character from the remote, aborting on error.  Returns
+   SERIAL_TIMEOUT on timeout (since that's what serial_readchar()
+   returns).  FIXME: If we see the string brownie32_monitor_prompt from the
+   board, then we are debugging on the main console port, and we have
+   somehow dropped out of remote debugging mode.  In this case, we
+   automatically go back in to remote debugging mode.  This is a hack,
+   put in because I can't find any way for a program running on the
+   remote board to terminate without also ending remote debugging
+   mode.  I assume users won't have any trouble with this; for one
+   thing, the IDT documentation generally assumes that the remote
+   debugging port is not the console port.  This is, however, very
+   convenient for DejaGnu when you only have one connected serial
+   port.  */
+
+static int
+brownie32_readchar (int timeout)
+{
+  int ch;
+  static int state = 0;
+  int brownie32_monitor_prompt_len = strlen (brownie32_monitor_prompt);
+
+  {
+    int i;
+
+    i = timeout;
+    if (i == -1 && watchdog > 0)
+      i = watchdog;
+  }
+
+  if (state == brownie32_monitor_prompt_len)
+    timeout = 1;
+  ch = serial_readchar (brownie32_desc, timeout);
+
+  if (ch == SERIAL_TIMEOUT && timeout == -1)	/* Watchdog went off */
+    {
+      target_mourn_inferior ();
+      error ("Watchdog has expired.  Target detached.\n");
+    }
+
+  if (ch == SERIAL_EOF)
+    brownie32_error ("End of file from remote");
+  if (ch == SERIAL_ERROR)
+    brownie32_error ("Error reading from remote: %s", safe_strerror (errno));
+  if (remote_debug > 1)
+    {
+      /* Don't use _filtered; we can't deal with a QUIT out of
+         target_wait, and I think this might be called from there.  */
+      if (ch != SERIAL_TIMEOUT)
+	fprintf_unfiltered (gdb_stdlog, "Read '%c' %d 0x%x\n", ch, ch, ch);
+      else
+	fprintf_unfiltered (gdb_stdlog, "Timed out in read\n");
+    }
+
+  /* If we have seen brownie32_monitor_prompt and we either time out, or
+     we see a @ (which was echoed from a packet we sent), reset the
+     board as described above.  The first character in a packet after
+     the SYN (which is not echoed) is always an @ unless the packet is
+     more than 64 characters long, which ours never are.  */
+  if ((ch == SERIAL_TIMEOUT || ch == '@')
+      && state == brownie32_monitor_prompt_len
+      && !brownie32_initializing
+      && !brownie32_exiting)
+    {
+      if (remote_debug > 0)
+	/* Don't use _filtered; we can't deal with a QUIT out of
+	   target_wait, and I think this might be called from there.  */
+	fprintf_unfiltered (gdb_stdlog, "Reinitializing BROWNIE32 debugging mode\n");
+
+      brownie32_need_reply = 0;
+      brownie32_initialize ();
+
+      state = 0;
+
+      /* At this point, about the only thing we can do is abort the command
+         in progress and get back to command level as quickly as possible. */
+
+      error ("Remote board reset, debug protocol re-initialized.");
+    }
+
+  if (ch == brownie32_monitor_prompt[state])
+    ++state;
+  else
+    state = 0;
+
+  return ch;
+}
+
+/* Get a packet header, putting the data in the supplied buffer.
+   PGARBAGE is a pointer to the number of garbage characters received
+   so far.  CH is the last character received.  Returns 0 for success,
+   or -1 for timeout.  */
+
+static int
+brownie32_receive_header (unsigned char *hdr, int *pgarbage, int ch, int timeout)
+{
+  int i;
+
+  while (1)
+    {
+      /* Wait for a SYN.  brownie32_syn_garbage is intended to prevent
+         sitting here indefinitely if the board sends us one garbage
+         character per second.  ch may already have a value from the
+         last time through the loop.  */
+      while (ch != SYN)
+	{
+	  ch = brownie32_readchar (timeout);
+	  if (ch == SERIAL_TIMEOUT)
+	    return -1;
+	  if (ch != SYN)
+	    {
+	      /* Printing the character here lets the user of gdb see
+	         what the program is outputting, if the debugging is
+	         being done on the console port.  Don't use _filtered:
+	         we can't deal with a QUIT out of target_wait and
+	         buffered target output confuses the user. */
+ 	      if (!brownie32_initializing || remote_debug > 0)
+  		{
+		  if (isprint (ch) || isspace (ch))
+		    {
+		      fputc_unfiltered (ch, gdb_stdtarg);
+		    }
+		  else
+		    {
+		      fputc_readable (ch, gdb_stdtarg);
+		    }
+		  gdb_flush (gdb_stdtarg);
+  		}
+	      
+	      /* Only count unprintable characters. */
+	      if (! (isprint (ch) || isspace (ch)))
+		(*pgarbage) += 1;
+
+	      if (brownie32_syn_garbage > 0
+		  && *pgarbage > brownie32_syn_garbage)
+		brownie32_error ("Debug protocol failure:  more than %d characters before a sync.",
+			    brownie32_syn_garbage);
+	    }
+	}
+
+      /* Get the packet header following the SYN.  */
+      for (i = 1; i < HDR_LENGTH; i++)
+	{
+	  ch = brownie32_readchar (timeout);
+	  if (ch == SERIAL_TIMEOUT)
+	    return -1;
+	  /* Make sure this is a header byte.  */
+	  if (ch == SYN || !HDR_CHECK (ch))
+	    break;
+
+	  hdr[i] = ch;
+	}
+
+      /* If we got the complete header, we can return.  Otherwise we
+         loop around and keep looking for SYN.  */
+      if (i >= HDR_LENGTH)
+	return 0;
+    }
+}
+
+/* Get a packet header, putting the data in the supplied buffer.
+   PGARBAGE is a pointer to the number of garbage characters received
+   so far.  The last character read is returned in *PCH.  Returns 0
+   for success, -1 for timeout, -2 for error.  */
+
+static int
+brownie32_receive_trailer (unsigned char *trlr, int *pgarbage, int *pch, int timeout)
+{
+  int i;
+  int ch;
+
+  for (i = 0; i < TRLR_LENGTH; i++)
+    {
+      ch = brownie32_readchar (timeout);
+      *pch = ch;
+      if (ch == SERIAL_TIMEOUT)
+	return -1;
+      if (!TRLR_CHECK (ch))
+	return -2;
+      trlr[i] = ch;
+    }
+  return 0;
+}
+
+/* Get the checksum of a packet.  HDR points to the packet header.
+   DATA points to the packet data.  LEN is the length of DATA.  */
+
+static int
+brownie32_cksum (const unsigned char *hdr, const unsigned char *data, int len)
+{
+  const unsigned char *p;
+  int c;
+  int cksum;
+
+  cksum = 0;
+
+  /* The initial SYN is not included in the checksum.  */
+  c = HDR_LENGTH - 1;
+  p = hdr + 1;
+  while (c-- != 0)
+    cksum += *p++;
+
+  c = len;
+  p = data;
+  while (c-- != 0)
+    cksum += *p++;
+
+  return cksum;
+}
+
+/* Send a packet containing the given ASCII string.  */
+
+static void
+brownie32_send_packet (const char *s, int get_ack)
+{
+  /* unsigned */ int len;
+  unsigned char *packet;
+  int cksum;
+  int try;
+
+  len = strlen (s);
+  if (len > DATA_MAXLEN)
+    brownie32_error ("BROWNIE32 protocol data packet too long: %s", s);
+
+  packet = (unsigned char *) alloca (HDR_LENGTH + len + TRLR_LENGTH + 1);
+
+  packet[HDR_INDX_SYN] = HDR_SET_SYN (1, len, brownie32_send_seq);
+  packet[HDR_INDX_TYPE_LEN] = HDR_SET_TYPE_LEN (1, len, brownie32_send_seq);
+  packet[HDR_INDX_LEN1] = HDR_SET_LEN1 (1, len, brownie32_send_seq);
+  packet[HDR_INDX_SEQ] = HDR_SET_SEQ (1, len, brownie32_send_seq);
+
+  memcpy (packet + HDR_LENGTH, s, len);
+
+  cksum = brownie32_cksum (packet, packet + HDR_LENGTH, len);
+  packet[HDR_LENGTH + len + TRLR_INDX_CSUM1] = TRLR_SET_CSUM1 (cksum);
+  packet[HDR_LENGTH + len + TRLR_INDX_CSUM2] = TRLR_SET_CSUM2 (cksum);
+  packet[HDR_LENGTH + len + TRLR_INDX_CSUM3] = TRLR_SET_CSUM3 (cksum);
+
+  /* Increment the sequence number.  This will set brownie32_send_seq to
+     the sequence number we expect in the acknowledgement.  */
+  brownie32_send_seq = (brownie32_send_seq + 1) % SEQ_MODULOS;
+
+  /* We can only have one outstanding data packet, so we just wait for
+     the acknowledgement here.  Keep retransmitting the packet until
+     we get one, or until we've tried too many times.  */
+  for (try = 0; try < brownie32_send_retries; try++)
+    {
+      int garbage;
+      int ch;
+
+      if (remote_debug > 0)
+	{
+	  /* Don't use _filtered; we can't deal with a QUIT out of
+	     target_wait, and I think this might be called from there.  */
+	  packet[HDR_LENGTH + len + TRLR_LENGTH] = '\0';
+	  fprintf_unfiltered (gdb_stdlog, "Writing \"%s\"\n", packet + 1);
+	}
+
+      if (serial_write (brownie32_desc, packet,
+			HDR_LENGTH + len + TRLR_LENGTH) != 0)
+	brownie32_error ("write to target failed: %s", safe_strerror (errno));
+
+      if (!get_ack)
+	return;
+
+      garbage = 0;
+      ch = 0;
+      while (1)
+	{
+	  unsigned char hdr[HDR_LENGTH + 1];
+	  unsigned char trlr[TRLR_LENGTH + 1];
+	  int err;
+	  unsigned int seq;
+
+	  /* Get the packet header.  If we time out, resend the data
+	     packet.  */
+	  err = brownie32_receive_header (hdr, &garbage, ch, brownie32_retransmit_wait);
+	  if (err != 0)
+	    break;
+
+	  ch = 0;
+
+	  /* If we get a data packet, assume it is a duplicate and
+	     ignore it.  FIXME: If the acknowledgement is lost, this
+	     data packet may be the packet the remote sends after the
+	     acknowledgement.  */
+	  if (HDR_IS_DATA (hdr))
+	    {
+	      int i;
+
+	      /* Ignore any errors raised whilst attempting to ignore
+	         packet. */
+
+	      len = HDR_GET_LEN (hdr);
+
+	      for (i = 0; i < len; i++)
+		{
+		  int rch;
+
+		  rch = brownie32_readchar (remote_timeout);
+		  if (rch == SYN)
+		    {
+		      ch = SYN;
+		      break;
+		    }
+		  if (rch == SERIAL_TIMEOUT)
+		    break;
+		  /* ignore the character */
+		}
+
+	      if (i == len)
+		(void) brownie32_receive_trailer (trlr, &garbage, &ch,
+					     remote_timeout);
+
+	      /* We don't bother checking the checksum, or providing an
+	         ACK to the packet. */
+	      continue;
+	    }
+
+	  /* If the length is not 0, this is a garbled packet.  */
+	  if (HDR_GET_LEN (hdr) != 0)
+	    continue;
+
+	  /* Get the packet trailer.  */
+	  err = brownie32_receive_trailer (trlr, &garbage, &ch,
+				      brownie32_retransmit_wait);
+
+	  /* If we timed out, resend the data packet.  */
+	  if (err == -1)
+	    break;
+
+	  /* If we got a bad character, reread the header.  */
+	  if (err != 0)
+	    continue;
+
+	  /* If the checksum does not match the trailer checksum, this
+	     is a bad packet; ignore it.  */
+	  if (brownie32_cksum (hdr, (unsigned char *) NULL, 0)
+	      != TRLR_GET_CKSUM (trlr))
+	    continue;
+
+	  if (remote_debug > 0)
+	    {
+	      hdr[HDR_LENGTH] = '\0';
+	      trlr[TRLR_LENGTH] = '\0';
+	      /* Don't use _filtered; we can't deal with a QUIT out of
+	         target_wait, and I think this might be called from there.  */
+	      fprintf_unfiltered (gdb_stdlog, "Got ack %d \"%s%s\"\n",
+				  HDR_GET_SEQ (hdr), hdr + 1, trlr);
+	    }
+
+	  /* If this ack is for the current packet, we're done.  */
+	  seq = HDR_GET_SEQ (hdr);
+	  if (seq == brownie32_send_seq)
+	    return;
+
+	  /* If this ack is for the last packet, resend the current
+	     packet.  */
+	  if ((seq + 1) % SEQ_MODULOS == brownie32_send_seq)
+	    break;
+
+	  /* Otherwise this is a bad ack; ignore it.  Increment the
+	     garbage count to ensure that we do not stay in this loop
+	     forever.  */
+	  ++garbage;
+	}
+    }
+
+  brownie32_error ("Remote did not acknowledge packet");
+}
+
+/* Receive and acknowledge a packet, returning the data in BUFF (which
+   should be DATA_MAXLEN + 1 bytes).  The protocol documentation
+   implies that only the sender retransmits packets, so this code just
+   waits silently for a packet.  It returns the length of the received
+   packet.  If THROW_ERROR is nonzero, call error() on errors.  If not,
+   don't print an error message and return -1.  */
+
+static int
+brownie32_receive_packet (char *buff, int throw_error, int timeout)
+{
+  int ch;
+  int garbage;
+  int len;
+  unsigned char ack[HDR_LENGTH + TRLR_LENGTH + 1];
+  int cksum;
+
+  ch = 0;
+  garbage = 0;
+  while (1)
+    {
+      unsigned char hdr[HDR_LENGTH];
+      unsigned char trlr[TRLR_LENGTH];
+      int i;
+      int err;
+
+      if (brownie32_receive_header (hdr, &garbage, ch, timeout) != 0)
+	{
+	  if (throw_error)
+	    brownie32_error ("Timed out waiting for remote packet");
+	  else
+	    return -1;
+	}
+
+      ch = 0;
+
+      /* An acknowledgement is probably a duplicate; ignore it.  */
+      if (!HDR_IS_DATA (hdr))
+	{
+	  len = HDR_GET_LEN (hdr);
+	  /* Check if the length is valid for an ACK, we may aswell
+	     try and read the remainder of the packet: */
+	  if (len == 0)
+	    {
+	      /* Ignore the error condition, since we are going to
+	         ignore the packet anyway. */
+	      (void) brownie32_receive_trailer (trlr, &garbage, &ch, timeout);
+	    }
+	  /* Don't use _filtered; we can't deal with a QUIT out of
+	     target_wait, and I think this might be called from there.  */
+	  if (remote_debug > 0)
+	    fprintf_unfiltered (gdb_stdlog, "Ignoring unexpected ACK\n");
+	  continue;
+	}
+
+      len = HDR_GET_LEN (hdr);
+      for (i = 0; i < len; i++)
+	{
+	  int rch;
+
+	  rch = brownie32_readchar (timeout);
+	  if (rch == SYN)
+	    {
+	      ch = SYN;
+	      break;
+	    }
+	  if (rch == SERIAL_TIMEOUT)
+	    {
+	      if (throw_error)
+		brownie32_error ("Timed out waiting for remote packet");
+	      else
+		return -1;
+	    }
+	  buff[i] = rch;
+	}
+
+      if (i < len)
+	{
+	  /* Don't use _filtered; we can't deal with a QUIT out of
+	     target_wait, and I think this might be called from there.  */
+	  if (remote_debug > 0)
+	    fprintf_unfiltered (gdb_stdlog,
+				"Got new SYN after %d chars (wanted %d)\n",
+				i, len);
+	  continue;
+	}
+
+      err = brownie32_receive_trailer (trlr, &garbage, &ch, timeout);
+      if (err == -1)
+	{
+	  if (throw_error)
+	    brownie32_error ("Timed out waiting for packet");
+	  else
+	    return -1;
+	}
+      if (err == -2)
+	{
+	  /* Don't use _filtered; we can't deal with a QUIT out of
+	     target_wait, and I think this might be called from there.  */
+	  if (remote_debug > 0)
+	    fprintf_unfiltered (gdb_stdlog, "Got SYN when wanted trailer\n");
+	  continue;
+	}
+
+      /* If this is the wrong sequence number, ignore it.  */
+      if (HDR_GET_SEQ (hdr) != brownie32_receive_seq)
+	{
+	  /* Don't use _filtered; we can't deal with a QUIT out of
+	     target_wait, and I think this might be called from there.  */
+	  if (remote_debug > 0)
+	    fprintf_unfiltered (gdb_stdlog,
+				"Ignoring sequence number %d (want %d)\n",
+				HDR_GET_SEQ (hdr), brownie32_receive_seq);
+	  continue;
+	}
+
+      if (brownie32_cksum (hdr, buff, len) == TRLR_GET_CKSUM (trlr))
+	break;
+
+      if (remote_debug > 0)
+	/* Don't use _filtered; we can't deal with a QUIT out of
+	   target_wait, and I think this might be called from there.  */
+	printf_unfiltered ("Bad checksum; data %d, trailer %d\n",
+			   brownie32_cksum (hdr, buff, len),
+			   TRLR_GET_CKSUM (trlr));
+
+      /* The checksum failed.  Send an acknowledgement for the
+         previous packet to tell the remote to resend the packet.  */
+      ack[HDR_INDX_SYN] = HDR_SET_SYN (0, 0, brownie32_receive_seq);
+      ack[HDR_INDX_TYPE_LEN] = HDR_SET_TYPE_LEN (0, 0, brownie32_receive_seq);
+      ack[HDR_INDX_LEN1] = HDR_SET_LEN1 (0, 0, brownie32_receive_seq);
+      ack[HDR_INDX_SEQ] = HDR_SET_SEQ (0, 0, brownie32_receive_seq);
+
+      cksum = brownie32_cksum (ack, (unsigned char *) NULL, 0);
+
+      ack[HDR_LENGTH + TRLR_INDX_CSUM1] = TRLR_SET_CSUM1 (cksum);
+      ack[HDR_LENGTH + TRLR_INDX_CSUM2] = TRLR_SET_CSUM2 (cksum);
+      ack[HDR_LENGTH + TRLR_INDX_CSUM3] = TRLR_SET_CSUM3 (cksum);
+
+      if (remote_debug > 0)
+	{
+	  ack[HDR_LENGTH + TRLR_LENGTH] = '\0';
+	  /* Don't use _filtered; we can't deal with a QUIT out of
+	     target_wait, and I think this might be called from there.  */
+	  printf_unfiltered ("Writing ack %d \"%s\"\n", brownie32_receive_seq,
+			     ack + 1);
+	}
+
+      if (serial_write (brownie32_desc, ack, HDR_LENGTH + TRLR_LENGTH) != 0)
+	{
+	  if (throw_error)
+	    brownie32_error ("write to target failed: %s", safe_strerror (errno));
+	  else
+	    return -1;
+	}
+    }
+
+  if (remote_debug > 0)
+    {
+      buff[len] = '\0';
+      /* Don't use _filtered; we can't deal with a QUIT out of
+         target_wait, and I think this might be called from there.  */
+      printf_unfiltered ("Got packet \"%s\"\n", buff);
+    }
+
+  /* We got the packet.  Send an acknowledgement.  */
+  brownie32_receive_seq = (brownie32_receive_seq + 1) % SEQ_MODULOS;
+
+  ack[HDR_INDX_SYN] = HDR_SET_SYN (0, 0, brownie32_receive_seq);
+  ack[HDR_INDX_TYPE_LEN] = HDR_SET_TYPE_LEN (0, 0, brownie32_receive_seq);
+  ack[HDR_INDX_LEN1] = HDR_SET_LEN1 (0, 0, brownie32_receive_seq);
+  ack[HDR_INDX_SEQ] = HDR_SET_SEQ (0, 0, brownie32_receive_seq);
+
+  cksum = brownie32_cksum (ack, (unsigned char *) NULL, 0);
+
+  ack[HDR_LENGTH + TRLR_INDX_CSUM1] = TRLR_SET_CSUM1 (cksum);
+  ack[HDR_LENGTH + TRLR_INDX_CSUM2] = TRLR_SET_CSUM2 (cksum);
+  ack[HDR_LENGTH + TRLR_INDX_CSUM3] = TRLR_SET_CSUM3 (cksum);
+
+  if (remote_debug > 0)
+    {
+      ack[HDR_LENGTH + TRLR_LENGTH] = '\0';
+      /* Don't use _filtered; we can't deal with a QUIT out of
+         target_wait, and I think this might be called from there.  */
+      printf_unfiltered ("Writing ack %d \"%s\"\n", brownie32_receive_seq,
+			 ack + 1);
+    }
+
+  if (serial_write (brownie32_desc, ack, HDR_LENGTH + TRLR_LENGTH) != 0)
+    {
+      if (throw_error)
+	brownie32_error ("write to target failed: %s", safe_strerror (errno));
+      else
+	return -1;
+    }
+
+  return len;
+}
+
+/* Optionally send a request to the remote system and optionally wait
+   for the reply.  This implements the remote debugging protocol,
+   which is built on top of the packet protocol defined above.  Each
+   request has an ADDR argument and a DATA argument.  The following
+   requests are defined:
+
+   \0   don't send a request; just wait for a reply
+   i    read word from instruction space at ADDR
+   d    read word from data space at ADDR
+   I    write DATA to instruction space at ADDR
+   D    write DATA to data space at ADDR
+   r    read register number ADDR
+   R    set register number ADDR to value DATA
+   c    continue execution (if ADDR != 1, set pc to ADDR)
+   s    single step (if ADDR != 1, set pc to ADDR)
+
+   The read requests return the value requested.  The write requests
+   return the previous value in the changed location.  The execution
+   requests return a UNIX wait value (the approximate signal which
+   caused execution to stop is in the upper eight bits).
+
+   If PERR is not NULL, this function waits for a reply.  If an error
+   occurs, it sets *PERR to 1 and sets errno according to what the
+   target board reports.  */
+
+static ULONGEST
+brownie32_request (int cmd,
+	      ULONGEST addr,
+	      ULONGEST data,
+	      int *perr,
+	      int timeout,
+	      char *buff)
+{
+  char myBuff[DATA_MAXLEN + 1];
+  int len;
+  int rpid;
+  char rcmd;
+  int rerrflg;
+  unsigned long rresponse;
+
+  if (buff == (char *) NULL)
+    buff = myBuff;
+
+  if (cmd != '\0')
+    {
+      if (brownie32_need_reply)
+	internal_error (__FILE__, __LINE__,
+			_("brownie32_request: Trying to send command before reply"));
+      sprintf (buff, "0x0 %c 0x%s 0x%s", cmd, paddr_nz (addr), paddr_nz (data));
+      brownie32_send_packet (buff, 1);
+      brownie32_need_reply = 1;
+    }
+
+  if (perr == (int *) NULL)
+    return 0;
+
+  if (!brownie32_need_reply)
+    internal_error (__FILE__, __LINE__,
+		    _("brownie32_request: Trying to get reply before command"));
+
+  brownie32_need_reply = 0;
+
+  len = brownie32_receive_packet (buff, 1, timeout);
+  buff[len] = '\0';
+
+  if (sscanf (buff, "0x%x %c 0x%x 0x%lx",
+	      &rpid, &rcmd, &rerrflg, &rresponse) != 4
+      || (cmd != '\0' && rcmd != cmd))
+    brownie32_error ("Bad response from remote board");
+
+  if (rerrflg != 0)
+    {
+      *perr = 1;
+
+      /* FIXME: This will returns BROWNIE32 errno numbers, which may or may
+         not be the same as errno values used on other systems.  If
+         they stick to common errno values, they will be the same, but
+         if they don't, they must be translated.  */
+      errno = rresponse;
+
+      return 0;
+    }
+
+  *perr = 0;
+  return rresponse;
+}
+
+static void
+brownie32_initialize_cleanups (void *arg)
+{
+  brownie32_initializing = 0;
+}
+
+static void
+brownie32_exit_cleanups (void *arg)
+{
+  brownie32_exiting = 0;
+}
+
+static void
+brownie32_send_command (const char *cmd, int prompt)
+{
+  serial_write (brownie32_desc, cmd, strlen (cmd));
+  brownie32_expect (cmd);
+  brownie32_expect ("\n");
+  if (prompt)
+    brownie32_expect (brownie32_monitor_prompt);
+}
+
+/* Enter remote (dbx) debug mode: */
+static void
+brownie32_enter_debug (void)
+{
+  /* Reset the sequence numbers, ready for the new debug sequence: */
+  brownie32_send_seq = 0;
+  brownie32_receive_seq = 0;
+
+  if (brownie32_monitor != MON_IDT)
+    brownie32_send_command ("debug\r", 0);
+  else				/* assume IDT monitor by default */
+    brownie32_send_command ("db tty0\r", 0);
+
+  sleep (1);
+  serial_write (brownie32_desc, "\r", sizeof "\r" - 1);
+
+  /* We don't need to absorb any spurious characters here, since the
+     brownie32_receive_header will eat up a reasonable number of characters
+     whilst looking for the SYN, however this avoids the "garbage"
+     being displayed to the user. */
+  if (brownie32_monitor != MON_IDT)
+    brownie32_expect ("\r");
+
+  {
+    char buff[DATA_MAXLEN + 1];
+    if (brownie32_receive_packet (buff, 1, 3) < 0)
+      brownie32_error ("Failed to initialize (didn't receive packet).");
+  }
+}
+
+/* Exit remote (dbx) debug mode, returning to the monitor prompt: */
+static int
+brownie32_exit_debug (void)
+{
+  int err;
+  struct cleanup *old_cleanups = make_cleanup (brownie32_exit_cleanups, NULL);
+
+  brownie32_exiting = 1;
+
+  if (brownie32_monitor != MON_IDT)
+    {
+      /* The DDB (NEC) and MiniRISC (LSI) versions of PMON exit immediately,
+         so we do not get a reply to this command: */
+      brownie32_request ('x', 0, 0, NULL, brownie32_receive_wait, NULL);
+      brownie32_need_reply = 0;
+      if (!brownie32_expect (" break!"))
+	return -1;
+    }
+  else
+    brownie32_request ('x', 0, 0, &err, brownie32_receive_wait, NULL);
+
+  if (!brownie32_expect (brownie32_monitor_prompt))
+    return -1;
+
+  do_cleanups (old_cleanups);
+
+  return 0;
+}
+
+/* Initialize a new connection to the BROWNIE32 board, and make sure we are
+   really connected.  */
+
+static void
+brownie32_initialize (void)
+{
+  int err;
+  struct cleanup *old_cleanups = make_cleanup (brownie32_initialize_cleanups, NULL);
+  int j;
+
+  /* What is this code doing here?  I don't see any way it can happen, and
+     it might mean brownie32_initializing didn't get cleared properly.
+     So I'll make it a warning.  */
+
+  if (brownie32_initializing)
+    {
+      warning ("internal error: brownie32_initialize called twice");
+      return;
+    }
+
+  brownie32_wait_flag = 0;
+  brownie32_initializing = 1;
+
+  /* At this point, the packit protocol isn't responding.  We'll try getting
+     into the monitor, and restarting the protocol.  */
+
+  /* Force the system into the monitor.  After this we *should* be at
+     the brownie32_monitor_prompt.  */
+  if (brownie32_monitor != MON_IDT)
+    j = 0;			/* start by checking if we are already at the prompt */
+  else
+    j = 1;			/* start by sending a break */
+  for (; j <= 4; j++)
+    {
+      switch (j)
+	{
+	case 0:		/* First, try sending a CR */
+	  serial_flush_input (brownie32_desc);
+	  serial_write (brownie32_desc, "\r", 1);
+	  break;
+	case 1:		/* First, try sending a break */
+	  serial_send_break (brownie32_desc);
+	  break;
+	case 2:		/* Then, try a ^C */
+	  serial_write (brownie32_desc, "\003", 1);
+	  break;
+	case 3:		/* Then, try escaping from download */
+	  {
+	    if (brownie32_monitor != MON_IDT)
+	      {
+		char tbuff[7];
+
+		/* We shouldn't need to send multiple termination
+		   sequences, since the target performs line (or
+		   block) reads, and then processes those
+		   packets. In-case we were downloading a large packet
+		   we flush the output buffer before inserting a
+		   termination sequence. */
+		serial_flush_output (brownie32_desc);
+		sprintf (tbuff, "\r/E/E\r");
+		serial_write (brownie32_desc, tbuff, 6);
+	      }
+	    else
+	      {
+		char srec[10];
+		int i;
+
+		/* We are possibly in binary download mode, having
+		   aborted in the middle of an S-record.  ^C won't
+		   work because of binary mode.  The only reliable way
+		   out is to send enough termination packets (8 bytes)
+		   to fill up and then overflow the largest size
+		   S-record (255 bytes in this case).  This amounts to
+		   256/8 + 1 packets.
+		 */
+
+		brownie32_make_srec (srec, '7', 0, NULL, 0);
+
+		for (i = 1; i <= 33; i++)
+		  {
+		    serial_write (brownie32_desc, srec, 8);
+
+		    if (serial_readchar (brownie32_desc, 0) >= 0)
+		      break;	/* Break immediatly if we get something from
+				   the board. */
+		  }
+	      }
+	  }
+	  break;
+	case 4:
+	  brownie32_error ("Failed to initialize.");
+	}
+
+      if (brownie32_expect (brownie32_monitor_prompt))
+	break;
+    }
+
+  if (brownie32_monitor != MON_IDT)
+    {
+      /* Sometimes PMON ignores the first few characters in the first
+         command sent after a load.  Sending a blank command gets
+         around that.  */
+      brownie32_send_command ("\r", -1);
+
+      /* Ensure the correct target state: */
+      if (brownie32_monitor != MON_LSI)
+	brownie32_send_command ("set regsize 64\r", -1);
+      brownie32_send_command ("set hostport tty0\r", -1);
+      brownie32_send_command ("set brkcmd \"\"\r", -1);
+      /* Delete all the current breakpoints: */
+      brownie32_send_command ("db *\r", -1);
+      /* NOTE: PMON does not have breakpoint support through the
+         "debug" mode, only at the monitor command-line. */
+    }
+
+  brownie32_enter_debug ();
+
+  /* Clear all breakpoints: */
+  if ((brownie32_monitor == MON_IDT
+       && clear_breakpoint (-1, 0, BREAK_UNUSED) == 0)
+      || brownie32_monitor == MON_LSI)
+    monitor_supports_breakpoints = 1;
+  else
+    monitor_supports_breakpoints = 0;
+
+  do_cleanups (old_cleanups);
+
+  /* If this doesn't call error, we have connected; we don't care if
+     the request itself succeeds or fails.  */
+
+  brownie32_request ('r', 0, 0, &err, brownie32_receive_wait, NULL);
+}
+
+/* Open a connection to the remote board.  */
+static void
+common_open (struct target_ops *ops, char *name, int from_tty,
+	     enum brownie32_monitor_type new_monitor,
+	     const char *new_monitor_prompt)
+{
+  char *ptype;
+  char *serial_port_name;
+  char *remote_name = 0;
+  char *local_name = 0;
+  char **argv;
+
+  if (name == 0)
+    error (
+	    "To open a BROWNIE32 remote debugging connection, you need to specify what serial\n\
+device is attached to the target board (e.g., /dev/ttya).\n"
+	    "If you want to use TFTP to download to the board, specify the name of a\n"
+	    "temporary file to be used by GDB for downloads as the second argument.\n"
+	    "This filename must be in the form host:filename, where host is the name\n"
+	    "of the host running the TFTP server, and the file must be readable by the\n"
+	    "world.  If the local name of the temporary file differs from the name as\n"
+	    "seen from the board via TFTP, specify that name as the third parameter.\n");
+
+  /* Parse the serial port name, the optional TFTP name, and the
+     optional local TFTP name.  */
+  if ((argv = buildargv (name)) == NULL)
+    nomem (0);
+  make_cleanup_freeargv (argv);
+
+  serial_port_name = xstrdup (argv[0]);
+  if (argv[1])			/* remote TFTP name specified? */
+    {
+      remote_name = argv[1];
+      if (argv[2])		/* local TFTP filename specified? */
+	local_name = argv[2];
+    }
+
+  target_preopen (from_tty);
+
+  if (brownie32_is_open)
+    unpush_target (current_ops);
+
+  /* Open and initialize the serial port.  */
+  brownie32_desc = serial_open (serial_port_name);
+  if (brownie32_desc == NULL)
+    perror_with_name (serial_port_name);
+
+  if (baud_rate != -1)
+    {
+      if (serial_setbaudrate (brownie32_desc, baud_rate))
+	{
+	  serial_close (brownie32_desc);
+	  perror_with_name (serial_port_name);
+	}
+    }
+
+  serial_raw (brownie32_desc);
+
+  /* Open and initialize the optional download port.  If it is in the form
+     hostname#portnumber, it's a UDP socket.  If it is in the form
+     hostname:filename, assume it's the TFTP filename that must be
+     passed to the DDB board to tell it where to get the load file.  */
+  if (remote_name)
+    {
+      if (strchr (remote_name, '#'))
+	{
+	  udp_desc = serial_open (remote_name);
+	  if (!udp_desc)
+	    perror_with_name ("Unable to open UDP port");
+	  udp_in_use = 1;
+	}
+      else
+	{
+	  /* Save the remote and local names of the TFTP temp file.  If
+	     the user didn't specify a local name, assume it's the same
+	     as the part of the remote name after the "host:".  */
+	  if (tftp_name)
+	    xfree (tftp_name);
+	  if (tftp_localname)
+	    xfree (tftp_localname);
+	  if (local_name == NULL)
+	    if ((local_name = strchr (remote_name, ':')) != NULL)
+	      local_name++;	/* skip over the colon */
+	  if (local_name == NULL)
+	    local_name = remote_name;	/* local name same as remote name */
+	  tftp_name = xstrdup (remote_name);
+	  tftp_localname = xstrdup (local_name);
+	  tftp_in_use = 1;
+	}
+    }
+
+  current_ops = ops;
+  brownie32_is_open = 1;
+
+  /* Reset the expected monitor prompt if it's never been set before.  */
+  if (brownie32_monitor_prompt == NULL)
+    brownie32_monitor_prompt = xstrdup (new_monitor_prompt);
+  brownie32_monitor = new_monitor;
+
+  brownie32_initialize ();
+
+  if (from_tty)
+    printf_unfiltered ("Remote BROWNIE32 debugging using %s\n", serial_port_name);
+
+  /* Switch to using remote target now.  */
+  push_target (ops);
+
+  /* FIXME: Should we call start_remote here?  */
+
+  /* Try to figure out the processor model if possible.  */
+  deprecated_brownie32_set_processor_regs_hack ();
+
+  /* This is really the job of start_remote however, that makes an
+     assumption that the target is about to print out a status message
+     of some sort.  That doesn't happen here (in fact, it may not be
+     possible to get the monitor to send the appropriate packet).  */
+
+  flush_cached_frames ();
+  registers_changed ();
+  stop_pc = read_pc ();
+  print_stack_frame (get_selected_frame (NULL), 0, SRC_AND_LOC);
+  xfree (serial_port_name);
+}
+
+static void
+brownie32_open (char *name, int from_tty)
+{
+  const char *monitor_prompt = NULL;
+  if (TARGET_ARCHITECTURE != NULL
+      && TARGET_ARCHITECTURE->arch == bfd_arch_brownie32)
+    {
+    switch (TARGET_ARCHITECTURE->mach)
+      {
+      case bfd_mach_brownie324100:
+      case bfd_mach_brownie324300:
+      case bfd_mach_brownie324600:
+      case bfd_mach_brownie324650:
+      case bfd_mach_brownie325000:
+	monitor_prompt = "<RISQ> ";
+	break;
+      }
+    }
+  if (monitor_prompt == NULL)
+    monitor_prompt = "<IDT>";
+  common_open (&brownie32_ops, name, from_tty, MON_IDT, monitor_prompt);
+}
+
+static void
+pmon_open (char *name, int from_tty)
+{
+  common_open (&pmon_ops, name, from_tty, MON_PMON, "PMON> ");
+}
+
+static void
+ddb_open (char *name, int from_tty)
+{
+  common_open (&ddb_ops, name, from_tty, MON_DDB, "NEC010>");
+}
+
+static void
+lsi_open (char *name, int from_tty)
+{
+  int i;
+
+  /* Clear the LSI breakpoint table.  */
+  for (i = 0; i < MAX_LSI_BREAKPOINTS; i++)
+    lsi_breakpoints[i].type = BREAK_UNUSED;
+
+  common_open (&lsi_ops, name, from_tty, MON_LSI, "PMON> ");
+}
+
+/* Close a connection to the remote board.  */
+
+static void
+brownie32_close (int quitting)
+{
+  if (brownie32_is_open)
+    {
+      /* Get the board out of remote debugging mode.  */
+      (void) brownie32_exit_debug ();
+
+      close_ports ();
+    }
+}
+
+/* Detach from the remote board.  */
+
+static void
+brownie32_detach (char *args, int from_tty)
+{
+  if (args)
+    error ("Argument given to \"detach\" when remotely debugging.");
+
+  pop_target ();
+
+  brownie32_close (1);
+
+  if (from_tty)
+    printf_unfiltered ("Ending remote BROWNIE32 debugging.\n");
+}
+
+/* Tell the target board to resume.  This does not wait for a reply
+   from the board, except in the case of single-stepping on LSI boards,
+   where PMON does return a reply.  */
+
+static void
+brownie32_resume (ptid_t ptid, int step, enum target_signal siggnal)
+{
+  int err;
+
+  /* LSI PMON requires returns a reply packet "0x1 s 0x0 0x57f" after
+     a single step, so we wait for that.  */
+  brownie32_request (step ? 's' : 'c', 1, siggnal,
+		brownie32_monitor == MON_LSI && step ? &err : (int *) NULL,
+		brownie32_receive_wait, NULL);
+}
+
+/* Return the signal corresponding to SIG, where SIG is the number which
+   the BROWNIE32 protocol uses for the signal.  */
+static enum target_signal
+brownie32_signal_from_protocol (int sig)
+{
+  /* We allow a few more signals than the IDT board actually returns, on
+     the theory that there is at least *some* hope that perhaps the numbering
+     for these signals is widely agreed upon.  */
+  if (sig <= 0
+      || sig > 31)
+    return TARGET_SIGNAL_UNKNOWN;
+
+  /* Don't want to use target_signal_from_host because we are converting
+     from BROWNIE32 signal numbers, not host ones.  Our internal numbers
+     match the BROWNIE32 numbers for the signals the board can return, which
+     are: SIGINT, SIGSEGV, SIGBUS, SIGILL, SIGFPE, SIGTRAP.  */
+  return (enum target_signal) sig;
+}
+
+/* Wait until the remote stops, and return a wait status.  */
+
+static ptid_t
+brownie32_wait (ptid_t ptid, struct target_waitstatus *status)
+{
+  int rstatus;
+  int err;
+  char buff[DATA_MAXLEN];
+  int rpc, rfp, rsp;
+  char flags[20];
+  int nfields;
+  int i;
+
+  interrupt_count = 0;
+  hit_watchpoint = 0;
+
+  /* If we have not sent a single step or continue command, then the
+     board is waiting for us to do something.  Return a status
+     indicating that it is stopped.  */
+  if (!brownie32_need_reply)
+    {
+      status->kind = TARGET_WAITKIND_STOPPED;
+      status->value.sig = TARGET_SIGNAL_TRAP;
+      return inferior_ptid;
+    }
+
+  /* No timeout; we sit here as long as the program continues to execute.  */
+  brownie32_wait_flag = 1;
+  rstatus = brownie32_request ('\000', 0, 0, &err, -1, buff);
+  brownie32_wait_flag = 0;
+  if (err)
+    brownie32_error ("Remote failure: %s", safe_strerror (errno));
+
+  /* On returning from a continue, the PMON monitor seems to start
+     echoing back the messages we send prior to sending back the
+     ACK. The code can cope with this, but to try and avoid the
+     unnecessary serial traffic, and "spurious" characters displayed
+     to the user, we cheat and reset the debug protocol. The problems
+     seems to be caused by a check on the number of arguments, and the
+     command length, within the monitor causing it to echo the command
+     as a bad packet. */
+  if (brownie32_monitor == MON_PMON)
+    {
+      brownie32_exit_debug ();
+      brownie32_enter_debug ();
+    }
+
+  /* See if we got back extended status.  If so, pick out the pc, fp, sp, etc... */
+
+  nfields = sscanf (buff, "0x%*x %*c 0x%*x 0x%*x 0x%x 0x%x 0x%x 0x%*x %s",
+		    &rpc, &rfp, &rsp, flags);
+  if (nfields >= 3)
+    {
+      char buf[MAX_REGISTER_SIZE];
+
+      store_unsigned_integer (buf, register_size (current_gdbarch, PC_REGNUM), rpc);
+      regcache_raw_supply (current_regcache, PC_REGNUM, buf);
+#if 0
+      store_unsigned_integer (buf, register_size (current_gdbarch, PC_REGNUM), rfp);
+      regcache_raw_supply (current_regcache, 30, buf);	/* This register they are avoiding and so it is unnamed */
+#endif
+      store_unsigned_integer (buf, register_size (current_gdbarch, SP_REGNUM), rsp);
+      regcache_raw_supply (current_regcache, SP_REGNUM, buf);
+#if 0
+      store_unsigned_integer (buf, register_size (current_gdbarch, DEPRECATED_FP_REGNUM), 0);
+      regcache_raw_supply (current_regcache, DEPRECATED_FP_REGNUM, buf);
+#endif
+      if (nfields == 9)
+	{
+	  int i;
+
+	  for (i = 0; i <= 2; i++)
+	    if (flags[i] == 'r' || flags[i] == 'w')
+	      hit_watchpoint = 1;
+	    else if (flags[i] == '\000')
+	      break;
+	}
+    }
+
+  if (strcmp (target_shortname, "lsi") == 0)
+    {
+#if 0
+      /* If this is an LSI PMON target, see if we just hit a hardrdware watchpoint.
+         Right now, PMON doesn't give us enough information to determine which
+         breakpoint we hit.  So we have to look up the PC in our own table
+         of breakpoints, and if found, assume it's just a normal instruction
+         fetch breakpoint, not a data watchpoint.  FIXME when PMON
+         provides some way to tell us what type of breakpoint it is.  */
+      int i;
+      CORE_ADDR pc = read_pc ();
+
+      hit_watchpoint = 1;
+      for (i = 0; i < MAX_LSI_BREAKPOINTS; i++)
+	{
+	  if (lsi_breakpoints[i].addr == pc
+	      && lsi_breakpoints[i].type == BREAK_FETCH)
+	    {
+	      hit_watchpoint = 0;
+	      break;
+	    }
+	}
+#else
+      /* If a data breakpoint was hit, PMON returns the following packet:
+         0x1 c 0x0 0x57f 0x1
+         The return packet from an ordinary breakpoint doesn't have the
+         extra 0x01 field tacked onto the end.  */
+      if (nfields == 1 && rpc == 1)
+	hit_watchpoint = 1;
+#endif
+    }
+
+  /* NOTE: The following (sig) numbers are defined by PMON:
+     SPP_SIGTRAP     5       breakpoint
+     SPP_SIGINT      2
+     SPP_SIGSEGV     11
+     SPP_SIGBUS      10
+     SPP_SIGILL      4
+     SPP_SIGFPE      8
+     SPP_SIGTERM     15 */
+
+  /* Translate a BROWNIE32 waitstatus.  We use constants here rather than WTERMSIG
+     and so on, because the constants we want here are determined by the
+     BROWNIE32 protocol and have nothing to do with what host we are running on.  */
+  if ((rstatus & 0xff) == 0)
+    {
+      status->kind = TARGET_WAITKIND_EXITED;
+      status->value.integer = (((rstatus) >> 8) & 0xff);
+    }
+  else if ((rstatus & 0xff) == 0x7f)
+    {
+      status->kind = TARGET_WAITKIND_STOPPED;
+      status->value.sig = brownie32_signal_from_protocol (((rstatus) >> 8) & 0xff);
+
+      /* If the stop PC is in the _exit function, assume
+         we hit the 'break 0x3ff' instruction in _exit, so this
+         is not a normal breakpoint.  */
+      if (strcmp (target_shortname, "lsi") == 0)
+	{
+	  char *func_name;
+	  CORE_ADDR func_start;
+	  CORE_ADDR pc = read_pc ();
+
+	  find_pc_partial_function (pc, &func_name, &func_start, NULL);
+	  if (func_name != NULL && strcmp (func_name, "_exit") == 0
+	      && func_start == pc)
+	    status->kind = TARGET_WAITKIND_EXITED;
+	}
+    }
+  else
+    {
+      status->kind = TARGET_WAITKIND_SIGNALLED;
+      status->value.sig = brownie32_signal_from_protocol (rstatus & 0x7f);
+    }
+
+  return inferior_ptid;
+}
+
+/* We have to map between the register numbers used by gdb and the
+   register numbers used by the debugging protocol.  */
+
+#define REGNO_OFFSET 96
+
+static int
+brownie32_map_regno (int regno)
+{
+#if 1
+  if (regno < 32)
+    return regno;
+  else if (regno == brownie32_regnum (current_gdbarch)->pc)
+    return 33;
+  else
+    /* FIXME: Is there a way to get the status register?  */
+    return 0;
+#else
+  if (regno < 32)
+    return regno;
+  if (regno >= brownie32_regnum (current_gdbarch)->fp0
+      && regno < brownie32_regnum (current_gdbarch)->fp0 + 32)
+    return regno - brownie32_regnum (current_gdbarch)->fp0 + 32;
+  else if (regno == brownie32_regnum (current_gdbarch)->pc)
+    return REGNO_OFFSET + 0;
+  else if (regno == brownie32_regnum (current_gdbarch)->cause)
+    return REGNO_OFFSET + 1;
+  else if (regno == brownie32_regnum (current_gdbarch)->hi)
+    return REGNO_OFFSET + 2;
+  else if (regno == brownie32_regnum (current_gdbarch)->lo)
+    return REGNO_OFFSET + 3;
+  else if (regno == brownie32_regnum (current_gdbarch)->fp_control_status)
+    return REGNO_OFFSET + 4;
+  else if (regno == brownie32_regnum (current_gdbarch)->fp_implementation_revision)
+    return REGNO_OFFSET + 5;
+  else
+    /* FIXME: Is there a way to get the status register?  */
+    return 0;
+#endif
+}
+
+/* Fetch the remote registers.  */
+
+static void
+brownie32_fetch_registers (int regno)
+{
+  unsigned LONGEST val;
+  int err;
+
+  if (regno == -1)
+    {
+      for (regno = 0; regno < NUM_REGS; regno++)
+	brownie32_fetch_registers (regno);
+      return;
+    }
+
+  if (regno == DEPRECATED_FP_REGNUM || regno == BROWNIE32_ZERO_REGNUM)
+    /* DEPRECATED_FP_REGNUM on the brownie32 is a hack which is just
+       supposed to read zero (see also brownie32-nat.c).  */
+    val = 0;
+  else
+    {
+      /* If PMON doesn't support this register, don't waste serial
+         bandwidth trying to read it.  */
+      int pmon_reg = brownie32_map_regno (regno);
+      if (regno != 0 && pmon_reg == 0)
+	val = 0;
+      else
+	{
+	  /* Unfortunately the PMON version in the Vr4300 board has been
+	     compiled without the 64bit register access commands. This
+	     means we cannot get hold of the full register width. */
+	  if (brownie32_monitor == MON_DDB)
+	    val = (unsigned) brownie32_request ('t', pmon_reg, 0,
+					   &err, brownie32_receive_wait, NULL);
+	  else
+	    val = brownie32_request ('r', pmon_reg, 0,
+				&err, brownie32_receive_wait, NULL);
+	  if (err)
+	    brownie32_error ("Can't read register %d: %s", regno,
+			safe_strerror (errno));
+	}
+    }
+
+  {
+    char buf[MAX_REGISTER_SIZE];
+
+    /* We got the number the register holds, but gdb expects to see a
+       value in the target byte ordering.  */
+    store_unsigned_integer (buf, register_size (current_gdbarch, regno), val);
+    regcache_raw_supply (current_regcache, regno, buf);
+  }
+}
+
+/* Prepare to store registers.  The BROWNIE32 protocol can store individual
+   registers, so this function doesn't have to do anything.  */
+
+static void
+brownie32_prepare_to_store (void)
+{
+}
+
+/* Store remote register(s).  */
+
+static void
+brownie32_store_registers (int regno)
+{
+  int err;
+
+  if (regno == -1)
+    {
+      for (regno = 0; regno < NUM_REGS; regno++)
+	brownie32_store_registers (regno);
+      return;
+    }
+
+  brownie32_request ('R', brownie32_map_regno (regno),
+		read_register (regno),
+		&err, brownie32_receive_wait, NULL);
+  if (err)
+    brownie32_error ("Can't write register %d: %s", regno, safe_strerror (errno));
+}
+
+/* Fetch a word from the target board.  */
+
+static unsigned int
+brownie32_fetch_word (CORE_ADDR addr)
+{
+  unsigned int val;
+  int err;
+
+  val = brownie32_request ('d', addr, 0, &err, brownie32_receive_wait, NULL);
+  if (err)
+    {
+      /* Data space failed; try instruction space.  */
+      val = brownie32_request ('i', addr, 0, &err,
+			  brownie32_receive_wait, NULL);
+      if (err)
+	brownie32_error ("Can't read address 0x%s: %s",
+		    paddr_nz (addr), safe_strerror (errno));
+    }
+  return val;
+}
+
+/* Store a word to the target board.  Returns errno code or zero for
+   success.  If OLD_CONTENTS is non-NULL, put the old contents of that
+   memory location there.  */
+
+/* FIXME! make sure only 32-bit quantities get stored! */
+static int
+brownie32_store_word (CORE_ADDR addr, unsigned int val, char *old_contents)
+{
+  int err;
+  unsigned int oldcontents;
+
+  oldcontents = brownie32_request ('D', addr, val, &err,
+			      brownie32_receive_wait, NULL);
+  if (err)
+    {
+      /* Data space failed; try instruction space.  */
+      oldcontents = brownie32_request ('I', addr, val, &err,
+				  brownie32_receive_wait, NULL);
+      if (err)
+	return errno;
+    }
+  if (old_contents != NULL)
+    store_unsigned_integer (old_contents, 4, oldcontents);
+  return 0;
+}
+
+/* Read or write LEN bytes from inferior memory at MEMADDR,
+   transferring to or from debugger address MYADDR.  Write to inferior
+   if SHOULD_WRITE is nonzero.  Returns length of data written or
+   read; 0 for error.  Note that protocol gives us the correct value
+   for a longword, since it transfers values in ASCII.  We want the
+   byte values, so we have to swap the longword values.  */
+
+static int mask_address_p = 1;
+
+static int
+brownie32_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
+		  struct mem_attrib *attrib, struct target_ops *target)
+{
+  int i;
+  CORE_ADDR addr;
+  int count;
+  char *buffer;
+  int status;
+
+  /* PMON targets do not cope well with 64 bit addresses.  Mask the
+     value down to 32 bits. */
+  if (mask_address_p)
+    memaddr &= (CORE_ADDR) 0xffffffff;
+
+  /* Round starting address down to longword boundary.  */
+  addr = memaddr & ~3;
+  /* Round ending address up; get number of longwords that makes.  */
+  count = (((memaddr + len) - addr) + 3) / 4;
+  /* Allocate buffer of that many longwords.  */
+  buffer = alloca (count * 4);
+
+  if (write)
+    {
+      /* Fill start and end extra bytes of buffer with existing data.  */
+      if (addr != memaddr || len < 4)
+	{
+	  /* Need part of initial word -- fetch it.  */
+	  store_unsigned_integer (&buffer[0], 4, brownie32_fetch_word (addr));
+	}
+
+      if (count > 1)
+	{
+	  /* Need part of last word -- fetch it.  FIXME: we do this even
+	     if we don't need it.  */
+	  store_unsigned_integer (&buffer[(count - 1) * 4], 4,
+				  brownie32_fetch_word (addr + (count - 1) * 4));
+	}
+
+      /* Copy data to be written over corresponding part of buffer */
+
+      memcpy ((char *) buffer + (memaddr & 3), myaddr, len);
+
+      /* Write the entire buffer.  */
+
+      for (i = 0; i < count; i++, addr += 4)
+	{
+	  status = brownie32_store_word (addr,
+			       extract_unsigned_integer (&buffer[i * 4], 4),
+				    NULL);
+	  /* Report each kilobyte (we download 32-bit words at a time) */
+	  if (i % 256 == 255)
+	    {
+	      printf_unfiltered ("*");
+	      gdb_flush (gdb_stdout);
+	    }
+	  if (status)
+	    {
+	      errno = status;
+	      return 0;
+	    }
+	  /* FIXME: Do we want a QUIT here?  */
+	}
+      if (count >= 256)
+	printf_unfiltered ("\n");
+    }
+  else
+    {
+      /* Read all the longwords */
+      for (i = 0; i < count; i++, addr += 4)
+	{
+	  store_unsigned_integer (&buffer[i * 4], 4, brownie32_fetch_word (addr));
+	  QUIT;
+	}
+
+      /* Copy appropriate bytes out of the buffer.  */
+      memcpy (myaddr, buffer + (memaddr & 3), len);
+    }
+  return len;
+}
+
+/* Print info on this target.  */
+
+static void
+brownie32_files_info (struct target_ops *ignore)
+{
+  printf_unfiltered ("Debugging a BROWNIE32 board over a serial line.\n");
+}
+
+/* Kill the process running on the board.  This will actually only
+   work if we are doing remote debugging over the console input.  I
+   think that if IDT/sim had the remote debug interrupt enabled on the
+   right port, we could interrupt the process with a break signal.  */
+
+static void
+brownie32_kill (void)
+{
+  if (!brownie32_wait_flag)
+    return;
+
+  interrupt_count++;
+
+  if (interrupt_count >= 2)
+    {
+      interrupt_count = 0;
+
+      target_terminal_ours ();
+
+      if (query ("Interrupted while waiting for the program.\n\
+Give up (and stop debugging it)? "))
+	{
+	  /* Clean up in such a way that brownie32_close won't try to talk to the
+	     board (it almost surely won't work since we weren't able to talk to
+	     it).  */
+	  brownie32_wait_flag = 0;
+	  close_ports ();
+
+	  printf_unfiltered ("Ending remote BROWNIE32 debugging.\n");
+	  target_mourn_inferior ();
+
+	  deprecated_throw_reason (RETURN_QUIT);
+	}
+
+      target_terminal_inferior ();
+    }
+
+  if (remote_debug > 0)
+    printf_unfiltered ("Sending break\n");
+
+  serial_send_break (brownie32_desc);
+
+#if 0
+  if (brownie32_is_open)
+    {
+      char cc;
+
+      /* Send a ^C.  */
+      cc = '\003';
+      serial_write (brownie32_desc, &cc, 1);
+      sleep (1);
+      target_mourn_inferior ();
+    }
+#endif
+}
+
+/* Start running on the target board.  */
+
+static void
+brownie32_create_inferior (char *execfile, char *args, char **env, int from_tty)
+{
+  CORE_ADDR entry_pt;
+
+  if (args && *args)
+    {
+      warning ("\
+Can't pass arguments to remote BROWNIE32 board; arguments ignored.");
+      /* And don't try to use them on the next "run" command.  */
+      execute_command ("set args", 0);
+    }
+
+  if (execfile == 0 || exec_bfd == 0)
+    error ("No executable file specified");
+
+  entry_pt = (CORE_ADDR) bfd_get_start_address (exec_bfd);
+
+  init_wait_for_inferior ();
+
+  /* FIXME: Should we set inferior_ptid here?  */
+
+  proceed (entry_pt, TARGET_SIGNAL_DEFAULT, 0);
+}
+
+/* Clean up after a process.  Actually nothing to do.  */
+
+static void
+brownie32_mourn_inferior (void)
+{
+  if (current_ops != NULL)
+    unpush_target (current_ops);
+  generic_mourn_inferior ();
+}
+
+/* We can write a breakpoint and read the shadow contents in one
+   operation.  */
+
+/* Insert a breakpoint.  On targets that don't have built-in
+   breakpoint support, we read the contents of the target location and
+   stash it, then overwrite it with a breakpoint instruction.  ADDR is
+   the target location in the target machine.  CONTENTS_CACHE is a
+   pointer to memory allocated for saving the target contents.  It is
+   guaranteed by the caller to be long enough to save the breakpoint
+   length returned by BREAKPOINT_FROM_PC.  */
+
+static int
+brownie32_insert_breakpoint (CORE_ADDR addr, char *contents_cache)
+{
+  if (monitor_supports_breakpoints)
+    return set_breakpoint (addr, BROWNIE32_INSN32_SIZE, BREAK_FETCH);
+  else
+    return memory_insert_breakpoint (addr, contents_cache);
+}
+
+static int
+brownie32_remove_breakpoint (CORE_ADDR addr, char *contents_cache)
+{
+  if (monitor_supports_breakpoints)
+    return clear_breakpoint (addr, BROWNIE32_INSN32_SIZE, BREAK_FETCH);
+  else
+    return memory_remove_breakpoint (addr, contents_cache);
+}
+
+/* Tell whether this target can support a hardware breakpoint.  CNT
+   is the number of hardware breakpoints already installed.  This
+   implements the TARGET_CAN_USE_HARDWARE_WATCHPOINT macro.  */
+
+int
+brownie32_can_use_watchpoint (int type, int cnt, int othertype)
+{
+  return cnt < MAX_LSI_BREAKPOINTS && strcmp (target_shortname, "lsi") == 0;
+}
+
+
+/* Compute a don't care mask for the region bounding ADDR and ADDR + LEN - 1.
+   This is used for memory ref breakpoints.  */
+
+static unsigned long
+calculate_mask (CORE_ADDR addr, int len)
+{
+  unsigned long mask;
+  int i;
+
+  mask = addr ^ (addr + len - 1);
+
+  for (i = 32; i >= 0; i--)
+    if (mask == 0)
+      break;
+    else
+      mask >>= 1;
+
+  mask = (unsigned long) 0xffffffff >> i;
+
+  return mask;
+}
+
+
+/* Set a data watchpoint.  ADDR and LEN should be obvious.  TYPE is 0
+   for a write watchpoint, 1 for a read watchpoint, or 2 for a read/write
+   watchpoint. */
+
+int
+brownie32_insert_watchpoint (CORE_ADDR addr, int len, int type)
+{
+  if (set_breakpoint (addr, len, type))
+    return -1;
+
+  return 0;
+}
+
+int
+brownie32_remove_watchpoint (CORE_ADDR addr, int len, int type)
+{
+  if (clear_breakpoint (addr, len, type))
+    return -1;
+
+  return 0;
+}
+
+int
+brownie32_stopped_by_watchpoint (void)
+{
+  return hit_watchpoint;
+}
+
+
+/* Insert a breakpoint.  */
+
+static int
+set_breakpoint (CORE_ADDR addr, int len, enum break_type type)
+{
+  return common_breakpoint (1, addr, len, type);
+}
+
+
+/* Clear a breakpoint.  */
+
+static int
+clear_breakpoint (CORE_ADDR addr, int len, enum break_type type)
+{
+  return common_breakpoint (0, addr, len, type);
+}
+
+
+/* Check the error code from the return packet for an LSI breakpoint
+   command.  If there's no error, just return 0.  If it's a warning,
+   print the warning text and return 0.  If it's an error, print
+   the error text and return 1.  <ADDR> is the address of the breakpoint
+   that was being set.  <RERRFLG> is the error code returned by PMON. 
+   This is a helper function for common_breakpoint.  */
+
+static int
+check_lsi_error (CORE_ADDR addr, int rerrflg)
+{
+  struct lsi_error *err;
+  char *saddr = paddr_nz (addr);	/* printable address string */
+
+  if (rerrflg == 0)		/* no error */
+    return 0;
+
+  /* Warnings can be ORed together, so check them all.  */
+  if (rerrflg & W_WARN)
+    {
+      if (monitor_warnings)
+	{
+	  int found = 0;
+	  for (err = lsi_warning_table; err->code != 0; err++)
+	    {
+	      if ((err->code & rerrflg) == err->code)
+		{
+		  found = 1;
+		  fprintf_unfiltered (gdb_stderr,
+				  "common_breakpoint (0x%s): Warning: %s\n",
+				      saddr,
+				      err->string);
+		}
+	    }
+	  if (!found)
+	    fprintf_unfiltered (gdb_stderr,
+			"common_breakpoint (0x%s): Unknown warning: 0x%x\n",
+				saddr,
+				rerrflg);
+	}
+      return 0;
+    }
+
+  /* Errors are unique, i.e. can't be ORed together.  */
+  for (err = lsi_error_table; err->code != 0; err++)
+    {
+      if ((err->code & rerrflg) == err->code)
+	{
+	  fprintf_unfiltered (gdb_stderr,
+			      "common_breakpoint (0x%s): Error: %s\n",
+			      saddr,
+			      err->string);
+	  return 1;
+	}
+    }
+  fprintf_unfiltered (gdb_stderr,
+		      "common_breakpoint (0x%s): Unknown error: 0x%x\n",
+		      saddr,
+		      rerrflg);
+  return 1;
+}
+
+
+/* This routine sends a breakpoint command to the remote target.
+
+   <SET> is 1 if setting a breakpoint, or 0 if clearing a breakpoint.
+   <ADDR> is the address of the breakpoint.
+   <LEN> the length of the region to break on.
+   <TYPE> is the type of breakpoint:
+   0 = write                    (BREAK_WRITE)
+   1 = read                     (BREAK_READ)
+   2 = read/write               (BREAK_ACCESS)
+   3 = instruction fetch        (BREAK_FETCH)
+
+   Return 0 if successful; otherwise 1.  */
+
+static int
+common_breakpoint (int set, CORE_ADDR addr, int len, enum break_type type)
+{
+  char buf[DATA_MAXLEN + 1];
+  char cmd, rcmd;
+  int rpid, rerrflg, rresponse, rlen;
+  int nfields;
+
+  addr = ADDR_BITS_REMOVE (addr);
+
+  if (brownie32_monitor == MON_LSI)
+    {
+      if (set == 0)		/* clear breakpoint */
+	{
+	  /* The LSI PMON "clear breakpoint" has this form:
+	     <pid> 'b' <bptn> 0x0
+	     reply:
+	     <pid> 'b' 0x0 <code>
+
+	     <bptn> is a breakpoint number returned by an earlier 'B' command.
+	     Possible return codes: OK, E_BPT.  */
+
+	  int i;
+
+	  /* Search for the breakpoint in the table.  */
+	  for (i = 0; i < MAX_LSI_BREAKPOINTS; i++)
+	    if (lsi_breakpoints[i].type == type
+		&& lsi_breakpoints[i].addr == addr
+		&& lsi_breakpoints[i].len == len)
+	      break;
+
+	  /* Clear the table entry and tell PMON to clear the breakpoint.  */
+	  if (i == MAX_LSI_BREAKPOINTS)
+	    {
+	      warning ("common_breakpoint: Attempt to clear bogus breakpoint at %s\n",
+		       paddr_nz (addr));
+	      return 1;
+	    }
+
+	  lsi_breakpoints[i].type = BREAK_UNUSED;
+	  sprintf (buf, "0x0 b 0x%x 0x0", i);
+	  brownie32_send_packet (buf, 1);
+
+	  rlen = brownie32_receive_packet (buf, 1, brownie32_receive_wait);
+	  buf[rlen] = '\0';
+
+	  nfields = sscanf (buf, "0x%x b 0x0 0x%x", &rpid, &rerrflg);
+	  if (nfields != 2)
+	    brownie32_error ("common_breakpoint: Bad response from remote board: %s", buf);
+
+	  return (check_lsi_error (addr, rerrflg));
+	}
+      else
+	/* set a breakpoint */
+	{
+	  /* The LSI PMON "set breakpoint" command has this form:
+	     <pid> 'B' <addr> 0x0
+	     reply:
+	     <pid> 'B' <bptn> <code>
+
+	     The "set data breakpoint" command has this form:
+
+	     <pid> 'A' <addr1> <type> [<addr2>  [<value>]]
+
+	     where: type= "0x1" = read
+	     "0x2" = write
+	     "0x3" = access (read or write)
+
+	     The reply returns two values:
+	     bptn - a breakpoint number, which is a small integer with
+	     possible values of zero through 255.
+	     code - an error return code, a value of zero indicates a
+	     succesful completion, other values indicate various
+	     errors and warnings.
+
+	     Possible return codes: OK, W_QAL, E_QAL, E_OUT, E_NON.  
+
+	   */
+
+	  if (type == BREAK_FETCH)	/* instruction breakpoint */
+	    {
+	      cmd = 'B';
+	      sprintf (buf, "0x0 B 0x%s 0x0", paddr_nz (addr));
+	    }
+	  else
+	    /* watchpoint */
+	    {
+	      cmd = 'A';
+	      sprintf (buf, "0x0 A 0x%s 0x%x 0x%s", paddr_nz (addr),
+		     type == BREAK_READ ? 1 : (type == BREAK_WRITE ? 2 : 3),
+		       paddr_nz (addr + len - 1));
+	    }
+	  brownie32_send_packet (buf, 1);
+
+	  rlen = brownie32_receive_packet (buf, 1, brownie32_receive_wait);
+	  buf[rlen] = '\0';
+
+	  nfields = sscanf (buf, "0x%x %c 0x%x 0x%x",
+			    &rpid, &rcmd, &rresponse, &rerrflg);
+	  if (nfields != 4 || rcmd != cmd || rresponse > 255)
+	    brownie32_error ("common_breakpoint: Bad response from remote board: %s", buf);
+
+	  if (rerrflg != 0)
+	    if (check_lsi_error (addr, rerrflg))
+	      return 1;
+
+	  /* rresponse contains PMON's breakpoint number.  Record the
+	     information for this breakpoint so we can clear it later.  */
+	  lsi_breakpoints[rresponse].type = type;
+	  lsi_breakpoints[rresponse].addr = addr;
+	  lsi_breakpoints[rresponse].len = len;
+
+	  return 0;
+	}
+    }
+  else
+    {
+      /* On non-LSI targets, the breakpoint command has this form:
+         0x0 <CMD> <ADDR> <MASK> <FLAGS>
+         <MASK> is a don't care mask for addresses.
+         <FLAGS> is any combination of `r', `w', or `f' for read/write/fetch.
+       */
+      unsigned long mask;
+
+      mask = calculate_mask (addr, len);
+      addr &= ~mask;
+
+      if (set)			/* set a breakpoint */
+	{
+	  char *flags;
+	  switch (type)
+	    {
+	    case BREAK_WRITE:	/* write */
+	      flags = "w";
+	      break;
+	    case BREAK_READ:	/* read */
+	      flags = "r";
+	      break;
+	    case BREAK_ACCESS:	/* read/write */
+	      flags = "rw";
+	      break;
+	    case BREAK_FETCH:	/* fetch */
+	      flags = "f";
+	      break;
+	    default:
+	      internal_error (__FILE__, __LINE__, _("failed internal consistency check"));
+	    }
+
+	  cmd = 'B';
+	  sprintf (buf, "0x0 B 0x%s 0x%s %s", paddr_nz (addr),
+		   paddr_nz (mask), flags);
+	}
+      else
+	{
+	  cmd = 'b';
+	  sprintf (buf, "0x0 b 0x%s", paddr_nz (addr));
+	}
+
+      brownie32_send_packet (buf, 1);
+
+      rlen = brownie32_receive_packet (buf, 1, brownie32_receive_wait);
+      buf[rlen] = '\0';
+
+      nfields = sscanf (buf, "0x%x %c 0x%x 0x%x",
+			&rpid, &rcmd, &rerrflg, &rresponse);
+
+      if (nfields != 4 || rcmd != cmd)
+	brownie32_error ("common_breakpoint: Bad response from remote board: %s",
+		    buf);
+
+      if (rerrflg != 0)
+	{
+	  /* Ddb returns "0x0 b 0x16 0x0\000", whereas
+	     Cogent returns "0x0 b 0xffffffff 0x16\000": */
+	  if (brownie32_monitor == MON_DDB)
+	    rresponse = rerrflg;
+	  if (rresponse != 22)	/* invalid argument */
+	    fprintf_unfiltered (gdb_stderr,
+			     "common_breakpoint (0x%s):  Got error: 0x%x\n",
+				paddr_nz (addr), rresponse);
+	  return 1;
+	}
+    }
+  return 0;
+}
+
+static void
+send_srec (char *srec, int len, CORE_ADDR addr)
+{
+  while (1)
+    {
+      int ch;
+
+      serial_write (brownie32_desc, srec, len);
+
+      ch = brownie32_readchar (remote_timeout);
+
+      switch (ch)
+	{
+	case SERIAL_TIMEOUT:
+	  error ("Timeout during download.");
+	  break;
+	case 0x6:		/* ACK */
+	  return;
+	case 0x15:		/* NACK */
+	  fprintf_unfiltered (gdb_stderr, "Download got a NACK at byte %s!  Retrying.\n", paddr_u (addr));
+	  continue;
+	default:
+	  error ("Download got unexpected ack char: 0x%x, retrying.\n", ch);
+	}
+    }
+}
+
+/*  Download a binary file by converting it to S records. */
+
+static void
+brownie32_load_srec (char *args)
+{
+  bfd *abfd;
+  asection *s;
+  char *buffer, srec[1024];
+  unsigned int i;
+  unsigned int srec_frame = 200;
+  int reclen;
+  static int hashmark = 1;
+
+  buffer = alloca (srec_frame * 2 + 256);
+
+  abfd = bfd_openr (args, 0);
+  if (!abfd)
+    {
+      printf_filtered ("Unable to open file %s\n", args);
+      return;
+    }
+
+  if (bfd_check_format (abfd, bfd_object) == 0)
+    {
+      printf_filtered ("File is not an object file\n");
+      return;
+    }
+
+/* This actually causes a download in the IDT binary format: */
+  brownie32_send_command (LOAD_CMD, 0);
+
+  for (s = abfd->sections; s; s = s->next)
+    {
+      if (s->flags & SEC_LOAD)
+	{
+	  unsigned int numbytes;
+
+	  /* FIXME!  vma too small????? */
+	  printf_filtered ("%s\t: 0x%4lx .. 0x%4lx  ", s->name,
+			   (long) s->vma,
+			   (long) (s->vma + bfd_get_section_size (s)));
+	  gdb_flush (gdb_stdout);
+
+	  for (i = 0; i < bfd_get_section_size (s); i += numbytes)
+	    {
+	      numbytes = min (srec_frame, bfd_get_section_size (s) - i);
+
+	      bfd_get_section_contents (abfd, s, buffer, i, numbytes);
+
+	      reclen = brownie32_make_srec (srec, '3', s->vma + i, 
+				       buffer, numbytes);
+	      send_srec (srec, reclen, s->vma + i);
+
+	      if (deprecated_ui_load_progress_hook)
+		deprecated_ui_load_progress_hook (s->name, i);
+
+	      if (hashmark)
+		{
+		  putchar_unfiltered ('#');
+		  gdb_flush (gdb_stdout);
+		}
+
+	    }			/* Per-packet (or S-record) loop */
+
+	  putchar_unfiltered ('\n');
+	}			/* Loadable sections */
+    }
+  if (hashmark)
+    putchar_unfiltered ('\n');
+
+  /* Write a type 7 terminator record. no data for a type 7, and there
+     is no data, so len is 0.  */
+
+  reclen = brownie32_make_srec (srec, '7', abfd->start_address, NULL, 0);
+
+  send_srec (srec, reclen, abfd->start_address);
+
+  serial_flush_input (brownie32_desc);
+}
+
+/*
+ * brownie32_make_srec -- make an srecord. This writes each line, one at a
+ *      time, each with it's own header and trailer line.
+ *      An srecord looks like this:
+ *
+ * byte count-+     address
+ * start ---+ |        |       data        +- checksum
+ *          | |        |                   |
+ *        S01000006F6B692D746573742E73726563E4
+ *        S315000448600000000000000000FC00005900000000E9
+ *        S31A0004000023C1400037DE00F023604000377B009020825000348D
+ *        S30B0004485A0000000000004E
+ *        S70500040000F6
+ *
+ *      S<type><length><address><data><checksum>
+ *
+ *      Where
+ *      - length
+ *        is the number of bytes following upto the checksum. Note that
+ *        this is not the number of chars following, since it takes two
+ *        chars to represent a byte.
+ *      - type
+ *        is one of:
+ *        0) header record
+ *        1) two byte address data record
+ *        2) three byte address data record
+ *        3) four byte address data record
+ *        7) four byte address termination record
+ *        8) three byte address termination record
+ *        9) two byte address termination record
+ *       
+ *      - address
+ *        is the start address of the data following, or in the case of
+ *        a termination record, the start address of the image
+ *      - data
+ *        is the data.
+ *      - checksum
+ *        is the sum of all the raw byte data in the record, from the length
+ *        upwards, modulo 256 and subtracted from 255.
+ *
+ * This routine returns the length of the S-record.
+ *
+ */
+
+static int
+brownie32_make_srec (char *buf, int type, CORE_ADDR memaddr, unsigned char *myaddr,
+		int len)
+{
+  unsigned char checksum;
+  int i;
+
+  /* Create the header for the srec. addr_size is the number of bytes in the address,
+     and 1 is the number of bytes in the count.  */
+
+  /* FIXME!! bigger buf required for 64-bit! */
+  buf[0] = 'S';
+  buf[1] = type;
+  buf[2] = len + 4 + 1;		/* len + 4 byte address + 1 byte checksum */
+  /* This assumes S3 style downloads (4byte addresses). There should
+     probably be a check, or the code changed to make it more
+     explicit. */
+  buf[3] = memaddr >> 24;
+  buf[4] = memaddr >> 16;
+  buf[5] = memaddr >> 8;
+  buf[6] = memaddr;
+  memcpy (&buf[7], myaddr, len);
+
+  /* Note that the checksum is calculated on the raw data, not the
+     hexified data.  It includes the length, address and the data
+     portions of the packet.  */
+  checksum = 0;
+  buf += 2;			/* Point at length byte */
+  for (i = 0; i < len + 4 + 1; i++)
+    checksum += *buf++;
+
+  *buf = ~checksum;
+
+  return len + 8;
+}
+
+/* The following manifest controls whether we enable the simple flow
+   control support provided by the monitor. If enabled the code will
+   wait for an affirmative ACK between transmitting packets. */
+#define DOETXACK (1)
+
+/* The PMON fast-download uses an encoded packet format constructed of
+   3byte data packets (encoded as 4 printable ASCII characters), and
+   escape sequences (preceded by a '/'):
+
+   'K'     clear checksum
+   'C'     compare checksum (12bit value, not included in checksum calculation)
+   'S'     define symbol name (for addr) terminated with "," and padded to 4char boundary
+   'Z'     zero fill multiple of 3bytes
+   'B'     byte (12bit encoded value, of 8bit data)
+   'A'     address (36bit encoded value)
+   'E'     define entry as original address, and exit load
+
+   The packets are processed in 4 character chunks, so the escape
+   sequences that do not have any data (or variable length data)
+   should be padded to a 4 character boundary.  The decoder will give
+   an error if the complete message block size is not a multiple of
+   4bytes (size of record).
+
+   The encoding of numbers is done in 6bit fields.  The 6bit value is
+   used to index into this string to get the specific character
+   encoding for the value: */
+static char encoding[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789,.";
+
+/* Convert the number of bits required into an encoded number, 6bits
+   at a time (range 0..63).  Keep a checksum if required (passed
+   pointer non-NULL). The function returns the number of encoded
+   characters written into the buffer. */
+static int
+pmon_makeb64 (unsigned long v, char *p, int n, int *chksum)
+{
+  int count = (n / 6);
+
+  if ((n % 12) != 0)
+    {
+      fprintf_unfiltered (gdb_stderr,
+			  "Fast encoding bitcount must be a multiple of 12bits: %dbit%s\n", n, (n == 1) ? "" : "s");
+      return (0);
+    }
+  if (n > 36)
+    {
+      fprintf_unfiltered (gdb_stderr,
+			  "Fast encoding cannot process more than 36bits at the moment: %dbits\n", n);
+      return (0);
+    }
+
+  /* Deal with the checksum: */
+  if (chksum != NULL)
+    {
+      switch (n)
+	{
+	case 36:
+	  *chksum += ((v >> 24) & 0xFFF);
+	case 24:
+	  *chksum += ((v >> 12) & 0xFFF);
+	case 12:
+	  *chksum += ((v >> 0) & 0xFFF);
+	}
+    }
+
+  do
+    {
+      n -= 6;
+      *p++ = encoding[(v >> n) & 0x3F];
+    }
+  while (n > 0);
+
+  return (count);
+}
+
+/* Shorthand function (that could be in-lined) to output the zero-fill
+   escape sequence into the data stream. */
+static int
+pmon_zeroset (int recsize, char **buff, int *amount, unsigned int *chksum)
+{
+  int count;
+
+  sprintf (*buff, "/Z");
+  count = pmon_makeb64 (*amount, (*buff + 2), 12, chksum);
+  *buff += (count + 2);
+  *amount = 0;
+  return (recsize + count + 2);
+}
+
+static int
+pmon_checkset (int recsize, char **buff, int *value)
+{
+  int count;
+
+  /* Add the checksum (without updating the value): */
+  sprintf (*buff, "/C");
+  count = pmon_makeb64 (*value, (*buff + 2), 12, NULL);
+  *buff += (count + 2);
+  sprintf (*buff, "\n");
+  *buff += 2;			/* include zero terminator */
+  /* Forcing a checksum validation clears the sum: */
+  *value = 0;
+  return (recsize + count + 3);
+}
+
+/* Amount of padding we leave after at the end of the output buffer,
+   for the checksum and line termination characters: */
+#define CHECKSIZE (4 + 4 + 4 + 2)
+/* zero-fill, checksum, transfer end and line termination space. */
+
+/* The amount of binary data loaded from the object file in a single
+   operation: */
+#define BINCHUNK (1024)
+
+/* Maximum line of data accepted by the monitor: */
+#define MAXRECSIZE (550)
+/* NOTE: This constant depends on the monitor being used. This value
+   is for PMON 5.x on the Cogent Vr4300 board. */
+
+static void
+pmon_make_fastrec (char **outbuf, unsigned char *inbuf, int *inptr,
+		   int inamount, int *recsize, unsigned int *csum,
+		   unsigned int *zerofill)
+{
+  int count = 0;
+  char *p = *outbuf;
+
+  /* This is a simple check to ensure that our data will fit within
+     the maximum allowable record size. Each record output is 4bytes
+     in length. We must allow space for a pending zero fill command,
+     the record, and a checksum record. */
+  while ((*recsize < (MAXRECSIZE - CHECKSIZE)) && ((inamount - *inptr) > 0))
+    {
+      /* Process the binary data: */
+      if ((inamount - *inptr) < 3)
+	{
+	  if (*zerofill != 0)
+	    *recsize = pmon_zeroset (*recsize, &p, zerofill, csum);
+	  sprintf (p, "/B");
+	  count = pmon_makeb64 (inbuf[*inptr], &p[2], 12, csum);
+	  p += (2 + count);
+	  *recsize += (2 + count);
+	  (*inptr)++;
+	}
+      else
+	{
+	  unsigned int value = ((inbuf[*inptr + 0] << 16) | (inbuf[*inptr + 1] << 8) | inbuf[*inptr + 2]);
+	  /* Simple check for zero data. TODO: A better check would be
+	     to check the last, and then the middle byte for being zero
+	     (if the first byte is not). We could then check for
+	     following runs of zeros, and if above a certain size it is
+	     worth the 4 or 8 character hit of the byte insertions used
+	     to pad to the start of the zeroes. NOTE: This also depends
+	     on the alignment at the end of the zero run. */
+	  if (value == 0x00000000)
+	    {
+	      (*zerofill)++;
+	      if (*zerofill == 0xFFF)	/* 12bit counter */
+		*recsize = pmon_zeroset (*recsize, &p, zerofill, csum);
+	    }
+	  else
+	    {
+	      if (*zerofill != 0)
+		*recsize = pmon_zeroset (*recsize, &p, zerofill, csum);
+	      count = pmon_makeb64 (value, p, 24, csum);
+	      p += count;
+	      *recsize += count;
+	    }
+	  *inptr += 3;
+	}
+    }
+
+  *outbuf = p;
+  return;
+}
+
+static int
+pmon_check_ack (char *mesg)
+{
+#if defined(DOETXACK)
+  int c;
+
+  if (!tftp_in_use)
+    {
+      c = serial_readchar (udp_in_use ? udp_desc : brownie32_desc,
+			   remote_timeout);
+      if ((c == SERIAL_TIMEOUT) || (c != 0x06))
+	{
+	  fprintf_unfiltered (gdb_stderr,
+			      "Failed to receive valid ACK for %s\n", mesg);
+	  return (-1);		/* terminate the download */
+	}
+    }
+#endif /* DOETXACK */
+  return (0);
+}
+
+/* pmon_download - Send a sequence of characters to the PMON download port,
+   which is either a serial port or a UDP socket.  */
+
+static void
+pmon_start_download (void)
+{
+  if (tftp_in_use)
+    {
+      /* Create the temporary download file.  */
+      if ((tftp_file = fopen (tftp_localname, "w")) == NULL)
+	perror_with_name (tftp_localname);
+    }
+  else
+    {
+      brownie32_send_command (udp_in_use ? LOAD_CMD_UDP : LOAD_CMD, 0);
+      brownie32_expect ("Downloading from ");
+      brownie32_expect (udp_in_use ? "udp" : "tty0");
+      brownie32_expect (", ^C to abort\r\n");
+    }
+}
+
+static int
+brownie32_expect_download (char *string)
+{
+  if (!brownie32_expect (string))
+    {
+      fprintf_unfiltered (gdb_stderr, "Load did not complete successfully.\n");
+      if (tftp_in_use)
+	remove (tftp_localname);	/* Remove temporary file */
+      return 0;
+    }
+  else
+    return 1;
+}
+
+static void
+pmon_check_entry_address (char *entry_address, int final)
+{
+  char hexnumber[9];		/* includes '\0' space */
+  brownie32_expect_timeout (entry_address, tftp_in_use ? 15 : remote_timeout);
+  sprintf (hexnumber, "%x", final);
+  brownie32_expect (hexnumber);
+  brownie32_expect ("\r\n");
+}
+
+static int
+pmon_check_total (int bintotal)
+{
+  char hexnumber[9];		/* includes '\0' space */
+  brownie32_expect ("\r\ntotal = 0x");
+  sprintf (hexnumber, "%x", bintotal);
+  brownie32_expect (hexnumber);
+  return brownie32_expect_download (" bytes\r\n");
+}
+
+static void
+pmon_end_download (int final, int bintotal)
+{
+  char hexnumber[9];		/* includes '\0' space */
+
+  if (tftp_in_use)
+    {
+      static char *load_cmd_prefix = "load -b -s ";
+      char *cmd;
+      struct stat stbuf;
+
+      /* Close off the temporary file containing the load data.  */
+      fclose (tftp_file);
+      tftp_file = NULL;
+
+      /* Make the temporary file readable by the world.  */
+      if (stat (tftp_localname, &stbuf) == 0)
+	chmod (tftp_localname, stbuf.st_mode | S_IROTH);
+
+      /* Must reinitialize the board to prevent PMON from crashing.  */
+      brownie32_send_command ("initEther\r", -1);
+
+      /* Send the load command.  */
+      cmd = xmalloc (strlen (load_cmd_prefix) + strlen (tftp_name) + 2);
+      strcpy (cmd, load_cmd_prefix);
+      strcat (cmd, tftp_name);
+      strcat (cmd, "\r");
+      brownie32_send_command (cmd, 0);
+      xfree (cmd);
+      if (!brownie32_expect_download ("Downloading from "))
+	return;
+      if (!brownie32_expect_download (tftp_name))
+	return;
+      if (!brownie32_expect_download (", ^C to abort\r\n"))
+	return;
+    }
+
+  /* Wait for the stuff that PMON prints after the load has completed.
+     The timeout value for use in the tftp case (15 seconds) was picked
+     arbitrarily but might be too small for really large downloads. FIXME. */
+  switch (brownie32_monitor)
+    {
+    case MON_LSI:
+      pmon_check_ack ("termination");
+      pmon_check_entry_address ("Entry address is ", final);
+      if (!pmon_check_total (bintotal))
+	return;
+      break;
+    default:
+      pmon_check_entry_address ("Entry Address  = ", final);
+      pmon_check_ack ("termination");
+      if (!pmon_check_total (bintotal))
+	return;
+      break;
+    }
+
+  if (tftp_in_use)
+    remove (tftp_localname);	/* Remove temporary file */
+}
+
+static void
+pmon_download (char *buffer, int length)
+{
+  if (tftp_in_use)
+    fwrite (buffer, 1, length, tftp_file);
+  else
+    serial_write (udp_in_use ? udp_desc : brownie32_desc, buffer, length);
+}
+
+static void
+pmon_load_fast (char *file)
+{
+  bfd *abfd;
+  asection *s;
+  unsigned char *binbuf;
+  char *buffer;
+  int reclen;
+  unsigned int csum = 0;
+  int hashmark = !tftp_in_use;
+  int bintotal = 0;
+  int final = 0;
+  int finished = 0;
+
+  buffer = (char *) xmalloc (MAXRECSIZE + 1);
+  binbuf = (unsigned char *) xmalloc (BINCHUNK);
+
+  abfd = bfd_openr (file, 0);
+  if (!abfd)
+    {
+      printf_filtered ("Unable to open file %s\n", file);
+      return;
+    }
+
+  if (bfd_check_format (abfd, bfd_object) == 0)
+    {
+      printf_filtered ("File is not an object file\n");
+      return;
+    }
+
+  /* Setup the required download state: */
+  brownie32_send_command ("set dlproto etxack\r", -1);
+  brownie32_send_command ("set dlecho off\r", -1);
+  /* NOTE: We get a "cannot set variable" message if the variable is
+     already defined to have the argument we give. The code doesn't
+     care, since it just scans to the next prompt anyway. */
+  /* Start the download: */
+  pmon_start_download ();
+
+  /* Zero the checksum */
+  sprintf (buffer, "/Kxx\n");
+  reclen = strlen (buffer);
+  pmon_download (buffer, reclen);
+  finished = pmon_check_ack ("/Kxx");
+
+  for (s = abfd->sections; s && !finished; s = s->next)
+    if (s->flags & SEC_LOAD)	/* only deal with loadable sections */
+      {
+	bintotal += bfd_get_section_size (s);
+	final = (s->vma + bfd_get_section_size (s));
+
+	printf_filtered ("%s\t: 0x%4x .. 0x%4x  ", s->name, (unsigned int) s->vma,
+			 (unsigned int) (s->vma + bfd_get_section_size (s)));
+	gdb_flush (gdb_stdout);
+
+	/* Output the starting address */
+	sprintf (buffer, "/A");
+	reclen = pmon_makeb64 (s->vma, &buffer[2], 36, &csum);
+	buffer[2 + reclen] = '\n';
+	buffer[3 + reclen] = '\0';
+	reclen += 3;		/* for the initial escape code and carriage return */
+	pmon_download (buffer, reclen);
+	finished = pmon_check_ack ("/A");
+
+	if (!finished)
+	  {
+	    unsigned int binamount;
+	    unsigned int zerofill = 0;
+	    char *bp = buffer;
+	    unsigned int i;
+
+	    reclen = 0;
+
+	    for (i = 0;
+		 i < bfd_get_section_size (s) && !finished;
+		 i += binamount)
+	      {
+		int binptr = 0;
+
+		binamount = min (BINCHUNK, bfd_get_section_size (s) - i);
+
+		bfd_get_section_contents (abfd, s, binbuf, i, binamount);
+
+		/* This keeps a rolling checksum, until we decide to output
+		   the line: */
+		for (; ((binamount - binptr) > 0);)
+		  {
+		    pmon_make_fastrec (&bp, binbuf, &binptr, binamount, 
+				       &reclen, &csum, &zerofill);
+		    if (reclen >= (MAXRECSIZE - CHECKSIZE))
+		      {
+			reclen = pmon_checkset (reclen, &bp, &csum);
+			pmon_download (buffer, reclen);
+			finished = pmon_check_ack ("data record");
+			if (finished)
+			  {
+			    zerofill = 0;	/* do not transmit pending zerofills */
+			    break;
+			  }
+
+			if (deprecated_ui_load_progress_hook)
+			  deprecated_ui_load_progress_hook (s->name, i);
+
+			if (hashmark)
+			  {
+			    putchar_unfiltered ('#');
+			    gdb_flush (gdb_stdout);
+			  }
+
+			bp = buffer;
+			reclen = 0;	/* buffer processed */
+		      }
+		  }
+	      }
+
+	    /* Ensure no out-standing zerofill requests: */
+	    if (zerofill != 0)
+	      reclen = pmon_zeroset (reclen, &bp, &zerofill, &csum);
+
+	    /* and then flush the line: */
+	    if (reclen > 0)
+	      {
+		reclen = pmon_checkset (reclen, &bp, &csum);
+		/* Currently pmon_checkset outputs the line terminator by
+		   default, so we write out the buffer so far: */
+		pmon_download (buffer, reclen);
+		finished = pmon_check_ack ("record remnant");
+	      }
+	  }
+
+	putchar_unfiltered ('\n');
+      }
+
+  /* Terminate the transfer. We know that we have an empty output
+     buffer at this point. */
+  sprintf (buffer, "/E/E\n");	/* include dummy padding characters */
+  reclen = strlen (buffer);
+  pmon_download (buffer, reclen);
+
+  if (finished)
+    {				/* Ignore the termination message: */
+      serial_flush_input (udp_in_use ? udp_desc : brownie32_desc);
+    }
+  else
+    {				/* Deal with termination message: */
+      pmon_end_download (final, bintotal);
+    }
+
+  return;
+}
+
+/* brownie32_load -- download a file. */
+
+static void
+brownie32_load (char *file, int from_tty)
+{
+  /* Get the board out of remote debugging mode.  */
+  if (brownie32_exit_debug ())
+    error ("brownie32_load:  Couldn't get into monitor mode.");
+
+  if (brownie32_monitor != MON_IDT)
+    pmon_load_fast (file);
+  else
+    brownie32_load_srec (file);
+
+  brownie32_initialize ();
+
+  /* Finally, make the PC point at the start address */
+  if (brownie32_monitor != MON_IDT)
+    {
+      /* Work around problem where PMON monitor updates the PC after a load
+         to a different value than GDB thinks it has. The following ensures
+         that the write_pc() WILL update the PC value: */
+      deprecated_register_valid[PC_REGNUM] = 0;
+    }
+  if (exec_bfd)
+    write_pc (bfd_get_start_address (exec_bfd));
+
+  inferior_ptid = null_ptid;	/* No process now */
+
+/* This is necessary because many things were based on the PC at the time that
+   we attached to the monitor, which is no longer valid now that we have loaded
+   new code (and just changed the PC).  Another way to do this might be to call
+   normal_stop, except that the stack may not be valid, and things would get
+   horribly confused... */
+
+  clear_symtab_users ();
+}
+
+
+/* Pass the command argument as a packet to PMON verbatim.  */
+
+static void
+pmon_command (char *args, int from_tty)
+{
+  char buf[DATA_MAXLEN + 1];
+  int rlen;
+
+  sprintf (buf, "0x0 %s", args);
+  brownie32_send_packet (buf, 1);
+  printf_filtered ("Send packet: %s\n", buf);
+
+  rlen = brownie32_receive_packet (buf, 1, brownie32_receive_wait);
+  buf[rlen] = '\0';
+  printf_filtered ("Received packet: %s\n", buf);
+}
+
+extern initialize_file_ftype _initialize_remote_brownie32; /* -Wmissing-prototypes */
+
+void
+_initialize_remote_brownie32 (void)
+{
+  /* Initialize the fields in brownie32_ops that are common to all four targets.  */
+  brownie32_ops.to_longname = "Remote BROWNIE32 debugging over serial line";
+  brownie32_ops.to_close = brownie32_close;
+  brownie32_ops.to_detach = brownie32_detach;
+  brownie32_ops.to_resume = brownie32_resume;
+  brownie32_ops.to_fetch_registers = brownie32_fetch_registers;
+  brownie32_ops.to_store_registers = brownie32_store_registers;
+  brownie32_ops.to_prepare_to_store = brownie32_prepare_to_store;
+  brownie32_ops.deprecated_xfer_memory = brownie32_xfer_memory;
+  brownie32_ops.to_files_info = brownie32_files_info;
+  brownie32_ops.to_insert_breakpoint = brownie32_insert_breakpoint;
+  brownie32_ops.to_remove_breakpoint = brownie32_remove_breakpoint;
+  brownie32_ops.to_insert_watchpoint = brownie32_insert_watchpoint;
+  brownie32_ops.to_remove_watchpoint = brownie32_remove_watchpoint;
+  brownie32_ops.to_stopped_by_watchpoint = brownie32_stopped_by_watchpoint;
+  brownie32_ops.to_can_use_hw_breakpoint = brownie32_can_use_watchpoint;
+  brownie32_ops.to_kill = brownie32_kill;
+  brownie32_ops.to_load = brownie32_load;
+  brownie32_ops.to_create_inferior = brownie32_create_inferior;
+  brownie32_ops.to_mourn_inferior = brownie32_mourn_inferior;
+  brownie32_ops.to_stratum = process_stratum;
+  brownie32_ops.to_has_all_memory = 1;
+  brownie32_ops.to_has_memory = 1;
+  brownie32_ops.to_has_stack = 1;
+  brownie32_ops.to_has_registers = 1;
+  brownie32_ops.to_has_execution = 1;
+  brownie32_ops.to_magic = OPS_MAGIC;
+
+  /* Copy the common fields to all four target vectors.  */
+  pmon_ops = ddb_ops = lsi_ops = brownie32_ops;
+
+  /* Initialize target-specific fields in the target vectors.  */
+  brownie32_ops.to_shortname = "brownie32";
+  brownie32_ops.to_doc = "\
+Debug a board using the BROWNIE32 remote debugging protocol over a serial line.\n\
+The argument is the device it is connected to or, if it contains a colon,\n\
+HOST:PORT to access a board over a network";
+  brownie32_ops.to_open = brownie32_open;
+  brownie32_ops.to_wait = brownie32_wait;
+
+  pmon_ops.to_shortname = "pmon";
+  pmon_ops.to_doc = "\
+Debug a board using the PMON BROWNIE32 remote debugging protocol over a serial\n\
+line. The argument is the device it is connected to or, if it contains a\n\
+colon, HOST:PORT to access a board over a network";
+  pmon_ops.to_open = pmon_open;
+  pmon_ops.to_wait = brownie32_wait;
+
+  ddb_ops.to_shortname = "ddb";
+  ddb_ops.to_doc = "\
+Debug a board using the PMON BROWNIE32 remote debugging protocol over a serial\n\
+line. The first argument is the device it is connected to or, if it contains\n\
+a colon, HOST:PORT to access a board over a network.  The optional second\n\
+parameter is the temporary file in the form HOST:FILENAME to be used for\n\
+TFTP downloads to the board.  The optional third parameter is the local name\n\
+of the TFTP temporary file, if it differs from the filename seen by the board.";
+  ddb_ops.to_open = ddb_open;
+  ddb_ops.to_wait = brownie32_wait;
+
+  lsi_ops.to_shortname = "lsi";
+  lsi_ops.to_doc = pmon_ops.to_doc;
+  lsi_ops.to_open = lsi_open;
+  lsi_ops.to_wait = brownie32_wait;
+
+  /* Add the targets.  */
+  add_target (&brownie32_ops);
+  add_target (&pmon_ops);
+  add_target (&ddb_ops);
+  add_target (&lsi_ops);
+
+  add_setshow_zinteger_cmd ("timeout", no_class, &brownie32_receive_wait, _("\
+Set timeout in seconds for remote BROWNIE32 serial I/O."), _("\
+Show timeout in seconds for remote BROWNIE32 serial I/O."), NULL,
+			    NULL,
+			    NULL, /* FIXME: i18n: */
+			    &setlist, &showlist);
+
+  add_setshow_zinteger_cmd ("retransmit-timeout", no_class,
+			    &brownie32_retransmit_wait, _("\
+Set retransmit timeout in seconds for remote BROWNIE32 serial I/O."), _("\
+Show retransmit timeout in seconds for remote BROWNIE32 serial I/O."), _("\
+This is the number of seconds to wait for an acknowledgement to a packet\n\
+before resending the packet."),
+			    NULL,
+			    NULL, /* FIXME: i18n: */
+			    &setlist, &showlist);
+
+  add_setshow_zinteger_cmd ("syn-garbage-limit", no_class,
+			    &brownie32_syn_garbage,  _("\
+Set the maximum number of characters to ignore when scanning for a SYN."), _("\
+Show the maximum number of characters to ignore when scanning for a SYN."), _("\
+This is the maximum number of characters GDB will ignore when trying to\n\
+synchronize with the remote system.  A value of -1 means that there is no\n\
+limit. (Note that these characters are printed out even though they are\n\
+ignored.)"),
+			    NULL,
+			    NULL, /* FIXME: i18n: */
+			    &setlist, &showlist);
+
+  add_setshow_string_cmd ("monitor-prompt", class_obscure,
+			  &brownie32_monitor_prompt, _("\
+Set the prompt that GDB expects from the monitor."), _("\
+Show the prompt that GDB expects from the monitor."), NULL,
+			  NULL,
+			  NULL, /* FIXME: i18n: */
+			  &setlist, &showlist);
+
+  add_setshow_zinteger_cmd ("monitor-warnings", class_obscure,
+			    &monitor_warnings, _("\
+Set printing of monitor warnings."), _("\
+Show printing of monitor warnings."), _("\
+When enabled, monitor warnings about hardware breakpoints will be displayed."),
+			    NULL,
+			    NULL, /* FIXME: i18n: */
+			    &setlist, &showlist);
+
+  add_com ("pmon", class_obscure, pmon_command,
+	   _("Send a packet to PMON (must be in debug mode)."));
+
+  add_setshow_boolean_cmd ("mask-address", no_class, &mask_address_p, _("\
+Set zeroing of upper 32 bits of 64-bit addresses when talking to PMON targets."), _("\
+Show zeroing of upper 32 bits of 64-bit addresses when talking to PMON targets."), _("\
+Use \"on\" to enable the masking and \"off\" to disable it."),
+			   NULL,
+			   NULL, /* FIXME: i18n: */
+			   &setlist, &showlist);
+}
Index: gdb/config/brownie32/embed.mt
===================================================================
RCS file: gdb/config/brownie32/embed.mt
diff -N gdb/config/brownie32/embed.mt
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/config/brownie32/embed.mt	11 Feb 2008 15:43:53 -0000	1.2
@@ -0,0 +1,3 @@
+TDEPFILES= brownie32-tdep.o
+SIM_OBS = remote-sim.o
+SIM = ../sim/brownie32/libsim.a
Index: gdb/config/brownie32/linux.mh
===================================================================
RCS file: gdb/config/brownie32/linux.mh
diff -N gdb/config/brownie32/linux.mh
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/config/brownie32/linux.mh	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,7 @@
+# Host: Linux/BROWNIE32
+NAT_FILE= nm-linux.h
+NATDEPFILES= inf-ptrace.o fork-child.o brownie32-linux-nat.o \
+	linux-thread-db.o proc-service.o gcore.o \
+	linux-nat.o
+
+LOADLIBES = -ldl -rdynamic
Index: gdb/config/brownie32/linux.mt
===================================================================
RCS file: gdb/config/brownie32/linux.mt
diff -N gdb/config/brownie32/linux.mt
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/config/brownie32/linux.mt	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,7 @@
+# Target: Linux/BROWNIE32
+TDEPFILES= brownie32-tdep.o brownie32-linux-tdep.o corelow.o \
+	solib.o solib-svr4.o symfile-mem.o
+DEPRECATED_TM_FILE= tm-linux.h
+
+SIM_OBS = remote-sim.o
+SIM = ../sim/brownie32/libsim.a
Index: gdb/config/brownie32/nbsd.mh
===================================================================
RCS file: gdb/config/brownie32/nbsd.mh
diff -N gdb/config/brownie32/nbsd.mh
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/config/brownie32/nbsd.mh	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,2 @@
+# Host: NetBSD/BROWNIE32
+NATDEPFILES= fork-child.o inf-ptrace.o brownie32nbsd-nat.o
Index: gdb/config/brownie32/nbsd.mt
===================================================================
RCS file: gdb/config/brownie32/nbsd.mt
diff -N gdb/config/brownie32/nbsd.mt
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/config/brownie32/nbsd.mt	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,7 @@
+# Target: BROWNIE32 running NetBSD
+TDEPFILES= brownie32-tdep.o brownie32nbsd-tdep.o corelow.o solib.o solib-svr4.o \
+	nbsd-tdep.o
+DEPRECATED_TM_FILE= tm-nbsd.h
+
+SIM_OBS = remote-sim.o
+SIM = ../sim/brownie32/libsim.a
Index: gdb/config/brownie32/nm-linux.h
===================================================================
RCS file: gdb/config/brownie32/nm-linux.h
diff -N gdb/config/brownie32/nm-linux.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/config/brownie32/nm-linux.h	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,51 @@
+/* Native-dependent definitions for GNU/Linux on BROWNIE32.
+
+   Copyright 1996, 2001, 2002, 2003 Free Software Foundation, Inc.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef NM_BROWNIE32LINUX_H
+#define NM_BROWNIE32LINUX_H
+
+#include "config/nm-linux.h"
+
+/* Return sizeof user struct to callers in less machine dependent
+   routines.  Hard coded for cross-compilation friendliness. */
+
+#define KERNEL_U_SIZE 504
+
+/* ptrace register ``addresses'' are absolute.  */
+
+#define U_REGS_OFFSET 0
+
+/* ptrace transfers longs, and expects addresses as longs.  */
+
+#define PTRACE_ARG3_TYPE long
+#define PTRACE_XFER_TYPE long
+
+#define REGISTER_U_ADDR(addr, blockend, regno) \
+  (addr) = brownie32_register_addr ((regno),(blockend))
+
+int brownie32_linux_cannot_fetch_register (int regno);
+int brownie32_linux_cannot_store_register (int regno);
+#define CANNOT_FETCH_REGISTER(regno) brownie32_linux_cannot_fetch_register (regno)
+#define CANNOT_STORE_REGISTER(regno) brownie32_linux_cannot_store_register (regno)
+
+#endif /* NM_brownie32LINUX_H */
Index: gdb/config/brownie32/obsd64.mh
===================================================================
RCS file: gdb/config/brownie32/obsd64.mh
diff -N gdb/config/brownie32/obsd64.mh
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/config/brownie32/obsd64.mh	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,2 @@
+# Host: OpenBSD/BROWNIE3264
+NATDEPFILES= fork-child.o inf-ptrace.o brownie3264obsd-nat.o
Index: gdb/config/brownie32/obsd64.mt
===================================================================
RCS file: gdb/config/brownie32/obsd64.mt
diff -N gdb/config/brownie32/obsd64.mt
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/config/brownie32/obsd64.mt	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,2 @@
+# Target: OpenBSD/brownie3264
+TDEPFILES= brownie32-tdep.o brownie3264obsd-tdep.o corelow.o solib.o solib-svr4.o
Index: gdb/config/brownie32/tm-linux.h
===================================================================
RCS file: gdb/config/brownie32/tm-linux.h
diff -N gdb/config/brownie32/tm-linux.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/config/brownie32/tm-linux.h	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,40 @@
+/* Target-dependent definitions for GNU/Linux brownie32.
+
+   Copyright 2001, 2002, 2004 Free Software Foundation, Inc.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef TM_BROWNIE32LINUX_H
+#define TM_BROWNIE32LINUX_H
+
+/* GNU/Linux brownie32 has __SIGRTMAX == 127.  */
+
+#ifndef REALTIME_LO
+#define REALTIME_LO 32
+#define REALTIME_HI 128
+#endif
+
+#include "config/tm-linux.h"
+
+#undef IN_SOLIB_DYNSYM_RESOLVE_CODE
+#define IN_SOLIB_DYNSYM_RESOLVE_CODE(PC) brownie32_linux_in_dynsym_resolve_code (PC)
+int brownie32_linux_in_dynsym_resolve_code (CORE_ADDR pc);
+
+#endif /* TM_BROWNIE32LINUX_H */
Index: gdb/config/brownie32/tm-nbsd.h
===================================================================
RCS file: gdb/config/brownie32/tm-nbsd.h
diff -N gdb/config/brownie32/tm-nbsd.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/config/brownie32/tm-nbsd.h	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,32 @@
+/* Target-dependent definitions for NetBSD/brownie32.
+   Copyright 2002 Free Software Foundation, Inc.
+   Contributed by Wasabi Systems, Inc.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef TM_NBSD_H
+#define TM_NBSD_H
+
+#include "solib.h"
+
+#undef SKIP_TRAMPOLINE_CODE
+#undef DEPRECATED_IGNORE_HELPER_CALL
+
+#endif /* TM_NBSD_H */
Index: gdb/doc/configure
===================================================================
RCS file: /home/prj/asip/cvs/gdb/gdb/doc/configure,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- gdb/doc/configure	31 Jul 2007 11:40:24 -0000	1.1.1.1
+++ gdb/doc/configure	8 Aug 2007 08:49:54 -0000	1.2
@@ -1444,9 +1444,10 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   # 1. Remove the extension, and $U if already installed.
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
-  # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
-  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
 
Index: gdb/gdbserver/Makefile.in
===================================================================
RCS file: /home/prj/asip/cvs/gdb/gdb/gdbserver/Makefile.in,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- gdb/gdbserver/Makefile.in	31 Jul 2007 11:40:24 -0000	1.1.1.1
+++ gdb/gdbserver/Makefile.in	8 Aug 2007 08:49:54 -0000	1.2
@@ -1,5 +1,6 @@
 # Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
 # 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+# Copyright (C) 2005,2006  Upwind technology, Inc.
 
 # This file is part of GDB.
 
@@ -123,7 +124,7 @@ SFILES=	$(srcdir)/gdbreplay.c $(srcdir)/
 	$(srcdir)/i387-fp.c \
 	$(srcdir)/linux-ia64-low.c $(srcdir)/linux-low.c \
 	$(srcdir)/linux-m32r-low.c \
-	$(srcdir)/linux-m68k-low.c $(srcdir)/linux-mips-low.c \
+	$(srcdir)/linux-m68k-low.c $(srcdir)/linux-mips-low.c $(srcdir)/linux-brownie32-low.c \
 	$(srcdir)/linux-ppc-low.c $(srcdir)/linux-ppc64-low.c \
 	$(srcdir)/linux-s390-low.c \
 	$(srcdir)/linux-sh-low.c $(srcdir)/linux-x86-64-low.c
@@ -201,7 +202,7 @@ tags: TAGS
 clean:
 	rm -f *.o ${ADD_FILES} *~
 	rm -f gdbserver gdbreplay core make.log
-	rm -f reg-arm.c reg-i386.c reg-ia64.c reg-m32r.c reg-m68k.c reg-mips.c
+	rm -f reg-arm.c reg-i386.c reg-ia64.c reg-m32r.c reg-m68k.c reg-mips.c reg-brownie32.c
 	rm -f reg-ppc.c reg-sh.c reg-x86-64.c reg-i386-linux.c
 	rm -f reg-cris.c reg-crisv32.c
 
@@ -271,6 +272,7 @@ linux-i386-low.o: linux-i386-low.c $(lin
 linux-ia64-low.o: linux-ia64-low.c $(linux_low_h) $(server_h)
 linux-m32r-low.o: linux-m32r-low.c $(linux_low_h) $(server_h)
 linux-mips-low.o: linux-mips-low.c $(linux_low_h) $(server_h)
+linux-brownie32-low.o: linux-brownie32-low.c $(linux_low_h) $(server_h)
 linux-ppc-low.o: linux-ppc-low.c $(linux_low_h) $(server_h)
 linux-ppc64-low.o: linux-ppc64-low.c $(linux_low_h) $(server_h)
 linux-s390-low.o: linux-s390-low.c $(linux_low_h) $(server_h)
@@ -304,6 +306,9 @@ reg-m68k.c : $(srcdir)/../regformats/reg
 reg-mips.o : reg-mips.c $(regdef_h)
 reg-mips.c : $(srcdir)/../regformats/reg-mips.dat $(regdat_sh)
 	sh $(regdat_sh) $(srcdir)/../regformats/reg-mips.dat reg-mips.c
+reg-brownie32.o : reg-brownie32.c $(regdef_h)
+reg-brownie32.c : $(srcdir)/../regformats/reg-brownie32.dat $(regdat_sh)
+	sh $(regdat_sh) $(srcdir)/../regformats/reg-brownie32.dat reg-brownie32.c
 reg-ppc.o : reg-ppc.c $(regdef_h)
 reg-ppc.c : $(srcdir)/../regformats/reg-ppc.dat $(regdat_sh)
 	sh $(regdat_sh) $(srcdir)/../regformats/reg-ppc.dat reg-ppc.c
Index: gdb/gdbserver/configure
===================================================================
RCS file: /home/prj/asip/cvs/gdb/gdb/gdbserver/configure,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- gdb/gdbserver/configure	31 Jul 2007 11:40:24 -0000	1.1.1.1
+++ gdb/gdbserver/configure	8 Aug 2007 08:49:54 -0000	1.2
@@ -947,7 +947,7 @@ esac
     else
       echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
     fi
-    cd "$ac_popdir"
+    cd $ac_popdir
   done
 fi
 
@@ -1865,7 +1865,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -1923,7 +1924,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2039,7 +2041,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2093,7 +2096,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2138,7 +2142,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2182,7 +2187,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2708,7 +2714,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2879,7 +2886,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2956,7 +2964,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3104,7 +3113,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3179,7 +3189,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3257,7 +3268,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3318,7 +3330,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3383,7 +3396,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3447,7 +3461,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3511,7 +3526,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3575,7 +3591,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3700,7 +3717,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3779,7 +3797,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3836,7 +3855,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3901,7 +3921,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3958,7 +3979,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4081,9 +4103,10 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   # 1. Remove the extension, and $U if already installed.
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
-  # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
-  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
 
@@ -4811,6 +4834,11 @@ esac
   *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
   esac
 
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
   # Let's still pretend it is `configure' which instantiates (i.e., don't
   # use $as_me), people would be surprised to read:
   #    /* config.h.  Generated by config.status.  */
@@ -4849,12 +4877,6 @@ echo "$as_me: error: cannot find input f
 	 fi;;
       esac
     done` || { (exit 1); exit 1; }
-
-  if test x"$ac_file" != x-; then
-    { echo "$as_me:$LINENO: creating $ac_file" >&5
-echo "$as_me: creating $ac_file" >&6;}
-    rm -f "$ac_file"
-  fi
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF
   sed "$ac_vpsub
Index: gdb/gdbserver/configure.srv
===================================================================
RCS file: /home/prj/asip/cvs/gdb/gdb/gdbserver/configure.srv,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- gdb/gdbserver/configure.srv	31 Jul 2007 11:40:24 -0000	1.1.1.1
+++ gdb/gdbserver/configure.srv	8 Aug 2007 08:49:54 -0000	1.2
@@ -59,6 +59,11 @@ case "${target}" in
 			srv_linux_usrregs=yes
 			srv_linux_thread_db=yes
 			;;
+  brownie32*-*-linux*)	srv_regobj=reg-brownie32.o
+			srv_tgtobj="linux-low.o linux-brownie32-low.o"
+			srv_linux_usrregs=yes
+			srv_linux_thread_db=yes
+			;;
   powerpc64-*-linux*)	srv_regobj=reg-ppc64.o
 			srv_tgtobj="linux-low.o linux-ppc64-low.o"
 			srv_linux_usrregs=yes
Index: gdb/gdbserver/linux-brownie32-low.c
===================================================================
RCS file: gdb/gdbserver/linux-brownie32-low.c
diff -N gdb/gdbserver/linux-brownie32-low.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/gdbserver/linux-brownie32-low.c	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,157 @@
+/* GNU/Linux/BROWNIE32 specific low level interface, for the remote server for GDB.
+   Copyright 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2005
+   Free Software Foundation, Inc.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include "server.h"
+#include "linux-low.h"
+
+#ifdef HAVE_SYS_REG_H
+#include <sys/reg.h>
+#endif
+
+#define brownie32_num_regs 90
+
+#include <asm/ptrace.h>
+
+/* Return the ptrace ``address'' of register REGNO. */
+
+/* Matches brownie32_generic32_regs */
+static int brownie32_regmap[] = {
+  0,  1,  2,  3,  4,  5,  6,  7,
+  8,  9,  10, 11, 12, 13, 14, 15,
+  16, 17, 18, 19, 20, 21, 22, 23,
+  24, 25, 26, 27, 28, 29, 30, 31,
+
+  -1, MMLO, MMHI, BADVADDR, CAUSE, PC,
+
+  FPR_BASE,      FPR_BASE + 1,  FPR_BASE + 2,  FPR_BASE + 3,
+  FPR_BASE + 4,  FPR_BASE + 5,  FPR_BASE + 6,  FPR_BASE + 7,
+  FPR_BASE + 8,  FPR_BASE + 8,  FPR_BASE + 10, FPR_BASE + 11,
+  FPR_BASE + 12, FPR_BASE + 13, FPR_BASE + 14, FPR_BASE + 15,
+  FPR_BASE + 16, FPR_BASE + 17, FPR_BASE + 18, FPR_BASE + 19,
+  FPR_BASE + 20, FPR_BASE + 21, FPR_BASE + 22, FPR_BASE + 23,
+  FPR_BASE + 24, FPR_BASE + 25, FPR_BASE + 26, FPR_BASE + 27,
+  FPR_BASE + 28, FPR_BASE + 29, FPR_BASE + 30, FPR_BASE + 31,
+  FPC_CSR, FPC_EIR,
+
+  -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1,
+};
+
+/* From brownie32-linux-nat.c.  */
+
+/* Pseudo registers can not be read.  ptrace does not provide a way to
+   read (or set) PS_REGNUM, and there's no point in reading or setting
+   ZERO_REGNUM.  We also can not set BADVADDR, CAUSE, or FCRIR via
+   ptrace().  */
+
+static int
+brownie32_cannot_fetch_register (int regno)
+{
+  if (brownie32_regmap[regno] == -1)
+    return 1;
+
+  if (find_regno ("zero") == regno)
+    return 1;
+
+  return 0;
+}
+
+static int
+brownie32_cannot_store_register (int regno)
+{
+  if (brownie32_regmap[regno] == -1)
+    return 1;
+
+  if (find_regno ("zero") == regno)
+    return 1;
+
+  if (find_regno ("cause") == regno)
+    return 1;
+
+  if (find_regno ("bad") == regno)
+    return 1;
+
+  if (find_regno ("fir") == regno)
+    return 1;
+
+  return 0;
+}
+
+static CORE_ADDR
+brownie32_get_pc ()
+{
+  unsigned long pc;
+  collect_register_by_name ("pc", &pc);
+  return pc;
+}
+
+static void
+brownie32_set_pc (CORE_ADDR pc)
+{
+  unsigned long newpc = pc;
+  supply_register_by_name ("pc", &newpc);
+}
+
+/* Correct in either endianness.  */
+static const unsigned long brownie32_breakpoint = 0x0000000d;
+#define brownie32_breakpoint_len 4
+
+/* We only place breakpoints in empty marker functions, and thread locking
+   is outside of the function.  So rather than importing software single-step,
+   we can just run until exit.  */
+static CORE_ADDR
+brownie32_reinsert_addr ()
+{
+  unsigned long pc;
+  collect_register_by_name ("ra", &pc);
+  return pc;
+}
+
+static int
+brownie32_breakpoint_at (CORE_ADDR where)
+{
+  unsigned long insn;
+
+  (*the_target->read_memory) (where, (unsigned char *) &insn, 4);
+  if (insn == brownie32_breakpoint)
+    return 1;
+
+  /* If necessary, recognize more trap instructions here.  GDB only uses the
+     one.  */
+  return 0;
+}
+
+struct linux_target_ops the_low_target = {
+  brownie32_num_regs,
+  brownie32_regmap,
+  brownie32_cannot_fetch_register,
+  brownie32_cannot_store_register,
+  brownie32_get_pc,
+  brownie32_set_pc,
+  (const unsigned char *) &brownie32_breakpoint,
+  brownie32_breakpoint_len,
+  brownie32_reinsert_addr,
+  0,
+  brownie32_breakpoint_at,
+};
Index: gdb/nlm/configure
===================================================================
RCS file: /home/prj/asip/cvs/gdb/gdb/nlm/configure,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- gdb/nlm/configure	31 Jul 2007 11:40:24 -0000	1.1.1.1
+++ gdb/nlm/configure	8 Aug 2007 08:49:54 -0000	1.2
@@ -28,7 +28,6 @@ program_suffix=NONE
 program_transform_name=s,x,x,
 silent=
 site=
-sitefile=
 srcdir=
 target=NONE
 verbose=
@@ -143,7 +142,6 @@ Configuration:
   --help                  print this message
   --no-create             do not create output files
   --quiet, --silent       do not print \`checking...' messages
-  --site-file=FILE        use FILE as the site file
   --version               print the version of autoconf that created configure
 Directory and file names:
   --prefix=PREFIX         install architecture-independent files in PREFIX
@@ -314,11 +312,6 @@ EOF
   -site=* | --site=* | --sit=*)
     site="$ac_optarg" ;;
 
-  -site-file | --site-file | --site-fil | --site-fi | --site-f)
-    ac_prev=sitefile ;;
-  -site-file=* | --site-file=* | --site-fil=* | --site-fi=* | --site-f=*)
-    sitefile="$ac_optarg" ;;
-
   -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
     ac_prev=srcdir ;;
   -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
@@ -484,16 +477,12 @@ fi
 srcdir=`echo "${srcdir}" | sed 's%\([^/]\)/*$%\1%'`
 
 # Prefer explicitly selected file to automatically selected ones.
-if test -z "$sitefile"; then
-  if test -z "$CONFIG_SITE"; then
-    if test "x$prefix" != xNONE; then
-      CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
-    else
-      CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
-    fi
+if test -z "$CONFIG_SITE"; then
+  if test "x$prefix" != xNONE; then
+    CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
+  else
+    CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
   fi
-else
-  CONFIG_SITE="$sitefile"
 fi
 for ac_site_file in $CONFIG_SITE; do
   if test -r "$ac_site_file"; then
@@ -580,7 +569,7 @@ else { echo "configure: error: can not r
 fi
 
 echo $ac_n "checking host system type""... $ac_c" 1>&6
-echo "configure:584: checking host system type" >&5
+echo "configure:573: checking host system type" >&5
 
 host_alias=$host
 case "$host_alias" in
@@ -601,7 +590,7 @@ host_os=`echo $host | sed 's/^\([^-]*\)-
 echo "$ac_t""$host" 1>&6
 
 echo $ac_n "checking target system type""... $ac_c" 1>&6
-echo "configure:605: checking target system type" >&5
+echo "configure:594: checking target system type" >&5
 
 target_alias=$target
 case "$target_alias" in
@@ -619,7 +608,7 @@ target_os=`echo $target | sed 's/^\([^-]
 echo "$ac_t""$target" 1>&6
 
 echo $ac_n "checking build system type""... $ac_c" 1>&6
-echo "configure:623: checking build system type" >&5
+echo "configure:612: checking build system type" >&5
 
 build_alias=$build
 case "$build_alias" in
@@ -673,7 +662,7 @@ test "$program_transform_name" = "" && p
 # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
 # ./install, which can be erroneously created by make from ./install.sh.
 echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
-echo "configure:677: checking for a BSD compatible install" >&5
+echo "configure:666: checking for a BSD compatible install" >&5
 if test -z "$INSTALL"; then
 if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
Index: gdb/rdi-share/Makefile.in
===================================================================
RCS file: /home/prj/asip/cvs/gdb/gdb/rdi-share/Makefile.in,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- gdb/rdi-share/Makefile.in	31 Jul 2007 11:40:26 -0000	1.1.1.1
+++ gdb/rdi-share/Makefile.in	8 Aug 2007 08:49:54 -0000	1.2
@@ -1,6 +1,8 @@
-# Makefile.in generated automatically by automake 1.3b from Makefile.am
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# @configure_input@
 
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -10,66 +12,143 @@
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
+@SET_MAKE@
 
-SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-
-bindir = @bindir@
-sbindir = @sbindir@
-libexecdir = @libexecdir@
-datadir = @datadir@
-sysconfdir = @sysconfdir@
-sharedstatedir = @sharedstatedir@
-localstatedir = @localstatedir@
-libdir = @libdir@
-infodir = @infodir@
-htmldir = $(prefix)/html
-mandir = @mandir@
-includedir = @includedir@
-oldincludedir = /usr/include
-
-DESTDIR =
-
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
-
 top_builddir = .
-
-ACLOCAL = @ACLOCAL@
-AUTOCONF = @AUTOCONF@
-AUTOMAKE = @AUTOMAKE@
-AUTOHEADER = @AUTOHEADER@
-
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
 INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
-transform = @program_transform_name@
-
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
 NORMAL_INSTALL = :
 PRE_INSTALL = :
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
+LIBOBJDIR =
+subdir = .
+DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
+	$(top_srcdir)/configure $(am__configure_deps) \
+	$(srcdir)/../../mkinstalldirs $(noinst_HEADERS)
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
+ configure.lineno configure.status.lineno
+mkinstalldirs = $(SHELL) $(top_srcdir)/../../mkinstalldirs
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libangsd_a_AR = $(AR) $(ARFLAGS)
+libangsd_a_LIBADD =
+am_libangsd_a_OBJECTS = ardi.$(OBJEXT) angel_bytesex.$(OBJEXT) \
+	crc.$(OBJEXT) devsw.$(OBJEXT) drivers.$(OBJEXT) \
+	etherdrv.$(OBJEXT) hostchan.$(OBJEXT) hsys.$(OBJEXT) \
+	logging.$(OBJEXT) msgbuild.$(OBJEXT) params.$(OBJEXT) \
+	rx.$(OBJEXT) serdrv.$(OBJEXT) serpardr.$(OBJEXT) tx.$(OBJEXT) \
+	unixcomm.$(OBJEXT)
+libangsd_a_OBJECTS = $(am_libangsd_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir)
+depcomp =
+am__depfiles_maybe =
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libangsd_a_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
 CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
 MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
 MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
 VERSION = @VERSION@
-
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build_alias = @build_alias@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
+host_alias = @host_alias@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
 AUTOMAKE_OPTIONS = cygnus
-
 noinst_LIBRARIES = libangsd.a
-
 libangsd_a_SOURCES = ardi.c angel_bytesex.c crc.c devsw.c drivers.c etherdrv.c \
                      hostchan.c hsys.c logging.c msgbuild.c params.c rx.c \
                      serdrv.c serpardr.c tx.c unixcomm.c
@@ -81,215 +160,200 @@ noinst_HEADERS = adp.h adperr.h angel.h 
                  msgbuild.h params.h rxtx.h sys.h unixcomm.h angel_bytesex.h
 
 EXTRA_DIST = README.CYGNUS
-
-INCLUDES =  -DRETRANS -DARM_RELEASE='"Berkeley Licence for Cygnus"'
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-mkinstalldirs = $(SHELL) $(top_srcdir)/../../mkinstalldirs
-CONFIG_CLEAN_FILES = 
-LIBRARIES =  $(noinst_LIBRARIES)
-
-
-DEFS = @DEFS@ -I. -I$(srcdir) 
-CPPFLAGS = @CPPFLAGS@
-LDFLAGS = @LDFLAGS@
-LIBS = @LIBS@
-libangsd_a_LIBADD = 
-libangsd_a_OBJECTS =  ardi.o angel_bytesex.o crc.o devsw.o drivers.o \
-etherdrv.o hostchan.o hsys.o logging.o msgbuild.o params.o rx.o \
-serdrv.o serpardr.o tx.o unixcomm.o
-AR = ar
-CFLAGS = @CFLAGS@
-COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-LINK = $(CC) $(AM_CFLAGS) $(CFLAGS) $(LDFLAGS) -o $@
-HEADERS =  $(noinst_HEADERS)
-
-DIST_COMMON =  Makefile.am Makefile.in aclocal.m4 configure configure.in
-
-
-DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)
-
-TAR = tar
-GZIP = --best
-SOURCES = $(libangsd_a_SOURCES)
-OBJECTS = $(libangsd_a_OBJECTS)
-
-all: Makefile $(LIBRARIES) $(HEADERS)
+INCLUDES = -DRETRANS -DARM_RELEASE='"Berkeley Licence for Cygnus"'
+all: all-am
 
 .SUFFIXES:
-.SUFFIXES: .S .c .o .s
-$(srcdir)/Makefile.in: @MAINT@Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4)
-	cd $(top_srcdir) && $(AUTOMAKE) --cygnus Makefile
-
-Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) \
-	  && CONFIG_FILES=$@ CONFIG_HEADERS= $(SHELL) ./config.status
-
-$(ACLOCAL_M4): @MAINT@ configure.in 
-	cd $(srcdir) && $(ACLOCAL)
+.SUFFIXES: .c .o .obj
+am--refresh:
+	@:
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign '; \
+	      cd $(srcdir) && $(AUTOMAKE) --foreign  \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    echo ' $(SHELL) ./config.status'; \
+	    $(SHELL) ./config.status;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \
+	esac;
 
-config.status: $(srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
 	$(SHELL) ./config.status --recheck
-$(srcdir)/configure: @MAINT@$(srcdir)/configure.in $(ACLOCAL_M4) $(CONFIGURE_DEPENDENCIES)
-	cd $(srcdir) && $(AUTOCONF)
 
-mostlyclean-noinstLIBRARIES:
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(srcdir) && $(AUTOCONF)
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+libangsd.a: $(libangsd_a_OBJECTS) $(libangsd_a_DEPENDENCIES) 
+	-rm -f libangsd.a
+	$(libangsd_a_AR) libangsd.a $(libangsd_a_OBJECTS) $(libangsd_a_LIBADD)
+	$(RANLIB) libangsd.a
 
-distclean-noinstLIBRARIES:
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
 
-maintainer-clean-noinstLIBRARIES:
+distclean-compile:
+	-rm -f *.tab.c
 
 .c.o:
 	$(COMPILE) -c $<
 
-.s.o:
-	$(COMPILE) -c $<
+.c.obj:
+	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+uninstall-info-am:
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
 
-.S.o:
-	$(COMPILE) -c $<
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
 
-mostlyclean-compile:
-	-rm -f *.o core *.core
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+check-am:
+check: check-am
+all-am: Makefile $(LIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
 
-clean-compile:
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
 
-distclean-compile:
-	-rm -f *.tab.c
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
 
-maintainer-clean-compile:
+clean-generic:
 
-libangsd.a: $(libangsd_a_OBJECTS) $(libangsd_a_DEPENDENCIES)
-	-rm -f libangsd.a
-	$(AR) cru libangsd.a $(libangsd_a_OBJECTS) $(libangsd_a_LIBADD)
-	$(RANLIB) libangsd.a
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 
-tags: TAGS
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
 
-ID: $(HEADERS) $(SOURCES) $(LISP)
-	here=`pwd` && cd $(srcdir) \
-	  && mkid -f$$here/ID $(SOURCES) $(HEADERS) $(LISP)
+clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) $(LISP)
-	tags=; \
-	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)'; \
-	unique=`for i in $$list; do echo $$i; done | \
-	  awk '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
-	test -z "$(ETAGS_ARGS)$$unique$(LISP)$$tags" \
-	  || (cd $(srcdir) && etags $(ETAGS_ARGS) $$tags  $$unique $(LISP) -o $$here/TAGS)
+distclean: distclean-am
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
-mostlyclean-tags:
+dvi: dvi-am
 
-clean-tags:
+dvi-am:
 
-distclean-tags:
-	-rm -f TAGS ID
+html: html-am
 
-maintainer-clean-tags:
+info: info-am
 
-distdir = $(PACKAGE)-$(VERSION)
-top_distdir = $(distdir)
+info-am:
 
-# This target untars the dist file and tries a VPATH configuration.  Then
-# it guarantees that the distribution is self-contained by making another
-# tarfile.
-distcheck: dist
-	-rm -rf $(distdir)
-	GZIP=$(GZIP) $(TAR) zxf $(distdir).tar.gz
-	mkdir $(distdir)/=build
-	mkdir $(distdir)/=inst
-	dc_install_base=`cd $(distdir)/=inst && pwd`; \
-	cd $(distdir)/=build \
-	  && ../configure --srcdir=.. --prefix=$$dc_install_base \
-	  && $(MAKE) $(AM_MAKEFLAGS) \
-	  && $(MAKE) $(AM_MAKEFLAGS) dvi \
-	  && $(MAKE) $(AM_MAKEFLAGS) check \
-	  && $(MAKE) $(AM_MAKEFLAGS) install \
-	  && $(MAKE) $(AM_MAKEFLAGS) installcheck \
-	  && $(MAKE) $(AM_MAKEFLAGS) dist
-	-rm -rf $(distdir)
-	@echo "========================"; \
-	echo "$(distdir).tar.gz is ready for distribution"; \
-	echo "========================"
-dist: distdir
-	-chmod -R a+r $(distdir)
-	GZIP=$(GZIP) $(TAR) chozf $(distdir).tar.gz $(distdir)
-	-rm -rf $(distdir)
-dist-all: distdir
-	-chmod -R a+r $(distdir)
-	GZIP=$(GZIP) $(TAR) chozf $(distdir).tar.gz $(distdir)
-	-rm -rf $(distdir)
-distdir: $(DISTFILES)
-	-rm -rf $(distdir)
-	mkdir $(distdir)
-	-chmod 777 $(distdir)
-	@for file in $(DISTFILES); do \
-	  if test -f $$file; then d=.; else d=$(srcdir); fi; \
-	  test -f $(distdir)/$$file \
-	  || ln $$d/$$file $(distdir)/$$file 2> /dev/null \
-	  || cp -p $$d/$$file $(distdir)/$$file; \
-	done
-info:
-dvi:
-check:
-html:
-install-html:
-installcheck:
-install-info:
-install-exec: 
-	@$(NORMAL_INSTALL)
+install-data-am:
 
-install-data: 
-	@$(NORMAL_INSTALL)
+install-exec-am:
 
-install: install-exec install-data all
-	@:
+install-info: install-info-am
 
-uninstall: 
+install-man:
 
-install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' INSTALL_SCRIPT='$(INSTALL_PROGRAM)' install
-installdirs:
+installcheck-am:
 
+maintainer-clean: maintainer-clean-am
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf $(top_srcdir)/autom4te.cache
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
 
-mostlyclean-generic:
+mostlyclean: mostlyclean-am
 
-clean-generic:
+mostlyclean-am: mostlyclean-compile mostlyclean-generic
 
-distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
-	-rm -f config.cache config.log stamp-h stamp-h[0-9]*
+pdf: pdf-am
 
-maintainer-clean-generic:
-mostlyclean:  mostlyclean-noinstLIBRARIES mostlyclean-compile \
-		mostlyclean-tags mostlyclean-generic
+pdf-am:
 
-clean:  clean-noinstLIBRARIES clean-compile clean-tags clean-generic \
-		mostlyclean
+ps: ps-am
 
-distclean:  distclean-noinstLIBRARIES distclean-compile distclean-tags \
-		distclean-generic clean
-	-rm -f config.status
-
-maintainer-clean:  maintainer-clean-noinstLIBRARIES \
-		maintainer-clean-compile maintainer-clean-tags \
-		maintainer-clean-generic distclean
-	@echo "This command is intended for maintainers to use;"
-	@echo "it deletes files that may require special tools to rebuild."
-	-rm -f config.status
+ps-am:
 
-.PHONY: mostlyclean-noinstLIBRARIES distclean-noinstLIBRARIES \
-clean-noinstLIBRARIES maintainer-clean-noinstLIBRARIES \
-mostlyclean-compile distclean-compile clean-compile \
-maintainer-clean-compile tags mostlyclean-tags distclean-tags \
-clean-tags maintainer-clean-tags distdir info dvi installcheck \
-install-info install-exec install-data install uninstall all \
-installdirs mostlyclean-generic distclean-generic clean-generic \
-maintainer-clean-generic clean mostlyclean distclean maintainer-clean
+uninstall-am:
 
+.PHONY: CTAGS GTAGS all all-am am--refresh check check-am clean \
+	clean-generic clean-noinstLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-tags dvi dvi-am \
+	html html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
Index: gdb/rdi-share/aclocal.m4
===================================================================
RCS file: /home/prj/asip/cvs/gdb/gdb/rdi-share/aclocal.m4,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- gdb/rdi-share/aclocal.m4	31 Jul 2007 11:40:26 -0000	1.1.1.1
+++ gdb/rdi-share/aclocal.m4	8 Aug 2007 08:49:54 -0000	1.2
@@ -1,7 +1,7 @@
-# generated automatically by aclocal 1.9.3 -*- Autoconf -*-
+# generated automatically by aclocal 1.9.6 -*- Autoconf -*-
 
-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
-# Free Software Foundation, Inc.
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
+# 2005  Free Software Foundation, Inc.
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -11,23 +11,11 @@
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
-#                                                        -*- Autoconf -*-
-# Copyright (C) 2002, 2003  Free Software Foundation, Inc.
-# Generated from amversion.in; do not edit by hand.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+# Copyright (C) 2002, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
 # AM_AUTOMAKE_VERSION(VERSION)
 # ----------------------------
@@ -40,26 +28,15 @@ AC_DEFUN([AM_AUTOMAKE_VERSION], [am__api
 # Call AM_AUTOMAKE_VERSION so it can be traced.
 # This function is AC_REQUIREd by AC_INIT_AUTOMAKE.
 AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-	 [AM_AUTOMAKE_VERSION([1.9.3])])
-
-# AM_AUX_DIR_EXPAND
+	 [AM_AUTOMAKE_VERSION([1.9.6])])
 
-# Copyright (C) 2001, 2003 Free Software Foundation, Inc.
+# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
 
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
 # For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets
 # $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to
@@ -106,26 +83,16 @@ AC_PREREQ([2.50])dnl
 am_aux_dir=`cd $ac_aux_dir && pwd`
 ])
 
-# AM_CONDITIONAL                                              -*- Autoconf -*-
-
-# Copyright (C) 1997, 2000, 2001, 2003, 2004 Free Software Foundation, Inc.
+# AM_CONDITIONAL                                            -*- Autoconf -*-
 
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# serial 6
+# serial 7
 
 # AM_CONDITIONAL(NAME, SHELL-CONDITION)
 # -------------------------------------
@@ -149,26 +116,15 @@ AC_CONFIG_COMMANDS_PRE(
 Usually this means the macro was only invoked conditionally.]])
 fi])])
 
-# serial 7						-*- Autoconf -*-
 
-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005
 # Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
-
+# serial 8
 
 # There are a few dirty hacks below to avoid letting `AC_PROG_CC' be
 # written in clear, in which case automake, when reading aclocal.m4,
@@ -177,7 +133,6 @@ fi])])
 # CC etc. in the Makefile, will ask for an AC_PROG_CC use...
 
 
-
 # _AM_DEPENDENCIES(NAME)
 # ----------------------
 # See how the compiler implements dependency checking.
@@ -317,27 +272,16 @@ AM_CONDITIONAL([AMDEP], [test "x$enable_
 AC_SUBST([AMDEPBACKSLASH])
 ])
 
-# Generate code to set up dependency tracking.   -*- Autoconf -*-
-
-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004
-#   Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
+# Generate code to set up dependency tracking.              -*- Autoconf -*-
 
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-#serial 2
+#serial 3
 
 # _AM_OUTPUT_DEPENDENCY_COMMANDS
 # ------------------------------
@@ -396,30 +340,19 @@ AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS]
      [AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"])
 ])
 
-# Do all the work for Automake.                            -*- Autoconf -*-
+# Do all the work for Automake.                             -*- Autoconf -*-
 
-# This macro actually does too much some checks are only needed if
-# your package does certain things.  But this isn't really a big deal.
-
-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
 # Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# serial 12
 
-# serial 11
+# This macro actually does too much.  Some checks are only needed if
+# your package does certain things.  But this isn't really a big deal.
 
 # AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])
 # AM_INIT_AUTOMAKE([OPTIONS])
@@ -521,51 +454,27 @@ for _am_header in $config_headers :; do
 done
 echo "timestamp for $1" >`AS_DIRNAME([$1])`/stamp-h[]$_am_stamp_count])
 
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
 # AM_PROG_INSTALL_SH
 # ------------------
 # Define $install_sh.
-
-# Copyright (C) 2001, 2003 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
-
 AC_DEFUN([AM_PROG_INSTALL_SH],
 [AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
 install_sh=${install_sh-"$am_aux_dir/install-sh"}
 AC_SUBST(install_sh)])
 
-#                                                          -*- Autoconf -*-
-# Copyright (C) 2003  Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# serial 1
+# serial 2
 
 # Check whether the underlying file-system supports filenames
 # with a leading dot.  For instance MS-DOS doesn't.
@@ -580,28 +489,17 @@ fi
 rmdir .tst 2>/dev/null
 AC_SUBST([am__leading_dot])])
 
-# Add --enable-maintainer-mode option to configure.
+# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-
 # From Jim Meyering
 
-# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004
+# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005
 # Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
-
-# serial 3
+# serial 4
 
 AC_DEFUN([AM_MAINTAINER_MODE],
 [AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])
@@ -620,26 +518,15 @@ AC_DEFUN([AM_MAINTAINER_MODE],
 
 AU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])
 
-# Check to see how 'make' treats includes.	-*- Autoconf -*-
-
-# Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
+# Check to see how 'make' treats includes.	            -*- Autoconf -*-
 
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 2001, 2002, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# serial 2
+# serial 3
 
 # AM_MAKE_INCLUDE()
 # -----------------
@@ -683,27 +570,16 @@ AC_MSG_RESULT([$_am_result])
 rm -f confinc confmf
 ])
 
-#  -*- Autoconf -*-
-
-
-# Copyright (C) 1997, 1999, 2000, 2001, 2003 Free Software Foundation, Inc.
+# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
 
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# serial 3
+# serial 4
 
 # AM_MISSING_PROG(NAME, PROGRAM)
 # ------------------------------
@@ -729,27 +605,16 @@ else
 fi
 ])
 
+# Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
 # AM_PROG_MKDIR_P
 # ---------------
 # Check whether `mkdir -p' is supported, fallback to mkinstalldirs otherwise.
-
-# Copyright (C) 2003, 2004 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
-
+#
 # Automake 1.8 used `mkdir -m 0755 -p --' to ensure that directories
 # created by `make install' are always world readable, even if the
 # installer happens to have an overly restrictive umask (e.g. 077).
@@ -803,26 +668,13 @@ else
 fi
 AC_SUBST([mkdir_p])])
 
-# Helper functions for option handling.                    -*- Autoconf -*-
-
-# Copyright (C) 2002, 2003  Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 2002, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# serial 1
+# serial 2
 
 # Obsolete Automake macros.
 
@@ -853,26 +705,15 @@ AU_DEFUN([md_TYPE_PTRDIFF_T],    [AC_CHE
 # AC_FEATURE_EXIT
 # AC_SYSTEM_HEADER
 
-# Helper functions for option handling.                    -*- Autoconf -*-
-
-# Copyright (C) 2001, 2002, 2003  Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
+# Helper functions for option handling.                     -*- Autoconf -*-
 
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 2001, 2002, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# serial 2
+# serial 3
 
 # _AM_MANGLE_OPTION(NAME)
 # -----------------------
@@ -897,28 +738,16 @@ AC_DEFUN([_AM_SET_OPTIONS],
 AC_DEFUN([_AM_IF_OPTION],
 [m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])
 
-#
-# Check to make sure that the build environment is sane.
-#
-
-# Copyright (C) 1996, 1997, 2000, 2001, 2003 Free Software Foundation, Inc.
+# Check to make sure that the build environment is sane.    -*- Autoconf -*-
 
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# serial 3
+# serial 4
 
 # AM_SANITY_CHECK
 # ---------------
@@ -961,25 +790,14 @@ Check your system clock])
 fi
 AC_MSG_RESULT(yes)])
 
-# AM_PROG_INSTALL_STRIP
-
-# Copyright (C) 2001, 2003 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
+# AM_PROG_INSTALL_STRIP
+# ---------------------
 # One issue with vendor `install' (even GNU) is that you can't
 # specify the program used to strip binaries.  This is especially
 # annoying in cross-compiling environments, where the build's strip
@@ -1002,25 +820,13 @@ AC_SUBST([INSTALL_STRIP_PROGRAM])])
 
 # Check how to create a tarball.                            -*- Autoconf -*-
 
-# Copyright (C) 2004  Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
-
-# serial 1
+# Copyright (C) 2004, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
+# serial 2
 
 # _AM_PROG_TAR(FORMAT)
 # --------------------
Index: gdb/rdi-share/configure
===================================================================
RCS file: /home/prj/asip/cvs/gdb/gdb/rdi-share/configure,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- gdb/rdi-share/configure	31 Jul 2007 11:40:26 -0000	1.1.1.1
+++ gdb/rdi-share/configure	8 Aug 2007 08:49:54 -0000	1.2
@@ -4485,9 +4485,10 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   # 1. Remove the extension, and $U if already installed.
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
-  # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
-  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
 
Index: gdb/regformats/reg-brownie32.dat
===================================================================
RCS file: gdb/regformats/reg-brownie32.dat
diff -N gdb/regformats/reg-brownie32.dat
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/regformats/reg-brownie32.dat	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,112 @@
+name:brownie32
+expedite:pc,sp
+32:zero
+32:at
+32:v0
+32:v1
+
+32:a0
+32:a1
+32:a2
+32:a3
+
+32:t0
+32:t1
+32:t2
+32:t3
+
+32:t4
+32:t5
+32:t6
+32:t7
+
+32:s0
+32:s1
+32:s2
+32:s3
+
+32:s4
+32:s5
+32:s6
+32:s7
+
+32:t8
+32:t9
+32:k0
+32:k1
+
+32:gp
+32:sp
+32:s8
+32:ra
+
+32:sr
+32:lo
+32:hi
+32:bad
+
+32:cause
+32:pc
+
+32:f0
+32:f1
+32:f2
+32:f3
+
+32:f4
+32:f5
+32:f6
+32:f7
+
+32:f8
+32:f9
+32:f10
+32:f11
+
+32:f12
+32:f13
+32:f14
+32:f15
+
+32:f16
+32:f17
+32:f18
+32:f19
+
+32:f20
+32:f21
+32:f22
+32:f23
+
+32:f24
+32:f25
+32:f26
+32:f27
+
+32:f28
+32:f29
+32:f30
+32:f31
+
+32:fsr
+32:fir
+
+32:fp
+32:
+
+32:
+32:
+32:
+32:
+32:
+32:
+32:
+32:
+32:
+32:
+32:
+32:
+32:
+32:
+32:
+32:
Index: gdb/testsuite/configure
===================================================================
RCS file: /home/prj/asip/cvs/gdb/gdb/testsuite/configure,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- gdb/testsuite/configure	31 Jul 2007 11:40:23 -0000	1.1.1.1
+++ gdb/testsuite/configure	8 Aug 2007 08:49:54 -0000	1.2
@@ -956,7 +956,7 @@ esac
     else
       echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
     fi
-    cd "$ac_popdir"
+    cd $ac_popdir
   done
 fi
 
@@ -2080,7 +2080,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2138,7 +2139,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2254,7 +2256,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2308,7 +2311,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2353,7 +2357,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2397,7 +2402,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2720,7 +2726,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2890,7 +2897,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2957,7 +2965,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3189,9 +3198,10 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   # 1. Remove the extension, and $U if already installed.
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
-  # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
-  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
 
@@ -3911,6 +3921,11 @@ esac
 
 
 
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
   # Let's still pretend it is `configure' which instantiates (i.e., don't
   # use $as_me), people would be surprised to read:
   #    /* config.h.  Generated by config.status.  */
@@ -3949,12 +3964,6 @@ echo "$as_me: error: cannot find input f
 	 fi;;
       esac
     done` || { (exit 1); exit 1; }
-
-  if test x"$ac_file" != x-; then
-    { echo "$as_me:$LINENO: creating $ac_file" >&5
-echo "$as_me: creating $ac_file" >&6;}
-    rm -f "$ac_file"
-  fi
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF
   sed "$ac_vpsub
@@ -4186,7 +4195,7 @@ echo "$as_me: error: $ac_sub_configure f
    { (exit 1); exit 1; }; }
     fi
 
-    cd "$ac_popdir"
+    cd $ac_popdir
   done
 fi
 
Index: gdb/testsuite/config/brownie32-idt.exp
===================================================================
RCS file: gdb/testsuite/config/brownie32-idt.exp
diff -N gdb/testsuite/config/brownie32-idt.exp
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/testsuite/config/brownie32-idt.exp	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,18 @@
+#   Copyright (C) 1993, 1997 Free Software Foundation, Inc.
+#   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+load_lib ../config/monitor.exp
Index: gdb/testsuite/config/brownie32.exp
===================================================================
RCS file: gdb/testsuite/config/brownie32.exp
diff -N gdb/testsuite/config/brownie32.exp
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/testsuite/config/brownie32.exp	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,18 @@
+#   Copyright (C) 1993, 1997 Free Software Foundation, Inc.
+#   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+load_lib ../config/monitor.exp
Index: gdb/testsuite/gdb.asm/asm-source.exp
===================================================================
RCS file: /home/prj/asip/cvs/gdb/gdb/testsuite/gdb.asm/asm-source.exp,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- gdb/testsuite/gdb.asm/asm-source.exp	31 Jul 2007 11:40:23 -0000	1.1.1.1
+++ gdb/testsuite/gdb.asm/asm-source.exp	21 Jan 2008 01:43:06 -0000	1.2
@@ -51,6 +51,9 @@ switch -glob -- [istarget] {
     "xscale-*-*" {
         set asm-arch arm
     }
+    "brownie32-*-*" {
+        set asm-arch brownie32
+    }
     "d10v-*-*" {
         set asm-arch d10v
     }
Index: gdb/testsuite/gdb.asm/brownie32.inc
===================================================================
RCS file: gdb/testsuite/gdb.asm/brownie32.inc
diff -N gdb/testsuite/gdb.asm/brownie32.inc
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/testsuite/gdb.asm/brownie32.inc	11 Feb 2008 15:44:46 -0000	1.3
@@ -0,0 +1,57 @@
+#define FP r4
+#define SP r5
+	comment "subroutine declare"
+	.purgem gdbasm_declare
+	.macro gdbasm_declare name
+	.align	2
+	.globl	\name
+	.type	\name,@function
+\name:
+	.endm
+
+	comment "subroutine prologue"
+	.macro gdbasm_enter
+	sw	-4(SP),r3
+	sw	-8(SP),r5
+	addi	FP, SP, #-8
+	addi	SP, SP, #-16
+	.endm
+
+	comment "subroutine epilogue"
+	.macro gdbasm_leave
+	lw	r3, 4(FP)
+	addi	SP, FP, #8
+	lw	FP, (FP)
+	jpr	r3
+	.endm
+
+	comment "subroutine end"
+	.purgem gdbasm_end
+	.macro gdbasm_end name
+	.size	\name,.-\name
+	.endm
+
+	.macro gdbasm_call subr
+	jpl	\subr
+	.endm
+
+	.macro gdbasm_several_nops
+	nop
+	nop
+	nop
+	nop
+	.endm
+
+	comment "exit (0)"
+	.macro gdbasm_exit0
+	comment "Don't know how to exit, but this will certainly halt..."
+	trap 0
+	.endm
+
+	comment "crt0 startup"
+	.macro gdbasm_startup
+	addi	SP,r0,#0x2000
+	lsoi	SP,SP,#0x2000
+	addi	SP,SP,#-4
+	sw	(SP),r3
+	.endm
Index: gdb/testsuite/gdb.base/brownie32_pro.c
===================================================================
RCS file: gdb/testsuite/gdb.base/brownie32_pro.c
diff -N gdb/testsuite/gdb.base/brownie32_pro.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/testsuite/gdb.base/brownie32_pro.c	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,57 @@
+/* Tests regarding examination of prologues.  */
+
+#ifdef PROTOTYPES
+int
+inner (int z)
+#else
+int
+inner (z)
+     int z;
+#endif
+{
+  return 2 * z;
+}
+
+#ifdef PROTOTYPES
+int
+middle (int x)
+#else
+int
+middle (x)
+     int x;
+#endif
+{
+  if (x == 0)
+    return inner (5);
+  else
+    return inner (6);
+}
+
+#ifdef PROTOTYPES
+int
+top (int y)
+#else
+int
+top (y)
+     int y;
+#endif
+{
+  return middle (y + 1);
+}
+
+#ifdef PROTOTYPES
+int
+main (int argc, char **argv)
+#else
+int
+main (argc, argv)
+     int argc;
+     char **argv;
+#endif
+{
+#ifdef usestubs
+  set_debug_traps();
+  breakpoint();
+#endif
+  return top (-1) + top (1);
+}
Index: gdb/testsuite/gdb.base/brownie32_pro.exp
===================================================================
RCS file: gdb/testsuite/gdb.base/brownie32_pro.exp
diff -N gdb/testsuite/gdb.base/brownie32_pro.exp
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ gdb/testsuite/gdb.base/brownie32_pro.exp	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,67 @@
+# Copyright 1997, 1999, 2000, 2001, 2003 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gdb@prep.ai.mit.edu
+
+if $tracelevel then {
+	strace $tracelevel
+}
+
+set prms_id 0
+set bug_id 0
+
+set testfile brownie32_pro
+set srcfile ${testfile}.c
+set binfile ${objdir}/${subdir}/${testfile}
+
+# Create and source the file that provides information about the compiler
+# used to compile the test case.
+if [get_compiler_info ${binfile}] {
+    return -1;
+}
+
+
+# This test must be compiled with -O2 if using gcc.
+
+if { [test_compiler_info gcc-*-*] } then {
+    if  { [gdb_compile "${srcdir}/$subdir/${srcfile}" "${binfile}" executable {debug additional_flags=-O2}] != "" } {
+     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
+    }
+} else {
+    if  { [gdb_compile "${srcdir}/$subdir/${srcfile}" "${binfile}" executable {debug}] != "" } {
+     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
+    }
+}
+
+gdb_exit
+gdb_start
+gdb_reinitialize_dir $srcdir/$subdir
+gdb_load ${binfile}
+
+if [runto middle] then {
+    # PR 3016
+    #   warning: Hit heuristic-fence-post without finding
+    #   warning: enclosing function for pc 0x1006ead0
+    if { [test_compiler_info gcc-*-*] } then {
+	setup_xfail "brownie32*-sgi-irix4*" "brownie3264*-*-elf"
+    }
+    # The call chain is main -> top -> middle.  But gcc can optimize a tail
+    # call to a jump, so the stack may contain either main -> top -> middle
+    # or main -> middle.
+    gdb_test "backtrace" "#0.*middle.*#\[12\].*main.*"
+}
+return 0
Index: gdb/testsuite/gdb.hp/configure
===================================================================
RCS file: /home/prj/asip/cvs/gdb/gdb/testsuite/gdb.hp/configure,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- gdb/testsuite/gdb.hp/configure	31 Jul 2007 11:40:24 -0000	1.1.1.1
+++ gdb/testsuite/gdb.hp/configure	8 Aug 2007 08:49:54 -0000	1.2
@@ -1451,9 +1451,10 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   # 1. Remove the extension, and $U if already installed.
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
-  # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
-  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
 
Index: gdb/testsuite/gdb.hp/gdb.aCC/configure
===================================================================
RCS file: /home/prj/asip/cvs/gdb/gdb/testsuite/gdb.hp/gdb.aCC/configure,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- gdb/testsuite/gdb.hp/gdb.aCC/configure	31 Jul 2007 11:40:24 -0000	1.1.1.1
+++ gdb/testsuite/gdb.hp/gdb.aCC/configure	8 Aug 2007 08:49:54 -0000	1.2
@@ -1445,9 +1445,10 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   # 1. Remove the extension, and $U if already installed.
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
-  # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
-  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
 
Index: gdb/testsuite/gdb.hp/gdb.base-hp/configure
===================================================================
RCS file: /home/prj/asip/cvs/gdb/gdb/testsuite/gdb.hp/gdb.base-hp/configure,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- gdb/testsuite/gdb.hp/gdb.base-hp/configure	31 Jul 2007 11:40:24 -0000	1.1.1.1
+++ gdb/testsuite/gdb.hp/gdb.base-hp/configure	8 Aug 2007 08:49:54 -0000	1.2
@@ -1445,9 +1445,10 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   # 1. Remove the extension, and $U if already installed.
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
-  # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
-  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
 
Index: gdb/testsuite/gdb.hp/gdb.compat/configure
===================================================================
RCS file: /home/prj/asip/cvs/gdb/gdb/testsuite/gdb.hp/gdb.compat/configure,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- gdb/testsuite/gdb.hp/gdb.compat/configure	31 Jul 2007 11:40:24 -0000	1.1.1.1
+++ gdb/testsuite/gdb.hp/gdb.compat/configure	8 Aug 2007 08:49:54 -0000	1.2
@@ -1445,9 +1445,10 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   # 1. Remove the extension, and $U if already installed.
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
-  # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
-  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
 
Index: gdb/testsuite/gdb.hp/gdb.defects/configure
===================================================================
RCS file: /home/prj/asip/cvs/gdb/gdb/testsuite/gdb.hp/gdb.defects/configure,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- gdb/testsuite/gdb.hp/gdb.defects/configure	31 Jul 2007 11:40:24 -0000	1.1.1.1
+++ gdb/testsuite/gdb.hp/gdb.defects/configure	8 Aug 2007 08:49:54 -0000	1.2
@@ -1445,9 +1445,10 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   # 1. Remove the extension, and $U if already installed.
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
-  # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
-  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
 
Index: gdb/testsuite/gdb.hp/gdb.objdbg/configure
===================================================================
RCS file: /home/prj/asip/cvs/gdb/gdb/testsuite/gdb.hp/gdb.objdbg/configure,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- gdb/testsuite/gdb.hp/gdb.objdbg/configure	31 Jul 2007 11:40:24 -0000	1.1.1.1
+++ gdb/testsuite/gdb.hp/gdb.objdbg/configure	8 Aug 2007 08:49:54 -0000	1.2
@@ -1450,9 +1450,10 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   # 1. Remove the extension, and $U if already installed.
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
-  # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
-  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
 
Index: gdb/testsuite/gdb.stabs/configure
===================================================================
RCS file: /home/prj/asip/cvs/gdb/gdb/testsuite/gdb.stabs/configure,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- gdb/testsuite/gdb.stabs/configure	31 Jul 2007 11:40:24 -0000	1.1.1.1
+++ gdb/testsuite/gdb.stabs/configure	8 Aug 2007 08:49:54 -0000	1.2
@@ -1445,9 +1445,10 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   # 1. Remove the extension, and $U if already installed.
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
-  # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
-  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
 
Index: include/dis-asm.h
===================================================================
RCS file: /home/prj/asip/cvs/gdb/include/dis-asm.h,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- include/dis-asm.h	31 Jul 2007 11:40:26 -0000	1.1.1.1
+++ include/dis-asm.h	8 Aug 2007 08:49:54 -0000	1.2
@@ -3,6 +3,8 @@
    Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005
    Free Software Foundation, Inc.
    
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2, or (at your option)
@@ -200,6 +202,8 @@ typedef int (*disassembler_ftype) (bfd_v
 
 extern int print_insn_big_mips		(bfd_vma, disassemble_info *);
 extern int print_insn_little_mips	(bfd_vma, disassemble_info *);
+extern int print_insn_big_brownie32		(bfd_vma, disassemble_info *);
+extern int print_insn_little_brownie32	(bfd_vma, disassemble_info *);
 extern int print_insn_i386		(bfd_vma, disassemble_info *);
 extern int print_insn_i386_att		(bfd_vma, disassemble_info *);
 extern int print_insn_i386_intel	(bfd_vma, disassemble_info *);
@@ -270,6 +274,7 @@ extern disassembler_ftype arc_get_disass
 extern disassembler_ftype cris_get_disassembler (bfd *);
 
 extern void print_mips_disassembler_options (FILE *);
+extern void print_brownie32_disassembler_options (FILE *);
 extern void print_ppc_disassembler_options (FILE *);
 extern void print_arm_disassembler_options (FILE *);
 extern void parse_arm_disassembler_option (char *);
Index: include/coff/brownie32.h
===================================================================
RCS file: include/coff/brownie32.h
diff -N include/coff/brownie32.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ include/coff/brownie32.h	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,345 @@
+/* ECOFF support on BROWNIE32 machines.
+   coff/ecoff.h must be included before this file.
+   
+   Copyright 1999, 2004 Free Software Foundation, Inc.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#define DO_NOT_DEFINE_AOUTHDR
+#define L_LNNO_SIZE 4
+#include "coff/external.h"
+
+/* Magic numbers are defined in coff/ecoff.h.  */
+#define BROWNIE32_ECOFF_BADMAG(x) (((x).f_magic!=BROWNIE32_MAGIC_1) && \
+			      ((x).f_magic!=BROWNIE32_MAGIC_LITTLE) &&\
+			      ((x).f_magic!=BROWNIE32_MAGIC_BIG) && \
+			      ((x).f_magic!=BROWNIE32_MAGIC_LITTLE2) && \
+			      ((x).f_magic!=BROWNIE32_MAGIC_BIG2) && \
+			      ((x).f_magic!=BROWNIE32_MAGIC_LITTLE3) && \
+			      ((x).f_magic!=BROWNIE32_MAGIC_BIG3))
+
+
+/********************** AOUT "OPTIONAL HEADER" **********************/
+
+typedef struct external_aouthdr
+{
+  unsigned char magic[2];	/* type of file				*/
+  unsigned char	vstamp[2];	/* version stamp			*/
+  unsigned char	tsize[4];	/* text size in bytes, padded to FW bdry*/
+  unsigned char	dsize[4];	/* initialized data "  "		*/
+  unsigned char	bsize[4];	/* uninitialized data "   "		*/
+  unsigned char	entry[4];	/* entry pt.				*/
+  unsigned char text_start[4];	/* base of text used for this file */
+  unsigned char data_start[4];	/* base of data used for this file */
+  unsigned char bss_start[4];	/* base of bss used for this file */
+  unsigned char gprmask[4];	/* ?? */
+  unsigned char cprmask[4][4];	/* ?? */
+  unsigned char gp_value[4];	/* value for gp register */
+} AOUTHDR;
+
+/* compute size of a header */
+
+#define AOUTSZ 56
+#define AOUTHDRSZ 56
+
+/********************** RELOCATION DIRECTIVES **********************/
+
+struct external_reloc
+  {
+    unsigned char r_vaddr[4];
+    unsigned char r_bits[4];
+  };
+
+#define RELOC struct external_reloc
+#define RELSZ 8
+
+/* BROWNIE32 ECOFF uses a packed 8 byte format for relocs.  These constants
+   are used to unpack the r_bits field.  */
+
+#define RELOC_BITS0_SYMNDX_SH_LEFT_BIG		16
+#define RELOC_BITS0_SYMNDX_SH_LEFT_LITTLE	0
+
+#define RELOC_BITS1_SYMNDX_SH_LEFT_BIG		8
+#define RELOC_BITS1_SYMNDX_SH_LEFT_LITTLE	8
+
+#define RELOC_BITS2_SYMNDX_SH_LEFT_BIG		0
+#define RELOC_BITS2_SYMNDX_SH_LEFT_LITTLE	16
+
+/* Originally, ECOFF used four bits for the reloc type and had three
+   reserved bits.  Irix 4 added another bit for the reloc type, which
+   was easy because it was big endian and one of the spare bits became
+   the new most significant bit.  To make this also work for little
+   endian ECOFF, we need to wrap one of the reserved bits around to
+   become the most significant bit of the reloc type.  */
+#define RELOC_BITS3_TYPE_BIG			0x3E
+#define RELOC_BITS3_TYPE_SH_BIG			1
+#define RELOC_BITS3_TYPE_LITTLE			0x78
+#define RELOC_BITS3_TYPE_SH_LITTLE		3
+#define RELOC_BITS3_TYPEHI_LITTLE		0x04
+#define RELOC_BITS3_TYPEHI_SH_LITTLE		2
+
+#define RELOC_BITS3_EXTERN_BIG			0x01
+#define RELOC_BITS3_EXTERN_LITTLE		0x80
+
+/* The r_type field in a reloc is one of the following values.  I
+   don't know if any other values can appear.  These seem to be all
+   that occur in the Ultrix 4.2 libraries.  */
+#define BROWNIE32_R_IGNORE	0
+#define BROWNIE32_R_REFHALF	1
+#define BROWNIE32_R_REFWORD	2
+#define BROWNIE32_R_JMPADDR	3
+#define BROWNIE32_R_REFHI	4
+#define BROWNIE32_R_REFLO	5
+#define BROWNIE32_R_GPREL	6
+#define BROWNIE32_R_LITERAL	7
+
+/* FIXME: This relocation is used (internally only) to represent branches
+   when assembling.  It should never appear in output files, and  
+   be removed.  (It used to be used for embedded-PIC support.)  */
+#define BROWNIE32_R_PCREL16	12
+
+/********************** STABS **********************/
+
+#define BROWNIE32_IS_STAB ECOFF_IS_STAB
+#define BROWNIE32_MARK_STAB ECOFF_MARK_STAB
+#define BROWNIE32_UNMARK_STAB ECOFF_UNMARK_STAB
+
+/********************** SYMBOLIC INFORMATION **********************/
+
+/* Written by John Gilmore.  */
+
+/* ECOFF uses COFF-like section structures, but its own symbol format.
+   This file defines the symbol format in fields whose size and alignment
+   will not vary on different host systems.  */
+
+/* File header as a set of bytes */
+
+struct hdr_ext
+{
+	unsigned char 	h_magic[2];
+	unsigned char	h_vstamp[2];
+	unsigned char	h_ilineMax[4];
+	unsigned char	h_cbLine[4];
+	unsigned char	h_cbLineOffset[4];
+	unsigned char	h_idnMax[4];
+	unsigned char	h_cbDnOffset[4];
+	unsigned char	h_ipdMax[4];
+	unsigned char	h_cbPdOffset[4];
+	unsigned char	h_isymMax[4];
+	unsigned char	h_cbSymOffset[4];
+	unsigned char	h_ioptMax[4];
+	unsigned char	h_cbOptOffset[4];
+	unsigned char	h_iauxMax[4];
+	unsigned char	h_cbAuxOffset[4];
+	unsigned char	h_issMax[4];
+	unsigned char	h_cbSsOffset[4];
+	unsigned char	h_issExtMax[4];
+	unsigned char	h_cbSsExtOffset[4];
+	unsigned char	h_ifdMax[4];
+	unsigned char	h_cbFdOffset[4];
+	unsigned char	h_crfd[4];
+	unsigned char	h_cbRfdOffset[4];
+	unsigned char	h_iextMax[4];
+	unsigned char	h_cbExtOffset[4];
+};
+
+/* File descriptor external record */
+
+struct fdr_ext
+{
+	unsigned char	f_adr[4];
+	unsigned char	f_rss[4];
+	unsigned char	f_issBase[4];
+	unsigned char	f_cbSs[4];
+	unsigned char	f_isymBase[4];
+	unsigned char	f_csym[4];
+	unsigned char	f_ilineBase[4];
+	unsigned char	f_cline[4];
+	unsigned char	f_ioptBase[4];
+	unsigned char	f_copt[4];
+	unsigned char	f_ipdFirst[2];
+	unsigned char	f_cpd[2];
+	unsigned char	f_iauxBase[4];
+	unsigned char	f_caux[4];
+	unsigned char	f_rfdBase[4];
+	unsigned char	f_crfd[4];
+	unsigned char	f_bits1[1];
+	unsigned char	f_bits2[3];
+	unsigned char	f_cbLineOffset[4];
+	unsigned char	f_cbLine[4];
+};
+
+#define	FDR_BITS1_LANG_BIG		0xF8
+#define	FDR_BITS1_LANG_SH_BIG		3
+#define	FDR_BITS1_LANG_LITTLE		0x1F
+#define	FDR_BITS1_LANG_SH_LITTLE	0
+
+#define	FDR_BITS1_FMERGE_BIG		0x04
+#define	FDR_BITS1_FMERGE_LITTLE		0x20
+
+#define	FDR_BITS1_FREADIN_BIG		0x02
+#define	FDR_BITS1_FREADIN_LITTLE	0x40
+
+#define	FDR_BITS1_FBIGENDIAN_BIG	0x01
+#define	FDR_BITS1_FBIGENDIAN_LITTLE	0x80
+
+#define	FDR_BITS2_GLEVEL_BIG		0xC0
+#define	FDR_BITS2_GLEVEL_SH_BIG		6
+#define	FDR_BITS2_GLEVEL_LITTLE		0x03
+#define	FDR_BITS2_GLEVEL_SH_LITTLE	0
+
+/* We ignore the `reserved' field in bits2. */
+
+/* Procedure descriptor external record */
+
+struct pdr_ext
+{
+	unsigned char	p_adr[4];
+	unsigned char	p_isym[4];
+	unsigned char	p_iline[4];
+	unsigned char	p_regmask[4];
+	unsigned char	p_regoffset[4];
+	unsigned char	p_iopt[4];
+	unsigned char	p_fregmask[4];
+	unsigned char	p_fregoffset[4];
+	unsigned char	p_frameoffset[4];
+	unsigned char	p_framereg[2];
+	unsigned char	p_pcreg[2];
+	unsigned char	p_lnLow[4];
+	unsigned char	p_lnHigh[4];
+	unsigned char	p_cbLineOffset[4];
+};
+
+/* Runtime procedure table */
+
+struct rpdr_ext
+{
+	unsigned char	p_adr[4];
+	unsigned char	p_regmask[4];
+	unsigned char	p_regoffset[4];
+	unsigned char	p_fregmask[4];
+	unsigned char	p_fregoffset[4];
+	unsigned char	p_frameoffset[4];
+	unsigned char	p_framereg[2];
+	unsigned char	p_pcreg[2];
+	unsigned char	p_irpss[4];
+	unsigned char	p_reserved[4];
+	unsigned char	p_exception_info[4];
+};
+
+/* Line numbers */
+
+struct line_ext
+{
+	unsigned char	l_line[4];
+};
+
+/* Symbol external record */
+
+struct sym_ext
+{
+	unsigned char	s_iss[4];
+	unsigned char	s_value[4];
+	unsigned char	s_bits1[1];
+	unsigned char	s_bits2[1];
+	unsigned char	s_bits3[1];
+	unsigned char	s_bits4[1];
+};
+
+#define	SYM_BITS1_ST_BIG		0xFC
+#define	SYM_BITS1_ST_SH_BIG		2
+#define	SYM_BITS1_ST_LITTLE		0x3F
+#define	SYM_BITS1_ST_SH_LITTLE		0
+
+#define	SYM_BITS1_SC_BIG		0x03
+#define	SYM_BITS1_SC_SH_LEFT_BIG	3
+#define	SYM_BITS1_SC_LITTLE		0xC0
+#define	SYM_BITS1_SC_SH_LITTLE		6
+
+#define	SYM_BITS2_SC_BIG		0xE0
+#define	SYM_BITS2_SC_SH_BIG		5
+#define	SYM_BITS2_SC_LITTLE		0x07
+#define	SYM_BITS2_SC_SH_LEFT_LITTLE	2
+
+#define	SYM_BITS2_RESERVED_BIG		0x10
+#define	SYM_BITS2_RESERVED_LITTLE	0x08
+
+#define	SYM_BITS2_INDEX_BIG		0x0F
+#define	SYM_BITS2_INDEX_SH_LEFT_BIG	16
+#define	SYM_BITS2_INDEX_LITTLE		0xF0
+#define	SYM_BITS2_INDEX_SH_LITTLE	4
+
+#define	SYM_BITS3_INDEX_SH_LEFT_BIG	8
+#define	SYM_BITS3_INDEX_SH_LEFT_LITTLE	4
+
+#define	SYM_BITS4_INDEX_SH_LEFT_BIG	0
+#define	SYM_BITS4_INDEX_SH_LEFT_LITTLE	12
+
+/* External symbol external record */
+
+struct ext_ext
+{
+	unsigned char	es_bits1[1];
+	unsigned char	es_bits2[1];
+	unsigned char	es_ifd[2];
+	struct	sym_ext es_asym;
+};
+
+#define	EXT_BITS1_JMPTBL_BIG		0x80
+#define	EXT_BITS1_JMPTBL_LITTLE		0x01
+
+#define	EXT_BITS1_COBOL_MAIN_BIG	0x40
+#define	EXT_BITS1_COBOL_MAIN_LITTLE	0x02
+
+#define	EXT_BITS1_WEAKEXT_BIG		0x20
+#define	EXT_BITS1_WEAKEXT_LITTLE	0x04
+
+/* Dense numbers external record */
+
+struct dnr_ext
+{
+	unsigned char	d_rfd[4];
+	unsigned char	d_index[4];
+};
+
+/* Relative file descriptor */
+
+struct rfd_ext
+{
+  unsigned char	rfd[4];
+};
+
+/* Optimizer symbol external record */
+
+struct opt_ext
+{
+  unsigned char o_bits1[1];
+  unsigned char o_bits2[1];
+  unsigned char o_bits3[1];
+  unsigned char o_bits4[1];
+  struct rndx_ext o_rndx;
+  unsigned char o_offset[4];
+};
+
+#define OPT_BITS2_VALUE_SH_LEFT_BIG	16
+#define OPT_BITS2_VALUE_SH_LEFT_LITTLE	0
+
+#define OPT_BITS3_VALUE_SH_LEFT_BIG	8
+#define OPT_BITS3_VALUE_SH_LEFT_LITTLE	8
+
+#define OPT_BITS4_VALUE_SH_LEFT_BIG	0
+#define OPT_BITS4_VALUE_SH_LEFT_LITTLE	16
Index: include/coff/brownie32pe.h
===================================================================
RCS file: include/coff/brownie32pe.h
diff -N include/coff/brownie32pe.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ include/coff/brownie32pe.h	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,68 @@
+/* coff information for Windows CE with BROWNIE32 VR4111
+   
+   Copyright 2000 Free Software Foundation, Inc.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#define L_LNNO_SIZE 2
+#define INCLUDE_COMDAT_FIELDS_IN_AUXENT
+#include "coff/external.h"
+
+#define BROWNIE32_ARCH_MAGIC_WINCE	0x0166  /* Windows CE - little endian */
+#define BROWNIE32_PE_MAGIC		0x010b
+
+#define BROWNIE32BADMAG(x) ((x).f_magic != BROWNIE32_ARCH_MAGIC_WINCE)
+
+/* define some NT default values */
+/*  #define NT_IMAGE_BASE        0x400000 moved to internal.h */
+#define NT_SECTION_ALIGNMENT 0x1000
+#define NT_FILE_ALIGNMENT    0x200
+#define NT_DEF_RESERVE       0x100000
+#define NT_DEF_COMMIT        0x1000
+
+/********************** RELOCATION DIRECTIVES **********************/
+
+/* The external reloc has an offset field, because some of the reloc
+   types on the h8 don't have room in the instruction for the entire
+   offset - eg the strange jump and high page addressing modes.  */
+
+struct external_reloc
+{
+  char r_vaddr[4];
+  char r_symndx[4];
+  char r_type[2];
+};
+
+#define RELOC struct external_reloc
+#define RELSZ 10
+
+/* BROWNIE32 PE relocation types. */
+
+#define	BROWNIE32_R_ABSOLUTE	0 /* ignored */
+#define	BROWNIE32_R_REFHALF	1
+#define	BROWNIE32_R_REFWORD	2
+#define	BROWNIE32_R_JMPADDR	3
+#define	BROWNIE32_R_REFHI	4 /* PAIR follows */
+#define	BROWNIE32_R_REFLO	5
+#define	BROWNIE32_R_GPREL	6
+#define	BROWNIE32_R_LITERAL	7 /* same as GPREL */
+#define	BROWNIE32_R_SECTION	10
+#define	BROWNIE32_R_SECREL	11
+#define	BROWNIE32_R_SECRELLO	12
+#define	BROWNIE32_R_SECRELHI	13 /* PAIR follows */
+#define	BROWNIE32_R_RVA	34 /* 0x22 */
+#define	BROWNIE32_R_PAIR	37 /* 0x25 - symndx is really a signed 16-bit addend */
Index: include/elf/brownie32.h
===================================================================
RCS file: include/elf/brownie32.h
diff -N include/elf/brownie32.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ include/elf/brownie32.h	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,1000 @@
+/* BROWNIE32 ELF support for BFD.
+   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+   2003, 2004, 2005
+   Free Software Foundation, Inc.
+
+   By Ian Lance Taylor, Cygnus Support, <ian@cygnus.com>, from
+   information in the System V Application Binary Interface, BROWNIE32
+   Processor Supplement.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* This file holds definitions specific to the BROWNIE32 ELF ABI.  Note
+   that most of this is not actually implemented by BFD.  */
+
+#ifndef _ELF_BROWNIE32_H
+#define _ELF_BROWNIE32_H
+
+#include "elf/reloc-macros.h"
+
+/* Relocation types.  */
+START_RELOC_NUMBERS (elf_brownie32_reloc_type)
+  RELOC_NUMBER (R_BROWNIE32_NONE, 0)
+  RELOC_NUMBER (R_BROWNIE32_16, 1)
+  RELOC_NUMBER (R_BROWNIE32_32, 2)		/* In Elf 64: alias R_BROWNIE32_ADD */
+  RELOC_NUMBER (R_BROWNIE32_REL32, 3)	/* In Elf 64: alias R_BROWNIE32_REL */
+  RELOC_NUMBER (R_BROWNIE32_26, 4)
+  RELOC_NUMBER (R_BROWNIE32_HI16, 5)
+  RELOC_NUMBER (R_BROWNIE32_LO16, 6)
+  RELOC_NUMBER (R_BROWNIE32_GPREL16, 7)	/* In Elf 64: alias R_BROWNIE32_GPREL */
+  RELOC_NUMBER (R_BROWNIE32_LITERAL, 8)
+  RELOC_NUMBER (R_BROWNIE32_GOT16, 9)	/* In Elf 64: alias R_BROWNIE32_GOT */
+  RELOC_NUMBER (R_BROWNIE32_PC16, 10)
+  RELOC_NUMBER (R_BROWNIE32_CALL16, 11)	/* In Elf 64: alias R_BROWNIE32_CALL */
+  RELOC_NUMBER (R_BROWNIE32_GPREL32, 12)
+  /* The remaining relocs are defined on Irix, although they are not
+     in the BROWNIE32 ELF ABI.  */
+  RELOC_NUMBER (R_BROWNIE32_UNUSED1, 13)
+  RELOC_NUMBER (R_BROWNIE32_UNUSED2, 14)
+  RELOC_NUMBER (R_BROWNIE32_UNUSED3, 15)
+  RELOC_NUMBER (R_BROWNIE32_SHIFT5, 16)
+  RELOC_NUMBER (R_BROWNIE32_SHIFT6, 17)
+  RELOC_NUMBER (R_BROWNIE32_64, 18)
+  RELOC_NUMBER (R_BROWNIE32_GOT_DISP, 19)
+  RELOC_NUMBER (R_BROWNIE32_GOT_PAGE, 20)
+  RELOC_NUMBER (R_BROWNIE32_GOT_OFST, 21)
+  RELOC_NUMBER (R_BROWNIE32_GOT_HI16, 22)
+  RELOC_NUMBER (R_BROWNIE32_GOT_LO16, 23)
+  RELOC_NUMBER (R_BROWNIE32_SUB, 24)
+  RELOC_NUMBER (R_BROWNIE32_INSERT_A, 25)
+  RELOC_NUMBER (R_BROWNIE32_INSERT_B, 26)
+  RELOC_NUMBER (R_BROWNIE32_DELETE, 27)
+  RELOC_NUMBER (R_BROWNIE32_HIGHER, 28)
+  RELOC_NUMBER (R_BROWNIE32_HIGHEST, 29)
+  RELOC_NUMBER (R_BROWNIE32_CALL_HI16, 30)
+  RELOC_NUMBER (R_BROWNIE32_CALL_LO16, 31)
+  RELOC_NUMBER (R_BROWNIE32_SCN_DISP, 32)
+  RELOC_NUMBER (R_BROWNIE32_REL16, 33)
+  RELOC_NUMBER (R_BROWNIE32_ADD_IMMEDIATE, 34)
+  RELOC_NUMBER (R_BROWNIE32_PJUMP, 35)
+  RELOC_NUMBER (R_BROWNIE32_RELGOT, 36)
+  RELOC_NUMBER (R_BROWNIE32_JALR, 37)
+  /* TLS relocations.  */
+  RELOC_NUMBER (R_BROWNIE32_TLS_DTPMOD32, 38)
+  RELOC_NUMBER (R_BROWNIE32_TLS_DTPREL32, 39)
+  RELOC_NUMBER (R_BROWNIE32_TLS_DTPMOD64, 40)
+  RELOC_NUMBER (R_BROWNIE32_TLS_DTPREL64, 41)
+  RELOC_NUMBER (R_BROWNIE32_TLS_GD, 42)
+  RELOC_NUMBER (R_BROWNIE32_TLS_LDM, 43)
+  RELOC_NUMBER (R_BROWNIE32_TLS_DTPREL_HI16, 44)
+  RELOC_NUMBER (R_BROWNIE32_TLS_DTPREL_LO16, 45)
+  RELOC_NUMBER (R_BROWNIE32_TLS_GOTTPREL, 46)
+  RELOC_NUMBER (R_BROWNIE32_TLS_TPREL32, 47)
+  RELOC_NUMBER (R_BROWNIE32_TLS_TPREL64, 48)
+  RELOC_NUMBER (R_BROWNIE32_TLS_TPREL_HI16, 49)
+  RELOC_NUMBER (R_BROWNIE32_TLS_TPREL_LO16, 50)
+  FAKE_RELOC (R_BROWNIE32_max, 51)
+  /* These relocs are used for the brownie3216.  */
+  FAKE_RELOC (R_BROWNIE3216_min, 100)
+  RELOC_NUMBER (R_BROWNIE3216_26, 100)
+  RELOC_NUMBER (R_BROWNIE3216_GPREL, 101)
+  RELOC_NUMBER (R_BROWNIE3216_GOT16, 102)
+  RELOC_NUMBER (R_BROWNIE3216_CALL16, 103)
+  RELOC_NUMBER (R_BROWNIE3216_HI16, 104)
+  RELOC_NUMBER (R_BROWNIE3216_LO16, 105)
+  FAKE_RELOC (R_BROWNIE3216_max, 106)
+  /* This was a GNU extension used by embedded-PIC.  It was co-opted by
+     brownie32-linux for exception-handling data.  It is no longer used, but
+     should continue to be supported by the linker for backward
+     compatibility.  (GCC stopped using it in May, 2004.)  */
+  RELOC_NUMBER (R_BROWNIE32_PC32, 248)
+  /* FIXME: this relocation is used internally by gas.  */
+  RELOC_NUMBER (R_BROWNIE32_GNU_REL16_S2, 250)
+  /* These are GNU extensions to enable C++ vtable garbage collection.  */
+  RELOC_NUMBER (R_BROWNIE32_GNU_VTINHERIT, 253)
+  RELOC_NUMBER (R_BROWNIE32_GNU_VTENTRY, 254)
+END_RELOC_NUMBERS (R_BROWNIE32_maxext)
+
+/* Processor specific flags for the ELF header e_flags field.  */
+
+/* At least one .noreorder directive appears in the source.  */
+#define EF_BROWNIE32_NOREORDER	0x00000001
+
+/* File contains position independent code.  */
+#define EF_BROWNIE32_PIC		0x00000002
+
+/* Code in file uses the standard calling sequence for calling
+   position independent code.  */
+#define EF_BROWNIE32_CPIC		0x00000004
+
+/* ???  Unknown flag, set in IRIX 6's BSDdup2.o in libbsd.a.  */
+#define EF_BROWNIE32_XGOT		0x00000008
+
+/* Code in file uses UCODE (obsolete) */
+#define EF_BROWNIE32_UCODE		0x00000010
+
+/* Code in file uses new ABI (-n32 on Irix 6).  */
+#define EF_BROWNIE32_ABI2		0x00000020
+
+/* Process the .BROWNIE32.options section first by ld */
+#define EF_BROWNIE32_OPTIONS_FIRST	0x00000080
+
+/* Architectural Extensions used by this file */
+#define EF_BROWNIE32_ARCH_ASE	0x0f000000
+
+/* Use MDMX multimedia extensions */
+#define EF_BROWNIE32_ARCH_ASE_MDMX	0x08000000
+
+/* Use BROWNIE32-16 ISA extensions */
+#define EF_BROWNIE32_ARCH_ASE_M16	0x04000000
+
+/* Indicates code compiled for a 64-bit machine in 32-bit mode.
+   (regs are 32-bits wide.) */
+#define EF_BROWNIE32_32BITMODE       0x00000100
+
+/* Four bit BROWNIE32 architecture field.  */
+#define EF_BROWNIE32_ARCH		0xf0000000
+
+/* -brownie321 code.  */
+#define E_BROWNIE32_ARCH_1		0x00000000
+
+/* -brownie322 code.  */
+#define E_BROWNIE32_ARCH_2		0x10000000
+
+/* -brownie323 code.  */
+#define E_BROWNIE32_ARCH_3		0x20000000
+
+/* -brownie324 code.  */
+#define E_BROWNIE32_ARCH_4		0x30000000
+
+/* -brownie325 code.  */
+#define E_BROWNIE32_ARCH_5           0x40000000
+
+/* -brownie3232 code.  */
+#define E_BROWNIE32_ARCH_32          0x50000000
+
+/* -brownie3264 code.  */
+#define E_BROWNIE32_ARCH_64          0x60000000
+
+/* -brownie3232r2 code.  */
+#define E_BROWNIE32_ARCH_32R2        0x70000000
+
+/* -brownie3264r2 code.  */
+#define E_BROWNIE32_ARCH_64R2        0x80000000
+
+/* The ABI of the file.  Also see EF_BROWNIE32_ABI2 above. */
+#define EF_BROWNIE32_ABI		0x0000F000
+
+/* The original o32 abi. */
+#define E_BROWNIE32_ABI_O32          0x00001000
+
+/* O32 extended to work on 64 bit architectures */
+#define E_BROWNIE32_ABI_O64          0x00002000
+
+/* EABI in 32 bit mode */
+#define E_BROWNIE32_ABI_EABI32       0x00003000
+
+/* EABI in 64 bit mode */
+#define E_BROWNIE32_ABI_EABI64       0x00004000
+
+
+/* Machine variant if we know it.  This field was invented at Cygnus,
+   but it is hoped that other vendors will adopt it.  If some standard
+   is developed, this code should be changed to follow it. */
+
+#define EF_BROWNIE32_MACH		0x00FF0000
+
+/* Cygnus is choosing values between 80 and 9F;
+   00 - 7F should be left for a future standard;
+   the rest are open. */
+
+#define E_BROWNIE32_MACH_3900	0x00810000
+#define E_BROWNIE32_MACH_4010	0x00820000
+#define E_BROWNIE32_MACH_4100	0x00830000
+#define E_BROWNIE32_MACH_4650	0x00850000
+#define E_BROWNIE32_MACH_4120	0x00870000
+#define E_BROWNIE32_MACH_4111	0x00880000
+#define E_BROWNIE32_MACH_SB1         0x008a0000
+#define E_BROWNIE32_MACH_5400	0x00910000
+#define E_BROWNIE32_MACH_5500	0x00980000
+#define E_BROWNIE32_MACH_9000	0x00990000
+
+/* Processor specific section indices.  These sections do not actually
+   exist.  Symbols with a st_shndx field corresponding to one of these
+   values have a special meaning.  */
+
+/* Defined and allocated common symbol.  Value is virtual address.  If
+   relocated, alignment must be preserved.  */
+#define SHN_BROWNIE32_ACOMMON	0xff00
+
+/* Defined and allocated text symbol.  Value is virtual address.
+   Occur in the dynamic symbol table of Alpha OSF/1 and Irix 5 executables.  */
+#define SHN_BROWNIE32_TEXT		0xff01
+
+/* Defined and allocated data symbol.  Value is virtual address.
+   Occur in the dynamic symbol table of Alpha OSF/1 and Irix 5 executables.  */
+#define SHN_BROWNIE32_DATA		0xff02
+
+/* Small common symbol.  */
+#define SHN_BROWNIE32_SCOMMON	0xff03
+
+/* Small undefined symbol.  */
+#define SHN_BROWNIE32_SUNDEFINED	0xff04
+
+/* Processor specific section types.  */
+
+/* Section contains the set of dynamic shared objects used when
+   statically linking.  */
+#define SHT_BROWNIE32_LIBLIST	0x70000000
+
+/* I'm not sure what this is, but it's used on Irix 5.  */
+#define SHT_BROWNIE32_MSYM		0x70000001
+
+/* Section contains list of symbols whose definitions conflict with
+   symbols defined in shared objects.  */
+#define SHT_BROWNIE32_CONFLICT	0x70000002
+
+/* Section contains the global pointer table.  */
+#define SHT_BROWNIE32_GPTAB		0x70000003
+
+/* Section contains microcode information.  The exact format is
+   unspecified.  */
+#define SHT_BROWNIE32_UCODE		0x70000004
+
+/* Section contains some sort of debugging information.  The exact
+   format is unspecified.  It's probably ECOFF symbols.  */
+#define SHT_BROWNIE32_DEBUG		0x70000005
+
+/* Section contains register usage information.  */
+#define SHT_BROWNIE32_REGINFO	0x70000006
+
+/* ??? */
+#define SHT_BROWNIE32_PACKAGE	0x70000007
+
+/* ??? */
+#define SHT_BROWNIE32_PACKSYM	0x70000008
+
+/* ??? */
+#define SHT_BROWNIE32_RELD		0x70000009
+
+/* Section contains interface information.  */
+#define SHT_BROWNIE32_IFACE		0x7000000b
+
+/* Section contains description of contents of another section.  */
+#define SHT_BROWNIE32_CONTENT	0x7000000c
+
+/* Section contains miscellaneous options.  */
+#define SHT_BROWNIE32_OPTIONS	0x7000000d
+
+/* ??? */
+#define SHT_BROWNIE32_SHDR		0x70000010
+
+/* ??? */
+#define SHT_BROWNIE32_FDESC		0x70000011
+
+/* ??? */
+#define SHT_BROWNIE32_EXTSYM		0x70000012
+
+/* ??? */
+#define SHT_BROWNIE32_DENSE		0x70000013
+
+/* ??? */
+#define SHT_BROWNIE32_PDESC		0x70000014
+
+/* ??? */
+#define SHT_BROWNIE32_LOCSYM		0x70000015
+
+/* ??? */
+#define SHT_BROWNIE32_AUXSYM		0x70000016
+
+/* ??? */
+#define SHT_BROWNIE32_OPTSYM		0x70000017
+
+/* ??? */
+#define SHT_BROWNIE32_LOCSTR		0x70000018
+
+/* ??? */
+#define SHT_BROWNIE32_LINE		0x70000019
+
+/* ??? */
+#define SHT_BROWNIE32_RFDESC		0x7000001a
+
+/* Delta C++: symbol table */
+#define SHT_BROWNIE32_DELTASYM	0x7000001b
+
+/* Delta C++: instance table */
+#define SHT_BROWNIE32_DELTAINST	0x7000001c
+
+/* Delta C++: class table */
+#define SHT_BROWNIE32_DELTACLASS	0x7000001d
+
+/* DWARF debugging section.  */
+#define SHT_BROWNIE32_DWARF		0x7000001e
+
+/* Delta C++: declarations */
+#define SHT_BROWNIE32_DELTADECL	0x7000001f
+
+/* List of libraries the binary depends on.  Includes a time stamp, version
+   number.  */
+#define SHT_BROWNIE32_SYMBOL_LIB	0x70000020
+
+/* Events section.  */
+#define SHT_BROWNIE32_EVENTS		0x70000021
+
+/* ??? */
+#define SHT_BROWNIE32_TRANSLATE	0x70000022
+
+/* Special pixie sections */
+#define SHT_BROWNIE32_PIXIE		0x70000023
+
+/* Address translation table (for debug info) */
+#define SHT_BROWNIE32_XLATE		0x70000024
+
+/* SGI internal address translation table (for debug info) */
+#define SHT_BROWNIE32_XLATE_DEBUG	0x70000025
+
+/* Intermediate code */
+#define SHT_BROWNIE32_WHIRL		0x70000026
+
+/* C++ exception handling region info */
+#define SHT_BROWNIE32_EH_REGION	0x70000027
+
+/* Obsolete address translation table (for debug info) */
+#define SHT_BROWNIE32_XLATE_OLD	0x70000028
+
+/* Runtime procedure descriptor table exception information (ucode) ??? */
+#define SHT_BROWNIE32_PDR_EXCEPTION	0x70000029
+
+
+/* A section of type SHT_BROWNIE32_LIBLIST contains an array of the
+   following structure.  The sh_link field is the section index of the
+   string table.  The sh_info field is the number of entries in the
+   section.  */
+typedef struct
+{
+  /* String table index for name of shared object.  */
+  unsigned long l_name;
+  /* Time stamp.  */
+  unsigned long l_time_stamp;
+  /* Checksum of symbol names and common sizes.  */
+  unsigned long l_checksum;
+  /* String table index for version.  */
+  unsigned long l_version;
+  /* Flags.  */
+  unsigned long l_flags;
+} Elf32_Lib;
+
+/* The external version of Elf32_Lib.  */
+typedef struct
+{
+  unsigned char l_name[4];
+  unsigned char l_time_stamp[4];
+  unsigned char l_checksum[4];
+  unsigned char l_version[4];
+  unsigned char l_flags[4];
+} Elf32_External_Lib;
+
+/* The l_flags field of an Elf32_Lib structure may contain the
+   following flags.  */
+
+/* Require an exact match at runtime.  */
+#define LL_EXACT_MATCH		0x00000001
+
+/* Ignore version incompatibilities at runtime.  */
+#define LL_IGNORE_INT_VER	0x00000002
+
+/* Require matching minor version number.  */
+#define LL_REQUIRE_MINOR	0x00000004
+
+/* ??? */
+#define LL_EXPORTS		0x00000008
+
+/* Delay loading of this library until really needed.  */
+#define LL_DELAY_LOAD		0x00000010
+
+/* ??? Delta C++ stuff ??? */
+#define LL_DELTA		0x00000020
+
+
+/* A section of type SHT_BROWNIE32_CONFLICT is an array of indices into the
+   .dynsym section.  Each element has the following type.  */
+typedef unsigned long Elf32_Conflict;
+typedef unsigned char Elf32_External_Conflict[4];
+
+typedef unsigned long Elf64_Conflict;
+typedef unsigned char Elf64_External_Conflict[8];
+
+/* A section of type SHT_BROWNIE32_GPTAB contains information about how
+   much GP space would be required for different -G arguments.  This
+   information is only used so that the linker can provide informative
+   suggestions as to the best -G value to use.  The sh_info field is
+   the index of the section for which this information applies.  The
+   contents of the section are an array of the following union.  The
+   first element uses the gt_header field.  The remaining elements use
+   the gt_entry field.  */
+typedef union
+{
+  struct
+    {
+      /* -G value actually used for this object file.  */
+      unsigned long gt_current_g_value;
+      /* Unused.  */
+      unsigned long gt_unused;
+    } gt_header;
+  struct
+    {
+      /* If this -G argument has been used...  */
+      unsigned long gt_g_value;
+      /* ...this many GP section bytes would be required.  */
+      unsigned long gt_bytes;
+    } gt_entry;
+} Elf32_gptab;
+
+/* The external version of Elf32_gptab.  */
+
+typedef union
+{
+  struct
+    {
+      unsigned char gt_current_g_value[4];
+      unsigned char gt_unused[4];
+    } gt_header;
+  struct
+    {
+      unsigned char gt_g_value[4];
+      unsigned char gt_bytes[4];
+    } gt_entry;
+} Elf32_External_gptab;
+
+/* A section of type SHT_BROWNIE32_REGINFO contains the following
+   structure.  */
+typedef struct
+{
+  /* Mask of general purpose registers used.  */
+  unsigned long ri_gprmask;
+  /* Mask of co-processor registers used.  */
+  unsigned long ri_cprmask[4];
+  /* GP register value for this object file.  */
+  long ri_gp_value;
+} Elf32_RegInfo;
+
+/* The external version of the Elf_RegInfo structure.  */
+typedef struct
+{
+  unsigned char ri_gprmask[4];
+  unsigned char ri_cprmask[4][4];
+  unsigned char ri_gp_value[4];
+} Elf32_External_RegInfo;
+
+/* BROWNIE32 ELF .reginfo swapping routines.  */
+extern void bfd_brownie32_elf32_swap_reginfo_in
+  (bfd *, const Elf32_External_RegInfo *, Elf32_RegInfo *);
+extern void bfd_brownie32_elf32_swap_reginfo_out
+  (bfd *, const Elf32_RegInfo *, Elf32_External_RegInfo *);
+
+/* Processor specific section flags.  */
+
+/* This section must be in the global data area.  */
+#define SHF_BROWNIE32_GPREL		0x10000000
+
+/* This section should be merged.  */
+#define SHF_BROWNIE32_MERGE		0x20000000
+
+/* This section contains address data of size implied by section
+   element size.  */
+#define SHF_BROWNIE32_ADDR		0x40000000
+
+/* This section contains string data.  */
+#define SHF_BROWNIE32_STRING		0x80000000
+
+/* This section may not be stripped.  */
+#define SHF_BROWNIE32_NOSTRIP	0x08000000
+
+/* This section is local to threads.  */
+#define SHF_BROWNIE32_LOCAL		0x04000000
+
+/* Linker should generate implicit weak names for this section.  */
+#define SHF_BROWNIE32_NAMES		0x02000000
+
+/* Section contais text/data which may be replicated in other sections.
+   Linker should retain only one copy.  */
+#define SHF_BROWNIE32_NODUPES	0x01000000
+
+/* Processor specific program header types.  */
+
+/* Register usage information.  Identifies one .reginfo section.  */
+#define PT_BROWNIE32_REGINFO		0x70000000
+
+/* Runtime procedure table.  */
+#define PT_BROWNIE32_RTPROC		0x70000001
+
+/* .BROWNIE32.options section.  */
+#define PT_BROWNIE32_OPTIONS		0x70000002
+
+/* Processor specific dynamic array tags.  */
+
+/* 32 bit version number for runtime linker interface.  */
+#define DT_BROWNIE32_RLD_VERSION	0x70000001
+
+/* Time stamp.  */
+#define DT_BROWNIE32_TIME_STAMP	0x70000002
+
+/* Checksum of external strings and common sizes.  */
+#define DT_BROWNIE32_ICHECKSUM	0x70000003
+
+/* Index of version string in string table.  */
+#define DT_BROWNIE32_IVERSION	0x70000004
+
+/* 32 bits of flags.  */
+#define DT_BROWNIE32_FLAGS		0x70000005
+
+/* Base address of the segment.  */
+#define DT_BROWNIE32_BASE_ADDRESS	0x70000006
+
+/* ??? */
+#define DT_BROWNIE32_MSYM		0x70000007
+
+/* Address of .conflict section.  */
+#define DT_BROWNIE32_CONFLICT	0x70000008
+
+/* Address of .liblist section.  */
+#define DT_BROWNIE32_LIBLIST		0x70000009
+
+/* Number of local global offset table entries.  */
+#define DT_BROWNIE32_LOCAL_GOTNO	0x7000000a
+
+/* Number of entries in the .conflict section.  */
+#define DT_BROWNIE32_CONFLICTNO	0x7000000b
+
+/* Number of entries in the .liblist section.  */
+#define DT_BROWNIE32_LIBLISTNO	0x70000010
+
+/* Number of entries in the .dynsym section.  */
+#define DT_BROWNIE32_SYMTABNO	0x70000011
+
+/* Index of first external dynamic symbol not referenced locally.  */
+#define DT_BROWNIE32_UNREFEXTNO	0x70000012
+
+/* Index of first dynamic symbol in global offset table.  */
+#define DT_BROWNIE32_GOTSYM		0x70000013
+
+/* Number of page table entries in global offset table.  */
+#define DT_BROWNIE32_HIPAGENO	0x70000014
+
+/* Address of run time loader map, used for debugging.  */
+#define DT_BROWNIE32_RLD_MAP		0x70000016
+
+/* Delta C++ class definition.  */
+#define DT_BROWNIE32_DELTA_CLASS	0x70000017
+
+/* Number of entries in DT_BROWNIE32_DELTA_CLASS.  */
+#define DT_BROWNIE32_DELTA_CLASS_NO	0x70000018
+
+/* Delta C++ class instances.  */
+#define DT_BROWNIE32_DELTA_INSTANCE	0x70000019
+
+/* Number of entries in DT_BROWNIE32_DELTA_INSTANCE.  */
+#define DT_BROWNIE32_DELTA_INSTANCE_NO	0x7000001a
+
+/* Delta relocations.  */
+#define DT_BROWNIE32_DELTA_RELOC	0x7000001b
+
+/* Number of entries in DT_BROWNIE32_DELTA_RELOC.  */
+#define DT_BROWNIE32_DELTA_RELOC_NO	0x7000001c
+
+/* Delta symbols that Delta relocations refer to.  */
+#define DT_BROWNIE32_DELTA_SYM	0x7000001d
+
+/* Number of entries in DT_BROWNIE32_DELTA_SYM.  */
+#define DT_BROWNIE32_DELTA_SYM_NO	0x7000001e
+
+/* Delta symbols that hold class declarations.  */
+#define DT_BROWNIE32_DELTA_CLASSSYM	0x70000020
+
+/* Number of entries in DT_BROWNIE32_DELTA_CLASSSYM.  */
+#define DT_BROWNIE32_DELTA_CLASSSYM_NO	0x70000021
+
+/* Flags indicating information about C++ flavor.  */
+#define DT_BROWNIE32_CXX_FLAGS	0x70000022
+
+/* Pixie information (???).  */
+#define DT_BROWNIE32_PIXIE_INIT	0x70000023
+
+/* Address of .BROWNIE32.symlib */
+#define DT_BROWNIE32_SYMBOL_LIB	0x70000024
+
+/* The GOT index of the first PTE for a segment */
+#define DT_BROWNIE32_LOCALPAGE_GOTIDX	0x70000025
+
+/* The GOT index of the first PTE for a local symbol */
+#define DT_BROWNIE32_LOCAL_GOTIDX	0x70000026
+
+/* The GOT index of the first PTE for a hidden symbol */
+#define DT_BROWNIE32_HIDDEN_GOTIDX	0x70000027
+
+/* The GOT index of the first PTE for a protected symbol */
+#define DT_BROWNIE32_PROTECTED_GOTIDX	0x70000028
+
+/* Address of `.BROWNIE32.options'.  */
+#define DT_BROWNIE32_OPTIONS		0x70000029
+
+/* Address of `.interface'.  */
+#define DT_BROWNIE32_INTERFACE	0x7000002a
+
+/* ??? */
+#define DT_BROWNIE32_DYNSTR_ALIGN	0x7000002b
+
+/* Size of the .interface section.  */
+#define DT_BROWNIE32_INTERFACE_SIZE	0x7000002c
+
+/* Size of rld_text_resolve function stored in the GOT.  */
+#define DT_BROWNIE32_RLD_TEXT_RESOLVE_ADDR	0x7000002d
+
+/* Default suffix of DSO to be added by rld on dlopen() calls.  */
+#define DT_BROWNIE32_PERF_SUFFIX	0x7000002e
+
+/* Size of compact relocation section (O32).  */
+#define DT_BROWNIE32_COMPACT_SIZE	0x7000002f
+
+/* GP value for auxiliary GOTs.  */
+#define DT_BROWNIE32_GP_VALUE	0x70000030
+
+/* Address of auxiliary .dynamic.  */
+#define DT_BROWNIE32_AUX_DYNAMIC	0x70000031
+
+/* Flags which may appear in a DT_BROWNIE32_FLAGS entry.  */
+
+/* No flags.  */
+#define RHF_NONE		0x00000000
+
+/* Uses shortcut pointers.  */
+#define RHF_QUICKSTART		0x00000001
+
+/* Hash size is not a power of two.  */
+#define RHF_NOTPOT		0x00000002
+
+/* Ignore LD_LIBRARY_PATH.  */
+#define RHS_NO_LIBRARY_REPLACEMENT 0x00000004
+
+/* DSO address may not be relocated. */
+#define RHF_NO_MOVE		0x00000008
+
+/* SGI specific features. */
+#define RHF_SGI_ONLY		0x00000010
+
+/* Guarantee that .init will finish executing before any non-init
+   code in DSO is called. */
+#define RHF_GUARANTEE_INIT	   0x00000020
+
+/* Contains Delta C++ code. */
+#define RHF_DELTA_C_PLUS_PLUS	   0x00000040
+
+/* Guarantee that .init will start executing before any non-init
+   code in DSO is called. */
+#define RHF_GUARANTEE_START_INIT   0x00000080
+
+/* Generated by pixie. */
+#define RHF_PIXIE		   0x00000100
+
+/* Delay-load DSO by default. */
+#define RHF_DEFAULT_DELAY_LOAD	   0x00000200
+
+/* Object may be requickstarted */
+#define RHF_REQUICKSTART	   0x00000400
+
+/* Object has been requickstarted */
+#define RHF_REQUICKSTARTED	   0x00000800
+
+/* Generated by cord. */
+#define RHF_CORD		   0x00001000
+
+/* Object contains no unresolved undef symbols. */
+#define RHF_NO_UNRES_UNDEF	   0x00002000
+
+/* Symbol table is in a safe order. */
+#define RHF_RLD_ORDER_SAFE	   0x00004000
+
+/* Special values for the st_other field in the symbol table.  These
+   are used in an Irix 5 dynamic symbol table.  */
+
+#define STO_DEFAULT		STV_DEFAULT
+#define STO_INTERNAL		STV_INTERNAL
+#define STO_HIDDEN		STV_HIDDEN
+#define STO_PROTECTED		STV_PROTECTED
+
+/* This value is used for a brownie3216 .text symbol.  */
+#define STO_BROWNIE3216		0xf0
+
+/* The 64-bit BROWNIE32 ELF ABI uses an unusual reloc format.  Each
+   relocation entry specifies up to three actual relocations, all at
+   the same address.  The first relocation which required a symbol
+   uses the symbol in the r_sym field.  The second relocation which
+   requires a symbol uses the symbol in the r_ssym field.  If all
+   three relocations require a symbol, the third one uses a zero
+   value.  */
+
+/* An entry in a 64 bit SHT_REL section.  */
+
+typedef struct
+{
+  /* Address of relocation.  */
+  unsigned char r_offset[8];
+  /* Symbol index.  */
+  unsigned char r_sym[4];
+  /* Special symbol.  */
+  unsigned char r_ssym[1];
+  /* Third relocation.  */
+  unsigned char r_type3[1];
+  /* Second relocation.  */
+  unsigned char r_type2[1];
+  /* First relocation.  */
+  unsigned char r_type[1];
+} Elf64_Mips_External_Rel;
+
+typedef struct
+{
+  /* Address of relocation.  */
+  bfd_vma r_offset;
+  /* Symbol index.  */
+  unsigned long r_sym;
+  /* Special symbol.  */
+  unsigned char r_ssym;
+  /* Third relocation.  */
+  unsigned char r_type3;
+  /* Second relocation.  */
+  unsigned char r_type2;
+  /* First relocation.  */
+  unsigned char r_type;
+} Elf64_Mips_Internal_Rel;
+
+/* An entry in a 64 bit SHT_RELA section.  */
+
+typedef struct
+{
+  /* Address of relocation.  */
+  unsigned char r_offset[8];
+  /* Symbol index.  */
+  unsigned char r_sym[4];
+  /* Special symbol.  */
+  unsigned char r_ssym[1];
+  /* Third relocation.  */
+  unsigned char r_type3[1];
+  /* Second relocation.  */
+  unsigned char r_type2[1];
+  /* First relocation.  */
+  unsigned char r_type[1];
+  /* Addend.  */
+  unsigned char r_addend[8];
+} Elf64_Mips_External_Rela;
+
+typedef struct
+{
+  /* Address of relocation.  */
+  bfd_vma r_offset;
+  /* Symbol index.  */
+  unsigned long r_sym;
+  /* Special symbol.  */
+  unsigned char r_ssym;
+  /* Third relocation.  */
+  unsigned char r_type3;
+  /* Second relocation.  */
+  unsigned char r_type2;
+  /* First relocation.  */
+  unsigned char r_type;
+  /* Addend.  */
+  bfd_signed_vma r_addend;
+} Elf64_Mips_Internal_Rela;
+
+/* BROWNIE32 ELF 64 relocation info access macros.  */
+#define ELF64_BROWNIE32_R_SSYM(i) (((i) >> 24) & 0xff)
+#define ELF64_BROWNIE32_R_TYPE3(i) (((i) >> 16) & 0xff)
+#define ELF64_BROWNIE32_R_TYPE2(i) (((i) >> 8) & 0xff)
+#define ELF64_BROWNIE32_R_TYPE(i) ((i) & 0xff)
+
+/* Values found in the r_ssym field of a relocation entry.  */
+
+/* No relocation.  */
+#define RSS_UNDEF	0
+
+/* Value of GP.  */
+#define RSS_GP		1
+
+/* Value of GP in object being relocated.  */
+#define RSS_GP0		2
+
+/* Address of location being relocated.  */
+#define RSS_LOC		3
+
+/* A SHT_BROWNIE32_OPTIONS section contains a series of options, each of
+   which starts with this header.  */
+
+typedef struct
+{
+  /* Type of option.  */
+  unsigned char kind[1];
+  /* Size of option descriptor, including header.  */
+  unsigned char size[1];
+  /* Section index of affected section, or 0 for global option.  */
+  unsigned char section[2];
+  /* Information specific to this kind of option.  */
+  unsigned char info[4];
+} Elf_External_Options;
+
+typedef struct
+{
+  /* Type of option.  */
+  unsigned char kind;
+  /* Size of option descriptor, including header.  */
+  unsigned char size;
+  /* Section index of affected section, or 0 for global option.  */
+  unsigned short section;
+  /* Information specific to this kind of option.  */
+  unsigned long info;
+} Elf_Internal_Options;
+
+/* BROWNIE32 ELF option header swapping routines.  */
+extern void bfd_brownie32_elf_swap_options_in
+  (bfd *, const Elf_External_Options *, Elf_Internal_Options *);
+extern void bfd_brownie32_elf_swap_options_out
+  (bfd *, const Elf_Internal_Options *, Elf_External_Options *);
+
+/* Values which may appear in the kind field of an Elf_Options
+   structure.  */
+
+/* Undefined.  */
+#define ODK_NULL	0
+
+/* Register usage and GP value.  */
+#define ODK_REGINFO	1
+
+/* Exception processing information.  */
+#define ODK_EXCEPTIONS	2
+
+/* Section padding information.  */
+#define ODK_PAD		3
+
+/* Hardware workarounds performed.  */
+#define ODK_HWPATCH	4
+
+/* Fill value used by the linker.  */
+#define ODK_FILL	5
+
+/* Reserved space for desktop tools.  */
+#define ODK_TAGS	6
+
+/* Hardware workarounds, AND bits when merging.  */
+#define ODK_HWAND	7
+
+/* Hardware workarounds, OR bits when merging.  */
+#define ODK_HWOR	8
+
+/* GP group to use for text/data sections.  */
+#define ODK_GP_GROUP	9
+
+/* ID information.  */
+#define ODK_IDENT	10
+
+/* In the 32 bit ABI, an ODK_REGINFO option is just a Elf32_RegInfo
+   structure.  In the 64 bit ABI, it is the following structure.  The
+   info field of the options header is not used.  */
+
+typedef struct
+{
+  /* Mask of general purpose registers used.  */
+  unsigned char ri_gprmask[4];
+  /* Padding.  */
+  unsigned char ri_pad[4];
+  /* Mask of co-processor registers used.  */
+  unsigned char ri_cprmask[4][4];
+  /* GP register value for this object file.  */
+  unsigned char ri_gp_value[8];
+} Elf64_External_RegInfo;
+
+typedef struct
+{
+  /* Mask of general purpose registers used.  */
+  unsigned long ri_gprmask;
+  /* Padding.  */
+  unsigned long ri_pad;
+  /* Mask of co-processor registers used.  */
+  unsigned long ri_cprmask[4];
+  /* GP register value for this object file.  */
+  bfd_vma ri_gp_value;
+} Elf64_Internal_RegInfo;
+
+typedef struct
+{
+  /* The hash value computed from the name of the corresponding
+     dynamic symbol.  */
+  unsigned char ms_hash_value[4];
+  /* Contains both the dynamic relocation index and the symbol flags
+     field.  The macros ELF32_MS_REL_INDEX and ELF32_MS_FLAGS are used
+     to access the individual values.  The dynamic relocation index
+     identifies the first entry in the .rel.dyn section that
+     references the dynamic symbol corresponding to this msym entry.
+     If the index is 0, no dynamic relocations are associated with the
+     symbol.  The symbol flags field is reserved for future use.  */
+  unsigned char ms_info[4];
+} Elf32_External_Msym;
+
+typedef struct
+{
+  /* The hash value computed from the name of the corresponding
+     dynamic symbol.  */
+  unsigned long ms_hash_value;
+  /* Contains both the dynamic relocation index and the symbol flags
+     field.  The macros ELF32_MS_REL_INDEX and ELF32_MS_FLAGS are used
+     to access the individual values.  The dynamic relocation index
+     identifies the first entry in the .rel.dyn section that
+     references the dynamic symbol corresponding to this msym entry.
+     If the index is 0, no dynamic relocations are associated with the
+     symbol.  The symbol flags field is reserved for future use.  */
+  unsigned long ms_info;
+} Elf32_Internal_Msym;
+
+#define ELF32_MS_REL_INDEX(i) ((i) >> 8)
+#define ELF32_MS_FLAGS(i)     (i) & 0xff)
+#define ELF32_MS_INFO(r, f)   (((r) << 8) + ((f) & 0xff))
+
+/* BROWNIE32 ELF reginfo swapping routines.  */
+extern void bfd_brownie32_elf64_swap_reginfo_in
+  (bfd *, const Elf64_External_RegInfo *, Elf64_Internal_RegInfo *);
+extern void bfd_brownie32_elf64_swap_reginfo_out
+  (bfd *, const Elf64_Internal_RegInfo *, Elf64_External_RegInfo *);
+
+/* Masks for the info work of an ODK_EXCEPTIONS descriptor.  */
+#define OEX_FPU_MIN	0x1f	/* FPEs which must be enabled.  */
+#define OEX_FPU_MAX	0x1f00	/* FPEs which may be enabled.  */
+#define OEX_PAGE0	0x10000	/* Page zero must be mapped.  */
+#define OEX_SMM		0x20000	/* Force sequential memory mode.  */
+#define OEX_FPDBUG	0x40000	/* Force precise floating-point
+				   exceptions (debug mode).  */
+#define OEX_DISMISS	0x80000	/* Dismiss invalid address faults.  */
+
+/* Masks of the FP exceptions for OEX_FPU_MIN and OEX_FPU_MAX.  */
+#define OEX_FPU_INVAL	0x10	/* Invalid operation exception.  */
+#define OEX_FPU_DIV0	0x08	/* Division by zero exception.  */
+#define OEX_FPU_OFLO	0x04	/* Overflow exception.  */
+#define OEX_FPU_UFLO	0x02	/* Underflow exception.  */
+#define OEX_FPU_INEX	0x01	/* Inexact exception.  */
+
+/* Masks for the info word of an ODK_PAD descriptor.  */
+#define OPAD_PREFIX	0x01
+#define OPAD_POSTFIX	0x02
+#define OPAD_SYMBOL	0x04
+
+/* Masks for the info word of an ODK_HWPATCH descriptor.  */
+#define OHW_R4KEOP	0x00000001	/* R4000 end-of-page patch.  */
+#define OHW_R8KPFETCH	0x00000002	/* May need R8000 prefetch patch.  */
+#define OHW_R5KEOP	0x00000004	/* R5000 end-of-page patch.  */
+#define OHW_R5KCVTL	0x00000008	/* R5000 cvt.[ds].l bug
+					   (clean == 1).  */
+#define OHW_R10KLDL	0x00000010	/* Needs R10K misaligned
+					   load patch. */
+
+/* Masks for the info word of an ODK_IDENT/ODK_GP_GROUP descriptor.  */
+#define OGP_GROUP	0x0000ffff	/* GP group number.  */
+#define OGP_SELF	0xffff0000	/* Self-contained GP groups.  */
+
+/* Masks for the info word of an ODK_HWAND/ODK_HWOR descriptor.  */
+#define OHWA0_R4KEOP_CHECKED	0x00000001
+#define OHWA0_R4KEOP_CLEAN	0x00000002
+
+
+#endif /* _ELF_BROWNIE32_H */
Index: include/elf/common.h
===================================================================
RCS file: /home/prj/asip/cvs/gdb/include/elf/common.h,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- include/elf/common.h	31 Jul 2007 11:40:26 -0000	1.1.1.1
+++ include/elf/common.h	8 Aug 2007 08:49:54 -0000	1.2
@@ -7,6 +7,8 @@
    in "UNIX System V Release 4, Programmers Guide: ANSI C and
    Programming Support Tools".
 
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
    This file is part of BFD, the Binary File Descriptor library.
 
    This program is free software; you can redistribute it and/or modify
@@ -21,7 +23,7 @@
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
 
 
 /* This file is part of ELF support for BFD, and contains the portions
@@ -182,7 +184,6 @@
 #define EM_IP2K		101	/* Ubicom IP2022 micro controller */
 #define EM_CR		103	/* National Semiconductor CompactRISC */
 #define EM_MSP430	105	/* TI msp430 micro controller */
-#define EM_BLACKFIN	106	/* ADI Blackfin */
 #define EM_CRX		114	/* National Semiconductor CRX */
 
 /* If it is necessary to assign new unofficial EM_* values, please pick large
@@ -212,9 +213,6 @@
 /* (Deprecated) Temporary number for the OpenRISC processor.  */
 #define EM_OR32		0x8472
 
-/* Renesas M32C and M16C.  */
-#define EM_M32C			0xFEB0
-
 /* Cygnus M32R ELF backend.  Written in the absence of an ABI.  */
 #define EM_CYGNUS_M32R	0x9041
 
@@ -253,6 +251,10 @@
    Written in the absense of an ABI.  */
 #define EM_DLX			0x5aa5
 
+/* BROWNIE32 magic number
+   Written in the absense of an ABI.  */
+#define EM_BROWNIE32		0x1005
+
 #define EM_XSTORMY16		0xad45
 
 /* FRV magic number - no EABI available??.  */
@@ -261,8 +263,6 @@
 /* Ubicom IP2xxx; no ABI */
 #define EM_IP2K_OLD		0x8217
 
-#define EM_MS1                  0x2530  /* Morpho MS1; no ABI */
-
 /* MSP430 magic number
       Written in the absense everything.  */
 #define EM_MSP430_OLD		0x1059
Index: include/opcode/brownie32.h
===================================================================
RCS file: include/opcode/brownie32.h
diff -N include/opcode/brownie32.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ include/opcode/brownie32.h	12 Feb 2008 08:43:47 -0000	1.2
@@ -0,0 +1,211 @@
+/* brownie32.h.  Brownie32 opcode list for GDB, the GNU debugger.
+   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+   2003, 2004, 2005
+   Free Software Foundation, Inc.
+   Contributed by Ralph Campbell and OSF
+   Commented and modified by Ian Lance Taylor, Cygnus Support
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+This file is part of GDB, GAS, and the GNU binutils.
+
+GDB, GAS, and the GNU binutils are free software; you can redistribute
+them and/or modify them under the terms of the GNU General Public
+License as published by the Free Software Foundation; either version
+1, or (at your option) any later version.
+
+GDB, GAS, and the GNU binutils are distributed in the hope that they
+will be useful, but WITHOUT ANY WARRANTY; without even the implied
+warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this file; see the file COPYING.  If not, write to the Free
+Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _BROWNIE32_H_
+#define _BROWNIE32_H_
+
+/* Following 1 opecode is used for all RR-TYPE instructions */
+#define  RRTYPOP     0x00000001
+
+/* Following 9 opecode is used for RI-TYPE instructions */
+#define  ADDIOP      0x00000020
+#define  SUBIOP      0x00000021
+#define  ANDIOP      0x00000022
+#define  ORIOP       0x00000023
+#define  XORIOP      0x00000024
+#define  LLSIOP      0x00000025
+#define  LRSIOP      0x00000026
+#define  ARSIOP      0x00000027
+#define  LSOIOP      0x00000028
+
+/* Following 6 opecode is used for MA-TYPE instructions */
+#define  LBOP        0x00000002
+#define  LHOP        0x00000003
+#define  LWOP        0x00000004
+#define  SBOP        0x00000005
+#define  SHOP        0x00000006
+#define  SWOP        0x00000007
+
+/* Following 2 opecode is used for BR-TYPE instructions */
+#define  BRZOP       0x00000009
+#define  BRNZOP      0x0000000A
+
+/* Following 3 opecode is used for JP-TYPE instructions */
+#define  JPOP        0x0000000B
+#define  JPLOP       0x0000000C
+#define  TRAPOP      0x0000000D
+
+/* Following 2 opecode is used for JPR-TYPE instructions */
+#define  JPROP       0x0000000E
+#define  JPRLOP      0x0000000F
+
+/* Following 2 opecode is used for SP-TYPE instructions */
+#define  NOPOP       0x00000000
+#define  RETIOP      0x00000040
+
+/* Following opecode is used for RT-TYPE instructions */
+#define  EXBWOP      0x00000080
+#define  EXHWOP      0x00000880
+
+
+/* "func" and "ftype" are a inidication that kind of RR-tpye instrucitons  */
+#define  ADDFUNC     0x00000000
+#define  SUBFUNC     0x00000040
+#define  MULFUNC     0x00000080
+#define  DIVFUNC     0x000000C0
+#define  DIVUFUNC    0x00000140
+#define  MODFUNC     0x00000100
+#define  MODUFUNC    0x00000180
+#define  ANDFUNC     0x00000000
+#define  NANDFUNC    0x000000C0
+#define  ORFUNC      0x00000040
+#define  NORFUNC     0x00000100
+#define  XORFUNC     0x00000080
+#define  LLSFUNC     0x00000000
+#define  LRSFUNC     0x00000040
+#define  ARSFUNC     0x00000080
+#define  ELTFUNC     0x00000000
+#define  ELTUFUNC    0x00000040
+#define  EEQFUNC     0x00000080
+#define  ENEQFUNC    0x000000C0
+
+#define  ADDFTYP     0x00000000
+#define  SUBFTYP     0x00000000
+#define  MULFTYP     0x00000000
+#define  DIVFTYP     0x00000000
+#define  DIVUFTYP    0x00000000
+#define  MODFTYP     0x00000000
+#define  MODUFTYP    0x00000000
+#define  ANDFTYP     0x00004000
+#define  NANDFTYP    0x00004000
+#define  ORFTYP      0x00004000
+#define  NORFTYP     0x00004000
+#define  XORFTYP     0x00004000
+#define  LLSFTYP     0x00008000
+#define  LRSFTYP     0x00008000
+#define  ARSFTYP     0x00008000
+#define  ELTFTYP     0x0000C000
+#define  ELTUFTYP    0x0000C000
+#define  EEQFTYP     0x0000C000
+#define  ENEQFTYP    0x0000C000
+
+/* This structure holds information for a particular instruction.  */
+
+struct brownie32_opcode
+{
+  /* Name of the instruction.  */
+  char *name;
+
+  /* Opcode word.  */
+  unsigned long opcode;
+
+  /* A string of characters which describe the operands.
+     Valid characters are:
+     ,        Itself.  The character appears in the assembly code.
+     a        rs1      The register number is in bits 27-31 of the instruction. SOURCE
+     b        rs1      The register number is in bits 11-15 of the instruction. SOURCE
+     c        rs1      The register number is in bits  6-10 of the instruction. SOURCE
+     p        rs1      The register number is in bits 22-26 of the instruction. SOURCE
+     d        rs2      The register number is in bits 22-26 of the instruction. SOURCE
+     e        rd       The register number is in bits 17-21 of the instruction. Destination
+     f        rd       The register number is in bits  6-10 of the instruction. Destination
+     q        rd       The register number is in bits 27-31 of the instruction. Destination
+     i        An immediate operand is in bits 16-31 of the instruction. 0 extended
+     I        An immediate operand is in bits 16-31 of the instruction. sign extended
+     o	      An offset value is in bits 16-31 of the instruction.
+     O	      An offset value is in bits  6-31 of the instruction.
+     A        abusolute address
+     N	      No opperands needed, for nops.    */
+
+  char *args;
+
+};
+
+static const struct brownie32_opcode brownie32_opcodes[] =
+  {
+
+  /* Arithmetic and Logic RR-TYPE instructions.  */
+    { "add",      (RRTYPOP|ADDFUNC|ADDFTYP),     "e,a,d" }, /* ADD  (Rm + Rn)                    */
+    { "sub",      (RRTYPOP|SUBFUNC|SUBFTYP),     "e,a,d" }, /* SUB  (Rm - Rn)                    */
+    { "mul",      (RRTYPOP|MULFUNC|MULFTYP),     "e,a,d" }, /* MULTIPLY  (Rm * Rn)               */
+    { "div",      (RRTYPOP|DIVFUNC|DIVFTYP),     "e,a,d" }, /* DIVIDE    (Rm / Rn)               */
+    { "divu",     (RRTYPOP|DIVUFUNC|DIVUFTYP),   "e,a,d" }, /* DIVU      (Rm / Rn)               */
+    { "mod",      (RRTYPOP|MODFUNC|MODFTYP),     "e,a,d" }, /* MOD       (Rm % Rn)               */
+    { "modu",     (RRTYPOP|MODUFUNC|MODUFTYP),   "e,a,d" }, /* MODU      (Rm % Rn)               */
+    { "and",      (RRTYPOP|ANDFUNC|ANDFTYP),     "e,a,d" }, /* AND       (Rm & Rn)               */
+    { "nand",     (RRTYPOP|NANDFUNC|NANDFTYP),   "e,a,d" }, /* NAND      (Rm & Rn)               */
+    { "or",       (RRTYPOP|ORFUNC|ORFTYP),       "e,a,d" }, /* OR        (Rm | Rn)               */
+    { "nor",      (RRTYPOP|NORFUNC|NORFTYP),     "e,a,d" }, /* NOR       (Rm | Rn)               */
+    { "xor",      (RRTYPOP|XORFUNC|XORFTYP),     "e,a,d" }, /* EXCLUSIVE OR  (Rm ^ Rn)           */
+    { "lls",      (RRTYPOP|LLSFUNC|LLSFTYP),     "e,a,d" }, /* LOGICAL LEFT SHIFT                */
+    { "lrs",      (RRTYPOP|LRSFUNC|LRSFTYP),     "e,a,d" }, /* LOGICAL RIGHT SHIFT               */
+    { "ars",      (RRTYPOP|ARSFUNC|ARSFTYP),     "e,a,d" }, /* ARITHMETIC RIGHT SHIFT            */
+    { "elt",      (RRTYPOP|ELTFUNC|ELTFTYP),     "e,a,d" },  /* SET IF LESS   SIGNED             */
+    { "eltu",     (RRTYPOP|ELTUFUNC|ELTUFTYP),   "e,a,d" }, /* SET IF LESS UNSIGNED              */
+    { "eeq",      (RRTYPOP|EEQFUNC|EEQFTYP),     "e,a,d" }, /* SET IF EQUAL                      */
+    { "eneq",      (RRTYPOP|ENEQFUNC|ENEQFTYP),  "e,a,d" }, /* SET IF NOT EQUAL                  */
+  /* Arithmetic and Logic RI-TYPE instructions.  */
+    { "addi",     (ADDIOP),   "f,b,i" },                    /* ADD  (Rm + Immediate)             */
+    { "subi",     (SUBIOP),   "f,b,i" },                    /* SUB  (Rm - Immediate)             */
+    { "andi",     (ANDIOP),   "f,b,i" },                    /* AND  (Rm & Immediate)             */
+    { "ori",       (ORIOP),   "f,b,i" },                    /* OR   (Rm | Immediate)             */
+    { "xori",     (XORIOP),   "f,b,i" },                    /* EXCLUSIVE OR  (Rm ^ Immediate)    */
+    { "llsi",     (LLSIOP),   "f,b,i" },                    /* LOGICAL LEFT SHIFT Immediate      */
+    { "lrsi",     (LRSIOP),   "f,b,i" },                    /* LOGICAL LEFT SHIFT Immediate      */
+    { "arsi",     (ARSIOP),   "f,b,i" },                    /* ARITHMETIC RIGHT SHIFT Immediate  */
+    { "lsoi",     (LSOIOP),   "f,b,i" },                    /* 16bit LEFT SHIFT and OR Immediate */
+  /* Arithmetic and Logic MA-TYPE instructions.  */
+    { "lb",     (LBOP),    "f,b,A" },                       /* LOAD 1BYTE DATA                   */
+    { "lh",     (LHOP),    "f,b,A" },                       /* LOAD 2BYTE DATA                   */
+    { "lw",     (LWOP),    "f,b,A" },                       /* LOAD 4BYTE DATA                   */
+    { "sb",     (SBOP),    "b,f,A" },                       /* STORE 1BYTE DATA                  */
+    { "sh",     (SHOP),    "b,f,A" },                       /* STORE 2BYTE DATA                  */
+    { "sw",     (SWOP),    "b,f,A" },                       /* STORE 4BYTE DATA                  */
+  /* Arithmetic and Logic BR-TYPE instructions.  */
+    { "brz",     (BRZOP),   "b,o" },                        /* BRANCH IF RS1 == 0                */
+    { "brnz",    (BRNZOP),  "b,o" },                        /* BRANCH IF RS1 != 0                */
+  /* Arithmetic and Logic JP-TYPE instructions.  */
+    { "jp",     (JPOP),     "O" },                        /* RELATIVE JUMP                    */
+    { "jpl",    (JPLOP),    "O" },                        /* SET NEXT ADDR AND RELATIVE JUMP  */
+    { "trap",   (TRAPOP),   "O" },                        /* OCCURE SOFTWARE INTERRUPT        */
+  /* Arithmetic and Logic JPR-TYPE instructions.  */
+    { "jpr",     (JPROP),    "c" },                        /* ABSOLUTE JUMP                    */
+    { "jprl",    (JPRLOP),   "c" },                        /* SET NEXT ADDR AND ABSOLUTE JUMP  */
+  /* Arithmetic and Logic SP-TYPE instructions.  */
+    { "nop",     (NOPOP),   "N" },                        /* NOT OPERATTON                    */
+    { "reti",    (RETIOP),  "N" },                        /* RETURN FROM INTERRUPT ROUTINE    */
+  /* Arithmetic and Logic RT-TYPE instructions.  */
+    { "exbw",    (EXBWOP),  "q,p" },                      /* EXTEND BYTE TO WORD              */
+    { "exhw",    (EXHWOP),  "q,p" },                      /* EXTEND HALF WORD TO WORD         */
+
+    { "", 0x0, "" }		/* Dummy entry, not included in NUM_OPCODES.
+				   This lets code examine entry i + 1 without
+				   checking if we've run off the end of the table.  */
+
+  };
+
+//const unsigned int num_brownie32_opcodes = (((sizeof brownie32_opcodes) / (sizeof brownie32_opcodes[0])) - 1);
+
+#endif /* _BROWNIE32_H_ */
Index: libiberty/configure
===================================================================
RCS file: /home/prj/asip/cvs/gdb/libiberty/configure,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- libiberty/configure	31 Jul 2007 11:40:21 -0000	1.1.1.1
+++ libiberty/configure	8 Aug 2007 08:49:54 -0000	1.2
@@ -957,7 +957,7 @@ esac
     else
       echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
     fi
-    cd "$ac_popdir"
+    cd $ac_popdir
   done
 fi
 
@@ -2330,7 +2330,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2388,7 +2389,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2504,7 +2506,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2558,7 +2561,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2603,7 +2607,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2647,7 +2652,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3103,7 +3109,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3163,7 +3170,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3239,7 +3247,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3281,7 +3290,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3338,7 +3348,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3710,7 +3721,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3774,7 +3786,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3835,7 +3848,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3916,7 +3930,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4145,7 +4160,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4207,7 +4223,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4247,7 +4264,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4303,7 +4321,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4343,7 +4362,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4407,7 +4427,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4438,8 +4459,10 @@ See \`config.log' for more details." >&2
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: internal error: not reached in cross-compile" >&5
-echo "$as_me: error: internal error: not reached in cross-compile" >&2;}
+  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
@@ -4552,7 +4575,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4618,7 +4642,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4664,7 +4689,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4710,7 +4736,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4787,7 +4814,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5029,7 +5057,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5093,7 +5122,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5162,7 +5192,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5231,7 +5262,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5300,7 +5332,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5369,7 +5402,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5438,7 +5472,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5864,7 +5899,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5923,7 +5959,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6023,7 +6060,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6161,7 +6199,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6382,7 +6421,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6727,7 +6767,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6838,7 +6879,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6907,7 +6949,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6972,7 +7015,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7068,7 +7112,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7132,7 +7177,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7201,7 +7247,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7270,7 +7317,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7339,7 +7387,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7408,7 +7457,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7477,7 +7527,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7548,7 +7599,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7617,7 +7669,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7686,7 +7739,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7755,7 +7809,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7824,7 +7879,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7893,7 +7949,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7964,7 +8021,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8047,7 +8105,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8219,7 +8278,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8648,9 +8708,10 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   # 1. Remove the extension, and $U if already installed.
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
-  # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
-  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
 
@@ -9407,6 +9468,11 @@ esac
   *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
   esac
 
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
   # Let's still pretend it is `configure' which instantiates (i.e., don't
   # use $as_me), people would be surprised to read:
   #    /* config.h.  Generated by config.status.  */
@@ -9445,12 +9511,6 @@ echo "$as_me: error: cannot find input f
 	 fi;;
       esac
     done` || { (exit 1); exit 1; }
-
-  if test x"$ac_file" != x-; then
-    { echo "$as_me:$LINENO: creating $ac_file" >&5
-echo "$as_me: creating $ac_file" >&6;}
-    rm -f "$ac_file"
-  fi
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF
   sed "$ac_vpsub
Index: opcodes/Makefile.am
===================================================================
RCS file: /home/prj/asip/cvs/gdb/opcodes/Makefile.am,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -p -r1.1.1.1 -r1.3
--- opcodes/Makefile.am	31 Jul 2007 11:40:27 -0000	1.1.1.1
+++ opcodes/Makefile.am	12 Feb 2008 08:45:27 -0000	1.3
@@ -129,6 +129,7 @@ CFILES = \
 	mips-dis.c \
 	mips-opc.c \
 	mips16-opc.c \
+	brownie32-dis.c \
 	m10200-dis.c \
 	m10200-opc.c \
 	m10300-dis.c \
@@ -258,6 +259,7 @@ ALL_MACHINES = \
 	mips-dis.lo \
 	mips-opc.lo \
 	mips16-opc.lo \
+	brownie32-dis.lo \
 	mmix-dis.lo \
 	mmix-opc.lo \
 	ms1-asm.lo \
@@ -904,6 +906,12 @@ mips-opc.lo: mips-opc.c sysdep.h config.
   $(INCDIR)/opcode/mips.h
 mips16-opc.lo: mips16-opc.c sysdep.h config.h $(INCDIR)/ansidecl.h \
   $(INCDIR)/opcode/mips.h
+brownie32-dis.lo: brownie32-dis.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(INCDIR)/dis-asm.h $(BFD_H) $(INCDIR)/ansidecl.h $(INCDIR)/symcat.h \
+  $(INCDIR)/libiberty.h $(INCDIR)/ansidecl.h $(INCDIR)/opcode/brownie32.h \
+  opintl.h $(BFDDIR)/elf-bfd.h $(INCDIR)/elf/common.h \
+  $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h \
+  $(INCDIR)/elf/brownie32.h $(INCDIR)/elf/reloc-macros.h
 m10200-dis.lo: m10200-dis.c sysdep.h config.h $(INCDIR)/ansidecl.h \
   $(INCDIR)/opcode/mn10200.h $(INCDIR)/dis-asm.h $(BFD_H) \
   $(INCDIR)/ansidecl.h $(INCDIR)/symcat.h opintl.h
Index: opcodes/Makefile.in
===================================================================
RCS file: /home/prj/asip/cvs/gdb/opcodes/Makefile.in,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -p -r1.1.1.1 -r1.3
--- opcodes/Makefile.in	31 Jul 2007 11:40:27 -0000	1.1.1.1
+++ opcodes/Makefile.in	12 Feb 2008 08:45:46 -0000	1.3
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.9.5 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
@@ -6,6 +6,8 @@
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
+#
+# Copyright (C) 2005,2006  Upwind technology, Inc.
 
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY, to the extent permitted by law; without
@@ -15,8 +17,6 @@
 @SET_MAKE@
 
 
-SOURCES = libopcodes.c $(libopcodes_la_SOURCES)
-
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
@@ -40,6 +40,7 @@ POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
 target_triplet = @target@
+LIBOBJDIR =
 DIST_COMMON = $(srcdir)/../config.guess $(srcdir)/../config.sub \
 	ChangeLog $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
 	$(top_srcdir)/configure $(am__configure_deps) \
@@ -351,6 +352,7 @@ CFILES = \
 	mips-dis.c \
 	mips-opc.c \
 	mips16-opc.c \
+	brownie32-dis.c \
 	m10200-dis.c \
 	m10200-opc.c \
 	m10300-dis.c \
@@ -480,6 +482,7 @@ ALL_MACHINES = \
 	mips-dis.lo \
 	mips-opc.lo \
 	mips16-opc.lo \
+	brownie32-dis.lo \
 	mmix-dis.lo \
 	mmix-opc.lo \
 	ms1-asm.lo \
@@ -1446,6 +1449,12 @@ mips-opc.lo: mips-opc.c sysdep.h config.
   $(INCDIR)/opcode/mips.h
 mips16-opc.lo: mips16-opc.c sysdep.h config.h $(INCDIR)/ansidecl.h \
   $(INCDIR)/opcode/mips.h
+brownie32-dis.lo: brownie32-dis.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(INCDIR)/dis-asm.h $(BFD_H) $(INCDIR)/ansidecl.h $(INCDIR)/symcat.h \
+  $(INCDIR)/libiberty.h $(INCDIR)/ansidecl.h $(INCDIR)/opcode/brownie32.h \
+  opintl.h $(BFDDIR)/elf-bfd.h $(INCDIR)/elf/common.h \
+  $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h \
+  $(INCDIR)/elf/brownie32.h $(INCDIR)/elf/reloc-macros.h
 m10200-dis.lo: m10200-dis.c sysdep.h config.h $(INCDIR)/ansidecl.h \
   $(INCDIR)/opcode/mn10200.h $(INCDIR)/dis-asm.h $(BFD_H) \
   $(INCDIR)/ansidecl.h $(INCDIR)/symcat.h opintl.h
Index: opcodes/aclocal.m4
===================================================================
RCS file: /home/prj/asip/cvs/gdb/opcodes/aclocal.m4,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- opcodes/aclocal.m4	31 Jul 2007 11:40:27 -0000	1.1.1.1
+++ opcodes/aclocal.m4	8 Aug 2007 08:49:54 -0000	1.2
@@ -1,4 +1,4 @@
-# generated automatically by aclocal 1.9.5 -*- Autoconf -*-
+# generated automatically by aclocal 1.9.6 -*- Autoconf -*-
 
 # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
 # 2005  Free Software Foundation, Inc.
@@ -28,7 +28,7 @@ AC_DEFUN([AM_AUTOMAKE_VERSION], [am__api
 # Call AM_AUTOMAKE_VERSION so it can be traced.
 # This function is AC_REQUIREd by AC_INIT_AUTOMAKE.
 AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-	 [AM_AUTOMAKE_VERSION([1.9.5])])
+	 [AM_AUTOMAKE_VERSION([1.9.6])])
 
 # AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
 
Index: opcodes/brownie32-dis.c
===================================================================
RCS file: opcodes/brownie32-dis.c
diff -N opcodes/brownie32-dis.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ opcodes/brownie32-dis.c	12 Feb 2008 08:50:11 -0000	1.2
@@ -0,0 +1,772 @@
+/* Instruction printing code for the BROWNIE32 Microprocessor
+   Copyright 2002 Free Software Foundation, Inc.
+   Contributed by Kuang Hwa Lin.  Written by Kuang Hwa Lin, 03/2002.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "sysdep.h"
+#include "dis-asm.h"
+#include "opcode/brownie32.h"
+
+#define R_ERROR     0x1
+#define R_TYPE      0x2
+#define ILD_TYPE    0x3
+#define IST_TYPE    0x4
+#define IRI_TYPE    0x5
+#define IBR_TYPE    0x6
+#define IJ_TYPE     0x7
+#define IJR_TYPE    0x8
+#define ISP_TYPE    0xA
+#define IRT_TYPE    0xB
+#define NIL         0x9
+
+#define OPC(x)      (x & 0x3F)
+
+// AO_patch
+unsigned char rs1, rs2, rd;
+unsigned long imm26, current_insn_addr;
+
+
+unsigned char opc, rs1_31, rs1_26, rs1_15, rs1_10;
+unsigned char rs2_26, rd_31, rd_21, rd_10;
+unsigned long imm16, offset16, offset26, func, func21;
+unsigned long current_insn_addr;
+
+// AO_patch
+//static unsigned char brownie32_get_opcode PARAMS ((unsigned long));
+//static unsigned char brownie32_get_rs1    PARAMS ((unsigned long));
+//static unsigned char brownie32_get_rs2    PARAMS ((unsigned long));
+//static unsigned char brownie32_get_rdR    PARAMS ((unsigned long));
+//static unsigned long brownie32_get_func   PARAMS ((unsigned long)); 
+//static unsigned long brownie32_get_imm16  PARAMS ((unsigned long));
+//static unsigned long brownie32_get_imm26  PARAMS ((unsigned long));
+static unsigned char brownie32_get_opcode PARAMS ((unsigned long));
+static unsigned char brownie32_get_rs1_31 PARAMS ((unsigned long));
+static unsigned char brownie32_get_rs1_26 PARAMS ((unsigned long));
+static unsigned char brownie32_get_rs1_15 PARAMS ((unsigned long));
+static unsigned char brownie32_get_rs1_10 PARAMS ((unsigned long));
+static unsigned char brownie32_get_rs2_26 PARAMS ((unsigned long));
+static unsigned char brownie32_get_rd_31  PARAMS ((unsigned long));
+static unsigned char brownie32_get_rd_21  PARAMS ((unsigned long));
+static unsigned char brownie32_get_rd_10  PARAMS ((unsigned long));
+static unsigned long brownie32_get_imm16  PARAMS ((unsigned long));
+static unsigned long brownie32_get_offset16 PARAMS ((unsigned long));
+static unsigned long brownie32_get_offset26 PARAMS ((unsigned long));
+static unsigned long brownie32_get_func PARAMS ((unsigned long));
+static unsigned long brownie32_get_func21 PARAMS ((unsigned long));
+
+static void     operand_deliminator PARAMS ((struct disassemble_info *, char *));
+static unsigned char brownie32_r_type     PARAMS ((struct disassemble_info *));
+static unsigned char brownie32_load_type  PARAMS ((struct disassemble_info *));
+static unsigned char brownie32_store_type PARAMS ((struct disassemble_info *));
+static unsigned char brownie32_ri_type    PARAMS ((struct disassemble_info *));
+static unsigned char brownie32_br_type    PARAMS ((struct disassemble_info *));
+static unsigned char brownie32_jmp_type   PARAMS ((struct disassemble_info *));
+static unsigned char brownie32_jr_type    PARAMS ((struct disassemble_info *));
+static unsigned char brownie32_sp_type    PARAMS ((struct disassemble_info *));
+static unsigned char brownie32_rt_type    PARAMS ((struct disassemble_info *));
+static int print_insn_brownie32 (bfd_vma memaddr, struct disassemble_info *info);
+
+/* Print one instruction from MEMADDR on INFO->STREAM.
+   Return the size of the instruction (always 4 on brownie32).  */
+
+static unsigned char
+brownie32_get_opcode (opcode)
+     unsigned long opcode;
+{
+  return (unsigned char) (opcode & 0x3F);
+}
+
+static unsigned char
+brownie32_get_rs1_31 (opcode)
+     unsigned long opcode;
+{
+  return (unsigned char) ((opcode >> 27) & 0x1F);
+}
+
+static unsigned char
+brownie32_get_rs1_26 (opcode)
+     unsigned long opcode;
+{
+  return (unsigned char) ((opcode >> 22) & 0x1F);
+}
+
+static unsigned char
+brownie32_get_rs1_15 (opcode)
+     unsigned long opcode;
+{
+  return (unsigned char) ((opcode >> 11) & 0x1F);
+}
+
+static unsigned char
+brownie32_get_rs1_10 (opcode)
+     unsigned long opcode;
+{
+  return (unsigned char) ((opcode >> 6) & 0x1F);
+}
+
+static unsigned char
+brownie32_get_rs2_26 (opcode)
+     unsigned long opcode;
+{
+  return (unsigned char) ((opcode >> 22) & 0x1F);
+}
+
+static unsigned char
+brownie32_get_rd_31 (opcode)
+     unsigned long opcode;
+{
+  return (unsigned char) ((opcode >> 27) & 0x1F);
+}
+
+static unsigned char
+brownie32_get_rd_21 (opcode)
+     unsigned long opcode;
+{
+  return (unsigned char) ((opcode >> 17) & 0x1F);
+}
+
+static unsigned char
+brownie32_get_rd_10 (opcode)
+     unsigned long opcode;
+{
+  return (unsigned char) ((opcode >> 6) & 0x1F);
+}
+
+static unsigned long
+brownie32_get_imm16 (opcode)
+     unsigned long opcode;
+{
+  return (unsigned long) ((opcode >> 16) & 0xFFFF);
+}
+
+static unsigned long
+brownie32_get_offset16 (opcode)
+     unsigned long opcode;
+{
+  return (unsigned long) ((opcode >> 16) & 0xFFFF);
+}
+
+static unsigned long
+brownie32_get_offset26 (opcode)
+     unsigned long opcode;
+{
+//  return (unsigned long) ((opcode >> 6) & 0xFFFF);  //C.Katano 
+  return (unsigned long) ((long)opcode >> 6);    
+}
+
+static unsigned long
+brownie32_get_func (opcode)
+     unsigned long opcode;
+{
+  return (unsigned long) (opcode & 0xFFFF);
+}
+
+static unsigned long
+brownie32_get_func21 (opcode)
+     unsigned long opcode;
+{
+  return (unsigned long) ((opcode >> 11) & 0x7FF); /* FIXMEE */
+}
+
+
+/* Fill the opcode to the max length.  */
+static void
+operand_deliminator (info, ptr)
+     struct disassemble_info *info;
+     char *ptr;
+{
+  int difft = 8 - (int) strlen (ptr);
+
+  while (difft > 0)
+    {
+      (*info->fprintf_func) (info->stream, "%c", ' ');
+      difft -= 1;
+    }
+}
+
+/* Process the R-type opcode.  */
+static unsigned char
+brownie32_r_type (info)
+     struct disassemble_info *info;
+{
+  unsigned char r_opc[] = { OPC(RRTYPOP) }; /* Fix ME */
+  int r_opc_num = (sizeof r_opc) / (sizeof (char));
+  struct _r_opcode
+  {
+    unsigned long func;
+    char *name;
+  }
+  brownie32_r_opcode[] =
+       {
+	{ (ADDFTYP|ADDFUNC|RRTYPOP),	"add"	}, /* ADD  (Rm + Rn)               */
+	{ (SUBFTYP|SUBFUNC|RRTYPOP),	"sub"	}, /* SUB  (Rm - Rn)               */
+	{ (MULFTYP|MULFUNC|RRTYPOP),	"mul"	}, /* MULTIPLY  (Rm * Rn)          */
+	{ (DIVFTYP|DIVFUNC|RRTYPOP),	"div"	}, /* DIVIDE    (Rm / Rn)          */
+	{ (DIVUFTYP|DIVUFUNC|RRTYPOP),	"divu"	}, /* DIVU      (Rm / Rn)          */
+	{ (MODFTYP|MODFUNC|RRTYPOP), 	"mod"	}, /* MOD       (Rm % Rn)          */
+	{ (MODUFTYP|MODUFUNC|RRTYPOP), 	"modu"	}, /* MODU      (Rm % Rn)          */
+	{ (ANDFTYP|ANDFUNC|RRTYPOP), 	"and"	}, /* AND       (Rm & Rn)          */
+	{ (NANDFTYP|NANDFUNC|RRTYPOP), 	"nand"	}, /* NAND      (Rm & Rn)          */
+	{ (ORFTYP|ORFUNC|RRTYPOP),	"or"	}, /* OR        (Rm | Rn)          */
+	{ (NORFTYP|NORFUNC|RRTYPOP),	"nor"	}, /* NOR       (Rm | Rn)          */
+	{ (XORFTYP|XORFUNC|RRTYPOP),	"xor"	}, /* EXCLUSIVE OR  (Rm ^ Rn)      */
+	{ (LLSFTYP|LLSFUNC|RRTYPOP),	"lls"	}, /* LOGICAL LEFT SHIFT           */
+	{ (LRSFTYP|LRSFUNC|RRTYPOP), 	"lrs"	}, /* LOGICAL RIGHT SHIFT          */
+	{ (ARSFTYP|ARSFUNC|RRTYPOP), 	"ars"	}, /* ARITHMETIC RIGHT SHIFT       */
+	{ (ELTFTYP|ELTFUNC|RRTYPOP), 	"elt"	}, /* SET IF LESS   SIGNED         */
+	{ (ELTUFTYP|ELTUFUNC|RRTYPOP), 	"eltu"	}, /* SET IF LESS UNSIGNED         */
+	{ (EEQFTYP|EEQFUNC|RRTYPOP),  	"eeq" 	}, /* SET IF EQUAL                 */
+	{ (ENEQFTYP|ENEQFUNC|RRTYPOP), 	"eneq"	}  /* SET IF NOT EQUAL             */
+       };
+// AO_patch
+//  {
+//    { NOPF,     "nop"    },  /* NOP                          */
+//    { ADDF,     "add"    },  /* Add                          */
+//    { ADDUF,    "addu"   },  /* Add Unsigned                 */
+//    { SUBF,     "sub"    },  /* SUB                          */
+//    { SUBUF,    "subu"   },  /* Sub Unsigned                 */
+//    { MULTF,    "mult"   },  /* MULTIPLY                     */
+//    { MULTUF,   "multu"  },  /* MULTIPLY Unsigned            */
+//    { DIVF,     "div"    },  /* DIVIDE                       */
+//    { DIVUF,    "divu"   },  /* DIVIDE Unsigned              */
+//    { ANDF,     "and"    },  /* AND                          */
+//    { ORF,      "or"     },  /* OR                           */
+//    { XORF,     "xor"    },  /* Exclusive OR                 */
+//    { SLLF,     "sll"    },  /* SHIFT LEFT LOGICAL           */
+//    { SRAF,     "sra"    },  /* SHIFT RIGHT ARITHMETIC       */
+//    { SRLF,     "srl"    },  /* SHIFT RIGHT LOGICAL          */
+//    { SEQF,     "seq"    },  /* Set if equal                 */
+//    { SNEF,     "sne"    },  /* Set if not equal             */
+//    { SLTF,     "slt"    },  /* Set if less                  */
+//    { SGTF,     "sgt"    },  /* Set if greater               */
+//    { SLEF,     "sle"    },  /* Set if less or equal         */
+//    { SGEF,     "sge"    },  /* Set if greater or equal      */
+//    { SEQUF,    "sequ"   },  /* Set if equal                 */
+//    { SNEUF,    "sneu"   },  /* Set if not equal             */
+//    { SLTUF,    "sltu"   },  /* Set if less                  */
+//    { SGTUF,    "sgtu"   },  /* Set if greater               */
+//    { SLEUF,    "sleu"   },  /* Set if less or equal         */
+//    { SGEUF,    "sgeu"   },  /* Set if greater or equal      */
+//    { MVTSF,    "mvts"   },  /* Move to special register     */
+//    { MVFSF,    "mvfs"   },  /* Move from special register   */
+//    { BSWAPF,   "bswap"  },  /* Byte swap ??                 */
+//    { LUTF,     "lut"    }   /* ????????? ??                 */
+//  };
+
+  int brownie32_r_opcode_num = (sizeof brownie32_r_opcode) / (sizeof brownie32_r_opcode[0]);
+  int idx;
+
+  for (idx = 0; idx < r_opc_num; idx++)
+    {
+      if (r_opc[idx] != opc)
+	continue;
+      else
+	break;
+  }
+
+  if (idx == r_opc_num)
+    return NIL;
+
+  for (idx = 0 ; idx < brownie32_r_opcode_num; idx++)
+    if (brownie32_r_opcode[idx].func == func)
+      {
+	(*info->fprintf_func) (info->stream, "%s", brownie32_r_opcode[idx].name);
+	if (func != NOPOP)
+	  {
+	    /* This is not a nop.  */
+	    operand_deliminator (info, brownie32_r_opcode[idx].name);
+	    (*info->fprintf_func) (info->stream, "r%d,", (int)rd_21);
+	    (*info->fprintf_func) (info->stream, "r%d", (int)rs1_31);
+            (*info->fprintf_func) (info->stream, ",r%d", (int)rs2_26);
+	  }
+	return (unsigned char) R_TYPE;
+      }
+  return (unsigned char) R_ERROR;
+}
+
+/* Process the memory read opcode.  */
+
+static unsigned char
+brownie32_load_type (info)
+     struct disassemble_info* info;
+{
+  struct _load_opcode
+  {
+    unsigned long opcode;
+    char *name;
+  }
+  brownie32_load_opcode[] =
+    {
+      { OPC(LBOP),     "lb" },  /* load byte sign extended.       */
+      { OPC(LHOP),     "lh" },  /* load halfword sign extended.   */
+      { OPC(LWOP),     "lw" }   /* load halfword sign extended.   */
+    };
+// AO_patch
+//  {
+//      { OPC(LHIOP),   "lhi" },  /* Load HI to register.           */
+//      { OPC(LBOP),     "lb" },  /* load byte sign extended.       */
+//      { OPC(LBUOP),   "lbu" },  /* load byte unsigned.            */
+//      { OPC(LSBUOP),"ldstbu"},  /* load store byte unsigned.      */
+//      { OPC(LHOP),     "lh" },  /* load halfword sign extended.   */
+//      { OPC(LHUOP),   "lhu" },  /* load halfword unsigned.        */
+//      { OPC(LSHUOP),"ldsthu"},  /* load store halfword unsigned.  */
+//      { OPC(LWOP),     "lw" },  /* load word.                     */
+//      { OPC(LSWOP), "ldstw" }   /* load store word.               */
+//    };
+
+  int brownie32_load_opcode_num =
+    (sizeof brownie32_load_opcode) / (sizeof brownie32_load_opcode[0]);
+  int idx;
+
+  for (idx = 0 ; idx < brownie32_load_opcode_num; idx++)
+    if (brownie32_load_opcode[idx].opcode == opc)
+      {
+         (*info->fprintf_func) (info->stream, "%s", brownie32_load_opcode[idx].name);
+         operand_deliminator (info, brownie32_load_opcode[idx].name);
+         (*info->fprintf_func) (info->stream, "r%d,", (int)rd_10);
+         (*info->fprintf_func) (info->stream, "0x%04x[r%d]", (int)offset16, (int)rs1_15);
+         return (unsigned char) ILD_TYPE;
+       }
+     return (unsigned char) NIL;
+     }
+
+/* Process the memory store opcode.  */
+
+static unsigned char
+brownie32_store_type (info)
+     struct disassemble_info* info;
+{
+  struct _store_opcode
+  {
+    unsigned long opcode;
+    char *name;
+  }
+  brownie32_store_opcode[] =
+    {
+      { OPC(SBOP),     "sb" },  /* store byte sign extended.       */
+      { OPC(SHOP),     "sh" },  /* store halfword sign extended.   */
+      { OPC(SWOP),     "sw" }   /* store halfword sign extended.   */
+    };
+// AO_patch
+//    {
+//      { OPC(SBOP),     "sb" },  /* Store byte.      */
+//      { OPC(SHOP),     "sh" },  /* Store halfword.  */
+//      { OPC(SWOP),     "sw" },  /* Store word.      */
+//    };
+  int brownie32_store_opcode_num =
+    (sizeof brownie32_store_opcode) / (sizeof brownie32_store_opcode[0]);
+  int idx;
+
+  for (idx = 0 ; idx < brownie32_store_opcode_num; idx++)
+    if (brownie32_store_opcode[idx].opcode == opc)
+      {
+         (*info->fprintf_func) (info->stream, "%s", brownie32_store_opcode[idx].name);
+         operand_deliminator (info, brownie32_store_opcode[idx].name);
+         (*info->fprintf_func) (info->stream, "0x%04x[r%d],", (int)offset16, (int)rd_10);
+         (*info->fprintf_func) (info->stream, "r%d", (int)rs1_15);
+	return (unsigned char) IST_TYPE;
+      }
+  return (unsigned char) NIL;
+}
+
+/* Process the Arithmetic and Logical RI-TYPE opcode.  */
+
+static unsigned char
+brownie32_ri_type (info)
+     struct disassemble_info* info;
+{
+  struct _aluI_opcode
+  {
+    unsigned long opcode;
+    char *name;
+  }
+  brownie32_aluI_opcode[] =
+       {
+           { OPC(ADDIOP),   "addi" },                    /* ADD  (Rm + Immediate)             */
+           { OPC(SUBIOP),   "subi" },                    /* SUB  (Rm - Immediate)             */
+           { OPC(ANDIOP),   "andi" },                    /* AND  (Rm & Immediate)             */
+           { OPC(ORIOP) ,   "ori"  },                    /* OR   (Rm | Immediate)             */
+           { OPC(XORIOP),   "xori" },                    /* EXCLUSIVE OR  (Rm ^ Immediate)    */
+           { OPC(LLSIOP),   "llsi" },                    /* LOGICAL LEFT SHIFT Immediate      */
+           { OPC(LRSIOP),   "lrsi" },                    /* LOGICAL LEFT SHIFT Immediate      */
+           { OPC(ARSIOP),   "arsi" },                    /* ARITHMETIC RIGHT SHIFT Immediate  */
+           { OPC(LSOIOP),   "lsoi" }                     /* 16bit LEFT SHIFT and OR Immediate */
+       };
+// AO_patch
+//
+//    {
+//      { OPC(ADDIOP),   "addi"  },  /* Store byte.      */
+//      { OPC(ADDUIOP),  "addui" },  /* Store halfword.  */
+//      { OPC(SUBIOP),   "subi"  },  /* Store word.      */
+//      { OPC(SUBUIOP),  "subui" },  /* Store word.      */
+//      { OPC(ANDIOP),   "andi"  },  /* Store word.      */
+//      { OPC(ORIOP),    "ori"   },  /* Store word.      */
+//      { OPC(XORIOP),   "xori"  },  /* Store word.      */
+//      { OPC(SLLIOP),   "slli"  },  /* Store word.      */
+//      { OPC(SRAIOP),   "srai"  },  /* Store word.      */
+//      { OPC(SRLIOP),   "srli"  },  /* Store word.      */
+//      { OPC(SEQIOP),   "seqi"  },  /* Store word.      */
+//      { OPC(SNEIOP),   "snei"  },  /* Store word.      */
+//      { OPC(SLTIOP),   "slti"  },  /* Store word.      */
+//      { OPC(SGTIOP),   "sgti"  },  /* Store word.      */
+//      { OPC(SLEIOP),   "slei"  },  /* Store word.      */
+//      { OPC(SGEIOP),   "sgei"  },  /* Store word.      */
+//      { OPC(SEQUIOP),  "sequi" },  /* Store word.      */
+//      { OPC(SNEUIOP),  "sneui" },  /* Store word.      */
+//      { OPC(SLTUIOP),  "sltui" },  /* Store word.      */
+//      { OPC(SGTUIOP),  "sgtui" },  /* Store word.      */
+//      { OPC(SLEUIOP),  "sleui" },  /* Store word.      */
+//      { OPC(SGEUIOP),  "sgeui" },  /* Store word.      */
+//#if 0						       
+//      { OPC(MVTSOP),   "mvts"  },  /* Store word.      */
+//      { OPC(MVFSOP),   "mvfs"  },  /* Store word.      */
+//#endif
+//    };
+
+
+  int brownie32_aluI_opcode_num =
+    (sizeof brownie32_aluI_opcode) / (sizeof brownie32_aluI_opcode[0]);
+  int idx;
+  for (idx = 0 ; idx < brownie32_aluI_opcode_num; idx++)
+    if (brownie32_aluI_opcode[idx].opcode == opc)
+      {
+	(*info->fprintf_func) (info->stream, "%s", brownie32_aluI_opcode[idx].name);
+	operand_deliminator (info, brownie32_aluI_opcode[idx].name);
+	(*info->fprintf_func) (info->stream, "r%d,", (int)rd_10);
+	(*info->fprintf_func) (info->stream, "r%d,", (int)rs1_15);
+	(*info->fprintf_func) (info->stream, "0x%04x", (int)imm16);
+	return (unsigned char) IRI_TYPE;
+      }
+
+  return (unsigned char) NIL;
+}
+
+/* Process the branch instruction.  */
+
+static unsigned char
+brownie32_br_type (info)
+     struct disassemble_info* info;
+{
+  struct _br_opcode
+  {
+    unsigned long opcode;
+    char *name;
+  }
+  brownie32_br_opcode[] =
+      {
+        { OPC(BRZOP),   "brz" },
+        { OPC(BRNZOP),  "brnz" }
+      };
+// AO_patch
+//
+//    {
+//      { OPC(BEQOP), "beqz" }, /* Store byte.  */
+//      { OPC(BNEOP), "bnez" }  /* Store halfword.  */
+//    };
+
+  int brownie32_br_opcode_num =
+    (sizeof brownie32_br_opcode) / (sizeof brownie32_br_opcode[0]);
+  int idx;
+
+  for (idx = 0 ; idx < brownie32_br_opcode_num; idx++)
+    if (brownie32_br_opcode[idx].opcode == opc)
+      {
+	if (offset16 & 0x00008000)
+	  offset16 |= 0xFFFF0000;
+
+	imm16 += (current_insn_addr + 4);
+	(*info->fprintf_func) (info->stream, "%s", brownie32_br_opcode[idx].name);
+	operand_deliminator (info, brownie32_br_opcode[idx].name);
+	(*info->fprintf_func) (info->stream, "r%d,", (int)rs1_15);
+	(*info->fprintf_func) (info->stream, "0x%08x", (int)offset16);
+
+	return (unsigned char) IBR_TYPE;
+      }
+
+  return (unsigned char) NIL;
+}
+
+/* Process the jump instruction.  */
+
+static unsigned char
+brownie32_jmp_type (info)
+     struct disassemble_info* info;
+{
+  struct _jmp_opcode
+  {
+    unsigned long opcode;
+    char *name;
+  }
+  brownie32_jmp_opcode[] =
+       {
+           { OPC(JPOP),     "jp"   },                    /* RELATIVE JUMP                    */
+           { OPC(JPLOP),    "jpl"  },                    /* SET NEXT ADDR AND RELATIVE JUMP  */
+           { OPC(TRAPOP),   "trap" }                     /* OCCURE SOFTWARE INTERRUPT        */
+       };
+// AO_patch
+//
+//      { OPC(JOP),         "j" },  /* Store byte.      */
+//      { OPC(JALOP),     "jal" },  /* Store halfword.  */
+//      { OPC(BREAKOP), "break" },  /* Store halfword.  */
+//      { OPC(TRAPOP),   "trap" },  /* Store halfword.  */
+//      { OPC(RFEOP),     "rfe" }   /* Store halfword.  */
+//    };
+
+  int brownie32_jmp_opcode_num =
+    (sizeof brownie32_jmp_opcode) / (sizeof brownie32_jmp_opcode[0]);
+  int idx;
+
+  for (idx = 0 ; idx < brownie32_jmp_opcode_num; idx++)
+    if (brownie32_jmp_opcode[idx].opcode == opc)
+      {
+	if (offset26 & 0x02000000)
+	  offset26 |= 0xFC000000;
+
+	imm26 += (current_insn_addr + 4);
+
+	(*info->fprintf_func) (info->stream, "%s", brownie32_jmp_opcode[idx].name);
+	operand_deliminator (info, brownie32_jmp_opcode[idx].name);
+	(*info->fprintf_func) (info->stream, "0x%08x", (int)offset26);
+
+	return (unsigned char) IJ_TYPE;
+      }
+
+  return (unsigned char) NIL;
+}
+
+/* Process the jump register instruction.  */
+
+static unsigned char
+brownie32_jr_type (info)
+     struct disassemble_info* info;
+{
+  struct _jr_opcode
+  {
+    unsigned long opcode;
+    char *name;
+  }
+  brownie32_jr_opcode[] = 
+       {
+          { OPC(JPROP),    "jpr"  },                   /* ABSOLUTE JUMP                    */
+          { OPC(JPRLOP),   "jprl" }                    /* SET NEXT ADDR AND ABSOLUTE JUMP  */
+       };
+// AO_patch
+//
+//    { OPC(JROP),   "jr"    },  /* Store byte.  */
+//    { OPC(JALROP), "jalr"  }   /* Store halfword.  */
+//  };
+
+
+  int brownie32_jr_opcode_num =
+    (sizeof brownie32_jr_opcode) / (sizeof brownie32_jr_opcode[0]);
+  int idx;
+
+  for (idx = 0 ; idx < brownie32_jr_opcode_num; idx++)
+    if (brownie32_jr_opcode[idx].opcode == opc)
+      {
+	(*info->fprintf_func) (info->stream, "%s", brownie32_jr_opcode[idx].name);
+	operand_deliminator (info, brownie32_jr_opcode[idx].name);
+	(*info->fprintf_func) (info->stream, "r%d", (int)rs1_10);
+	return (unsigned char) IJR_TYPE;
+      }
+
+  return (unsigned char) NIL;
+}
+
+
+/* Process the Special instruction.  */
+
+static unsigned char
+brownie32_sp_type (info)
+     struct disassemble_info* info;
+{
+  struct _sp_opcode
+  {
+    unsigned long opcode;
+    char *name;
+  }
+  brownie32_sp_opcode[] = 
+       {
+          { RETIOP&0x7F,   "reti" },                    /* RETI                   */
+          { NOPOP&0x7F,    "nop"  }                     /* NOP                    */
+       };
+
+  int brownie32_sp_opcode_num =
+    (sizeof brownie32_sp_opcode) / (sizeof brownie32_sp_opcode[0]);
+  int idx;
+
+  for (idx = 0 ; idx < brownie32_sp_opcode_num; idx++)
+    if (brownie32_sp_opcode[idx].opcode == (func&0xFF) )
+      {
+	(*info->fprintf_func) (info->stream, "%s", brownie32_sp_opcode[idx].name);
+	operand_deliminator (info, brownie32_sp_opcode[idx].name);
+	return (unsigned char) ISP_TYPE;
+      }
+
+  return (unsigned char) NIL;
+}
+
+/* Process the extend to word instruction.  */
+
+static unsigned char
+brownie32_rt_type (info)
+     struct disassemble_info* info;
+{
+  struct _rt_opcode
+  {
+    unsigned long opcode;
+    char *name;
+  }
+  brownie32_rt_opcode[] = 
+       {
+          { EXBWOP&0xFFF,   "exbw" },                   /* EXBW                   */
+          { EXHWOP&0xFFF,   "exhw" }                    /* NOP                    */
+       };
+
+  int brownie32_rt_opcode_num =
+    (sizeof brownie32_rt_opcode) / (sizeof brownie32_rt_opcode[0]);
+  int idx;
+
+  for (idx = 0 ; idx < brownie32_rt_opcode_num; idx++)
+    if (brownie32_rt_opcode[idx].opcode == (func&0xFFF) )
+      {
+	(*info->fprintf_func) (info->stream, "%s", brownie32_rt_opcode[idx].name);
+	operand_deliminator (info, brownie32_rt_opcode[idx].name);
+	(*info->fprintf_func) (info->stream, "r%d,", (int)rd_31);
+	(*info->fprintf_func) (info->stream, "r%d", (int)rs1_26);
+	return (unsigned char) IRT_TYPE;
+      }
+
+  return (unsigned char) NIL;
+}
+
+typedef unsigned char (* brownie32_insn) PARAMS ((struct disassemble_info *));
+
+/* This is the main BROWNIE32 insn handling routine.  */
+
+int
+print_insn_brownie32 (memaddr, info)
+     bfd_vma memaddr;
+     struct disassemble_info* info;
+{
+  bfd_byte buffer[4];
+  int insn_idx;
+  unsigned long insn_word;
+  unsigned char rtn_code;
+  unsigned long brownie32_insn_type[] =
+    {
+      (unsigned long) brownie32_r_type,
+      (unsigned long) brownie32_load_type,
+      (unsigned long) brownie32_store_type,
+      (unsigned long) brownie32_ri_type,
+      (unsigned long) brownie32_br_type,
+      (unsigned long) brownie32_jmp_type,
+      (unsigned long) brownie32_jr_type,
+      (unsigned long) brownie32_sp_type,
+      (unsigned long) brownie32_rt_type,
+      (unsigned long) NULL
+  };
+  int brownie32_insn_type_num = ((sizeof brownie32_insn_type) / (sizeof (unsigned long))) - 1;
+  int status =
+    (*info->read_memory_func) (memaddr, (bfd_byte *) &buffer[0], 4, info);
+
+  if (status != 0)
+    {
+      (*info->memory_error_func) (status, memaddr, info);
+      return -1;
+    }
+
+  /* Now decode the insn    */
+  insn_word = bfd_getb32 (buffer);
+  opc  = brownie32_get_opcode (insn_word);
+  rs1_31 = brownie32_get_rs1_31 (insn_word);
+  rs1_26 = brownie32_get_rs1_26 (insn_word);
+  rs1_15 = brownie32_get_rs1_15 (insn_word);
+  rs1_10 = brownie32_get_rs1_10 (insn_word);
+  rs2_26 = brownie32_get_rs2_26 (insn_word);
+  rd_31  = brownie32_get_rd_31 (insn_word);
+  rd_21  = brownie32_get_rd_21 (insn_word);
+  rd_10  = brownie32_get_rd_10 (insn_word);
+  imm16  = brownie32_get_imm16 (insn_word);
+  offset16 = brownie32_get_offset16 (insn_word);
+  offset26 = brownie32_get_offset26 (insn_word);
+  func     = brownie32_get_func (insn_word);
+  func21   = brownie32_get_func21 (insn_word);
+// AO_patch
+//  rs2  = brownie32_get_rs2 (insn_word);
+//  rd   = brownie32_get_rdR (insn_word);
+//  func = brownie32_get_func (insn_word);
+//  imm16= brownie32_get_imm16 (insn_word);
+//  imm26= brownie32_get_imm26 (insn_word);
+
+#if 0
+  printf ("print_insn_big_brownie32: opc = 0x%02x\n"
+	  "                    rs1_31 = 0x%02x\n"
+	  "                    rs2_26 = 0x%02x\n"
+	  "                    rd_21  = 0x%02x\n"
+	  "                    func  = 0x%08x\n",
+	  opc, rs1_31, rs2_26, rd_21, func);
+#endif
+
+  /* Scan through all the insn type and print the insn out.  */
+  rtn_code = 0;
+  current_insn_addr = (unsigned long) memaddr;
+
+  for (insn_idx = 0; brownie32_insn_type[insn_idx] != 0x0; insn_idx++)
+    switch (((brownie32_insn) (brownie32_insn_type[insn_idx])) (info))
+      {
+	/* Found the correct opcode   */
+      case R_TYPE:
+      case ILD_TYPE:
+      case IST_TYPE:
+      case IRI_TYPE:
+      case IBR_TYPE:
+      case IJ_TYPE:
+      case IJR_TYPE:
+      case ISP_TYPE:
+      case IRT_TYPE:
+	return 4;
+
+	/* Wrong insn type check next one. */
+      default:
+      case NIL:
+	continue;
+
+	/* All rest of the return code are not recongnized, treat it as error */
+	/* we should never get here,  I hope! */
+      case R_ERROR:
+	return -1;
+      }
+
+  if (insn_idx ==  brownie32_insn_type_num)
+    /* Well, does not recoganize this opcode.  */
+    (*info->fprintf_func) (info->stream, "<%s>", "Unrecognized Opcode");
+
+  return 4;
+}
+
+
+int
+print_insn_big_brownie32 (bfd_vma memaddr, struct disassemble_info *info)
+{
+  return print_insn_brownie32 (memaddr, info);
+}
+
+int
+print_insn_little_brownie32 (bfd_vma memaddr, struct disassemble_info *info)
+{
+  return print_insn_brownie32 (memaddr, info);
+}
Index: opcodes/brownie32-opc.c
===================================================================
RCS file: opcodes/brownie32-opc.c
diff -N opcodes/brownie32-opc.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ opcodes/brownie32-opc.c	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,95 @@
+/* brownie32-opc.c -- BROWNIE32 opcode list.
+   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
+   2003, 2004, 2005 Free Software Foundation, Inc.
+   Contributed by Ralph Campbell and OSF
+   Commented and modified by Ian Lance Taylor, Cygnus Support
+   Extended for BROWNIE3232 support by Anders Norlander, and by SiByte, Inc.
+   BROWNIE32-3D, MDMX, and BROWNIE3232 Release 2 support added by Broadcom
+   Corporation (SiByte).
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+This file is part of GDB, GAS, and the GNU binutils.
+
+GDB, GAS, and the GNU binutils are free software; you can redistribute
+them and/or modify them under the terms of the GNU General Public
+License as published by the Free Software Foundation; either version
+1, or (at your option) any later version.
+
+GDB, GAS, and the GNU binutils are distributed in the hope that they
+will be useful, but WITHOUT ANY WARRANTY; without even the implied
+warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this file; see the file COPYING.  If not, write to the Free
+Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#include <stdio.h>
+#include "sysdep.h"
+#include "opcode/brownie32.h"
+
+const struct brownie32_opcode brownie32_opcodes[] =
+  {
+
+  /* Arithmetic and Logic RR-TYPE instructions.  */
+    { "add",      (RRTYPOP|ADDFUNC|ADDFTYP),     "e,a,d" }, /* ADD  (Rm + Rn)                    */
+    { "sub",      (RRTYPOP|SUBFUNC|SUBFTYP),     "e,a,d" }, /* SUB  (Rm - Rn)                    */
+    { "mul",      (RRTYPOP|MULFUNC|MULFTYP),     "e,a,d" }, /* MULTIPLY  (Rm * Rn)               */
+    { "div",      (RRTYPOP|DIVFUNC|DIVFTYP),     "e,a,d" }, /* DIVIDE    (Rm / Rn)               */
+    { "mod",      (RRTYPOP|MODFUNC|MODFTYP),     "e,a,d" }, /* MOD       (Rm % Rn)               */
+    { "and",      (RRTYPOP|ANDFUNC|ANDFTYP),     "e,a,d" }, /* AND       (Rm & Rn)               */
+    { "or",       (RRTYPOP|ORFUNC|ORFTYP),       "e,a,d" }, /* OR        (Rm | Rn)               */
+    { "xor",      (RRTYPOP|XORFUNC|XORFTYP),     "e,a,d" }, /* EXCLUSIVE OR  (Rm ^ Rn)           */
+    { "lls",      (RRTYPOP|LLSFUNC|LLSFTYP),     "e,a,d" }, /* LOGICAL LEFT SHIFT                */
+    { "lrs",      (RRTYPOP|LRSFUNC|LRSFTYP),     "e,a,d" }, /* LOGICAL RIGHT SHIFT               */
+    { "ars",      (RRTYPOP|ARSFUNC|ARSFTYP),     "e,a,d" }, /* ARITHMETIC RIGHT SHIFT            */
+    { "elt",      (RRTYPOP|ELTFUNC|ELTFTYP),     "e,a,d" },  /* SET IF LESS   SIGNED             */
+    { "eltu",     (RRTYPOP|ELTUFUNC|ELTUFTYP),   "e,a,d" }, /* SET IF LESS UNSIGNED              */
+    { "eeq",      (RRTYPOP|EEQFUNC|EEQFTYP),     "e,a,d" }, /* SET IF EQUAL                      */
+    { "eneq",      (RRTYPOP|ENEQFUNC|ENEQFTYP),  "e,a,d" }, /* SET IF NOT EQUAL                  */
+  /* Arithmetic and Logic RI-TYPE instructions.  */
+    { "addi",     (ADDIOP),   "f,b,i" },                    /* ADD  (Rm + Immediate)             */
+    { "subi",     (SUBIOP),   "f,b,i" },                    /* SUB  (Rm - Immediate)             */
+    { "andi",     (ANDIOP),   "f,b,i" },                    /* AND  (Rm & Immediate)             */
+    { "ori",       (ORIOP),   "f,b,i" },                    /* OR   (Rm | Immediate)             */
+    { "xori",     (XORIOP),   "f,b,i" },                    /* EXCLUSIVE OR  (Rm ^ Immediate)    */
+    { "llsi",     (LLSIOP),   "f,b,i" },                    /* LOGICAL LEFT SHIFT Immediate      */
+    { "lrsi",     (LRSIOP),   "f,b,i" },                    /* LOGICAL LEFT SHIFT Immediate      */
+    { "arsi",     (ARSIOP),   "f,b,i" },                    /* ARITHMETIC RIGHT SHIFT Immediate  */
+    { "lsoi",     (LSOIOP),   "f,b,i" },                    /* 16bit LEFT SHIFT and OR Immediate */
+  /* Arithmetic and Logic MA-TYPE instructions.  */
+    { "lb",     (LBOP),    "f,b,o" },                       /* LOAD 1BYTE DATA                   */
+    { "lh",     (LHOP),    "f,b,o" },                       /* LOAD 2BYTE DATA                   */
+    { "lw",     (LWOP),    "f,b,o" },                       /* LOAD 4BYTE DATA                   */
+    { "sb",     (SBOP),    "b,f,o" },                       /* STORE 1BYTE DATA                  */
+    { "sh",     (SHOP),    "b,f,o" },                       /* STORE 2BYTE DATA                  */
+    { "sw",     (SWOP),    "b,f,o" },                       /* STORE 4BYTE DATA                  */
+  /* Arithmetic and Logic BR-TYPE instructions.  */
+    { "brz",     (BRZOP),   "b,o" },                        /* BRANCH IF RS1 == 0                */
+    { "brnz",    (BRNZOP),  "b,o" },                        /* BRANCH IF RS1 != 0                */
+  /* Arithmetic and Logic JP-TYPE instructions.  */
+    { "jp",     (JPOP),     "O" },                        /* RELATIVE JUMP                    */
+    { "jpl",    (JPLOP),    "O" },                        /* SET NEXT ADDR AND RELATIVE JUMP  */
+    { "trap",   (TRAPOP),   "O" },                        /* OCCURE SOFTWARE INTERRUPT        */
+  /* Arithmetic and Logic JPR-TYPE instructions.  */
+    { "jpr",     (JPROP),    "c" },                        /* ABSOLUTE JUMP                    */
+    { "jprl",    (JPRLOP),   "c" },                        /* SET NEXT ADDR AND ABSOLUTE JUMP  */
+  /* Arithmetic and Logic SP-TYPE instructions.  */
+    { "nop",     (NOPOP),   "N" },                        /* NOT OPERATTON                    */
+    { "reti",    (RETIOP),  "N" },                        /* RETURN FROM INTERRUPT ROUTINE    */
+
+    { "", 0x0, "" }		/* Dummy entry, not included in NUM_OPCODES.
+				   This lets code examine entry i + 1 without
+				   checking if we've run off the end of the table.  */
+
+  };
+
+#define BROWNIE32_NUM_OPCODES \
+	(((sizeof brownie32_opcodes) / (sizeof brownie32_opcodes[0])) - 1);
+const int num_brownie32_opcodes = BROWNIE32_NUM_OPCODES;
+
+/* const removed from the following to allow for dynamic extensions to the
+ * built-in instruction set. */
+int bfd_brownie32_num_opcodes = BROWNIE32_NUM_OPCODES;
+#undef BROWNIE32_NUM_OPCODES
Index: opcodes/configure
===================================================================
RCS file: /home/prj/asip/cvs/gdb/opcodes/configure,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -p -r1.1.1.1 -r1.3
--- opcodes/configure	31 Jul 2007 11:40:27 -0000	1.1.1.1
+++ opcodes/configure	12 Feb 2008 08:53:02 -0000	1.3
@@ -3,6 +3,7 @@
 # Generated by GNU Autoconf 2.59.
 #
 # Copyright (C) 2003 Free Software Foundation, Inc.
+# Copyright (C) 2005,2006  Upwind technology, Inc.
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
 ## --------------------- ##
@@ -8724,6 +8725,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_maxq_arch)		ta="$ta maxq-dis.lo" ;;
 	bfd_mcore_arch)		ta="$ta mcore-dis.lo" ;;
 	bfd_mips_arch)		ta="$ta mips-dis.lo mips-opc.lo mips16-opc.lo" ;;
+	bfd_brownie32_arch)	ta="$ta brownie32-dis.lo" ;;
 	bfd_mmix_arch)		ta="$ta mmix-dis.lo mmix-opc.lo" ;;
 	bfd_mn10200_arch)	ta="$ta m10200-dis.lo m10200-opc.lo" ;;
 	bfd_mn10300_arch)	ta="$ta m10300-dis.lo m10300-opc.lo" ;;
@@ -8899,9 +8901,10 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   # 1. Remove the extension, and $U if already installed.
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
-  # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
-  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
 
Index: opcodes/configure.in
===================================================================
RCS file: /home/prj/asip/cvs/gdb/opcodes/configure.in,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -p -r1.1.1.1 -r1.3
--- opcodes/configure.in	31 Jul 2007 11:40:27 -0000	1.1.1.1
+++ opcodes/configure.in	12 Feb 2008 08:53:33 -0000	1.3
@@ -184,6 +184,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_maxq_arch)		ta="$ta maxq-dis.lo" ;;
 	bfd_mcore_arch)		ta="$ta mcore-dis.lo" ;;
 	bfd_mips_arch)		ta="$ta mips-dis.lo mips-opc.lo mips16-opc.lo" ;;
+	bfd_brownie32_arch)	ta="$ta brownie32-dis.lo" ;;
 	bfd_mmix_arch)		ta="$ta mmix-dis.lo mmix-opc.lo" ;;
 	bfd_mn10200_arch)	ta="$ta m10200-dis.lo m10200-opc.lo" ;;
 	bfd_mn10300_arch)	ta="$ta m10300-dis.lo m10300-opc.lo" ;;
Index: readline/configure
===================================================================
RCS file: /home/prj/asip/cvs/gdb/readline/configure,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- readline/configure	31 Jul 2007 11:40:32 -0000	1.1.1.1
+++ readline/configure	8 Aug 2007 08:49:54 -0000	1.2
@@ -7018,9 +7018,10 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   # 1. Remove the extension, and $U if already installed.
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
-  # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
-  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
 
Index: readline/support/config.sub
===================================================================
RCS file: /home/prj/asip/cvs/gdb/readline/support/config.sub,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- readline/support/config.sub	31 Jul 2007 11:40:32 -0000	1.1.1.1
+++ readline/support/config.sub	8 Aug 2007 08:49:54 -0000	1.2
@@ -2,8 +2,9 @@
 # Configuration validation subroutine script.
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 #   2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+#   Copyright (C) 2005,2006  Upwind technology, Inc.
 
-timestamp='2004-02-16'
+timestamp='2006-10-17'
 
 # This file is (in principle) common to ALL GNU software.
 # The presence of a machine in this file suggests that SOME GNU software
@@ -139,7 +140,7 @@ case $os in
 	-sun*os*)
 		# Prevent following clause from handling this invalid input.
 		;;
-	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
+	-dec* | -mips* | -brownie32 | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
 	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
 	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
 	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
@@ -253,6 +254,21 @@ case $basic_machine in
 	| mipsisa64sb1 | mipsisa64sb1el \
 	| mipsisa64sr71k | mipsisa64sr71kel \
 	| mipstx39 | mipstx39el \
+	| brownie32 | brownie32be | brownie32eb | brownie32el | brownie32le \
+	| brownie3216 \
+	| brownie3264 | brownie3264el \
+	| brownie3264vr | brownie3264vrel \
+	| brownie3264orion | brownie3264orionel \
+	| brownie3264vr4100 | brownie3264vr4100el \
+	| brownie3264vr4300 | brownie3264vr4300el \
+	| brownie3264vr5000 | brownie3264vr5000el \
+	| brownie32isa32 | brownie32isa32el \
+	| brownie32isa32r2 | brownie32isa32r2el \
+	| brownie32isa64 | brownie32isa64el \
+	| brownie32isa64r2 | brownie32isa64r2el \
+	| brownie32isa64sb1 | brownie32isa64sb1el \
+	| brownie32isa64sr71k | brownie32isa64sr71kel \
+	| brownie32tx39 | brownie32tx39el \
 	| mn10200 | mn10300 \
 	| msp430 \
 	| ns16k | ns32k \
@@ -326,6 +342,21 @@ case $basic_machine in
 	| mipsisa64sb1-* | mipsisa64sb1el-* \
 	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
 	| mipstx39-* | mipstx39el-* \
+	| brownie32-* | brownie32be-* | brownie32eb-* | brownie32el-* | brownie32le-* \
+	| brownie3216-* \
+	| brownie3264-* | brownie3264el-* \
+	| brownie3264vr-* | brownie3264vrel-* \
+	| brownie3264orion-* | brownie3264orionel-* \
+	| brownie3264vr4100-* | brownie3264vr4100el-* \
+	| brownie3264vr4300-* | brownie3264vr4300el-* \
+	| brownie3264vr5000-* | brownie3264vr5000el-* \
+	| brownie32isa32-* | brownie32isa32el-* \
+	| brownie32isa32r2-* | brownie32isa32r2el-* \
+	| brownie32isa64-* | brownie32isa64el-* \
+	| brownie32isa64r2-* | brownie32isa64r2el-* \
+	| brownie32isa64sb1-* | brownie32isa64sb1el-* \
+	| brownie32isa64sr71k-* | brownie32isa64sr71kel-* \
+	| brownie32tx39-* | brownie32tx39el-* \
 	| msp430-* \
 	| none-* | np1-* | nv1-* | ns16k-* | ns32k-* \
 	| orion-* \
@@ -655,6 +686,12 @@ case $basic_machine in
 	mips3*)
 		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
 		;;
+	brownie323*-*)
+		basic_machine=`echo $basic_machine | sed -e 's/brownie323/brownie3264/'`
+		;;
+	brownie323*)
+		basic_machine=`echo $basic_machine | sed -e 's/brownie323/brownie3264/'`-unknown
+		;;
 	mmix*)
 		basic_machine=mmix-knuth
 		os=-mmixware
@@ -1355,6 +1392,12 @@ case $basic_machine in
 	mips*-*)
 		os=-elf
 		;;
+	brownie32*-cisco)
+		os=-elf
+		;;
+	brownie32*-*)
+		os=-elf
+		;;
 	or32-*)
 		os=-coff
 		;;
Index: sim/configure
===================================================================
RCS file: /home/prj/asip/cvs/gdb/sim/configure,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- sim/configure	31 Jul 2007 11:40:27 -0000	1.1.1.1
+++ sim/configure	8 Aug 2007 08:49:54 -0000	1.2
@@ -3,6 +3,7 @@
 # Generated by GNU Autoconf 2.59.
 #
 # Copyright (C) 2003 Free Software Foundation, Inc.
+# Copyright (C) 2005,2006  Upwind technology, Inc.
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
 ## --------------------- ##
@@ -282,6 +283,7 @@ ac_subdirs_all="$ac_subdirs_all m32r"
 ac_subdirs_all="$ac_subdirs_all m68hc11"
 ac_subdirs_all="$ac_subdirs_all mcore"
 ac_subdirs_all="$ac_subdirs_all mips"
+ac_subdirs_all="$ac_subdirs_all brownie32"
 ac_subdirs_all="$ac_subdirs_all mn10300"
 ac_subdirs_all="$ac_subdirs_all sh64"
 ac_subdirs_all="$ac_subdirs_all sh"
@@ -3491,6 +3493,15 @@ subdirs="$subdirs mips"
 	   common=yes
 	   igen=yes
 	   ;;
+       brownie32*-*-*)
+
+
+subdirs="$subdirs brownie32"
+
+	   testsuite=yes
+	   common=yes
+	   igen=yes
+	   ;;
        mn10300*-*-*)
 
 
@@ -3665,9 +3676,10 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   # 1. Remove the extension, and $U if already installed.
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
-  # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
-  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
 
Index: sim/configure.ac
===================================================================
RCS file: /home/prj/asip/cvs/gdb/sim/configure.ac,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- sim/configure.ac	31 Jul 2007 11:40:27 -0000	1.1.1.1
+++ sim/configure.ac	8 Aug 2007 08:49:54 -0000	1.2
@@ -94,6 +94,12 @@ if test "${enable_sim}" != no; then
 	   common=yes
 	   igen=yes
 	   ;;
+       brownie32*-*-*)
+           AC_CONFIG_SUBDIRS(brownie32)
+	   testsuite=yes
+	   common=yes
+	   igen=yes
+	   ;;
        mn10300*-*-*)
            AC_CONFIG_SUBDIRS(mn10300)
 	   common=yes
Index: sim/brownie32/ChangeLog
===================================================================
RCS file: sim/brownie32/ChangeLog
diff -N sim/brownie32/ChangeLog
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/ChangeLog	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,2995 @@
+2005-07-08  Ian Lance Taylor  <ian@airs.com>
+
+	* tconfig.in (SIM_QUIET_NAN_NEGATED): Define.
+
+2005-06-16  David Ung  <davidu@mips.com>
+            Nigel Stephens  <nigel@mips.com>
+
+        * mips.igen: New mips16e model and include m16e.igen.
+        (check_u64): Add mips16e tag.
+        * m16e.igen: New file for MIPS16e instructions.
+        * configure.ac (mipsisa32*-*-*, mipsisa32r2*-*-*, mipsisa64*-*-*,
+        mipsisa64r2*-*-*): Change sim_gen to M16, add mips16 and mips16e
+        models.
+        * configure: Regenerate.
+
+2005-05-26  David Ung  <davidu@mips.com>
+ 
+ 	* mips.igen (mips32r2, mips64r2): New ISA models.  Add new model
+	tags to all instructions which are applicable to the new ISAs.
+ 	(do_ror, do_dror, ROR, RORV, DROR, DROR32, DRORV): Add, moved from
+	vr.igen.
+ 	* mips3264r2.igen: New file for MIPS 32/64 revision 2 specific
+ 	instructions. 
+ 	* vr.igen (do_ror, do_dror, ROR, RORV, DROR, DROR32, DRORV): Move
+	to mips.igen.
+ 	* configure.ac (mipsisa32r2*-*-*, mipsisa64r2*-*-*): Add new targets.
+	* configure: Regenerate.
+ 
+2005-03-23  Mark Kettenis  <kettenis@gnu.org>
+
+	* configure: Regenerate.
+
+2005-01-14  Andrew Cagney  <cagney@gnu.org>
+
+	* configure.ac: Sinclude aclocal.m4 before common.m4.  Add
+	explicit call to AC_CONFIG_HEADER.
+	* configure: Regenerate.
+
+2005-01-12  Andrew Cagney  <cagney@gnu.org>
+
+	* configure.ac: Update to use ../common/common.m4.
+	* configure: Re-generate.
+
+2005-01-11  Andrew Cagney  <cagney@localhost.localdomain>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+
+2005-01-07  Andrew Cagney  <cagney@gnu.org>
+
+	* configure.ac: Rename configure.in, require autoconf 2.59.
+	* configure: Re-generate.
+
+2004-12-08  Hans-Peter Nilsson  <hp@axis.com>
+
+	* configure: Regenerate for ../common/aclocal.m4 update.
+
+2004-09-24  Monika Chaddha  <monika@acmet.com>
+	
+	Committed by Andrew Cagney.
+	* m16.igen (CMP, CMPI): Fix assembler.
+
+2004-08-18  Chris Demetriou  <cgd@broadcom.com>
+
+	* configure.in (mipsisa64sb1*-*-*): Add mips3d to sim_igen_machine.
+	* configure: Regenerate.
+
+2004-06-25  Chris Demetriou  <cgd@broadcom.com>
+
+	* configure.in (sim_m16_machine): Include mipsIII.
+	* configure: Regenerate.
+
+2004-05-11  Maciej W. Rozycki  <macro@ds2.pg.gda.pl>
+
+	* mips/interp.c (decode_coproc): Sign-extend the address retrieved 
+	from COP0_BADVADDR.
+	* mips/sim-main.h (COP0_BADVADDR): Remove a cast.
+
+2004-04-10  Chris Demetriou  <cgd@broadcom.com>
+
+	* sb1.igen (DIV.PS, RECIP.PS, RSQRT.PS, SQRT.PS): New.
+
+2004-04-09  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (check_fmt): Remove.
+	(ABS.fmt, ADD.fmt, C.cond.fmta, C.cond.fmtb, CEIL.L.fmt, CEIL.W)
+	(CVT.D.fmt, CVT.L.fmt, CVT.S.fmt, CVT.W.fmt, DIV.fmt, FLOOR.L.fmt)
+	(FLOOR.W.fmt, MADD.fmt, MOV.fmt, MOVtf.fmt, MOVN.fmt, MOVZ.fmt)
+	(MSUB.fmt, MUL.fmt, NEG.fmt, NMADD.fmt, NMSUB.fmt, RECIP.fmt)
+	(ROUND.L.fmt, ROUND.W.fmt, RSQRT.fmt, SQRT.fmt, SUB.fmt)
+	(TRUNC.L.fmt, TRUNC.W): Explicitly specify allowed FPU formats.
+	(check_fmt_p, CEIL.L.fmt, CEIL.W, DIV.fmt, FLOOR.L.fmt)
+	(FLOOR.W.fmt, RECIP.fmt, ROUND.L.fmt, ROUND.W.fmt, RSQRT.fmt)
+	(SQRT.fmt, TRUNC.L.fmt, TRUNC.W): Remove all uses of check_fmt.
+	(C.cnd.fmta): Remove incorrect call to check_fmt_p.
+
+2004-04-09  Chris Demetriou  <cgd@broadcom.com>
+
+	* sb1.igen (check_sbx): New function.
+	(PABSDIFF.fmt, PABSDIFC.fmt, PAVG.fmt): Use check_sbx.
+
+2004-03-29  Chris Demetriou  <cgd@broadcom.com>
+	    Richard Sandiford  <rsandifo@redhat.com>
+
+	* sim-main.h (MIPS_MACH_HAS_MT_HILO_HAZARD)
+	(MIPS_MACH_HAS_MULT_HILO_HAZARD, MIPS_MACH_HAS_DIV_HILO_HAZARD): New.
+	* mips.igen (check_mt_hilo, check_mult_hilo, check_div_hilo): Provide
+	separate implementations for mipsIV and mipsV.  Use new macros to
+	determine whether the restrictions apply.
+
+2004-01-19  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (check_mf_cycles, check_mt_hilo, check_mf_hilo)
+	(check_mult_hilo): Improve comments.
+	(check_div_hilo): Likewise.  Also, fork off a new version
+	to handle mips32/mips64 (since there are no hazards to check
+	in MIPS32/MIPS64).
+
+2003-06-17  Richard Sandiford  <rsandifo@redhat.com>
+
+	* mips.igen (do_dmultx): Fix check for negative operands.
+
+2003-05-16  Ian Lance Taylor  <ian@airs.com>
+
+	* Makefile.in (SHELL): Make sure this is defined.
+	(various): Use $(SHELL) whenever we invoke move-if-change.
+
+2003-05-03  Chris Demetriou  <cgd@broadcom.com>
+
+	* cp1.c: Tweak attribution slightly.
+	* cp1.h: Likewise.
+	* mdmx.c: Likewise.
+	* mdmx.igen: Likewise.
+	* mips3d.igen: Likewise.
+	* sb1.igen: Likewise.
+
+2003-04-15  Richard Sandiford  <rsandifo@redhat.com>
+
+	* vr.igen (do_vr_mul_op): Zero-extend the low 32 bits of
+	unsigned operands.
+
+2003-02-27  Andrew Cagney  <cagney@redhat.com>
+
+	* interp.c (sim_open): Rename _bfd to bfd.
+	(sim_create_inferior): Ditto.
+
+2003-01-14  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (LUXC1, SUXC1): New, for mipsV and mips64.
+
+2003-01-14  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (EI, DI): Remove.
+
+2003-01-05  Richard Sandiford  <rsandifo@redhat.com>
+
+	* Makefile.in (tmp-run-multi): Fix mips16 filter.
+
+2003-01-04  Richard Sandiford  <rsandifo@redhat.com>
+	    Andrew Cagney  <ac131313@redhat.com>
+	    Gavin Romig-Koch  <gavin@redhat.com>
+	    Graydon Hoare  <graydon@redhat.com>
+	    Aldy Hernandez  <aldyh@redhat.com>
+	    Dave Brolley  <brolley@redhat.com>
+	    Chris Demetriou  <cgd@broadcom.com>
+
+	* configure.in (mips64vr*): Define TARGET_ENABLE_FR to 1.
+	(sim_mach_default): New variable.
+	(mips64vr-*-*, mips64vrel-*-*): New configurations.
+	Add a new simulator generator, MULTI.
+	* configure: Regenerate.
+	* Makefile.in (SIM_MULTI_OBJ, SIM_EXTRA_DISTCLEAN): New variables.
+	(multi-run.o): New dependency.
+	(SIM_MULTI_ALL, SIM_MULTI_IGEN_CONFIGS): New variables.
+	(tmp-mach-multi, tmp-itable-multi, tmp-run-multi): New rules.
+	(tmp-multi): Combine them.
+	(BUILT_SRC_FROM_MULTI): New variable.  Depend on tmp-multi.
+	(clean-extra): Remove sources in BUILT_SRC_FROM_MULTI.
+	(distclean-extra): New rule.
+	* sim-main.h: Include bfd.h.
+	(MIPS_MACH): New macro.
+	* mips.igen (vr4120, vr5400, vr5500): New models.
+	(clo, clz, dclo, dclz, madd, maddu, msub, msub, mul): Add *vr5500.
+	* vr.igen: Replace with new version.
+
+2003-01-04  Chris Demetriou  <cgd@broadcom.com>
+
+	* configure.in: Use SIM_AC_OPTION_RESERVED_BITS(1).
+	* configure: Regenerate.
+
+2002-12-31  Chris Demetriou  <cgd@broadcom.com>
+
+	* sim-main.h (check_branch_bug, mark_branch_bug): Remove.
+	* mips.igen: Remove all invocations of check_branch_bug and
+	mark_branch_bug.
+
+2002-12-16  Chris Demetriou  <cgd@broadcom.com>
+
+        * tconfig.in: Include "gdb/callback.h" and "gdb/remote-sim.h".
+
+2002-07-30  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (do_load_double, do_store_double): New functions.
+	(LDC1, SDC1): Rename to...
+	(LDC1b, SDC1b): respectively.
+	(LDC1a, SDC1a): New instructions for MIPS II and MIPS32 support.
+
+2002-07-29  Michael Snyder  <msnyder@redhat.com>
+
+	* cp1.c (fp_recip2): Modify initialization expression so that
+	GCC will recognize it as constant.
+
+2002-06-18  Chris Demetriou  <cgd@broadcom.com>
+
+	* mdmx.c (SD_): Delete.
+	(Unpredictable): Re-define, for now, to directly invoke
+	unpredictable_action().
+	(mdmx_acc_op): Fix error in .ob immediate handling.
+
+2002-06-18  Andrew Cagney  <cagney@redhat.com>
+
+	* interp.c (sim_firmware_command): Initialize `address'.
+
+2002-06-16  Andrew Cagney  <ac131313@redhat.com>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+
+2002-06-14  Chris Demetriou  <cgd@broadcom.com>
+            Ed Satterthwaite  <ehs@broadcom.com>
+
+	* mips3d.igen: New file which contains MIPS-3D ASE instructions.
+	* Makefile.in (IGEN_INCLUDE): Add mips3d.igen.
+	* mips.igen: Include mips3d.igen.
+	(mips3d): New model name for MIPS-3D ASE instructions.
+	(CVT.W.fmt): Don't use this instruction for word (source) format
+	instructions. 
+	* cp1.c (fp_binary_r, fp_add_r, fp_mul_r, fpu_inv1, fpu_inv1_32)
+	(fpu_inv1_64, fp_recip1, fp_recip2, fpu_inv_sqrt1, fpu_inv_sqrt1_32)
+	(fpu_inv_sqrt1_64, fp_rsqrt1, fp_rsqrt2): New functions.
+	(NR_FRAC_GUARD, IMPLICIT_1): New macros.
+	* sim-main.h (fmt_pw, CompareAbs, AddR, MultiplyR, Recip1, Recip2)
+	(RSquareRoot1, RSquareRoot2): New macros.
+	(fp_add_r, fp_mul_r, fp_recip1, fp_recip2, fp_rsqrt1)
+	(fp_rsqrt2): New functions.
+	* configure.in: Add MIPS-3D support to mipsisa64 simulator.
+	* configure: Regenerate.
+
+2002-06-13  Chris Demetriou  <cgd@broadcom.com>
+            Ed Satterthwaite  <ehs@broadcom.com>
+
+	* cp1.c (FP_PS_upper, FP_PS_lower, FP_PS_cat, FPQNaN_PS): New macros.
+	(value_fpr, store_fpr, fp_cmp, fp_unary, fp_binary, fp_mac)
+	(fp_inv_sqrt, fpu_format_name): Add paired-single support.
+	(convert): Note that this function is not used for paired-single
+	format conversions.
+	(ps_lower, ps_upper, pack_ps, convert_ps): New functions.
+	* mips.igen (FMT, MOVtf.fmt): Add paired-single support.
+	(check_fmt_p): Enable paired-single support.
+	(ALNV.PS, CVT.PS.S, CVT.S.PL, CVT.S.PU, PLL.PS, PLU.PS, PUL.PS)
+	(PUU.PS): New instructions.
+	(CVT.S.fmt): Don't use this instruction for paired-single format
+	destinations.
+	* sim-main.h (FP_formats): New value 'fmt_ps.'
+	(ps_lower, ps_upper, pack_ps, convert_ps): New prototypes.
+	(PSLower, PSUpper, PackPS, ConvertPS): New macros.
+
+2002-06-12  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen: Fix formatting of function calls in
+	many FP operations.
+
+2002-06-12  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (MOVN, MOVZ): Trace result.
+	(TNEI): Print "tnei" as the opcode name in traces.
+	(CEIL.W): Add disassembly string for traces.
+	(RSQRT.fmt): Make location of disassembly string consistent
+	with other instructions.
+
+2002-06-12  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (X): Delete unused function.
+
+2002-06-08  Andrew Cagney  <cagney@redhat.com>
+
+	* interp.c: Include "gdb/callback.h" and "gdb/remote-sim.h".
+
+2002-06-07  Chris Demetriou  <cgd@broadcom.com>
+            Ed Satterthwaite  <ehs@broadcom.com>
+
+	* cp1.c (inner_mac, fp_mac, inner_rsqrt, fp_inv_sqrt)
+	(fp_rsqrt, fp_madd, fp_msub, fp_nmadd, fp_nmsub): New functions.
+	* sim-main.h (fp_rsqrt, fp_madd, fp_msub, fp_nmadd)
+	(fp_nmsub): New prototypes.
+	(RSquareRoot, MultiplyAdd, MultiplySub, NegMultiplyAdd)
+	(NegMultiplySub): New defines.
+	* mips.igen (RSQRT.fmt): Use RSquareRoot().
+	(MADD.D, MADD.S): Replace with...
+	(MADD.fmt): New instruction.
+	(MSUB.D, MSUB.S): Replace with...
+	(MSUB.fmt): New instruction.
+	(NMADD.D, NMADD.S): Replace with...
+	(NMADD.fmt): New instruction.
+	(NMSUB.D, MSUB.S): Replace with...
+	(NMSUB.fmt): New instruction.
+
+2002-06-07  Chris Demetriou  <cgd@broadcom.com>
+            Ed Satterthwaite  <ehs@broadcom.com>
+
+	* cp1.c: Fix more comment spelling and formatting.
+	(value_fcr, store_fcr): Use fenr_FS rather than hard-coding value.
+	(denorm_mode): New function.
+	(fpu_unary, fpu_binary): Round results after operation, collect
+	status from rounding operations, and update the FCSR.
+	(convert): Collect status from integer conversions and rounding
+	operations, and update the FCSR.  Adjust NaN values that result
+	from conversions.  Convert to use sim_io_eprintf rather than
+	fprintf, and remove some debugging code.
+	* cp1.h (fenr_FS): New define.
+
+2002-06-07  Chris Demetriou  <cgd@broadcom.com>
+
+	* cp1.c (convert): Remove unusable debugging code, and move MIPS
+	rounding mode to sim FP rounding mode flag conversion code into...
+	(rounding_mode): New function.
+
+2002-06-07  Chris Demetriou  <cgd@broadcom.com>
+
+	* cp1.c: Clean up formatting of a few comments.
+	(value_fpr): Reformat switch statement.
+
+2002-06-06  Chris Demetriou  <cgd@broadcom.com>
+            Ed Satterthwaite  <ehs@broadcom.com>
+
+	* cp1.h: New file.
+	* sim-main.h: Include cp1.h.
+	(SETFCC, GETFCC, IR, UF, OF, DX, IO, UO, FP_FLAGS, FP_ENABLE)
+	(FP_CAUSE, GETFS, FP_RM_NEAREST, FP_RM_TOZERO, FP_RM_TOPINF)
+	(FP_RM_TOMINF, GETRM): Remove.  Moved to cp1.h.
+	(FP_FS, FP_MASK_RM, FP_SH_RM, Nan, Less, Equal): Remove.
+	(value_fcr, store_fcr, test_fcsr, fp_cmp): New prototypes.
+	(ValueFCR, StoreFCR, TestFCSR, Compare): New macros.
+	* cp1.c: Don't include sim-fpu.h; already included by
+	sim-main.h.  Clean up formatting of some comments.
+	(NaN, Equal, Less): Remove.
+	(test_fcsr, value_fcr, store_fcr, update_fcsr, fp_test)
+	(fp_cmp): New functions.
+	* mips.igen (do_c_cond_fmt): Remove.
+	(C.cond.fmta, C.cond.fmtb): Replace uses of do_c_cond_fmt_a with
+	Compare.  Add result tracing.
+	(CxC1): Remove, replace with...
+	(CFC1a, CFC1b, CFC1c, CTC1a, CTC1b, CTC1c): New instructions.
+	(DMxC1): Remove, replace with...
+	(DMFC1a, DMFC1b, DMTC1a, DMTC1b): New instructions.
+	(MxC1): Remove, replace with... 
+	(MFC1a, MFC1b, MTC1a, MTC1b): New instructions.  
+
+2002-06-04  Chris Demetriou  <cgd@broadcom.com>
+
+	* sim-main.h (FGRIDX): Remove, replace all uses with...
+	(FGR_BASE): New macro.
+	(FP0_REGNUM, FCRCS_REGNUM, FCRIR_REGNUM): New macros.
+	(_sim_cpu): Move 'fgr' member to be right before 'fpr_state' member.
+	(NR_FGR, FGR): Likewise.
+	* interp.c: Replace all uses of FGRIDX with FGR_BASE.
+	* mips.igen: Likewise.
+
+2002-06-04  Chris Demetriou  <cgd@broadcom.com>
+
+	* cp1.c: Add an FSF Copyright notice to this file.
+
+2002-06-04  Chris Demetriou  <cgd@broadcom.com>
+            Ed Satterthwaite  <ehs@broadcom.com>
+
+	* cp1.c (Infinity): Remove.
+	* sim-main.h (Infinity): Likewise.
+
+	* cp1.c (fp_unary, fp_binary): New functions.
+	(fp_abs, fp_neg, fp_add, fp_sub, fp_mul, fp_div, fp_recip)
+	(fp_sqrt): New functions, implemented in terms of the above.
+	(AbsoluteValue, Negate, Add, Sub, Multiply, Divide)
+	(Recip, SquareRoot): Remove (replaced by functions above).
+	* sim-main.h (fp_abs, fp_neg, fp_add, fp_sub, fp_mul, fp_div)
+	(fp_recip, fp_sqrt): New prototypes.
+	(AbsoluteValue, Negate, Add, Sub, Multiply, Divide)
+	(Recip, SquareRoot): Replace prototypes with #defines which
+	invoke the functions above.
+	
+2002-06-03  Chris Demetriou  <cgd@broadcom.com>
+
+	* sim-main.h (Nan, Infinity, Less, Equal, AbsoluteValue, Negate)
+	(Add, Sub, Multiply, Divide, Recip, SquareRoot): Move lower in
+	file, remove PARAMS from prototypes.
+	(value_fpr, store_fpr, convert): Likewise.  Use SIM_STATE to provide
+	simulator state arguments.
+	(ValueFPR, StoreFPR, Convert): Move lower in file.  Use SIM_ARGS to
+	pass simulator state arguments.
+	* cp1.c (SD): Redefine as CPU_STATE(cpu).
+	(store_fpr, convert): Remove 'sd' argument.
+	(value_fpr): Likewise.  Convert to use 'SD' instead.
+
+2002-06-03  Chris Demetriou  <cgd@broadcom.com>
+
+	* cp1.c (Min, Max): Remove #if 0'd functions.
+	* sim-main.h (Min, Max): Remove.
+
+2002-06-03  Chris Demetriou  <cgd@broadcom.com>
+
+	* cp1.c: fix formatting of switch case and default labels.
+	* interp.c: Likewise.
+	* sim-main.c: Likewise.
+
+2002-06-03  Chris Demetriou  <cgd@broadcom.com>
+
+	* cp1.c: Clean up comments which describe FP formats.
+	 (FPQNaN_DOUBLE, FPQNaN_LONG): Generate using UNSIGNED64.
+
+2002-06-03  Chris Demetriou  <cgd@broadcom.com>
+            Ed Satterthwaite  <ehs@broadcom.com>
+
+	* configure.in (mipsisa64sb1*-*-*): New target for supporting
+	Broadcom SiByte SB-1 processor configurations.
+	* configure: Regenerate.
+	* sb1.igen: New file.
+	* mips.igen: Include sb1.igen.
+	(sb1): New model.
+	* Makefile.in (IGEN_INCLUDE): Add sb1.igen.
+	* mdmx.igen: Add "sb1" model to all appropriate functions and
+	instructions.
+	* mdmx.c (AbsDiffOB, AvgOB, AccAbsDiffOB): New functions.
+	(ob_func, ob_acc): Reference the above.
+	(qh_acc): Adjust to keep the same size as ob_acc.
+	* sim-main.h (status_SBX, MX_VECT_ABSD, MX_VECT_AVG, MX_AbsDiff)
+	(MX_Avg, MX_VECT_ABSDA, MX_AbsDiffC): New macros.
+
+2002-06-03  Chris Demetriou  <cgd@broadcom.com>
+
+	* Makefile.in (IGEN_INCLUDE): Add mdmx.igen.
+
+2002-06-02  Chris Demetriou  <cgd@broadcom.com>
+            Ed Satterthwaite  <ehs@broadcom.com>
+
+	* mips.igen (mdmx): New (pseudo-)model.
+	* mdmx.c, mdmx.igen: New files.
+	* Makefile.in (SIM_OBJS): Add mdmx.o.
+	* sim-main.h (MDMX_accumulator, MX_fmtsel, signed24, signed48):
+	New typedefs.
+	(ACC, MX_Add, MX_AddA, MX_AddL, MX_And, MX_C_EQ, MX_C_LT, MX_Comp)
+	(MX_FMT_OB, MX_FMT_QH, MX_Max, MX_Min, MX_Msgn, MX_Mul, MX_MulA)
+	(MX_MulL, MX_MulS, MX_MulSL, MX_Nor, MX_Or, MX_Pick, MX_RAC)
+	(MX_RAC_H, MX_RAC_L, MX_RAC_M, MX_RNAS, MX_RNAU, MX_RND_AS)
+	(MX_RND_AU, MX_RND_ES, MX_RND_EU, MX_RND_ZS, MX_RND_ZU, MX_RNES)
+	(MX_RNEU, MX_RZS, MX_RZU, MX_SHFL, MX_ShiftLeftLogical)
+	(MX_ShiftRightArith, MX_ShiftRightLogical, MX_Sub, MX_SubA, MX_SubL)
+	(MX_VECT_ADD, MX_VECT_ADDA, MX_VECT_ADDL, MX_VECT_AND)
+	(MX_VECT_MAX, MX_VECT_MIN, MX_VECT_MSGN, MX_VECT_MUL, MX_VECT_MULA)
+	(MX_VECT_MULL, MX_VECT_MULS, MX_VECT_MULSL, MX_VECT_NOR)
+	(MX_VECT_OR, MX_VECT_SLL, MX_VECT_SRA, MX_VECT_SRL, MX_VECT_SUB)
+	(MX_VECT_SUBA, MX_VECT_SUBL, MX_VECT_XOR, MX_WACH, MX_WACL, MX_Xor)
+	(SIM_ARGS, SIM_STATE, UnpredictableResult, fmt_mdmx, ob_fmtsel)
+	(qh_fmtsel): New macros.
+	(_sim_cpu): New member "acc".
+	(mdmx_acc_op, mdmx_cc_op, mdmx_cpr_op, mdmx_pick_op, mdmx_rac_op)
+	(mdmx_round_op, mdmx_shuffle, mdmx_wach, mdmx_wacl): New functions.
+
+2002-05-01  Chris Demetriou  <cgd@broadcom.com>
+
+	* interp.c: Use 'deprecated' rather than 'depreciated.'
+	* sim-main.h: Likewise.
+
+2002-05-01  Chris Demetriou  <cgd@broadcom.com>
+
+	* cp1.c (store_fpr): Remove #ifdef'd out call to UndefinedResult
+	which wouldn't compile anyway.
+	* sim-main.h (unpredictable_action): New function prototype.
+	(Unpredictable): Define to call igen function unpredictable().
+	(NotWordValue): New macro to call igen function not_word_value().
+	(UndefinedResult): Remove.
+	* interp.c (undefined_result): Remove.
+	(unpredictable_action): New function.
+	* mips.igen (not_word_value, unpredictable): New functions.
+	(ADD, ADDI, do_addiu, do_addu, BGEZAL, BGEZALL, BLTZAL, BLTZALL)
+	(CLO, CLZ, MADD, MADDU, MSUB, MSUBU, MUL, do_mult, do_multu)
+	(do_sra, do_srav, do_srl, do_srlv, SUB, do_subu): Invoke
+	NotWordValue() to check for unpredictable inputs, then
+	Unpredictable() to handle them.
+
+2002-02-24  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen: Fix formatting of calls to Unpredictable().
+
+2002-04-20  Andrew Cagney  <ac131313@redhat.com>
+
+	* interp.c (sim_open): Revert previous change.
+
+2002-04-18  Alexandre Oliva  <aoliva@redhat.com>
+
+	* interp.c (sim_open): Disable chunk of code that wrote code in
+	vector table entries.
+
+2002-03-19  Chris Demetriou  <cgd@broadcom.com>
+
+	* cp1.c (FP_S_s, FP_D_s, FP_S_be, FP_D_be, FP_S_e, FP_D_e, FP_S_f)
+	(FP_D_f, FP_S_fb, FP_D_fb, FPINF_SINGLE, FPINF_DOUBLE): Remove
+	unused definitions.
+
+2002-03-19  Chris Demetriou  <cgd@broadcom.com>
+
+	* cp1.c: Fix many formatting issues.
+
+2002-03-19  Chris G. Demetriou  <cgd@broadcom.com>
+
+	* cp1.c (fpu_format_name): New function to replace...
+	(DOFMT): This.  Delete, and update all callers.
+	(fpu_rounding_mode_name): New function to replace...
+	(RMMODE): This.  Delete, and update all callers.
+
+2002-03-19  Chris G. Demetriou  <cgd@broadcom.com>
+
+	* interp.c: Move FPU support routines from here to...
+	* cp1.c: Here.  New file.
+	* Makefile.in (SIM_OBJS): Add cp1.o to object list.
+	(cp1.o): New target.
+
+2002-03-12  Chris Demetriou  <cgd@broadcom.com>
+
+	* configure.in (mipsisa32*-*-*, mipsisa64*-*-*): New targets.
+	* mips.igen (mips32, mips64): New models, add to all instructions
+	and functions as appropriate.
+	(loadstore_ea, check_u64): New variant for model mips64.
+	(check_fmt_p): New variant for models mipsV and mips64, remove
+	mipsV model marking fro other variant.
+	(SLL) Rename to...
+	(SLLa) this.
+	(CLO, CLZ, MADD, MADDU, MSUB, MSUBU, MUL, SLLb): New instructions
+	for mips32 and mips64.
+	(DCLO, DCLZ): New instructions for mips64.
+
+2002-03-07  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (BREAK, LUI, ORI, SYSCALL, XORI): Print
+	immediate or code as a hex value with the "%#lx" format.
+	(ANDI): Likewise, and fix printed instruction name.
+
+2002-03-05  Chris Demetriou  <cgd@broadcom.com>
+
+	* sim-main.h (UndefinedResult, Unpredictable): New macros
+	which currently do nothing.
+
+2002-03-05  Chris Demetriou  <cgd@broadcom.com>
+
+	* sim-main.h (status_UX, status_SX, status_KX, status_TS)
+	(status_PX, status_MX, status_CU0, status_CU1, status_CU2)
+	(status_CU3): New definitions.
+
+	* sim-main.h (ExceptionCause): Add new values for MIPS32
+	and MIPS64: MDMX, MCheck, CacheErr.  Update comments
+	for DebugBreakPoint and NMIReset to note their status in
+	MIPS32 and MIPS64.
+	(SignalExceptionMDMX, SignalExceptionWatch, SignalExceptionMCheck)
+	(SignalExceptionCacheErr): New exception macros.
+
+2002-03-05  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (check_fpu): Enable check for coprocessor 1 usability.
+	* sim-main.h (COP_Usable): Define, but for now coprocessor 1
+	is always enabled.
+	(SignalExceptionCoProcessorUnusable): Take as argument the
+	unusable coprocessor number.
+
+2002-03-05  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen: Fix formatting of all SignalException calls.
+
+2002-03-05  Chris Demetriou  <cgd@broadcom.com>
+
+	* sim-main.h (SIGNEXTEND): Remove.
+
+2002-03-04  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen: Remove gencode comment from top of file, fix
+	spelling in another comment.
+
+2002-03-04  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (check_fmt, check_fmt_p): New functions to check
+	whether specific floating point formats are usable.
+	(ABS.fmt, ADD.fmt, CEIL.L.fmt, CEIL.W, DIV.fmt, FLOOR.L.fmt)
+	(FLOOR.W.fmt, MOV.fmt, MUL.fmt, NEG.fmt, RECIP.fmt, ROUND.L.fmt)
+	(ROUND.W.fmt, RSQRT.fmt, SQRT.fmt, SUB.fmt, TRUNC.L.fmt, TRUNC.W):
+	Use the new functions.
+	(do_c_cond_fmt): Remove format checks...
+	(C.cond.fmta, C.cond.fmtb): And move them into all callers.
+
+2002-03-03  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen: Fix formatting of check_fpu calls.
+
+2002-03-03  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (FLOOR.L.fmt): Store correct destination register.
+
+2002-03-03  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen: Remove whitespace at end of lines.
+
+2002-03-02  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (loadstore_ea): New function to do effective
+	address calculations.
+	(do_load, do_load_left, do_load_right, LL, LDD, PREF, do_store,
+	do_store_left, do_store_right, SC, SCD, PREFX, SWC1, SWXC1,
+	CACHE): Use loadstore_ea to do effective address computations.
+
+2002-03-02  Chris Demetriou  <cgd@broadcom.com>
+
+	* interp.c (load_word): Use EXTEND32 rather than SIGNEXTEND.
+	* mips.igen (LL, CxC1, MxC1): Likewise.
+
+2002-03-02  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (LL, LLD, PREF, SC, SCD, ABS.fmt, ADD.fmt, CEIL.L.fmt,
+	CEIL.W, CVT.D.fmt, CVT.L.fmt, CVT.S.fmt, CVT.W.fmt, DIV.fmt,
+	FLOOR.L.fmt, FLOOR.W.fmt, MADD.D, MADD.S, MOV.fmt, MOVtf.fmt,
+	MSUB.D, MSUB.S, MUL.fmt, NEG.fmt, NMADD.D, NMADD.S, NMSUB.D,
+	NMSUB.S, PREFX, RECIP.fmt, ROUND.L.fmt, ROUND.W.fmt, RSQRT.fmt,
+	SQRT.fmt, SUB.fmt, SWC1, SWXC1, TRUNC.L.fmt, TRUNC.W, CACHE):
+	Don't split opcode fields by hand, use the opcode field values
+	provided by igen.
+
+2002-03-01  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (do_divu): Fix spacing.
+
+	* mips.igen (do_dsllv): Move to be right before DSLLV,
+	to match the rest of the do_<shift> functions.
+
+2002-03-01  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (do_dsll, do_dsllv, DSLL32, do_dsra, DSRA32, do_dsrl,
+	DSRL32, do_dsrlv): Trace inputs and results.
+
+2002-03-01  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (CACHE): Provide instruction-printing string.
+
+	* interp.c (signal_exception): Comment tokens after #endif.
+
+2002-02-28  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (LWXC1): Mark with filter "64,f", rather than just "32".
+	(MOVtf, MxC1, MxC1, DMxC1, DMxC1, CxC1, CxC1, SQRT.fmt, MOV.fmt, 
+	NEG.fmt, ROUND.L.fmt, TRUNC.L.fmt, CEIL.L.fmt, FLOOR.L.fmt, 
+	ROUND.W.fmt, TRUNC.W, CEIL.W, FLOOR.W.fmt, RECIP.fmt, RSQRT.fmt, 
+	CVT.S.fmt, CVT.D.fmt, CVT.W.fmt, CVT.L.fmt, MOVtf.fmt, C.cond.fmta, 
+	C.cond.fmtb, SUB.fmt, MUL.fmt, DIV.fmt, MOVZ.fmt, MOVN.fmt, LDXC1, 
+	SWXC1, SDXC1, MSUB.D, MSUB.S, NMADD.S, NMADD.D, NMSUB.S, NMSUB.D, 
+	LWC1, SWC1): Add "f" to filter, since these are FP instructions.
+
+2002-02-28  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (DSRA32, DSRAV): Fix order of arguments in
+	instruction-printing string.
+	(LWU): Use '64' as the filter flag.
+
+2002-02-28  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (SDXC1): Fix instruction-printing string.
+
+2002-02-28  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (LDC1, SDC1): Remove mipsI model, and mark with
+	filter flags "32,f".
+
+2002-02-27  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (PREFX): This is a 64-bit instruction, use '64'
+	as the filter flag.
+
+2002-02-27  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (PREFX): Tweak instruction opcode fields (i.e.,
+	add a comma) so that it more closely match the MIPS ISA
+	documentation opcode partitioning.
+	(PREF): Put useful names on opcode fields, and include
+	instruction-printing string.
+
+2002-02-27  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (check_u64): New function which in the future will
+	check whether 64-bit instructions are usable and signal an
+	exception if not.  Currently a no-op.
+	(DADD, DADDI, DADDIU, DADDU, DDIV, DDIVU, DMULT, DMULTU, DSLL,
+	DSLL32, DSLLV, DSRA, DSRA32, DSRAV, DSRL, DSRL32, DSRLV, DSUB,
+	DSUBU, LD, LDL, LDR, LLD, LWU, SCD, SD, SDL, SDR, DMxC1, LDXC1,
+	LWXC1, SDXC1, SWXC1, DMFC0, DMTC0): Use check_u64.
+
+	* mips.igen (check_fpu): New function which in the future will
+	check whether FPU instructions are usable and signal an exception
+	if not.  Currently a no-op.
+	(ABS.fmt, ADD.fmt, BC1a, BC1b, C.cond.fmta, C.cond.fmtb,
+	CEIL.L.fmt, CEIL.W, CxC1, CVT.D.fmt, CVT.L.fmt, CVT.S.fmt,
+	CVT.W.fmt, DIV.fmt, DMxC1, DMxC1, FLOOR.L.fmt, FLOOR.W.fmt, LDC1,
+	LDXC1, LWC1, LWXC1, MADD.D, MADD.S, MxC1, MOV.fmt, MOVtf,
+	MOVtf.fmt, MOVN.fmt, MOVZ.fmt, MSUB.D, MSUB.S, MUL.fmt, NEG.fmt,
+	NMADD.D, NMADD.S, NMSUB.D, NMSUB.S, RECIP.fmt, ROUND.L.fmt,
+	ROUND.W.fmt, RSQRT.fmt, SDC1, SDXC1, SQRT.fmt, SUB.fmt, SWC1,
+	SWXC1, TRUNC.L.fmt, TRUNC.W): Use check_fpu.
+
+2002-02-27  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (do_load_left, do_load_right): Move to be immediately
+	following do_load.
+	(do_store_left, do_store_right): Move to be immediately following
+	do_store.
+
+2002-02-27  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (mipsV): New model name.  Also, add it to
+	all instructions and functions where it is appropriate.
+
+2002-02-18  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen: For all functions and instructions, list model
+	names that support that instruction one per line.
+
+2002-02-11  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen: Add some additional comments about supported
+	models, and about which instructions go where.
+	(BC1b, MFC0, MTC0, RFE): Sort supported models in the same
+	order as is used in the rest of the file.
+
+2002-02-11  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (ADD, ADDI, DADDI, DSUB, SUB): Add comment
+	indicating that ALU32_END or ALU64_END are there to check
+	for overflow.
+	(DADD): Likewise, but also remove previous comment about
+	overflow checking.
+
+2002-02-10  Chris Demetriou  <cgd@broadcom.com>
+
+	* mips.igen (DDIV, DIV, DIVU, DMULT, DMULTU, DSLL, DSLL32,
+	DSLLV, DSRA, DSRA32, DSRAV, DSRL, DSRL32, DSRLV, DSUB, DSUBU,
+	JALR, JR, MOVN, MOVZ, MTLO, MULT, MULTU, SLL, SLLV, SLT, SLTU,
+	SRAV, SRLV, SUB, SUBU, SYNC, XOR, MOVtf, DI, DMFC0, DMTC0, EI,
+	ERET, RFE, TLBP, TLBR, TLBWI, TLBWR): Tweak instruction opcode
+	fields (i.e., add and move commas) so that they more closely
+	match the MIPS ISA documentation opcode partitioning.
+
+2002-02-10  Chris Demetriou  <cgd@broadcom.com>
+
+        * mips.igen (ADDI): Print immediate value.
+        (BREAK): Print code.
+        (DADDIU, DSRAV, DSRLV): Print correct instruction name.
+        (SLL): Print "nop" specially, and don't run the code
+        that does the shift for the "nop" case.
+
+2001-11-17  Fred Fish  <fnf@redhat.com>
+
+	* sim-main.h (float_operation): Move enum declaration outside
+	of _sim_cpu struct declaration.
+
+2001-04-12  Jim Blandy  <jimb@redhat.com>
+
+	* mips.igen (CFC1, CTC1): Pass the correct register numbers to
+	PENDING_FILL.  Use PENDING_SCHED directly to handle the pending
+	set of the FCSR.
+	* sim-main.h (COCIDX): Remove definition; this isn't supported by
+	PENDING_FILL, and you can get the intended effect gracefully by
+	calling PENDING_SCHED directly.
+
+2001-02-23  Ben Elliston  <bje@redhat.com>
+
+	* sim-main.h (ENGINE_ISSUE_PREFIX_HOOK): Only define if not
+	already defined elsewhere.
+
+2001-02-19  Ben Elliston  <bje@redhat.com>
+
+	* sim-main.h (sim_monitor): Return an int.
+	* interp.c (sim_monitor): Add return values.
+	(signal_exception): Handle error conditions from sim_monitor.
+
+2001-02-08  Ben Elliston  <bje@redhat.com>
+
+	* sim-main.c (load_memory): Pass cia to sim_core_read* functions.
+	(store_memory): Likewise, pass cia to sim_core_write*.
+
+2000-10-19  Frank Ch. Eigler  <fche@redhat.com>
+
+	On advice from Chris G. Demetriou <cgd@sibyte.com>:
+	* sim-main.h (GPR_CLEAR): Remove unused alternative macro.
+
+Thu Jul 27 22:02:05 2000  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	From Maciej W. Rozycki <macro@ds2.pg.gda.pl>:
+	* Makefile.in: Don't delete *.igen when cleaning directory.
+
+Wed Jul 19 18:50:51 2000  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* m16.igen (break): Call SignalException not sim_engine_halt.
+
+Mon Jul  3 11:13:20 2000  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	From Jason Eckhardt:
+	* mips.igen (MOVZ.fmt, MOVN.fmt): Move conditional on GPR[RT].
+
+Tue Jun 13 20:52:07 2000  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* mips.igen (MxC1, DMxC1): Fix printf formatting.
+
+2000-05-24  Michael Hayes  <mhayes@cygnus.com>
+
+	* mips.igen (do_dmultx): Fix typo.
+
+Tue May 23 21:39:23 2000  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+
+Fri Apr 28 20:48:36 2000  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* mips.igen (DMxC1): Fix format arguments for sim_io_eprintf call.
+
+2000-04-12  Frank Ch. Eigler  <fche@redhat.com>
+
+	* sim-main.h (GPR_CLEAR): Define macro.
+
+Mon Apr 10 00:07:09 2000  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (decode_coproc): Output long using %lx and not %s.
+
+2000-03-21  Frank Ch. Eigler  <fche@redhat.com>
+
+	* interp.c (sim_open): Sort & extend dummy memory regions for
+	--board=jmr3904 for eCos.
+
+2000-03-02  Frank Ch. Eigler  <fche@redhat.com>
+
+	* configure: Regenerated.
+
+Tue Feb  8 18:35:01 2000  Donald Lindsay  <dlindsay@hound.cygnus.com>
+
+	* interp.c, mips.igen: all 5 DEADC0DE situations now have sim_io_eprintf
+	calls, conditional on the simulator being in verbose mode.
+
+Fri Feb  4 09:45:15 2000  Donald Lindsay  <dlindsay@cygnus.com>
+
+	* sim-main.c (cache_op): Added case arm so that CACHE ops to a secondary
+	cache don't get ReservedInstruction traps.
+
+1999-11-29  Mark Salter  <msalter@cygnus.com>
+
+	* dv-tx3904sio.c (tx3904sio_io_write_buffer): Use write value as a mask
+	to clear status bits in sdisr register. This is how the hardware works.
+
+	* interp.c (sim_open): Added more memory aliases for jmr3904 hardware
+	being used by cygmon.
+
+1999-11-11  Andrew Haley  <aph@cygnus.com>
+
+	* interp.c (decode_coproc): Correctly handle DMFC0 and DMTC0
+	instructions.
+
+Thu Sep  9 15:12:08 1999  Geoffrey Keating  <geoffk@cygnus.com>
+
+	* mips.igen (MULT): Correct previous mis-applied patch.
+
+Tue Sep  7 13:34:54 1999  Geoffrey Keating  <geoffk@cygnus.com>
+
+	* mips.igen (delayslot32): Handle sequence like
+	mtc1 $at,$f12 ; jal fp_add ; mov.s $f13,$f12
+	correctly by calling ENGINE_ISSUE_PREFIX_HOOK() before issue.
+	(MULT): Actually pass the third register...
+
+1999-09-03  Mark Salter  <msalter@cygnus.com>
+
+	* interp.c (sim_open): Added more memory aliases for additional
+	hardware being touched by cygmon on jmr3904 board.
+
+Thu Sep  2 18:15:53 1999  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+
+Tue Jul 27 16:36:51 1999  Andrew Cagney  <cagney@amy.cygnus.com>
+
+	* interp.c (sim_store_register): Handle case where client - GDB -
+ 	specifies that a 4 byte register is 8 bytes in size.
+	(sim_fetch_register): Ditto.
+	
+1999-07-14  Frank Ch. Eigler  <fche@cygnus.com>
+
+	Implement "sim firmware" option, inspired by jimb's version of 1998-01.
+	* interp.c (firmware_option_p): New global flag: "sim firmware" given.
+	(idt_monitor_base): Base address for IDT monitor traps.
+	(pmon_monitor_base): Ditto for PMON.
+	(lsipmon_monitor_base): Ditto for LSI PMON.
+	(MONITOR_BASE, MONITOR_SIZE): Removed macros.
+	(mips_option): Add "firmware" option with new OPTION_FIRMWARE key.
+	(sim_firmware_command): New function.
+	(mips_option_handler): Call it for OPTION_FIRMWARE.
+	(sim_open): Allocate memory for idt_monitor region.  If "--board"
+	option was given, add no monitor by default.  Add BREAK hooks only if
+	monitors are also there.
+	
+Mon Jul 12 00:02:27 1999  Andrew Cagney  <cagney@amy.cygnus.com>
+
+	* interp.c (sim_monitor): Flush output before reading input.
+
+Sun Jul 11 19:28:11 1999  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* tconfig.in (SIM_HANDLES_LMA): Always define.
+
+Thu Jul  8 16:06:59 1999  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	From Mark Salter <msalter@cygnus.com>:
+	* interp.c (BOARD_BSP): Define.  Add to list of possible boards.
+	(sim_open): Add setup for BSP board.
+
+Wed Jul  7 12:45:58 1999  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* mips.igen (MULT, MULTU): Add syntax for two operand version.
+	(DMFC0, DMTC0): Recognize.  Call DecodeCoproc which will report
+ 	them as unimplemented.
+
+1999-05-08  Felix Lee  <flee@cygnus.com>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+	
+1999-04-21  Frank Ch. Eigler  <fche@cygnus.com>
+
+	* mips.igen (bc0f): For the TX39 only, decode this as a no-op stub.
+
+Thu Apr 15 14:15:17 1999  Andrew Cagney  <cagney@amy.cygnus.com>
+
+	* configure.in: Any mips64vr5*-*-* target should have
+ 	-DTARGET_ENABLE_FR=1.
+	(default_endian): Any mips64vr*el-*-* target should default to
+	LITTLE_ENDIAN.
+	* configure: Re-generate.
+
+1999-02-19  Gavin Romig-Koch  <gavin@cygnus.com>
+
+	* mips.igen (ldl): Extend from _16_, not 32.
+
+Wed Jan 27 18:51:38 1999  Andrew Cagney  <cagney@chook.cygnus.com>
+
+	* interp.c (sim_store_register): Force registers written to by GDB
+ 	into an un-interpreted state.
+
+1999-02-05  Frank Ch. Eigler  <fche@cygnus.com>
+
+	* dv-tx3904sio.c (tx3904sio_tickle): After a polled I/O from the
+ 	CPU, start periodic background I/O polls.
+	(tx3904sio_poll): New function: periodic I/O poller. 
+
+1998-12-30  Frank Ch. Eigler  <fche@cygnus.com>
+
+	* mips.igen (BREAK): Call signal_exception instead of sim_engine_halt.
+	
+Tue Dec 29 16:03:53 1998  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* configure.in, configure (mips64vr5*-*-*): Added missing ;; in
+ 	case statement.
+
+1998-12-29  Frank Ch. Eigler  <fche@cygnus.com>
+	
+	* interp.c (sim_open): Allocate jm3904 memory in smaller chunks. 
+	(load_word): Call SIM_CORE_SIGNAL hook on error.
+	(signal_exception): Call SIM_CPU_EXCEPTION_TRIGGER hook before
+	starting.  For exception dispatching, pass PC instead of NULL_CIA.
+	(decode_coproc): Use COP0_BADVADDR to store faulting address.
+	* sim-main.h (COP0_BADVADDR): Define. 
+	(SIM_CORE_SIGNAL): Define hook to call mips_core_signal.
+	(SIM_CPU_EXCEPTION*): Define hooks to call mips_cpu_exception*().
+	(_sim_cpu): Add exc_* fields to store register value snapshots.	
+	* mips.igen (*): Replace memory-related SignalException* calls
+	with references to SIM_CORE_SIGNAL hook.
+	
+	* dv-tx3904irc.c (tx3904irc_port_event): printf format warning
+	fix.
+	* sim-main.c (*): Minor warning cleanups.
+	
+1998-12-24  Gavin Romig-Koch  <gavin@cygnus.com>
+
+	* m16.igen (DADDIU5): Correct type-o.
+
+Mon Dec 21 10:34:48 1998  Andrew Cagney  <cagney@chook>
+
+	* mips.igen (do_ddiv, do_ddivu): Pacify GCC. Update hi/lo via tmp
+ 	variables.
+
+Wed Dec 16 18:20:28 1998  Andrew Cagney  <cagney@chook>
+
+	* Makefile.in (SIM_EXTRA_CFLAGS): No longer need to add .../newlib
+ 	to include path.
+	(interp.o): Add dependency on itable.h
+	(oengine.c, gencode): Delete remaining references.
+	(BUILT_SRC_FROM_GEN): Clean up.
+	
+1998-12-16  Gavin Romig-Koch  <gavin@cygnus.com>
+	
+	* vr4run.c: New.
+	* Makefile.in (SIM_HACK_OBJ,HACK_OBJS,HACK_GEN_SRCS,libhack.a,
+	tmp-hack,tmp-m32-hack,tmp-m16-hack,tmp-itable-hack,
+	tmp-run-hack) : New.
+	* m16.igen (LD,DADDIU,DADDUI5,DADJSP,DADDIUSP,DADDI,DADDU,DSUBU,
+	DSLL,DSRL,DSRA,DSLLV,DSRAV,DMULT,DMULTU,DDIV,DDIVU,JALX32,JALX): 
+	Drop the "64" qualifier to get the HACK generator working.
+	Use IMMEDIATE rather than IMMED.  Use SHAMT rather than SHIFT.
+	* mips.igen (do_daddiu,do_ddiv,do_divu): Remove the 64-only
+	qualifier to get the hack generator working.
+	(do_dsll,do_dsllv,do_dsra,do_dsrl,do_dsrlv): New.
+	(DSLL): Use do_dsll.
+	(DSLLV): Use do_dsllv.
+	(DSRA): Use do_dsra.
+	(DSRL): Use do_dsrl.
+	(DSRLV): Use do_dsrlv.
+	(BC1): Move *vr4100 to get the HACK generator working.
+	(CxC1, DMxC1, MxC1,MACCU,MACCHI,MACCHIU): Rename to 
+	get the HACK generator working.
+	(MACC) Rename to get the HACK generator working.
+	(DMACC,MACCS,DMACCS): Add the 64.
+	
+1998-12-12  Gavin Romig-Koch  <gavin@cygnus.com>
+
+	* mips.igen (BC1): Renamed to BC1a and BC1b to avoid conflicts.
+	* sim-main.h (SizeFGR): Handle TARGET_ENABLE_FR.
+	
+1998-12-11  Gavin Romig-Koch  <gavin@cygnus.com>
+
+    * mips/interp.c (DEBUG): Cleanups.
+
+1998-12-10  Frank Ch. Eigler  <fche@cygnus.com>
+
+	* dv-tx3904sio.c (tx3904sio_io_read_buffer): Endianness fixes.
+	(tx3904sio_tickle): fflush after a stdout character output.
+	
+1998-12-03  Frank Ch. Eigler  <fche@cygnus.com>
+
+	* interp.c (sim_close): Uninstall modules.
+
+Wed Nov 25 13:41:03 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* sim-main.h, interp.c (sim_monitor): Change to global
+ 	function.
+
+Wed Nov 25 17:33:24 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure.in (vr4100): Only include vr4100 instructions in
+ 	simulator.
+	* configure: Re-generate.
+	* m16.igen (*): Tag all mips16 instructions as also being vr4100.
+
+Mon Nov 23 18:20:36 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (SIM_CFLAGS): Do not define WITH_IGEN.
+	* sim-main.h, sim-main.c, interp.c: Delete #if WITH_IGEN keeping
+ 	true alternative.
+
+	* configure.in (sim_default_gen, sim_use_gen): Replace with
+ 	sim_gen.
+	(--enable-sim-igen): Delete config option. Always using IGEN.
+	* configure: Re-generate.
+	
+	* Makefile.in (gencode): Kill, kill, kill.
+	* gencode.c: Ditto.
+	
+Mon Nov 23 18:07:36 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure.in: Configure mips64vr4100-elf nee mips64vr41* as a 64
+ 	bit mips16 igen simulator.
+	* configure: Re-generate.
+
+	* mips.igen (check_div_hilo, check_mult_hilo, check_mf_hilo): Mark
+ 	as part of vr4100 ISA.
+	* vr.igen: Mark all instructions as 64 bit only.
+
+Mon Nov 23 17:07:37 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (get_cell, sim_monitor, fetch_str, CoProcPresent):
+ 	Pacify GCC.
+
+Mon Nov 23 13:23:40 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure.in: Configure mips-lsi-elf nee mips*lsi* as a
+ 	mipsIII/mips16 igen simulator.  Fix sim_gen VS sim_igen typos.
+	* configure: Re-generate.
+
+	* m16.igen (BREAK): Define breakpoint instruction.
+	(JALX32): Mark instruction as mips16 and not r3900.
+	* mips.igen (C.cond.fmt): Fix typo in instruction format.
+
+	* sim-main.h (PENDING_FILL): Wrap C statements in do/while.
+
+Sat Nov  7 09:54:38 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* gencode.c (build_instruction - BREAK): For MIPS16, handle BREAK
+ 	insn as a debug breakpoint.
+
+	* sim-main.h (PENDING_SLOT_BIT): Fix, was incorrectly defined as
+ 	pending.slot_size.
+	(PENDING_SCHED): Clean up trace statement.
+	(PENDING_SCHED): Increment PENDING_IN and PENDING_TOTAL.
+	(PENDING_FILL): Delay write by only one cycle.
+	(PENDING_FILL): For FSRs, write fmt_uninterpreted to FPR_STATE.
+
+	* sim-main.c (pending_tick): Clean up trace statements. Add trace
+ 	of pending writes.
+	(pending_tick): Fix sizes in switch statements, 4 & 8 instead of
+ 	32 & 64.
+	(pending_tick): Move incrementing of index to FOR statement.
+	(pending_tick): Only update PENDING_OUT after a write has occured.
+	
+	* configure.in: Add explicit mips-lsi-* target.  Use gencode to
+ 	build simulator.
+	* configure: Re-generate.
+	
+	* interp.c (sim_engine_run OLD): Delete explicit call to
+ 	PENDING_TICK. Now called via ENGINE_ISSUE_PREFIX_HOOK.
+	
+Sat Oct 30 09:49:10 1998  Frank Ch. Eigler  <fche@cygnus.com>
+
+	* dv-tx3904cpu.c (deliver_tx3904cpu_interrupt): Add dummy
+	interrupt level number to match changed SignalExceptionInterrupt
+	macro.
+
+Fri Oct  9 18:02:25 1998  Doug Evans  <devans@canuck.cygnus.com>
+
+	* interp.c: #include "itable.h" if WITH_IGEN.
+	(get_insn_name): New function.
+	(sim_open): Initialize CPU_INSN_NAME,CPU_MAX_INSNS.
+	* sim-main.h (MAX_INSNS,INSN_NAME): Delete.
+
+Mon Sep 14 12:36:44 1998  Frank Ch. Eigler  <fche@cygnus.com>
+
+	* configure: Rebuilt to inhale new common/aclocal.m4.
+
+Tue Sep  1 15:39:18 1998  Frank Ch. Eigler  <fche@cygnus.com>
+
+	* dv-tx3904sio.c: Include sim-assert.h.
+
+Tue Aug 25 12:49:46 1998  Frank Ch. Eigler  <fche@cygnus.com>
+
+	* dv-tx3904sio.c: New file: tx3904 serial I/O module.
+	* configure.in: Add dv-tx3904sio, dv-sockser for tx39 target.
+	Reorganize target-specific sim-hardware checks.
+	* configure: rebuilt.
+	* interp.c (sim_open): For tx39 target boards, set
+	OPERATING_ENVIRONMENT, add tx3904sio devices.
+	* tconfig.in: For tx39 target, set SIM_HANDLES_LMA for loading
+	ROM executables.  Install dv-sockser into sim-modules list.
+	
+	* dv-tx3904irc.c: Compiler warning clean-up.
+	* dv-tx3904tmr.c: Compiler warning clean-up.  Remove particularly
+	frequent hw-trace messages.
+
+Fri Jul 31 18:14:16 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* vr.igen (MulAcc): Identify as a vr4100 specific function.
+
+Sat Jul 25 16:03:14 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (IGEN_INCLUDE): Add vr.igen.
+
+	* vr.igen: New file.
+	(MAC/MADD16, DMAC/DMADD16): Implement using code from gencode.c.
+	* mips.igen: Define vr4100 model. Include vr.igen.
+Mon Jun 29 09:21:07 1998  Gavin Koch  <gavin@cygnus.com>
+
+	* mips.igen (check_mf_hilo): Correct check.
+
+Wed Jun 17 12:20:49 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* sim-main.h (interrupt_event): Add prototype.
+
+	* dv-tx3904tmr.c (tx3904tmr_io_write_buffer): Delete unused
+ 	register_ptr, register_value.
+	(deliver_tx3904tmr_tick): Fix types passed to printf fmt.
+
+	* sim-main.h (tracefh): Make extern.
+
+Tue Jun 16 14:39:00 1998  Frank Ch. Eigler  <fche@cygnus.com>
+
+	* dv-tx3904tmr.c: Deschedule timer event after dispatching.
+	Reduce unnecessarily high timer event frequency.  
+	* dv-tx3904cpu.c: Ditto for interrupt event.
+	
+Wed Jun 10 13:22:32 1998  Frank Ch. Eigler  <fche@cygnus.com>
+
+	* interp.c (decode_coproc): For TX39, add stub COP0 register #7,
+ 	to allay warnings.
+	(interrupt_event): Made non-static.
+	
+	* dv-tx3904tmr.c (deliver_tx3904tmr_tick): Correct accidental
+ 	interchange of configuration values for external vs. internal
+ 	clock dividers.
+	
+Tue Jun  9 12:46:24 1998  Ian Carmichael  <iancarm@cygnus.com>
+
+	* mips.igen (BREAK): Moved code to here for 
+	simulator-reserved break instructions.
+	* gencode.c (build_instruction): Ditto.
+	* interp.c (signal_exception): Code moved from here.  Non-
+	reserved instructions now use exception vector, rather 
+	than halting sim.
+	* sim-main.h: Moved magic constants to here.
+
+Tue Jun  9 12:29:50 1998  Frank Ch. Eigler  <fche@cygnus.com>
+
+	* dv-tx3904cpu.c (deliver_*_interrupt,*_port_event): Set the CAUSE
+ 	register upon non-zero interrupt event level, clear upon zero
+ 	event value.
+	* dv-tx3904irc.c (*_port_event): Handle deactivated interrupt signal
+	by passing zero event value.
+	(*_io_{read,write}_buffer): Endianness fixes.
+	* dv-tx3904tmr.c (*_io_{read,write}_buffer): Endianness fixes.
+	(deliver_*_tick): Reduce sim event interval to 75% of count interval.
+
+	* interp.c (sim_open): Added jmr3904pal board type that adds PAL-based
+	serial I/O and timer module at base address 0xFFFF0000.
+	
+Tue Jun  9 11:52:29 1998  Gavin Koch  <gavin@cygnus.com>
+
+	* mips.igen (SWC1) : Correct the handling of ReverseEndian 
+	and BigEndianCPU.
+
+Tue Jun  9 11:40:57 1998  Gavin Koch  <gavin@cygnus.com>
+
+	* configure.in (mips_fpu_bitsize) : Set this correctly for 32-bit mips
+	parts.
+	* configure: Update.
+
+Thu Jun  4 15:37:33 1998  Frank Ch. Eigler  <fche@cygnus.com>
+
+	* dv-tx3904tmr.c: New file - implements tx3904 timer.
+	* dv-tx3904{irc,cpu}.c: Mild reformatting.
+	* configure.in: Include tx3904tmr in hw_device list.
+	* configure: Rebuilt.
+	* interp.c (sim_open): Instantiate three timer instances.
+	Fix address typo of tx3904irc instance.
+
+Tue Jun  2 15:48:02 1998  Ian Carmichael  <iancarm@cygnus.com>
+
+	* interp.c (signal_exception): SystemCall exception now uses
+	the exception vector.
+
+Mon Jun  1 18:18:26 1998  Frank Ch. Eigler  <fche@cygnus.com>
+
+	* interp.c (decode_coproc): For TX39, add stub COP0 register #3,
+	to allay warnings.
+
+Fri May 29 11:40:39 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure.in (sim_igen_filter): Match mips*tx39 not mipst*tx39.
+
+Mon May 25 20:47:45 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* dv-tx3904cpu.c, dv-tx3904irc.c: Rename *_callback to *_method.
+
+	* dv-tx3904cpu.c, dv-tx3904irc.c: Include hw-main.h and
+ 	sim-main.h. Declare a struct hw_descriptor instead of struct
+ 	hw_device_descriptor.
+
+Mon May 25 12:41:38 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* mips.igen (do_store_left, do_load_left): Compute nr of left and
+ 	right bits and then re-align left hand bytes to correct byte
+ 	lanes.  Fix incorrect computation in do_store_left when loading
+ 	bytes from second word.
+
+Fri May 22 13:34:20 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure.in (SIM_AC_OPTION_HARDWARE): Only enable when tx3904.
+	* interp.c (sim_open): Only create a device tree when HW is
+ 	enabled.
+
+	* dv-tx3904irc.c (tx3904irc_finish): Pacify GCC.
+	* interp.c (signal_exception): Ditto.
+
+Thu May 21 14:24:11 1998  Gavin Koch  <gavin@cygnus.com>
+
+	* gencode.c: Mark BEGEZALL as LIKELY.
+
+Thu May 21 18:57:19 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* sim-main.h (ALU32_END): Sign extend 32 bit results.
+	* mips.igen (ADD, SUB, ADDI, DADD, DSUB): Trace.
+	
+Mon May 18 18:22:42 1998  Frank Ch. Eigler  <fche@cygnus.com>
+
+	* configure.in (SIM_AC_OPTION_HARDWARE): Added common hardware
+ 	modules.  Recognize TX39 target with "mips*tx39" pattern.
+	* configure: Rebuilt.
+	* sim-main.h (*): Added many macros defining bits in
+ 	TX39 control registers.
+	(SignalInterrupt): Send actual PC instead of NULL.
+	(SignalNMIReset): New exception type.
+	* interp.c (board): New variable for future use to identify
+	a particular board being simulated.
+	(mips_option_handler,mips_options): Added "--board" option.
+	(interrupt_event): Send actual PC.
+	(sim_open): Make memory layout conditional on board setting.
+	(signal_exception): Initial implementation of hardware interrupt
+ 	handling.  Accept another break instruction variant for simulator
+ 	exit.
+	(decode_coproc): Implement RFE instruction for TX39.
+	(mips.igen): Decode RFE instruction as such.
+	* configure.in (tx3904cpu,tx3904irc): Added devices for tx3904.
+	* interp.c: Define "jmr3904" and "jmr3904debug" board types and
+	bbegin to implement memory map.
+	* dv-tx3904cpu.c: New file.
+	* dv-tx3904irc.c: New file.
+
+Wed May 13 14:40:11 1998  Gavin Koch  <gavin@cygnus.com>
+
+	* mips.igen (check_mt_hilo): Create a separate r3900 version.
+
+Wed May 13 14:11:46 1998  Gavin Koch  <gavin@cygnus.com>
+
+	* tx.igen (madd,maddu):  Replace calls to check_op_hilo
+	with calls to check_div_hilo.
+
+Wed May 13 09:59:27 1998  Gavin Koch  <gavin@cygnus.com>
+
+	* mips/mips.igen (check_op_hilo,check_mult_hilo,check_div_hilo):
+	Replace check_op_hilo with check_mult_hilo and check_div_hilo.
+	Add special r3900 version of do_mult_hilo.  
+	(do_dmultx,do_mult,do_multu): Replace calls to check_op_hilo
+	with calls to check_mult_hilo.
+	(do_ddiv,do_ddivu,do_div,do_divu): Replace calls to check_op_hilo
+	with calls to check_div_hilo.
+
+Tue May 12 15:22:11 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure.in (SUBTARGET_R3900): Define for mipstx39 target.
+  	Document a replacement.
+
+Fri May  8 17:48:19 1998  Ian Carmichael  <iancarm@cygnus.com>
+
+	* interp.c (sim_monitor): Make mon_printf work.
+
+Wed May  6 19:42:19 1998  Doug Evans  <devans@canuck.cygnus.com>
+
+	* sim-main.h (INSN_NAME): New arg `cpu'.
+
+Tue Apr 28 18:33:31 1998  Geoffrey Noer  <noer@cygnus.com>
+
+        * configure: Regenerated to track ../common/aclocal.m4 changes.
+
+Sun Apr 26 15:31:55 1998  Tom Tromey  <tromey@creche>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+	* config.in: Ditto.
+
+Sun Apr 26 15:20:01 1998  Tom Tromey  <tromey@cygnus.com>
+
+	* acconfig.h: New file.
+	* configure.in: Reverted change of Apr 24; use sinclude again.
+
+Fri Apr 24 14:16:40 1998  Tom Tromey  <tromey@creche>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+	* config.in: Ditto.
+
+Fri Apr 24 11:19:20 1998  Tom Tromey  <tromey@cygnus.com>
+
+	* configure.in: Don't call sinclude.
+
+Fri Apr 24 11:35:01 1998  Andrew Cagney  <cagney@chook.cygnus.com>
+
+	* mips.igen (do_store_left): Pass 0 not NULL to store_memory.
+
+Tue Apr 21 11:59:50 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* mips.igen (ERET): Implement.
+
+	* interp.c (decode_coproc): Return sign-extended EPC.
+
+	* mips.igen (ANDI, LUI, MFC0): Add tracing code.
+
+	* interp.c (signal_exception): Do not ignore Trap.
+	(signal_exception): On TRAP, restart at exception address.
+	(HALT_INSTRUCTION, HALT_INSTRUCTION_MASK): Define.
+	(signal_exception): Update.
+	(sim_open): Patch V_COMMON interrupt vector with an abort sequence
+ 	so that TRAP instructions are caught.
+
+Mon Apr 20 11:26:55 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* sim-main.h (struct hilo_access, struct hilo_history): Define,
+ 	contains HI/LO access history.
+	(struct _sim_cpu): Make hiaccess and loaccess of type hilo_access.
+	(HIACCESS, LOACCESS): Delete, replace with
+	(HIHISTORY, LOHISTORY): New macros.
+	(CHECKHILO): Delete all, moved to mips.igen
+	
+	* gencode.c (build_instruction): Do not generate checks for
+ 	correct HI/LO register usage.
+
+	* interp.c (old_engine_run): Delete checks for correct HI/LO
+ 	register usage.
+
+	* mips.igen (check_mt_hilo, check_mf_hilo, check_op_hilo,
+ 	check_mf_cycles): New functions.
+	(do_mfhi, do_mflo, "mthi", "mtlo", do_ddiv, do_ddivu, do_div,
+ 	do_divu, domultx, do_mult, do_multu): Use.
+
+	* tx.igen ("madd", "maddu"): Use.
+	
+Wed Apr 15 18:31:54 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* mips.igen (DSRAV): Use function do_dsrav.
+	(SRAV): Use new function do_srav.
+
+	* m16.igen (BEQZ, BNEZ): Compare GPR[TRX] not GPR[RX].
+	(B): Sign extend 11 bit immediate.
+	(EXT-B*): Shift 16 bit immediate left by 1.
+	(ADDIU*): Don't sign extend immediate value.
+
+Wed Apr 15 10:32:15 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* m16run.c (sim_engine_run): Restore CIA after handling an event.
+
+	* sim-main.h (DELAY_SLOT, NULLIFY_NEXT_INSTRUCTION): For IGEN, use
+ 	functions.
+
+	* mips.igen (delayslot32, nullify_next_insn): New functions.
+	(m16.igen): Always include.
+	(do_*): Add more tracing.
+
+	* m16.igen (delayslot16): Add NIA argument, could be called by a
+ 	32 bit MIPS16 instruction.
+	
+	* interp.c (ifetch16): Move function from here.
+	* sim-main.c (ifetch16): To here.
+	
+	* sim-main.c (ifetch16, ifetch32): Update to match current
+ 	implementations of LH, LW.
+	(signal_exception): Don't print out incorrect hex value of illegal
+ 	instruction.
+
+Wed Apr 15 00:17:25 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* m16run.c (sim_engine_run): Use IMEM16 and IMEM32 to fetch an
+ 	instruction.
+
+	* m16.igen: Implement MIPS16 instructions.
+	
+	* mips.igen (do_addiu, do_addu, do_and, do_daddiu, do_daddu,
+ 	do_ddiv, do_ddivu, do_div, do_divu, do_dmultx, do_dmultu, do_srav,
+ 	do_dsubu, do_mfhi, do_mflo, do_mult, do_multu, do_nor, do_or,
+ 	do_sll, do_sllv, do_slt, do_slti, do_sltiu, do_sltu, do_sra,
+ 	do_srl, do_srlv, do_subu, do_xor, do_xori): New functions.  Move
+ 	bodies of corresponding code from 32 bit insn to these.  Also used
+ 	by MIPS16 versions of functions.
+	
+	* sim-main.h (RAIDX, T8IDX, T8, SPIDX): Define.
+	(IMEM16): Drop NR argument from macro.
+
+Sat Apr  4 22:39:50 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (SIM_OBJS): Add sim-main.o.
+
+	* sim-main.h (address_translation, load_memory, store_memory,
+ 	cache_op, sync_operation, prefetch, ifetch32, pending_tick): Mark
+ 	as INLINE_SIM_MAIN.
+	(pr_addr, pr_uword64): Declare.
+	(sim-main.c): Include when H_REVEALS_MODULE_P.
+	
+	* interp.c (address_translation, load_memory, store_memory,
+ 	cache_op, sync_operation, prefetch, ifetch32, pending_tick): Move
+ 	from here.
+	* sim-main.c: To here. Fix compilation problems.
+	
+	* configure.in: Enable inlining.
+	* configure: Re-config.
+
+Sat Apr  4 20:36:25 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+
+Fri Apr  3 04:32:35 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* mips.igen: Include tx.igen.
+	* Makefile.in (IGEN_INCLUDE): Add tx.igen.
+	* tx.igen: New file, contains MADD and MADDU.
+
+	* interp.c (load_memory): When shifting bytes, use LOADDRMASK not
+ 	the hardwired constant `7'.
+	(store_memory): Ditto.
+	(LOADDRMASK): Move definition to sim-main.h.
+
+	mips.igen (MTC0): Enable for r3900.
+	(ADDU): Add trace.
+
+	mips.igen (do_load_byte): Delete.
+	(do_load, do_store, do_load_left, do_load_write, do_store_left,
+ 	do_store_right): New functions.
+	(SW*, LW*, SD*, LD*, SH, LH, SB, LB): Use.
+
+	configure.in: Let the tx39 use igen again.
+	configure: Update.
+	
+Thu Apr  2 10:59:39 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (sim_monitor): get_mem_info returns a 4 byte quantity,
+ 	not an address sized quantity.  Return zero for cache sizes.
+
+Wed Apr  1 23:47:53 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* mips.igen (r3900): r3900 does not support 64 bit integer
+ 	operations.
+
+Mon Mar 30 14:46:05 1998  Gavin Koch  <gavin@cygnus.com>
+
+	* configure.in (mipstx39*-*-*): Use gencode simulator rather
+	than igen one.
+	* configure : Rebuild.
+	
+Fri Mar 27 16:15:52 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+
+Fri Mar 27 15:01:50 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (mips_option_handler): Iterate over MAX_NR_PROCESSORS.
+
+Wed Mar 25 16:44:27 1998  Ian Carmichael  <iancarm@cygnus.com>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+	* config.in: Regenerated to track ../common/aclocal.m4 changes.
+
+Wed Mar 25 12:35:29 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+
+Wed Mar 25 10:05:46 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (Max, Min): Comment out functions. Not yet used.
+
+Wed Mar 18 12:38:12 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+
+Tue Mar 17 19:05:20 1998  Frank Ch. Eigler  <fche@cygnus.com>
+
+	* Makefile.in (MIPS_EXTRA_LIBS, SIM_EXTRA_LIBS): Added
+ 	configurable settings for stand-alone simulator.
+	
+	* configure.in: Added X11 search, just in case.
+	
+	* configure: Regenerated.
+
+Wed Mar 11 14:09:10 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (sim_write, sim_read, load_memory, store_memory):
+ 	Replace sim_core_*_map with read_map, write_map, exec_map resp.
+
+Tue Mar  3 13:58:43 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* sim-main.h (GETFCC): Return an unsigned value.
+
+Tue Mar  3 13:21:37 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* mips.igen (DIV): Fix check for -1 / MIN_INT.
+	(DADD): Result destination is RD not RT.
+
+Fri Feb 27 13:49:49 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* sim-main.h (HIACCESS, LOACCESS): Always define.
+
+	* mdmx.igen (Maxi, Mini): Rename Max, Min.
+
+	* interp.c (sim_info): Delete.
+
+Fri Feb 27 18:41:01 1998  Doug Evans  <devans@canuck.cygnus.com>
+
+	* interp.c (DECLARE_OPTION_HANDLER): Use it.
+	(mips_option_handler): New argument `cpu'.
+	(sim_open): Update call to sim_add_option_table.
+
+Wed Feb 25 18:56:22 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* mips.igen (CxC1): Add tracing.
+
+Fri Feb 20 17:43:21 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* sim-main.h (Max, Min): Declare.
+
+	* interp.c (Max, Min): New functions.
+
+	* mips.igen (BC1): Add tracing.
+	
+Thu Feb 19 14:50:00 1998  John Metzler  <jmetzler@cygnus.com>
+	
+	* interp.c Added memory map for stack in vr4100
+	
+Thu Feb 19 10:21:21 1998  Gavin Koch  <gavin@cygnus.com>
+
+	* interp.c (load_memory): Add missing "break"'s.
+
+Tue Feb 17 12:45:35 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (sim_store_register, sim_fetch_register): Pass in
+ 	length parameter.  Return -1.
+
+Tue Feb 10 11:57:40 1998  Ian Carmichael  <iancarm@cygnus.com>
+
+	* interp.c: Added hardware init hook, fixed warnings.
+
+Sat Feb  7 17:16:20 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (itable.h itable.c): Depend on SIM_@sim_gen@_ALL.
+
+Tue Feb  3 11:36:02 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (ifetch16): New function.
+
+	* sim-main.h (IMEM32): Rename IMEM.
+	(IMEM16_IMMED): Define.
+	(IMEM16): Define.
+	(DELAY_SLOT): Update.
+	
+	* m16run.c (sim_engine_run): New file.
+	
+	* m16.igen: All instructions except LB.
+	(LB): Call do_load_byte.
+	* mips.igen (do_load_byte): New function.
+	(LB): Call do_load_byte.
+
+	* mips.igen: Move spec for insn bit size and high bit from here.
+	* Makefile.in (tmp-igen, tmp-m16): To here.
+
+	* m16.dc: New file, decode mips16 instructions.
+
+	* Makefile.in (SIM_NO_ALL): Define.
+	(tmp-m16): Generate both 16 bit and 32 bit simulator engines.
+
+Tue Feb  3 11:28:00 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure.in (mips_fpu_bitsize): For tx39, restrict floating
+ 	point unit to 32 bit registers.
+	* configure: Re-generate.
+
+Sun Feb  1 15:47:14 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure.in (sim_use_gen): Make IGEN the default simulator
+ 	generator for generic 32 and 64 bit mips targets.
+	* configure: Re-generate.
+
+Sun Feb  1 16:52:37 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* sim-main.h (SizeFGR): Determine from floating-point and not gpr
+ 	bitsize.
+
+	* interp.c (sim_fetch_register, sim_store_register): Read/write
+ 	FGR from correct location.
+	(sim_open): Set size of FGR's according to
+ 	WITH_TARGET_FLOATING_POINT_BITSIZE.
+	
+	* sim-main.h (FGR): Store floating point registers in a separate
+ 	array.
+
+Sun Feb  1 16:47:51 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+
+Tue Feb  3 00:10:50 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (ColdReset): Call PENDING_INVALIDATE.
+
+	* sim-main.h (ENGINE_ISSUE_PREFIX_HOOK): Call PENDING_TICK.
+
+	* interp.c (pending_tick): New function.  Deliver pending writes.
+
+	* sim-main.h (PENDING_FILL, PENDING_TICK, PENDING_SCHED,
+ 	PENDING_BIT, PENDING_INVALIDATE): Re-write pipeline code so that
+ 	it can handle mixed sized quantites and single bits.
+	
+Mon Feb  2 17:43:15 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (oengine.h): Do not include when building with IGEN.
+	(sim_open): Replace GPRLEN by WITH_TARGET_WORD_BITSIZE.
+	(sim_info): Ditto for PROCESSOR_64BIT.
+	(sim_monitor): Replace ut_reg with unsigned_word.
+	(*): Ditto for t_reg.
+	(LOADDRMASK): Define.
+	(sim_open): Remove defunct check that host FP is IEEE compliant,
+ 	using software to emulate floating point.
+	(value_fpr, ...): Always compile, was conditional on HASFPU.
+
+Sun Feb  1 11:15:29 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* sim-main.h (sim_state): Make the cpu array MAX_NR_PROCESSORS in
+ 	size.
+
+	* interp.c (SD, CPU): Define.
+	(mips_option_handler): Set flags in each CPU.
+	(interrupt_event): Assume CPU 0 is the one being iterrupted.
+	(sim_close): Do not clear STATE, deleted anyway.
+	(sim_write, sim_read): Assume CPU zero's vm should be used for
+ 	data transfers.
+	(sim_create_inferior): Set the PC for all processors.
+	(sim_monitor, store_word, load_word, mips16_entry): Add cpu
+ 	argument.
+	(mips16_entry): Pass correct nr of args to store_word, load_word.
+	(ColdReset): Cold reset all cpu's.
+	(signal_exception): Pass cpu to sim_monitor & mips16_entry.
+	(sim_monitor, load_memory, store_memory, signal_exception): Use
+ 	`CPU' instead of STATE_CPU.
+
+
+	* sim-main.h: Replace uses of STATE_CPU with CPU. Replace sd with
+ 	SD or CPU_.
+	
+	* sim-main.h (signal_exception): Add sim_cpu arg.
+	(SignalException*): Pass both SD and CPU to signal_exception.
+	* interp.c (signal_exception): Update.
+	
+	* sim-main.h (value_fpr, store_fpr, dotrace, ifetch32), interp.c:
+ 	Ditto
+	(sync_operation, prefetch, cache_op, store_memory, load_memory,
+ 	address_translation): Ditto
+	(decode_coproc, cop_lw, cop_ld, cop_sw, cop_sd): Ditto.
+	
+Sat Jan 31 18:15:41 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+
+Sat Jan 31 14:49:24 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (sim_engine_run): Add `nr_cpus' argument.
+
+	* mips.igen (model): Map processor names onto BFD name.	
+
+	* sim-main.h (CPU_CIA): Delete.
+ 	(SET_CIA, GET_CIA): Define
+
+Wed Jan 21 16:16:27 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* sim-main.h (GPR_SET): Define, used by igen when zeroing a
+ 	regiser.
+
+	* configure.in (default_endian): Configure a big-endian simulator
+ 	by default.
+	* configure: Re-generate.
+	
+Mon Jan 19 22:26:29 1998  Doug Evans  <devans@seba>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+
+Mon Jan  5 20:38:54 1998  Mark Alexander  <marka@cygnus.com>
+
+	* interp.c (sim_monitor): Handle Densan monitor outbyte
+	and inbyte functions.
+
+1997-12-29  Felix Lee  <flee@cygnus.com>
+
+	* interp.c (sim_engine_run): msvc cpp barfs on #if (a==b!=c).
+
+Wed Dec 17 14:48:20 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (tmp-igen): Arrange for $zero to always be
+	reset to zero after every instruction.
+
+Mon Dec 15 23:17:11 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+	* config.in: Ditto.
+
+Wed Dec 10 17:10:45 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* mips.igen (MSUB): Fix to work like MADD.
+	* gencode.c (MSUB): Similarly.
+
+Thu Dec  4 09:21:05 1997  Doug Evans  <devans@canuck.cygnus.com>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+
+Wed Nov 26 11:00:23 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* mips.igen (LWC1): Correct assembler - lwc1 not swc1.
+
+Sun Nov 23 01:45:20 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* sim-main.h (sim-fpu.h): Include.
+
+	* interp.c (convert, SquareRoot, Recip, Divide, Multiply, Sub,
+ 	Add, Negate, AbsoluteValue, Equal, Less, Infinity, NaN): Rewrite
+ 	using host independant sim_fpu module.
+
+Thu Nov 20 19:56:22 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (signal_exception): Report internal errors with SIGABRT
+ 	not SIGQUIT.
+
+	* sim-main.h (C0_CONFIG): New register.
+	(signal.h): No longer include.
+
+	* interp.c (decode_coproc): Allow access C0_CONFIG to register.
+
+Tue Nov 18 15:33:48 1997  Doug Evans  <devans@canuck.cygnus.com>
+
+	* Makefile.in (SIM_OBJS): Use $(SIM_NEW_COMMON_OBJS).
+
+Fri Nov 14 11:56:48 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* mips.igen: Tag vr5000 instructions.
+	(ANDI): Was missing mipsIV model, fix assembler syntax.
+	(do_c_cond_fmt): New function.
+	(C.cond.fmt): Handle mips I-III which do not support CC field
+ 	separatly.
+	(bc1): Handle mips IV which do not have a delaed FCC separatly.
+	(SDR): Mask paddr when BigEndianMem, not the converse as specified
+ 	in IV3.2 spec.
+	(DMULT, DMULTU): Force use of hosts 64bit multiplication.  Handle
+ 	vr5000 which saves LO in a GPR separatly.
+	
+	* configure.in (enable-sim-igen): For vr5000, select vr5000
+ 	specific instructions.
+	* configure: Re-generate.
+	
+Wed Nov 12 14:42:52 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (SIM_OBJS): Add sim-fpu module.
+
+	* interp.c (store_fpr), sim-main.h: Add separate fmt_uninterpreted_32 and
+ 	fmt_uninterpreted_64 bit cases to switch.  Convert to
+ 	fmt_formatted,
+
+	* sim-main.h (ENGINE_ISSUE_PREFIX_HOOK): Define,
+
+	* mips.igen (SWR): Mask paddr when BigEndianMem, not the converse
+ 	as specified in IV3.2 spec.
+	(MTC1, DMTC1): Call StoreFPR to store the GPR in the FPR.
+
+Tue Nov 11 12:38:23 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* mips.igen: Delay slot branches add OFFSET to NIA not CIA.
+ 	(MFC0, MTC0, SWC1, LWC1, SDC1, LDC1): Implement.
+	(MTC1, MFC1, DMTC1, DMFC1, CFC1, CTC1): Implement separate non
+ 	PENDING_FILL versions of instructions.  Simplify.
+	(X): New function.
+	(MULT, MULTU): Implement separate RD==0 and RD!=0 versions of
+ 	instructions.
+	(BEQZ, ..., SLT, SLTI, TLT, TLE, TLI, ...): Explicitly cast GPR to
+ 	a signed value.
+	(MTHI, MFHI): Disable code checking HI-LO.
+	
+	* sim-main.h (dotrace,tracefh), interp.c: Make dotrace & tracefh
+ 	global.
+	(NULLIFY_NEXT_INSTRUCTION): Call dotrace.
+
+Thu Nov  6 16:36:35 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* gencode.c (build_mips16_operands): Replace IPC with cia.
+
+	* interp.c (sim_monitor, signal_exception, cache_op, store_fpr,
+ 	value_fpr, cop_ld, cop_lw, cop_sw, cop_sd, decode_coproc): Replace
+ 	IPC to `cia'.
+	(UndefinedResult): Replace function with macro/function
+ 	combination.
+	(sim_engine_run): Don't save PC in IPC.
+
+	* sim-main.h (IPC): Delete.
+
+
+	* interp.c (signal_exception, store_word, load_word,
+ 	address_translation, load_memory, store_memory, cache_op,
+ 	prefetch, sync_operation, ifetch, value_fpr, store_fpr, convert,
+ 	cop_lw, cop_ld, cop_sw, cop_sd, decode_coproc, sim_monitor): Add
+ 	current instruction address - cia - argument.
+	(sim_read, sim_write): Call address_translation directly.
+	(sim_engine_run): Rename variable vaddr to cia.
+	(signal_exception): Pass cia to sim_monitor
+	
+	* sim-main.h (SignalException, LoadWord, StoreWord, CacheOp,
+ 	Prefetch, SyncOperation, ValueFPR, StoreFPR, Convert, COP_LW,
+ 	COP_LD, COP_SW, COP_SD, DecodeCoproc): Update.
+
+	* sim-main.h (SignalExceptionSimulatorFault): Delete definition.
+  	* interp.c (sim_open): Replace SignalExceptionSimulatorFault with
+ 	SIM_ASSERT.
+	
+	* interp.c (signal_exception): Pass restart address to
+ 	sim_engine_restart.
+
+	* Makefile.in (semantics.o, engine.o, support.o, itable.o,
+ 	idecode.o): Add dependency.
+
+	* sim-main.h (SIM_ENGINE_HALT_HOOK, SIM_ENGINE_RESUME_HOOK):
+ 	Delete definitions
+	(DELAY_SLOT): Update NIA not PC with branch address.
+	(NULLIFY_NEXT_INSTRUCTION): Set NIA to instruction after next.
+
+	* mips.igen: Use CIA not PC in branch calculations.
+	(illegal): Call SignalException.
+ 	(BEQ, ADDIU): Fix assembler.
+
+Wed Nov  5 12:19:56 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* m16.igen (JALX): Was missing.
+
+	* configure.in (enable-sim-igen): New configuration option.
+	* configure: Re-generate.
+	
+	* sim-main.h (MAX_INSNS, INSN_NAME): Define.
+
+	* interp.c (load_memory, store_memory): Delete parameter RAW.
+	(sim_read, sim_write): Use sim_core_{read,write}_buffer directly
+ 	bypassing {load,store}_memory.
+
+	* sim-main.h (ByteSwapMem): Delete definition.
+
+	* Makefile.in (SIM_OBJS): Add sim-memopt module.
+
+	* interp.c (sim_do_command, sim_commands): Delete mips specific
+ 	commands.  Handled by module sim-options.
+		
+	* sim-main.h (SIM_HAVE_FLATMEM): Undefine, use sim-core.o module.
+	(WITH_MODULO_MEMORY): Define.
+
+	* interp.c (sim_info): Delete code printing memory size.
+
+	* interp.c (mips_size): Nee sim_size, delete function.
+	(power2): Delete.
+	(monitor, monitor_base, monitor_size): Delete global variables.
+	(sim_open, sim_close): Delete code creating monitor and other
+ 	memory regions.  Use sim-memopts module, via sim_do_commandf, to
+ 	manage memory regions.
+	(load_memory, store_memory): Use sim-core for memory model.
+	
+	* interp.c (address_translation): Delete all memory map code
+ 	except line forcing 32 bit addresses.
+
+Wed Nov  5 11:21:11 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* sim-main.h (WITH_TRACE): Delete definition.  Enables common
+ 	trace options.
+
+	* interp.c (logfh, logfile): Delete globals.
+	(sim_open, sim_close): Delete code opening & closing log file.
+	(mips_option_handler): Delete -l and -n options.
+	(OPTION mips_options): Ditto.
+
+	* interp.c (OPTION mips_options): Rename option trace to dinero.
+	(mips_option_handler): Update.
+
+Wed Nov  5 09:35:59 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (fetch_str): New function.
+	(sim_monitor): Rewrite using sim_read & sim_write.
+	(sim_open): Check magic number.
+	(sim_open): Write monitor vectors into memory using sim_write.
+	(MONITOR_BASE, MONITOR_SIZE, MEM_SIZE): Define.
+	(sim_read, sim_write): Simplify - transfer data one byte at a
+ 	time.
+	(load_memory, store_memory): Clarify meaning of parameter RAW.
+
+	* sim-main.h (isHOST): Defete definition.
+	(isTARGET): Mark as depreciated.
+	(address_translation): Delete parameter HOST.
+
+	* interp.c (address_translation): Delete parameter HOST.
+
+Wed Oct 29 11:13:56 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* mips.igen: 
+
+	* Makefile.in (IGEN_INCLUDE): Files included by mips.igen.
+	(tmp-igen, tmp-m16): Depend on IGEN_INCLUDE.
+
+Tue Oct 28 11:06:47 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* mips.igen: Add model filter field to records.
+
+Mon Oct 27 17:53:59 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (SIM_NO_CFLAGS): Define.  Define WITH_IGEN=0.
+	
+	interp.c (sim_engine_run): Do not compile function sim_engine_run
+ 	when WITH_IGEN == 1.
+
+	* configure.in (sim_igen_flags, sim_m16_flags): Set according to
+ 	target architecture.
+
+	Makefile.in (tmp-igen, tmp-m16): Drop -F and -M options to
+ 	igen. Replace with configuration variables sim_igen_flags /
+ 	sim_m16_flags.
+
+	* m16.igen: New file.  Copy mips16 insns here.
+	* mips.igen: From here.
+
+Mon Oct 27 13:53:59 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (SIM_NO_OBJ): Define, move SIM_M16_OBJ, SIM_IGEN_OBJ
+ 	to top.
+	(tmp-igen, tmp-m16): Pass -I srcdir to igen.
+
+Sat Oct 25 16:51:40 1997  Gavin Koch  <gavin@cygnus.com>
+
+	* gencode.c (build_instruction): Follow sim_write's lead in using
+	BigEndianMem instead of !ByteSwapMem.
+
+Fri Oct 24 17:41:49 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure.in (sim_gen): Dependent on target, select type of
+ 	generator.  Always select old style generator.
+
+	configure: Re-generate.
+
+	Makefile.in (tmp-igen, tmp-m16, clean-m16, clean-igen): New
+ 	targets.
+	(SIM_M16_CFLAGS, SIM_M16_ALL, SIM_M16_OBJ, BUILT_SRC_FROM_M16,
+ 	SIM_IGEN_CFLAGS, SIM_IGEN_ALL, SIM_IGEN_OBJ, BUILT_SRC_FROM_IGEN,
+ 	IGEN_TRACE, IGEN_INSN, IGEN_DC): Define
+	(SIM_EXTRA_CFLAGS, SIM_EXTRA_ALL, SIM_OBJS): Add member
+ 	SIM_@sim_gen@_*, set by autoconf.
+	
+Wed Oct 22 12:52:06 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* sim-main.h (NULLIFY_NEXT_INSTRUCTION, DELAY_SLOT): Define.
+
+	* interp.c (ColdReset): Remove #ifdef HASFPU, check
+ 	CURRENT_FLOATING_POINT instead.
+
+	* interp.c (ifetch32): New function. Fetch 32 bit instruction.
+	(address_translation): Raise exception InstructionFetch when
+ 	translation fails and isINSTRUCTION.
+	
+	* interp.c (sim_open, sim_write, sim_monitor, store_word,
+ 	sim_engine_run): Change type of of vaddr and paddr to
+ 	address_word.
+	(address_translation, prefetch, load_memory, store_memory,
+ 	cache_op): Change type of vAddr and pAddr to address_word.
+
+	* gencode.c (build_instruction): Change type of vaddr and paddr to
+ 	address_word.
+
+Mon Oct 20 15:29:04 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* sim-main.h (ALU64_END, ALU32_END): Use ALU*_OVERFLOW_RESULT
+ 	macro to obtain result of ALU op.
+
+Tue Oct 21 17:39:14 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (sim_info): Call profile_print.
+
+Mon Oct 20 13:31:20 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (SIM_OBJS): Add sim-profile.o module.
+
+	* sim-main.h (WITH_PROFILE): Do not define, defined in
+ 	common/sim-config.h.  Use sim-profile module.
+	(simPROFILE): Delete defintion.
+
+	* interp.c (PROFILE): Delete definition.
+	(mips_option_handler): Delete 'p', 'y' and 'x' profile options.
+	(sim_close): Delete code writing profile histogram.
+	(mips_set_profile, mips_set_profile_size, writeout16, writeout32):
+ 	Delete.
+	(sim_engine_run): Delete code profiling the PC.
+
+Mon Oct 20 13:31:20 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* sim-main.h (SIGNEXTEND): Force type of result to unsigned_word.
+
+	* interp.c (sim_monitor): Make register pointers of type
+ 	unsigned_word*.
+
+	* sim-main.h: Make registers of type unsigned_word not
+ 	signed_word.
+
+Thu Oct 16 10:31:39 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (sync_operation): Rename from SyncOperation, make
+ 	global, add SD argument.
+	(prefetch): Rename from Prefetch, make global, add SD argument.
+	(decode_coproc): Make global.
+
+	* sim-main.h (SyncOperation, DecodeCoproc, Pefetch): Define.
+
+	* gencode.c (build_instruction): Generate DecodeCoproc not
+ 	decode_coproc calls.
+
+	* interp.c (SETFCC, GETFCC, PREVCOC1): Move to sim-main.h
+	(SizeFGR): Move to sim-main.h
+	(simHALTEX, simHALTIN, simTRACE, simPROFILE, simDELAYSLOT,
+ 	simSIGINT, simJALDELAYSLOT): Move to sim-main.h
+	(FP_FLAGS, FP_ENABLE, FP_CAUSE, IR, UF, OF, DZ, IO, UO): Move to
+ 	sim-main.h.
+	(FP_FS, FP_MASK_RM, FP_SH_RM, FP_RM_NEAREST, FP_RM_TOPINF,
+ 	FP_RM_TOMINF, GETRM): Move to sim-main.h.
+	(Uncached, CachedNoncoherent, CachedCoherent, Cached,
+ 	isINSTRUCTION, ..., AccessLength_BYTE, ...): Move to sim-main.h.
+	(UserMode, BigEndianMem, ByteSwapMem, ReverseEndian,
+ 	BigEndianCPU, status_KSU_mask, ...). Moved to sim-main.h
+	
+	* sim-main.h (ALU32_END, ALU64_END): Define. When overflow raise
+ 	exception.
+	(sim-alu.h): Include.
+	(NULLIFY_NIA, NULL_CIA, CPU_CIA): Define.
+ 	(sim_cia): Typedef to instruction_address.
+	
+Thu Oct 16 10:31:41 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (interp.o): Rename generated file engine.c to
+	oengine.c.
+  	
+	* interp.c: Update.
+	
+Thu Oct 16 10:31:40 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* gencode.c (build_instruction): Use FPR_STATE not fpr_state.
+	
+Thu Oct 16 10:31:39 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* gencode.c (build_instruction): For "FPSQRT", output correct
+ 	number of arguments to Recip.
+	
+Tue Oct 14 17:38:18 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (interp.o): Depends on sim-main.h
+
+	* interp.c (mips16_entry, ColdReset,dotrace): Add SD argument. Use GPR not registers.
+
+	* sim-main.h (sim_cpu): Add registers, register_widths, fpr_state,
+ 	ipc, dspc, pending_*, hiaccess, loaccess, state, dsstate fields.
+ 	(REGISTERS, REGISTER_WIDTHS, FPR_STATE, IPC, DSPC, PENDING_*,
+ 	STATE, DSSTATE): Define
+	(GPR, FGRIDX, ..): Define.
+
+	* interp.c (registers, register_widths, fpr_state, ipc, dspc,
+ 	pending_*, hiaccess, loaccess, state, dsstate): Delete globals.
+	(GPR, FGRIDX, ...): Delete macros.
+	
+	* interp.c: Update names to match defines from sim-main.h
+	
+Tue Oct 14 15:11:45 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (sim_monitor): Add SD argument.
+	(sim_warning): Delete.  Replace calls with calls to
+ 	sim_io_eprintf.
+	(sim_error): Delete. Replace calls with sim_io_error.
+	(open_trace, writeout32, writeout16, getnum): Add SD argument.
+	(mips_set_profile): Rename from sim_set_profile. Add SD argument.
+	(mips_set_profile_size): Rename from sim_set_profile_size. Add SD
+ 	argument.
+	(mips_size): Rename from sim_size. Add SD argument.
+
+	* interp.c (simulator): Delete global variable.
+	(callback): Delete global variable.
+	(mips_option_handler, sim_open, sim_write, sim_read,
+ 	sim_store_register, sim_fetch_register, sim_info, sim_do_command,
+ 	sim_size,sim_monitor): Use sim_io_* not callback->*.
+	(sim_open): ZALLOC simulator struct.
+	(PROFILE): Do not define.
+
+Tue Oct 14 13:35:48 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (sim_open), support.h: Replace CHECKSIM macro found in
+ 	support.h with corresponding code.
+
+	* sim-main.h (word64, uword64), support.h: Move definition to
+ 	sim-main.h.
+	(WORD64LO, WORD64HI, SET64LO, SET64HI, WORD64, UWORD64): Ditto.
+
+	* support.h: Delete
+	* Makefile.in: Update dependencies
+	* interp.c: Do not include.
+	
+Tue Oct 14 13:35:48 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (address_translation, load_memory, store_memory,
+ 	cache_op): Rename to from AddressTranslation et.al., make global,
+ 	add SD argument
+	
+	* sim-main.h (AddressTranslation, LoadMemory, StoreMemory,
+ 	CacheOp): Define.
+	
+	* interp.c (SignalException): Rename to signal_exception, make
+ 	global.
+
+	* interp.c (Interrupt, ...): Move definitions to sim-main.h.
+	
+	* sim-main.h (SignalException, SignalExceptionInterrupt,
+ 	SignalExceptionInstructionFetch, SignalExceptionAddressStore,
+ 	SignalExceptionAddressLoad, SignalExceptionSimulatorFault,
+ 	SignalExceptionIntegerOverflow, SignalExceptionCoProcessorUnusable):
+ 	Define.
+  	
+	* interp.c, support.h: Use.
+	
+Tue Oct 14 13:19:20 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (ValueFPR, StoreFPR), sim-main.h: Make global, rename
+ 	to value_fpr / store_fpr. Add SD argument.
+	(NaN, Infinity, Less, Equal, AbsoluteValue, Negate, Add, Sub,
+ 	Multiply, Divide, Recip, SquareRoot, Convert): Make global.
+
+	* sim-main.h (ValueFPR, StoreFPR): Define.
+	
+Tue Oct 14 13:06:55 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (sim_engine_run): Check consistency between configure
+ 	WITH_TARGET_WORD_BITSIZE and WITH_FLOATING_POINT and gensim GPRLEN
+ 	and HASFPU.
+
+	* configure.in (mips_bitsize): Configure WITH_TARGET_WORD_BITSIZE.
+        (mips_fpu): Configure WITH_FLOATING_POINT.
+	(mips_endian): Configure WITH_TARGET_ENDIAN.
+	* configure: Update.
+
+Fri Oct  3 09:28:00 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+
+Mon Sep 29 14:45:00 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* configure: Regenerated.
+
+Fri Sep 26 12:48:18 1997  Mark Alexander  <marka@cygnus.com>
+
+	* interp.c: Allow Debug, DEPC, and EPC registers to be examined in GDB.
+
+Thu Sep 25 11:15:22 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* gencode.c (print_igen_insn_models): Assume certain architectures
+ 	include all mips* instructions.
+	(print_igen_insn_format): Use data_size==-1 as marker for MIPS16
+ 	instruction.
+
+	* Makefile.in (tmp.igen): Add target. Generate igen input from
+ 	gencode file.
+
+	* gencode.c (FEATURE_IGEN): Define.
+	(main): Add --igen option.  Generate output in igen format.
+	(process_instructions): Format output according to igen option.
+	(print_igen_insn_format): New function.
+	(print_igen_insn_models): New function.
+	(process_instructions): Only issue warnings and ignore
+ 	instructions when no FEATURE_IGEN.
+
+Wed Sep 24 17:38:57 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (COP_SD, COP_LD): Add UNUSED to pacify GCC for some
+ 	MIPS targets.
+
+Tue Sep 23 11:04:38 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+
+Tue Sep 23 10:19:51 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (SIM_ALIGNMENT, SIM_ENDIAN, SIM_HOSTENDIAN,
+ 	SIM_RESERVED_BITS): Delete, moved to common.
+	(SIM_EXTRA_CFLAGS): Update.
+	
+Mon Sep 22 11:46:20 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure.in: Configure non-strict memory alignment.
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+
+Fri Sep 19 17:45:25 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+
+Sat Sep 20 14:07:28 1997  Gavin Koch  <gavin@cygnus.com>
+
+	* gencode.c (SDBBP,DERET): Added (3900) insns.
+	(RFE): Turn on for 3900.
+	* interp.c (DebugBreakPoint,DEPC,Debug,Debug_*): Added.
+	(dsstate): Made global.
+	(SUBTARGET_R3900): Added.
+	(CANCELDELAYSLOT): New.
+	(SignalException): Ignore SystemCall rather than ignore and
+	terminate.  Add DebugBreakPoint handling.
+	(decode_coproc): New insns RFE, DERET; and new registers Debug
+	and DEPC protected by SUBTARGET_R3900.
+	(sim_engine_run): Use CANCELDELAYSLOT rather than clearing
+	bits explicitly.
+	* Makefile.in,configure.in: Add mips subtarget option.
+	* configure: Update.	
+
+Fri Sep 19 09:33:27 1997  Gavin Koch  <gavin@cygnus.com>
+
+	* gencode.c: Add r3900 (tx39).
+	
+
+Tue Sep 16 15:52:04 1997  Gavin Koch  <gavin@cygnus.com>
+
+	* gencode.c (build_instruction): Don't need to subtract 4 for
+	JALR, just 2.
+
+Tue Sep 16 11:32:28 1997  Gavin Koch  <gavin@cygnus.com>
+
+	* interp.c: Correct some HASFPU problems.
+
+Mon Sep 15 17:36:15 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+
+Fri Sep 12 12:01:39 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (mips_options): Fix samples option short form, should
+ 	be `x'.
+
+Thu Sep 11 09:35:29 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (sim_info): Enable info code.  Was just returning.
+
+Tue Sep  9 17:30:57 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (decode_coproc): Clarify warning about unsuported MTC0,
+ 	MFC0.
+
+Tue Sep  9 16:28:28 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* gencode.c (build_instruction): Use SIGNED64 for 64 bit
+ 	constants.
+	(build_instruction): Ditto for LL.
+
+Thu Sep  4 17:21:23 1997  Doug Evans  <dje@seba>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+
+Wed Aug 27 18:13:22 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+	* config.in: Ditto.
+
+Wed Aug 27 14:12:27 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (sim_open): Add call to sim_analyze_program, update
+ 	call to sim_config.
+
+Tue Aug 26 10:40:07 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (sim_kill): Delete.
+	(sim_create_inferior): Add ABFD argument. Set PC from same.
+	(sim_load): Move code initializing trap handlers from here.
+	(sim_open): To here.
+	(sim_load): Delete, use sim-hload.c.
+
+	* Makefile.in (SIM_OBJS): Add sim-hload.o module.
+
+Mon Aug 25 17:50:22 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+	* config.in: Ditto.
+
+Mon Aug 25 15:59:48 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (sim_open): Add ABFD argument.
+	(sim_load): Move call to sim_config from here.
+	(sim_open): To here.  Check return status.
+
+Fri Jul 25 15:00:45 1997  Gavin Koch  <gavin@cygnus.com>
+ 
+ 	* gencode.c (build_instruction): Two arg MADD should
+ 	not assign result to $0.
+ 
+Thu Jun 26 12:13:17 1997  Angela Marie Thomas (angela@cygnus.com)
+
+	* sim/mips/configure: Change default_sim_endian to 0 (bi-endian)
+	* sim/mips/configure.in: Regenerate.
+
+Wed Jul  9 10:29:21 1997  Andrew Cagney  <cagney@critters.cygnus.com>
+
+	* interp.c (SUB_REG_UW, SUB_REG_SW, SUB_REG_*): Use more explicit
+ 	signed8, unsigned8 et.al. types.
+
+	* interp.c (SUB_REG_FETCH): Handle both little and big endian
+ 	hosts when selecting subreg.
+
+Wed Jul  2 11:54:10 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* interp.c (sim_engine_run): Reset the ZERO register to zero
+	regardless of FEATURE_WARN_ZERO.
+	* gencode.c (FEATURE_WARNINGS): Remove FEATURE_WARN_ZERO.
+
+Wed Jun  4 10:43:14 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (decode_coproc): Implement MTC0 N, CAUSE.
+	(SignalException): For BreakPoints ignore any mode bits and just
+ 	save the PC.
+	(SignalException): Always set the CAUSE register.
+
+Tue Jun  3 05:00:33 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (SignalException): Clear the simDELAYSLOT flag when an
+ 	exception has been taken.
+
+	* interp.c: Implement the ERET and mt/f sr instructions.
+
+Sat May 31 00:44:16 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (SignalException): Don't bother restarting an
+ 	interrupt.
+
+Fri May 30 23:41:48 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (SignalException): Really take an interrupt.
+	(interrupt_event): Only deliver interrupts when enabled.
+
+Tue May 27 20:08:06 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (sim_info): Only print info when verbose.
+	(sim_info) Use sim_io_printf for output.
+	
+Tue May 27 14:22:23 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (CoProcPresent): Add UNUSED attribute - not used by all
+ 	mips architectures.
+
+Tue May 27 14:22:23 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (sim_do_command): Check for common commands if a
+ 	simulator specific command fails.
+
+Thu May 22 09:32:03 1997  Gavin Koch  <gavin@cygnus.com>
+
+	* interp.c (sim_engine_run): ifdef out uses of simSTOP, simSTEP
+	and simBE when DEBUG is defined.
+
+Wed May 21 09:08:10 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (interrupt_event): New function.  Pass exception event
+ 	onto exception handler.
+
+	* configure.in: Check for stdlib.h.
+	* configure: Regenerate.
+
+	* gencode.c (build_instruction): Add UNUSED attribute to tempS
+ 	variable declaration.
+	(build_instruction): Initialize memval1.
+	(build_instruction): Add UNUSED attribute to byte, bigend,
+ 	reverse.
+	(build_operands): Ditto.
+
+	* interp.c: Fix GCC warnings.
+	(sim_get_quit_code): Delete.
+
+	* configure.in: Add INLINE, ENDIAN, HOSTENDIAN and WARNINGS.
+	* Makefile.in: Ditto.
+	* configure: Re-generate.
+	
+	* Makefile.in (SIM_OBJS): Add sim-watch.o module.
+
+Tue May 20 15:08:56 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (mips_option_handler): New function parse argumes using
+ 	sim-options.
+	(myname): Replace with STATE_MY_NAME.
+	(sim_open): Delete check for host endianness - performed by
+ 	sim_config.
+	(simHOSTBE, simBE): Delete, replaced by sim-endian flags.
+	(sim_open): Move much of the initialization from here.
+	(sim_load): To here.  After the image has been loaded and
+ 	endianness set.
+	(sim_open): Move ColdReset from here.
+	(sim_create_inferior): To here.
+	(sim_open): Make FP check less dependant on host endianness.
+
+	* Makefile.in (SIM_RUN_OBJS): Set to nrun.o - use new version or
+ 	run.
+	* interp.c (sim_set_callbacks): Delete.
+
+	* interp.c (membank, membank_base, membank_size): Replace with
+ 	STATE_MEMORY, STATE_MEM_SIZE, STATE_MEM_BASE.
+	(sim_open): Remove call to callback->init. gdb/run do this.
+
+	* interp.c: Update
+
+	* sim-main.h (SIM_HAVE_FLATMEM): Define.
+
+	* interp.c (big_endian_p): Delete, replaced by
+ 	current_target_byte_order.
+
+Tue May 20 13:55:00 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (host_read_long, host_read_word, host_swap_word,
+ 	host_swap_long): Delete. Using common sim-endian.
+	(sim_fetch_register, sim_store_register): Use H2T.
+	(pipeline_ticks): Delete.  Handled by sim-events.
+	(sim_info): Update.
+	(sim_engine_run): Update.
+
+Tue May 20 13:42:03 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (sim_stop_reason): Move code determining simEXCEPTION
+ 	reason from here.
+	(SignalException): To here. Signal using sim_engine_halt.
+	(sim_stop_reason): Delete, moved to common.
+	
+Tue May 20 10:19:48 1997  Andrew Cagney  <cagney@b2.cygnus.com>
+
+	* interp.c (sim_open): Add callback argument.
+	(sim_set_callbacks): Delete SIM_DESC argument.
+	(sim_size): Ditto.
+
+Mon May 19 18:20:38 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (SIM_OBJS): Add common modules.
+
+	* interp.c (sim_set_callbacks): Also set SD callback.
+	(set_endianness, xfer_*, swap_*): Delete.
+	(host_read_word, host_read_long, host_swap_word, host_swap_long):
+ 	Change to functions using sim-endian macros.
+	(control_c, sim_stop): Delete, use common version.
+	(simulate): Convert into.
+	(sim_engine_run): This function.
+	(sim_resume): Delete.
+	
+	* interp.c (simulation): New variable - the simulator object.
+	(sim_kind): Delete global - merged into simulation.
+	(sim_load): Cleanup.  Move PC assignment from here.
+	(sim_create_inferior): To here.
+
+	* sim-main.h: New file.
+	* interp.c (sim-main.h): Include.
+	
+Thu Apr 24 00:39:51 1997  Doug Evans  <dje@canuck.cygnus.com>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+
+Wed Apr 23 17:32:19 1997  Doug Evans  <dje@canuck.cygnus.com>
+
+	* tconfig.in (SIM_HAVE_BIENDIAN): Define.
+
+Mon Apr 21 17:16:13 1997  Gavin Koch  <gavin@cygnus.com>
+
+	* gencode.c (build_instruction): DIV instructions: check 
+	for division by zero and integer overflow before using 
+	host's division operation.
+
+Thu Apr 17 03:18:14 1997  Doug Evans  <dje@canuck.cygnus.com>
+
+	* Makefile.in (SIM_OBJS): Add sim-load.o.
+	* interp.c: #include bfd.h.
+	(target_byte_order): Delete.
+	(sim_kind, myname, big_endian_p): New static locals.
+	(sim_open): Set sim_kind, myname.  Move call to set_endianness to
+	after argument parsing.  Recognize -E arg, set endianness accordingly.
+	(sim_load): Return SIM_RC.  New arg abfd.  Call sim_load_file to
+	load file into simulator.  Set PC from bfd.
+	(sim_create_inferior): Return SIM_RC.  Delete arg start_address.
+	(set_endianness): Use big_endian_p instead of target_byte_order.
+
+Wed Apr 16 17:55:37 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* interp.c (sim_size): Delete prototype - conflicts with
+ 	definition in remote-sim.h.  Correct definition.
+
+Mon Apr  7 15:45:02 1997  Andrew Cagney  <cagney@kremvax.cygnus.com>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+	* config.in: Ditto.
+
+Wed Apr  2 15:06:28 1997  Doug Evans  <dje@canuck.cygnus.com>
+
+	* interp.c (sim_open): New arg `kind'.
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+
+Wed Apr  2 14:34:19 1997 Andrew Cagney <cagney@kremvax.cygnus.com>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+
+Tue Mar 25 11:38:22 1997  Doug Evans  <dje@canuck.cygnus.com>
+
+	* interp.c (sim_open): Set optind to 0 before calling getopt.
+
+Wed Mar 19 01:14:00 1997  Andrew Cagney  <cagney@kremvax.cygnus.com>
+
+	* configure: Regenerated to track ../common/aclocal.m4 changes.
+
+Mon Mar 17 10:52:59 1997  Gavin Koch  <gavin@cetus.cygnus.com>
+
+	* interp.c : Replace uses of pr_addr with pr_uword64
+	where the bit length is always 64 independent of SIM_ADDR.
+	(pr_uword64) : added.
+
+Mon Mar 17 15:10:07 1997  Andrew Cagney  <cagney@kremvax.cygnus.com>
+
+	* configure: Re-generate.
+
+Fri Mar 14 10:34:11 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* configure: Regenerate to track ../common/aclocal.m4 changes.
+
+Thu Mar 13 12:51:36 1997  Doug Evans  <dje@canuck.cygnus.com>
+
+	* interp.c (sim_open): New SIM_DESC result.  Argument is now
+	in argv form.
+	(other sim_*): New SIM_DESC argument.
+
+Mon Feb 24 22:47:14 1997  Dawn Perchik  <dawn@cygnus.com>
+
+	* interp.c: Fix printing of addresses for non-64-bit targets.
+	(pr_addr): Add function to print address based on size.
+
+Wed Feb 19 14:42:09 1997  Mark Alexander  <marka@cygnus.com>
+
+	* interp.c (simopen): Add support for LSI MiniRISC PMON vectors.
+
+Thu Feb 13 14:08:30 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* gencode.c (build_mips16_operands): Correct computation of base
+	address for extended PC relative instruction.
+
+Thu Feb  6 17:16:15 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* interp.c (mips16_entry): Add support for floating point cases.
+	(SignalException): Pass floating point cases to mips16_entry.
+	(ValueFPR): Don't restrict fmt_single and fmt_word to even
+	registers.
+	(StoreFPR): Likewise.  Also, don't clobber fpr + 1 for fmt_single
+	or fmt_word.
+	(COP_LW): Pass fmt_word rather than fmt_uninterpreted to StoreFPR,
+	and then set the state to fmt_uninterpreted.
+	(COP_SW): Temporarily set the state to fmt_word while calling
+	ValueFPR.
+
+Tue Feb  4 16:48:25 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* gencode.c (build_instruction): The high order may be set in the
+	comparison flags at any ISA level, not just ISA 4.
+
+Tue Feb  4 13:33:30 1997  Doug Evans  <dje@canuck.cygnus.com>
+
+	* Makefile.in (@COMMON_MAKEFILE_FRAG): Use
+	COMMON_{PRE,POST}_CONFIG_FRAG instead.
+	* configure.in: sinclude ../common/aclocal.m4.
+	* configure: Regenerated.
+
+Fri Jan 31 11:11:45 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Rebuild after change to aclocal.m4.
+
+Thu Jan 23 11:46:23 1997  Stu Grossman  (grossman@critters.cygnus.com)
+
+	* configure configure.in Makefile.in:  Update to new configure
+	scheme which is more compatible with WinGDB builds.
+	* configure.in:  Improve comment on how to run autoconf.
+	* configure:  Re-run autoconf to get new ../common/aclocal.m4.
+	* Makefile.in:  Use autoconf substitution to install common
+	makefile fragment.
+
+Wed Jan  8 12:39:03 1997  Jim Wilson  <wilson@cygnus.com>
+
+	* gencode.c (build_instruction): Use BigEndianCPU instead of
+	ByteSwapMem.
+
+Thu Jan 02 22:23:04 1997  Mark Alexander  <marka@cygnus.com>
+
+	* interp.c (sim_monitor): Make output to stdout visible in
+	wingdb's I/O log window.
+
+Tue Dec 31 07:04:00 1996  Mark Alexander  <marka@cygnus.com>
+
+	* support.h: Undo previous change to SIGTRAP
+	and SIGQUIT values.
+
+Mon Dec 30 17:36:06 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* interp.c (store_word, load_word): New static functions.
+	(mips16_entry): New static function.
+	(SignalException): Look for mips16 entry and exit instructions.
+	(simulate): Use the correct index when setting fpr_state after
+	doing a pending move.
+
+Sun Dec 29 09:37:18 1996  Mark Alexander  <marka@cygnus.com>
+
+	* interp.c: Fix byte-swapping code throughout to work on
+	both little- and big-endian hosts.
+
+Sun Dec 29 09:18:32 1996  Mark Alexander  <marka@cygnus.com>
+
+	* support.h: Make definitions of SIGTRAP and SIGQUIT consistent
+	with gdb/config/i386/xm-windows.h.
+
+Fri Dec 27 22:48:51 1996  Mark Alexander  <marka@cygnus.com>
+
+	* gencode.c (build_instruction): Work around MSVC++ code gen bug
+	that messes up arithmetic shifts.
+
+Fri Dec 20 11:04:05 1996  Stu Grossman  (grossman@critters.cygnus.com)
+
+	* support.h:  Use _WIN32 instead of __WIN32__.  Also add defs for
+	SIGTRAP and SIGQUIT for _WIN32.
+
+Thu Dec 19 14:07:27 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* gencode.c (build_instruction) [MUL]: Cast operands to word64, to
+	force a 64 bit multiplication.
+	(build_instruction) [OR]: In mips16 mode, don't do anything if the
+	destination register is 0, since that is the default mips16 nop
+	instruction.
+
+Mon Dec 16 14:59:38 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* gencode.c (MIPS16_DECODE): SWRASP is I8, not RI.
+	(build_endian_shift): Don't check proc64.
+	(build_instruction): Always set memval to uword64.  Cast op2 to
+	uword64 when shifting it left in memory instructions.  Always use
+	the same code for stores--don't special case proc64.
+
+	* gencode.c (build_mips16_operands): Fix base PC value for PC
+	relative operands.
+	(build_instruction): Call JALDELAYSLOT rather than DELAYSLOT for a
+	jal instruction.
+	* interp.c (simJALDELAYSLOT): Define.
+ 	(JALDELAYSLOT): Define.
+	(INDELAYSLOT, INJALDELAYSLOT): Define.
+	(simulate): Clear simJALDELAYSLOT when simDELAYSLOT is cleared.
+
+Tue Dec 24 22:11:20 1996  Angela Marie Thomas (angela@cygnus.com)
+
+	* interp.c (sim_open): add flush_cache as a PMON routine
+	(sim_monitor): handle flush_cache by ignoring it
+
+Wed Dec 11 13:53:51 1996  Jim Wilson  <wilson@cygnus.com>
+
+	* gencode.c (build_instruction): Use !ByteSwapMem instead of
+	BigEndianMem.
+	* interp.c (CONFIG, config_EP_{mask,shift,D,DxxDxx, config_BE): Delete.
+	(BigEndianMem): Rename to ByteSwapMem and change sense.
+	(BigEndianCPU, sim_write, LoadMemory, StoreMemory): Change
+	BigEndianMem references to !ByteSwapMem.
+	(set_endianness): New function, with prototype.
+	(sim_open): Call set_endianness.
+	(sim_info): Use simBE instead of BigEndianMem.
+	(xfer_direct_word, xfer_direct_long, swap_direct_word,
+	swap_direct_long, xfer_big_word, xfer_big_long, xfer_little_word,
+	xfer_little_long, swap_word, swap_long): Delete unnecessary MSC_VER
+	ifdefs, keeping the prototype declaration.
+	(swap_word): Rewrite correctly.
+	(ColdReset): Delete references to CONFIG.  Delete endianness related
+	code; moved to set_endianness.
+	
+Tue Dec 10 11:32:04 1996  Jim Wilson  <wilson@cygnus.com>
+
+	* gencode.c (build_instruction, case JUMP): Truncate PC to 32 bits.
+	* interp.c (CHECKHILO): Define away.
+	(simSIGINT): New macro.
+	(membank_size): Increase from 1MB to 2MB.
+	(control_c): New function.
+	(sim_resume): Rename parameter signal to signal_number.  Add local
+	variable prev.  Call signal before and after simulate.
+	(sim_stop_reason): Add simSIGINT support.
+	(sim_warning, sim_error, dotrace, SignalException): Define as stdarg
+	functions always.
+	(sim_warning): Delete call to SignalException.  Do call printf_filtered
+	if logfh is NULL.
+	(AddressTranslation): Add #ifdef DEBUG around debugging message and
+	a call to sim_warning.
+
+Wed Nov 27 11:53:50 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* gencode.c (process_instructions): If ! proc64, skip DOUBLEWORD
+	16 bit instructions.
+
+Tue Nov 26 11:53:12 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	Add support for mips16 (16 bit MIPS implementation):
+	* gencode.c (inst_type): Add mips16 instruction encoding types.
+	(GETDATASIZEINSN): Define.
+	(MIPS_DECODE): Add REG flag to dsllv, dsrav, and dsrlv.  Add
+	jalx.  Add LEFT flag to mfhi and mflo.  Add RIGHT flag to mthi and
+	mtlo.
+	(MIPS16_DECODE): New table, for mips16 instructions.
+	(bitmap_val): New static function.
+	(struct mips16_op): Define.
+	(mips16_op_table): New table, for mips16 operands.
+	(build_mips16_operands): New static function.
+	(process_instructions): If PC is odd, decode a mips16
+	instruction.  Break out instruction handling into new
+	build_instruction function.
+	(build_instruction): New static function, broken out of
+	process_instructions.  Check modifiers rather than flags for SHIFT
+	bit count and m[ft]{hi,lo} direction.
+	(usage): Pass program name to fprintf.
+	(main): Remove unused variable this_option_optind.  Change
+	``*loptarg++'' to ``loptarg++''.
+	(my_strtoul): Parenthesize && within ||.
+	* interp.c (LoadMemory): Accept a halfword pAddr if vAddr is odd.
+	(simulate): If PC is odd, fetch a 16 bit instruction, and
+	increment PC by 2 rather than 4.
+	* configure.in: Add case for mips16*-*-*.
+	* configure: Rebuild.
+
+Fri Nov 22 08:49:36 1996  Mark Alexander  <marka@cygnus.com>
+
+	* interp.c: Allow -t to enable tracing in standalone simulator.
+	Fix garbage output in trace file and error messages.
+
+Wed Nov 20 01:54:37 1996  Doug Evans  <dje@canuck.cygnus.com>
+
+	* Makefile.in: Delete stuff moved to ../common/Make-common.in.
+	(SIM_{OBJS,EXTRA_CFLAGS,EXTRA_CLEAN}): Define.
+	* configure.in: Simplify using macros in ../common/aclocal.m4.
+	* configure: Regenerated.
+	* tconfig.in: New file.
+
+Tue Nov 12 13:34:00 1996  Dawn Perchik  <dawn@cygnus.com>
+
+	* interp.c: Fix bugs in 64-bit port.
+	Use ansi function declarations for msvc compiler.
+	Initialize and test file pointer in trace code.
+	Prevent duplicate definition of LAST_EMED_REGNUM.
+
+Tue Oct 15 11:07:06 1996  Mark Alexander  <marka@cygnus.com>
+
+	* interp.c (xfer_big_long): Prevent unwanted sign extension.
+
+Thu Sep 26 17:35:00 1996  James G. Smith  <jsmith@cygnus.co.uk>
+
+	* interp.c (SignalException): Check for explicit terminating
+ 	breakpoint value.
+	* gencode.c: Pass instruction value through SignalException()
+ 	calls for Trap, Breakpoint and Syscall.
+
+Thu Sep 26 11:35:17 1996  James G. Smith  <jsmith@cygnus.co.uk>
+
+	* interp.c (SquareRoot): Add HAVE_SQRT check to ensure sqrt() is
+ 	only used on those hosts that provide it.
+	* configure.in: Add sqrt() to list of functions to be checked for.
+	* config.in: Re-generated.
+	* configure: Re-generated.
+
+Fri Sep 20 15:47:12 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* gencode.c (process_instructions): Call build_endian_shift when
+	expanding STORE RIGHT, to fix swr.
+	* support.h (SIGNEXTEND): If the sign bit is not set, explicitly
+	clear the high bits.
+	* interp.c (Convert): Fix fmt_single to fmt_long to not truncate.
+	Fix float to int conversions to produce signed values.
+
+Thu Sep 19 15:34:17 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* gencode.c (MIPS_DECODE): Set UNSIGNED for multu instruction.
+	(process_instructions): Correct handling of nor instruction.
+	Correct shift count for 32 bit shift instructions. Correct sign
+	extension for arithmetic shifts to not shift the number of bits in
+	the type.  Fix 64 bit multiply high word calculation.  Fix 32 bit
+	unsigned multiply.  Fix ldxc1 and friends to use coprocessor 1.
+	Fix madd.
+	* interp.c (CHECKHILO): Don't set HIACCESS, LOACCESS, or HLPC.
+	It's OK to have a mult follow a mult.  What's not OK is to have a
+	mult follow an mfhi.
+	(Convert): Comment out incorrect rounding code.
+
+Mon Sep 16 11:38:16 1996  James G. Smith  <jsmith@cygnus.co.uk>
+
+	* interp.c (sim_monitor): Improved monitor printf
+ 	simulation. Tidied up simulator warnings, and added "--log" option
+ 	for directing warning message output.
+	* gencode.c: Use sim_warning() rather than WARNING macro.
+
+Thu Aug 22 15:03:12 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (gencode): Depend upon gencode.o, getopt.o, and
+	getopt1.o, rather than on gencode.c.  Link objects together.
+	Don't link against -liberty.
+	(gencode.o, getopt.o, getopt1.o): New targets.
+	* gencode.c: Include <ctype.h> and "ansidecl.h".
+	(AND): Undefine after including "ansidecl.h".
+	(ULONG_MAX): Define if not defined.
+	(OP_*): Don't define macros; now defined in opcode/mips.h.
+	(main): Call my_strtoul rather than strtoul.
+	(my_strtoul): New static function.
+
+Wed Jul 17 18:12:38 1996  Stu Grossman  (grossman@critters.cygnus.com)
+
+	* gencode.c (process_instructions):  Generate word64 and uword64
+	instead of `long long' and `unsigned long long' data types.
+	* interp.c:  #include sysdep.h to get signals, and define default
+	for SIGBUS.
+	* (Convert):  Work around for Visual-C++ compiler bug with type
+	conversion.
+	* support.h:  Make things compile under Visual-C++ by using
+	__int64 instead of `long long'.  Change many refs to long long
+	into word64/uword64 typedefs.
+
+Wed Jun 26 12:24:55 1996  Jason Molenda  (crash@godzilla.cygnus.co.jp)
+
+        * Makefile.in (bindir, libdir, datadir, mandir, infodir, includedir,
+        INSTALL_PROGRAM, INSTALL_DATA): Use autoconf-set values.
+        (docdir): Removed.
+        * configure.in (AC_PREREQ): autoconf 2.5 or higher.
+        (AC_PROG_INSTALL): Added.
+	(AC_PROG_CC): Moved to before configure.host call.
+        * configure: Rebuilt.
+	
+Wed Jun  5 08:28:13 1996  James G. Smith  <jsmith@cygnus.co.uk>
+
+	* configure.in: Define @SIMCONF@ depending on mips target.
+	* configure: Rebuild.
+	* Makefile.in (run): Add @SIMCONF@ to control simulator
+ 	construction.
+	* gencode.c: Change LOADDRMASK to 64bit memory model only.
+	* interp.c: Remove some debugging, provide more detailed error
+ 	messages, update memory accesses to use LOADDRMASK.
+	
+Mon Jun  3 11:55:03 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Add calls to AC_CONFIG_HEADER, AC_CHECK_HEADERS,
+	AC_CHECK_LIB, and AC_CHECK_FUNCS.  Change AC_OUTPUT to set
+	stamp-h.
+	* configure: Rebuild.
+	* config.in: New file, generated by autoheader.
+	* interp.c: Include "config.h".  Include <stdlib.h>, <string.h>,
+	and <strings.h> if they exist.  Replace #ifdef sun with #ifdef
+	HAVE_ANINT and HAVE_AINT, as appropriate.
+	* Makefile.in (run): Use @LIBS@ rather than -lm.
+	(interp.o): Depend upon config.h.
+	(Makefile): Just rebuild Makefile.
+	(clean): Remove stamp-h.
+	(mostlyclean): Make the same as clean, not as distclean.
+	(config.h, stamp-h): New targets.
+
+Fri May 10 00:41:17 1996  James G. Smith  <jsmith@cygnus.co.uk>
+
+	* interp.c (ColdReset): Fix boolean test. Make all simulator
+ 	globals static.
+
+Wed May  8 15:12:58 1996  James G. Smith  <jsmith@cygnus.co.uk>
+
+	* interp.c (xfer_direct_word, xfer_direct_long,
+	swap_direct_word, swap_direct_long, xfer_big_word,
+	xfer_big_long, xfer_little_word, xfer_little_long,
+	swap_word,swap_long): Added.
+	* interp.c (ColdReset): Provide function indirection to
+ 	host<->simulated_target transfer routines.
+	* interp.c (sim_store_register, sim_fetch_register): Updated to
+ 	make use of indirected transfer routines.
+
+Fri Apr 19 15:48:24 1996  James G. Smith  <jsmith@cygnus.co.uk>
+
+	* gencode.c (process_instructions): Ensure FP ABS instruction
+ 	recognised.
+	* interp.c (AbsoluteValue): Add routine. Also provide simple PMON
+ 	system call support.
+
+Wed Apr 10 09:51:38 1996  James G. Smith  <jsmith@cygnus.co.uk>
+
+	* interp.c (sim_do_command): Complain if callback structure not
+ 	initialised.
+
+Thu Mar 28 13:50:51 1996  James G. Smith  <jsmith@cygnus.co.uk>
+
+	* interp.c (Convert): Provide round-to-nearest and round-to-zero
+ 	support for Sun hosts.
+	* Makefile.in (gencode): Ensure the host compiler and libraries
+ 	used for cross-hosted build.
+
+Wed Mar 27 14:42:12 1996  James G. Smith  <jsmith@cygnus.co.uk>
+
+	* interp.c, gencode.c: Some more (TODO) tidying.
+
+Thu Mar  7 11:19:33 1996  James G. Smith  <jsmith@cygnus.co.uk>
+
+	* gencode.c, interp.c: Replaced explicit long long references with
+ 	WORD64HI, WORD64LO, SET64HI and SET64LO macro calls.
+	* support.h (SET64LO, SET64HI): Macros added.
+
+Wed Feb 21 12:16:21 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Regenerate with autoconf 2.7.
+
+Tue Jan 30 08:48:18 1996  Fred Fish  <fnf@cygnus.com>
+
+	* interp.c (LoadMemory): Enclose text following #endif in /* */.
+	* support.h: Remove superfluous "1" from #if.
+	* support.h (CHECKSIM): Remove stray 'a' at end of line.
+
+Mon Dec  4 11:44:40 1995  Jamie Smith  <jsmith@cygnus.com>
+
+	* interp.c (StoreFPR): Control UndefinedResult() call on
+ 	WARN_RESULT manifest.
+
+Fri Dec  1 16:37:19 1995  James G. Smith  <jsmith@cygnus.co.uk>
+
+	* gencode.c: Tidied instruction decoding, and added FP instruction
+ 	support.
+
+	* interp.c: Added dineroIII, and BSD profiling support. Also
+ 	run-time FP handling.
+
+Sun Oct 22 00:57:18 1995  James G. Smith  <jsmith@pasanda.cygnus.co.uk>
+
+	* Changelog, Makefile.in, README.Cygnus, configure, configure.in,
+ 	gencode.c, interp.c, support.h: created.
Index: sim/brownie32/Makefile.in
===================================================================
RCS file: sim/brownie32/Makefile.in
diff -N sim/brownie32/Makefile.in
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/Makefile.in	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,396 @@
+#    Makefile template for Configure for the brownie32 simulator.
+#    Written by Cygnus Support.
+
+SHELL = @SHELL@
+
+## COMMON_PRE_CONFIG_FRAG
+
+srcdir=@srcdir@
+srcroot=$(srcdir)/../../
+
+# Object files created by various simulator generators.
+
+
+SIM_IGEN_OBJ = \
+	support.o \
+	itable.o \
+	semantics.o \
+	idecode.o \
+	icache.o \
+	@brownie32_igen_engine@ \
+	irun.o \
+
+
+SIM_M16_OBJ = \
+	m16_support.o \
+	m16_semantics.o \
+	m16_idecode.o \
+	m16_icache.o \
+	\
+	m32_support.o \
+	m32_semantics.o \
+	m32_idecode.o \
+	m32_icache.o \
+	\
+	itable.o \
+	m16run.o \
+
+SIM_MULTI_OBJ = itable.o @sim_multi_obj@
+
+BROWNIE32_EXTRA_OBJS = @brownie32_extra_objs@
+BROWNIE32_EXTRA_LIBS = @brownie32_extra_libs@
+
+SIM_OBJS = \
+	$(SIM_@sim_gen@_OBJ) \
+	$(SIM_NEW_COMMON_OBJS) \
+	$(BROWNIE32_EXTRA_OBJS) \
+	cp1.o \
+	interp.o \
+	mdmx.o \
+	sim-main.o \
+	sim-hload.o \
+	sim-engine.o \
+	sim-stop.o \
+	sim-resume.o \
+	sim-reason.o \
+
+
+# List of flags to always pass to $(CC).
+SIM_SUBTARGET=@SIM_SUBTARGET@
+SIM_EXTRA_CFLAGS = $(SIM_SUBTARGET)
+
+SIM_EXTRA_CLEAN = clean-extra
+SIM_EXTRA_DISTCLEAN = distclean-extra
+
+SIM_EXTRA_ALL = $(SIM_@sim_gen@_ALL)
+
+SIM_EXTRA_LIBS = $(BROWNIE32_EXTRA_LIBS)
+
+# List of main object files for `run'.
+SIM_RUN_OBJS = nrun.o
+
+
+
+## COMMON_POST_CONFIG_FRAG
+
+interp.o: $(srcdir)/interp.c config.h sim-main.h itable.h
+cp1.o: $(srcdir)/cp1.c config.h sim-main.h
+
+mdmx.o: $(srcdir)/mdmx.c $(srcdir)/sim-main.h
+
+multi-run.o: multi-include.h tmp-mach-multi
+
+../igen/igen:
+	cd ../igen && $(MAKE)
+
+IGEN_TRACE= # -G omit-line-numbers # -G trace-rule-selection -G trace-rule-rejection -G trace-entries # -G trace-all
+IGEN_INSN=$(srcdir)/brownie32.igen
+IGEN_DC=$(srcdir)/brownie32.dc
+M16_DC=$(srcdir)/m16.dc
+IGEN_INCLUDE=\
+	$(srcdir)/m16.igen \
+	$(srcdir)/mdmx.igen \
+	$(srcdir)/brownie323d.igen \
+	$(srcdir)/sb1.igen \
+	$(srcdir)/tx.igen \
+	$(srcdir)/vr.igen \
+
+# NB:	Since these can be built by a number of generators, care
+#	must be taken to ensure that they are only dependant on
+#	one of those generators.
+BUILT_SRC_FROM_GEN = \
+	itable.h \
+	itable.c \
+
+SIM_IGEN_ALL = tmp-igen
+SIM_M16_ALL = tmp-m16
+SIM_MULTI_ALL = tmp-multi
+
+$(BUILT_SRC_FROM_GEN): $(SIM_@sim_gen@_ALL)
+
+
+
+BUILT_SRC_FROM_IGEN = \
+	icache.h \
+	icache.c \
+	idecode.h \
+	idecode.c \
+	semantics.h \
+	semantics.c \
+	model.h \
+	model.c \
+	support.h \
+	support.c \
+	engine.h \
+	engine.c \
+	irun.c \
+
+$(BUILT_SRC_FROM_IGEN): tmp-igen
+
+tmp-igen: $(IGEN_INSN) $(IGEN_DC) ../igen/igen $(IGEN_INCLUDE)
+	cd ../igen && $(MAKE)
+	../igen/igen \
+		$(IGEN_TRACE) \
+		-I $(srcdir) \
+		-Werror \
+		-Wnodiscard \
+		@sim_igen_flags@ \
+		-G gen-direct-access \
+		-G gen-zero-r0 \
+		-B 32 \
+		-H 31 \
+		-i $(IGEN_INSN) \
+		-o $(IGEN_DC) \
+		-x \
+		-n icache.h    -hc tmp-icache.h \
+		-n icache.c    -c  tmp-icache.c \
+		-n semantics.h -hs tmp-semantics.h \
+		-n semantics.c -s  tmp-semantics.c \
+		-n idecode.h   -hd tmp-idecode.h \
+		-n idecode.c   -d  tmp-idecode.c \
+		-n model.h     -hm tmp-model.h \
+		-n model.c     -m  tmp-model.c \
+		-n support.h   -hf tmp-support.h \
+		-n support.c   -f  tmp-support.c \
+		-n itable.h    -ht tmp-itable.h \
+		-n itable.c    -t  tmp-itable.c \
+		-n engine.h    -he tmp-engine.h \
+		-n engine.c    -e  tmp-engine.c \
+		-n irun.c      -r  tmp-irun.c
+	$(SHELL) $(srcdir)/../../move-if-change tmp-icache.h icache.h
+	$(SHELL) $(srcdir)/../../move-if-change tmp-icache.c icache.c
+	$(SHELL) $(srcdir)/../../move-if-change tmp-idecode.h idecode.h
+	$(SHELL) $(srcdir)/../../move-if-change tmp-idecode.c idecode.c
+	$(SHELL) $(srcdir)/../../move-if-change tmp-semantics.h semantics.h
+	$(SHELL) $(srcdir)/../../move-if-change tmp-semantics.c semantics.c
+	$(SHELL) $(srcdir)/../../move-if-change tmp-model.h model.h
+	$(SHELL) $(srcdir)/../../move-if-change tmp-model.c model.c
+	$(SHELL) $(srcdir)/../../move-if-change tmp-support.h support.h
+	$(SHELL) $(srcdir)/../../move-if-change tmp-support.c support.c
+	$(SHELL) $(srcdir)/../../move-if-change tmp-itable.h itable.h
+	$(SHELL) $(srcdir)/../../move-if-change tmp-itable.c itable.c
+	$(SHELL) $(srcdir)/../../move-if-change tmp-engine.h engine.h
+	$(SHELL) $(srcdir)/../../move-if-change tmp-engine.c engine.c
+	$(SHELL) $(srcdir)/../../move-if-change tmp-irun.c irun.c
+	touch tmp-igen
+
+semantics.o: sim-main.h semantics.c $(SIM_EXTRA_DEPS)
+engine.o: sim-main.h engine.c $(SIM_EXTRA_DEPS)
+support.o: sim-main.h support.c $(SIM_EXTRA_DEPS)
+idecode.o: sim-main.h idecode.c $(SIM_EXTRA_DEPS)
+itable.o: sim-main.h itable.c $(SIM_EXTRA_DEPS)
+
+
+
+
+BUILT_SRC_FROM_M16 = \
+	m16_icache.h \
+	m16_icache.c \
+	m16_idecode.h \
+	m16_idecode.c \
+	m16_semantics.h \
+	m16_semantics.c \
+	m16_model.h \
+	m16_model.c \
+	m16_support.h \
+	m16_support.c \
+	\
+	m32_icache.h \
+	m32_icache.c \
+	m32_idecode.h \
+	m32_idecode.c \
+	m32_semantics.h \
+	m32_semantics.c \
+	m32_model.h \
+	m32_model.c \
+	m32_support.h \
+	m32_support.c \
+
+$(BUILT_SRC_FROM_M16): tmp-m16
+
+tmp-m16: $(IGEN_INSN) $(IGEN_DC) ../igen/igen $(IGEN_INCLUDE)
+	cd ../igen && $(MAKE)
+	../igen/igen \
+		$(IGEN_TRACE) \
+		-I $(srcdir) \
+		-Werror \
+		-Wnodiscard \
+		@sim_m16_flags@ \
+		-G gen-direct-access \
+		-G gen-zero-r0 \
+		-B 16 \
+		-H 15 \
+		-i $(IGEN_INSN) \
+		-o $(M16_DC) \
+		-P m16_ \
+		-x \
+		-n m16_icache.h    -hc tmp-icache.h \
+		-n m16_icache.c    -c  tmp-icache.c \
+		-n m16_semantics.h -hs tmp-semantics.h \
+		-n m16_semantics.c -s  tmp-semantics.c \
+		-n m16_idecode.h   -hd tmp-idecode.h \
+		-n m16_idecode.c   -d  tmp-idecode.c \
+		-n m16_model.h     -hm tmp-model.h \
+		-n m16_model.c     -m  tmp-model.c \
+		-n m16_support.h   -hf tmp-support.h \
+		-n m16_support.c   -f  tmp-support.c \
+		#
+	$(SHELL) $(srcdir)/../../move-if-change tmp-icache.h m16_icache.h
+	$(SHELL) $(srcdir)/../../move-if-change tmp-icache.c m16_icache.c
+	$(SHELL) $(srcdir)/../../move-if-change tmp-idecode.h m16_idecode.h
+	$(SHELL) $(srcdir)/../../move-if-change tmp-idecode.c m16_idecode.c
+	$(SHELL) $(srcdir)/../../move-if-change tmp-semantics.h m16_semantics.h
+	$(SHELL) $(srcdir)/../../move-if-change tmp-semantics.c m16_semantics.c
+	$(SHELL) $(srcdir)/../../move-if-change tmp-model.h m16_model.h
+	$(SHELL) $(srcdir)/../../move-if-change tmp-model.c m16_model.c
+	$(SHELL) $(srcdir)/../../move-if-change tmp-support.h m16_support.h
+	$(SHELL) $(srcdir)/../../move-if-change tmp-support.c m16_support.c
+	../igen/igen \
+		$(IGEN_TRACE) \
+		-I $(srcdir) \
+		-Werror \
+		-Wnodiscard \
+		@sim_igen_flags@ \
+		-G gen-direct-access \
+		-G gen-zero-r0 \
+		-B 32 \
+		-H 31 \
+		-i $(IGEN_INSN) \
+		-o $(IGEN_DC) \
+		-P m32_ \
+		-x \
+		-n m32_icache.h    -hc tmp-icache.h \
+		-n m32_icache.c    -c  tmp-icache.c \
+		-n m32_semantics.h -hs tmp-semantics.h \
+		-n m32_semantics.c -s  tmp-semantics.c \
+		-n m32_idecode.h   -hd tmp-idecode.h \
+		-n m32_idecode.c   -d  tmp-idecode.c \
+		-n m32_model.h     -hm tmp-model.h \
+		-n m32_model.c     -m  tmp-model.c \
+		-n m32_support.h   -hf tmp-support.h \
+		-n m32_support.c   -f  tmp-support.c \
+		#
+	$(SHELL) $(srcdir)/../../move-if-change tmp-icache.h m32_icache.h
+	$(SHELL) $(srcdir)/../../move-if-change tmp-icache.c m32_icache.c
+	$(SHELL) $(srcdir)/../../move-if-change tmp-idecode.h m32_idecode.h
+	$(SHELL) $(srcdir)/../../move-if-change tmp-idecode.c m32_idecode.c
+	$(SHELL) $(srcdir)/../../move-if-change tmp-semantics.h m32_semantics.h
+	$(SHELL) $(srcdir)/../../move-if-change tmp-semantics.c m32_semantics.c
+	$(SHELL) $(srcdir)/../../move-if-change tmp-model.h m32_model.h
+	$(SHELL) $(srcdir)/../../move-if-change tmp-model.c m32_model.c
+	$(SHELL) $(srcdir)/../../move-if-change tmp-support.h m32_support.h
+	$(SHELL) $(srcdir)/../../move-if-change tmp-support.c m32_support.c
+	../igen/igen \
+		$(IGEN_TRACE) \
+		-I $(srcdir) \
+		-Werror \
+		-Wnodiscard \
+		-Wnowidth \
+		@sim_igen_flags@ @sim_m16_flags@ \
+		-G gen-direct-access \
+		-G gen-zero-r0 \
+		-i $(IGEN_INSN) \
+		-n itable.h    -ht tmp-itable.h \
+		-n itable.c    -t  tmp-itable.c \
+		#
+	$(SHELL) $(srcdir)/../../move-if-change tmp-itable.h itable.h
+	$(SHELL) $(srcdir)/../../move-if-change tmp-itable.c itable.c
+	touch tmp-m16
+
+
+BUILT_SRC_FROM_MULTI = @sim_multi_src@
+SIM_MULTI_IGEN_CONFIGS = @sim_multi_igen_configs@
+
+$(BUILT_SRC_FROM_MULTI): tmp-multi
+tmp-multi: tmp-mach-multi tmp-itable-multi tmp-run-multi targ-vals.h
+tmp-mach-multi: $(IGEN_INSN) $(IGEN_DC) ../igen/igen $(IGEN_INCLUDE)
+	for t in $(SIM_MULTI_IGEN_CONFIGS); do \
+	  p=`echo $${t} | sed -e 's/:.*//'` ; \
+	  m=`echo $${t} | sed -e 's/.*:\(.*\):.*/\1/'` ; \
+	  f=`echo $${t} | sed -e 's/.*://'` ; \
+	  case $${p} in \
+	    m16*) e="-B 16 -H 15 -o $(M16_DC) -F 16" ;; \
+	    *) e="-B 32 -H 31 -o $(IGEN_DC) -F $${f}" ;; \
+	  esac; \
+	  ../igen/igen \
+		$(IGEN_TRACE) \
+		$${e} \
+		-I $(srcdir) \
+		-Werror \
+		-Wnodiscard \
+		-N 0 \
+		-M $${m} \
+		-G gen-direct-access \
+		-G gen-zero-r0 \
+		-i $(IGEN_INSN) \
+		-P $${p}_ \
+		-x \
+		-n $${p}_icache.h    -hc tmp-icache.h \
+		-n $${p}_icache.c    -c  tmp-icache.c \
+		-n $${p}_semantics.h -hs tmp-semantics.h \
+		-n $${p}_semantics.c -s  tmp-semantics.c \
+		-n $${p}_idecode.h   -hd tmp-idecode.h \
+		-n $${p}_idecode.c   -d  tmp-idecode.c \
+		-n $${p}_model.h     -hm tmp-model.h \
+		-n $${p}_model.c     -m  tmp-model.c \
+		-n $${p}_support.h   -hf tmp-support.h \
+		-n $${p}_support.c   -f  tmp-support.c \
+		-n $${p}_engine.h    -he tmp-engine.h \
+		-n $${p}_engine.c    -e  tmp-engine.c \
+		; \
+	  $(SHELL) $(srcdir)/../../move-if-change tmp-icache.h $${p}_icache.h ; \
+	  $(SHELL) $(srcdir)/../../move-if-change tmp-icache.c $${p}_icache.c ; \
+	  $(SHELL) $(srcdir)/../../move-if-change tmp-idecode.h $${p}_idecode.h ; \
+	  $(SHELL) $(srcdir)/../../move-if-change tmp-idecode.c $${p}_idecode.c ; \
+	  $(SHELL) $(srcdir)/../../move-if-change tmp-semantics.h $${p}_semantics.h ; \
+	  $(SHELL) $(srcdir)/../../move-if-change tmp-semantics.c $${p}_semantics.c ; \
+	  $(SHELL) $(srcdir)/../../move-if-change tmp-model.h $${p}_model.h ; \
+	  $(SHELL) $(srcdir)/../../move-if-change tmp-model.c $${p}_model.c ; \
+	  $(SHELL) $(srcdir)/../../move-if-change tmp-support.h $${p}_support.h ; \
+	  $(SHELL) $(srcdir)/../../move-if-change tmp-support.c $${p}_support.c ; \
+	  $(SHELL) $(srcdir)/../../move-if-change tmp-engine.h $${p}_engine.h ; \
+	  $(SHELL) $(srcdir)/../../move-if-change tmp-engine.c $${p}_engine.c ; \
+	done
+	touch tmp-mach-multi
+tmp-itable-multi: $(IGEN_INSN) $(IGEN_DC) ../igen/igen $(IGEN_INCLUDE)
+	../igen/igen \
+		$(IGEN_TRACE) \
+		-I $(srcdir) \
+		-Werror \
+		-Wnodiscard \
+		-Wnowidth \
+		-N 0 \
+		@sim_multi_flags@ \
+		-G gen-direct-access \
+		-G gen-zero-r0 \
+		-i $(IGEN_INSN) \
+		-n itable.h    -ht tmp-itable.h \
+		-n itable.c    -t  tmp-itable.c \
+		#
+	$(SHELL) $(srcdir)/../../move-if-change tmp-itable.h itable.h
+	$(SHELL) $(srcdir)/../../move-if-change tmp-itable.c itable.c
+	touch tmp-itable-multi
+tmp-run-multi: $(srcdir)/m16run.c
+	for t in $(SIM_MULTI_IGEN_CONFIGS); do \
+	  case $${t} in \
+	    m16*) \
+	      m=`echo $${t} | sed -e 's/^m16//' -e 's/:.*//'`; \
+	      sed <  $(srcdir)/m16run.c > tmp-run \
+		    -e "s/^sim_/m16$${m}_/" \
+		    -e "s/m16_/m16$${m}_/" \
+		    -e "s/m32_/m32$${m}_/" ; \
+	      $(SHELL) $(srcdir)/../../move-if-change tmp-run m16$${m}_run.c ; \
+	  esac \
+	done
+	touch tmp-run-multi
+
+clean-extra:
+	rm -f $(BUILT_SRC_FROM_GEN)
+	rm -f $(BUILT_SRC_FROM_IGEN)
+	rm -f $(BUILT_SRC_FROM_M16)
+	rm -f $(BUILT_SRC_FROM_MULTI)
+	rm -f tmp-*
+	rm -f m16*.o m32*.o itable*.o
+
+distclean-extra:
+	rm -f multi-include.h multi-run.c
Index: sim/brownie32/acconfig.h
===================================================================
RCS file: sim/brownie32/acconfig.h
diff -N sim/brownie32/acconfig.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/acconfig.h	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,15 @@
+
+/* Define to 1 if NLS is requested.  */
+#undef ENABLE_NLS
+
+/* Define as 1 if you have catgets and don't want to use GNU gettext.  */
+#undef HAVE_CATGETS
+
+/* Define as 1 if you have gettext and don't want to use GNU gettext.  */
+#undef HAVE_GETTEXT
+
+/* Define as 1 if you have the stpcpy function.  */
+#undef HAVE_STPCPY
+
+/* Define if your locale.h file contains LC_MESSAGES.  */
+#undef HAVE_LC_MESSAGES
Index: sim/brownie32/brownie32.dc
===================================================================
RCS file: sim/brownie32/brownie32.dc
diff -N sim/brownie32/brownie32.dc
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/brownie32.dc	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,19 @@
+#   Copyright (C) 2005,2006  Upwind technology, Inc.
+# most instructions
+# ------ options ------ : Fst : Lst : ff : fl : fe : word : --- fmt --- : model ...
+# { : mask : value : word }
+
+# Top level - create a very big switch statement.
+
+  padded-switch,combine :  5 :  0 :    :    :    :      :             :
+
+  switch,combine        :  13 :  6 :    :    :    :      :             :
+
+  switch,combine        :  16 :  14 :    :    :    :      :             :
+
+  switch,combine        :  21 :  17 :    :    :    :      :             :
+
+  switch,combine        :  26 :  22 :    :    :    :      :             :
+
+  switch,combine        :  31 :  27 :    :    :    :      :             :
+
Index: sim/brownie32/brownie32.igen
===================================================================
RCS file: sim/brownie32/brownie32.igen
diff -N sim/brownie32/brownie32.igen
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/brownie32.igen	12 Feb 2008 08:55:38 -0000	1.5
@@ -0,0 +1,866 @@
+// Simulator definition for the Brownie32 instructions.
+// Copyright (C) 2004 Free Software Foundation, Inc.
+// Contributed by David Ung, of MIPS Technologies.
+//
+// Copyright (C) 2005,2006  Upwind technology, Inc.
+//
+// This file is part of GDB, the GNU debugger.
+// 
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License along
+// with this program; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//
+// -*- C -*-
+//
+//    <insn> ::=
+//        <insn-word> { "+" <insn-word> }
+//        ":" <format-name>
+//        ":" <filter-flags>
+//        ":" <options>
+//        ":" <name>
+//        <nl>
+//        { <insn-model> }
+//        { <insn-mnemonic> }
+//        <code-block>
+//
+
+
+// IGEN config - brownie32_std
+:option:32::insn-bit-size:32
+// :option:32::hi-bit-nr:31
+:option:32::insn-specifying-widths:true
+:option:32::gen-delayed-branch:false
+
+
+// Generate separate simulators for each target
+// :option:::multi-sim:true
+
+// Models known by this simulator are defined below.
+//
+// When placing models in the instruction descriptions, please place
+// them one per line, in the order given here.
+
+//  Brownie32 ISAs:
+//
+//  Instructions and related functions for these models are included in
+//  this file.
+:model:::brownie32_std:brownie32_std:
+
+// Pseudo instructions known by IGEN
+:internal::::illegal:
+{
+//  SignalException (ReservedInstruction, 0);
+}
+
+// Helper:
+//
+// Calculate an effective address given a base and an offset.
+//
+
+:function:::address_word:loadstore_ea:address_word base, address_word offset
+*brownie32_std:
+{
+  return base + offset;
+}
+
+:function:::int:not_word_value:unsigned_word value
+*brownie32_std:
+{
+  /* On Brownie32, since registers are 32-bits, there's no check to be done.  */
+  return 0;
+}
+:function:::void:unpredictable:
+*brownie32_std:
+{
+  unpredictable_action (CPU, CIA);
+}
+
+// Helper:
+//
+// Simulate a 32 bit delayslot instruction
+//
+
+:function:::address_word:delayslot32:address_word target
+{
+  return target;
+}
+
+:function:::address_word:nullify_next_insn32:
+{
+  sim_events_slip (SD, 1);
+  dotrace (SD, CPU, tracefh, 2, CIA + 4, 4, "load instruction");
+  return CIA + 8;
+}
+
+//
+// Brownie32 Architecture:
+//
+//        CPU Instruction Set (brownie32_std)
+//
+
+// Instruction Type = RR
+5.RS1,5.RS2,5.RD,000,00000000,000001:NORMAL:32::ADD
+"add r<RD>, r<RS1>, r<RS2>"
+*brownie32_std:
+{
+//dbgprintf("##### ADD inst #####\n");
+
+  if (NotWordValue (GPR[RS1]) || NotWordValue (GPR[RS2]))
+    Unpredictable ();
+
+  TRACE_ALU_INPUT2 (GPR[RS1], GPR[RS2]);
+  {
+     ALU32_BEGIN (GPR[RS1]);
+     ALU32_ADD (GPR[RS2]);
+     ALU32_END (GPR[RD]);
+  }
+  TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+5.RS1,5.RS2,5.RD,000,00000001,000001:NORMAL:32::SUB
+"sub r<RD>, r<RS1>, r<RS2>"
+*brownie32_std:
+{
+//dbgprintf("##### SUB inst #####\n");
+    if (NotWordValue (GPR[RS1]) || NotWordValue (GPR[RS2]))
+      Unpredictable ();
+  
+    TRACE_ALU_INPUT2 (GPR[RS1], GPR[RS2]);
+    {
+       ALU32_BEGIN (GPR[RS1]);
+//       ALU32_SUB (GPR[RS2]);
+         ALU32_SUBB(GPR[RS2]);
+       ALU32_END (GPR[RD]);
+    }
+    TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+5.RS1,5.RS2,5.RD,000,00000010,000001:NORMAL:32::MUL
+"mul r<RD>, r<RS1>, r<RS2>"
+*brownie32_std:
+{
+    signed64 prod;
+//dbgprintf("##### MUL inst #####\n");
+    if (NotWordValue (GPR[RS1]) || NotWordValue (GPR[RS2]))
+      Unpredictable ();
+
+    TRACE_ALU_INPUT2 (GPR[RS1], GPR[RS2]);
+    {
+      prod = (((signed64)(signed32) GPR[RS1])
+           * ((signed64)(signed32) GPR[RS2]));
+      GPR[RD] = EXTEND32 (VL4_8 (prod));
+    }
+    TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+5.RS1,5.RS2,5.RD,000,00000011,000001:NORMAL:32::DIV
+"div r<RD>, r<RS1>, r<RS2>"
+*brownie32_std:
+{
+    signed32 prod;
+//dbgprintf("##### DIV inst #####\n");
+    if (NotWordValue (GPR[RS1]) || NotWordValue (GPR[RS2]))
+      Unpredictable ();
+
+    TRACE_ALU_INPUT2 (GPR[RS1], GPR[RS2]);
+    {
+        prod = (((signed32) GPR[RS1])
+             / ((signed32) GPR[RS2]));
+        GPR[RD] = EXTEND32 (VL4_8 (prod));
+    }
+    TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+5.RS1,5.RS2,5.RD,000,00000101,000001:NORMAL:32::DIVU
+"divu r<RD>, r<RS1>, r<RS2>"
+*brownie32_std:
+{
+    unsigned32 prod;
+//dbgprintf("##### DIV inst #####\n");
+    if (NotWordValue (GPR[RS1]) || NotWordValue (GPR[RS2]))
+      Unpredictable ();
+
+    TRACE_ALU_INPUT2 (GPR[RS1], GPR[RS2]);
+    {
+// FIXMEE
+        prod = (((unsigned32) GPR[RS1])
+             / ((unsigned32) GPR[RS2]));
+        GPR[RD] = EXTEND32 (VL4_8 (prod));
+    }
+    TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+5.RS1,5.RS2,5.RD,000,00000100,000001:NORMAL:32::MOD
+"mod  r<RD>,r<RS1>,r<RS2>"
+*brownie32_std:
+{
+    signed32 prod;
+//dbgprintf("##### MOD inst #####\n");
+    if (NotWordValue (GPR[RS1]) || NotWordValue (GPR[RS2]))
+      Unpredictable ();
+
+    TRACE_ALU_INPUT2 (GPR[RS1], GPR[RS2]);
+    {
+#define TARGET_INT_MIN (-2147483647-1)
+      /* -2147483648 % 1 == 0 */
+      if ((signed32)GPR[RS1] == TARGET_INT_MIN && (signed32)GPR[RS2] == -1)
+        prod = 0;
+      else
+        prod = (((signed32) GPR[RS1])
+           % ((signed32) GPR[RS2]));
+      GPR[RD] = EXTEND32 (VL4_8 (prod));
+    }
+    TRACE_ALU_RESULT (GPR[RD]);
+  
+  re_load (SD_ );
+}
+
+5.RS1,5.RS2,5.RD,000,00000110,000001:NORMAL:32::MODU
+"modu  r<RD>,r<RS1>,r<RS2>"
+*brownie32_std:
+{
+    unsigned32 prod;
+//dbgprintf("##### MODU inst #####\n");
+    if (NotWordValue (GPR[RS1]) || NotWordValue (GPR[RS2]))
+      Unpredictable ();
+
+    TRACE_ALU_INPUT2 (GPR[RS1], GPR[RS2]);
+    {
+// FIXMEE
+#define TARGET_INT_MIN (-2147483647-1)
+      /* -2147483648 % 1 == 0 */
+      if ((signed32)GPR[RS1] == TARGET_INT_MIN && (signed32)GPR[RS2] == -1)
+        prod = 0;
+      else
+        prod = (((signed32) GPR[RS1])
+           % ((unsigned32) GPR[RS2]));
+      GPR[RD] = EXTEND32 (VL4_8 (prod));
+    }
+    TRACE_ALU_RESULT (GPR[RD]);
+  
+  re_load (SD_ );
+}
+
+5.RS1,5.RS2,5.RD,001,00000000,000001:NORMAL:32::AND
+"and  r<RD>,r<RS1>,r<RS2>"
+*brownie32_std:
+{
+//dbgprintf("##### AND inst #####\n");
+    TRACE_ALU_INPUT2 (GPR[RS1], GPR[RS2]);
+    {
+      GPR[RD] = GPR[RS1] & GPR[RS2];
+    }
+    TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+5.RS1,5.RS2,5.RD,001,00000011,000001:NORMAL:32::NAND
+"nand  r<RD>,r<RS1>,r<RS2>"
+*brownie32_std:
+{
+//dbgprintf("##### NAND inst #####\n");
+    TRACE_ALU_INPUT2 (GPR[RS1], GPR[RS2]);
+    {
+      GPR[RD] = ~(GPR[RS1] & GPR[RS2]);
+    }
+    TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+5.RS1,5.RS2,5.RD,001,00000001,000001:NORMAL:32::OR
+"or   r<RD>,r<RS1>,r<RS2>"
+*brownie32_std:
+{
+//dbgprintf("##### OR inst #####\n");
+    TRACE_ALU_INPUT2 (GPR[RS1], GPR[RS2]);
+    {
+      GPR[RD] = (GPR[RS1] | GPR[RS2]);
+    }
+    TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+5.RS1,5.RS2,5.RD,001,00000100,000001:NORMAL:32::NOR
+"nor   r<RD>,r<RS1>,r<RS2>"
+*brownie32_std:
+{
+//dbgprintf("##### NOR inst #####\n");
+    TRACE_ALU_INPUT2 (GPR[RS1], GPR[RS2]);
+    {
+      GPR[RD] = ~(GPR[RS1] | GPR[RS2]);
+    }
+    TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+5.RS1,5.RS2,5.RD,001,00000010,000001:NORMAL:32::XOR
+"xor  r<RD>,r<RS1>,r<RS2>"
+*brownie32_std:
+{
+//dbgprintf("##### XOR inst #####\n");
+    TRACE_ALU_INPUT2 (GPR[RS1], GPR[RS2]);
+    {
+      GPR[RD] = (GPR[RS1] ^ GPR[RS2]);
+    }
+    TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+5.RS1,5.RS2,5.RD,010,00000000,000001:NORMAL:32::LLS
+"lls  r<RD>,r<RS1>,r<RS2>"
+*brownie32_std:
+{
+//dbgprintf("##### LLS inst #####\n");
+  TRACE_ALU_INPUT2 (GPR[RS1], GPR[RS2]);
+  {
+    int s = MASKED (GPR[RS2], 4, 0);
+    unsigned32 temp = ((unsigned32)GPR[RS1] << s);
+    GPR[RD] = EXTEND32 (temp);
+  }
+  TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+5.RS1,5.RS2,5.RD,010,00000001,000001:NORMAL:32::LRS
+"lrs  r<RD>,r<RS1>,r<RS2>"
+*brownie32_std:
+{
+//dbgprintf("##### LRS inst #####\n");
+  TRACE_ALU_INPUT2 (GPR[RS1], GPR[RS2]);
+  {
+    int s = MASKED (GPR[RS2], 4, 0);
+    unsigned32 temp = ((unsigned32)GPR[RS1] >> s);
+    GPR[RD] = EXTEND32 (temp);
+  }
+  TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+5.RS1,5.RS2,5.RD,010,00000010,000001:NORMAL:32::ARS
+"ars  r<RD>,r<RS1>,r<RS2>"
+*brownie32_std:
+{
+//dbgprintf("##### ARS inst #####\n");
+  TRACE_ALU_INPUT2 (GPR[RS1], GPR[RS2]);
+  {
+    int s = MASKED (GPR[RS2], 4, 0);
+    signed32 temp = ((signed32)GPR[RS1] >> s);
+    GPR[RD] = EXTEND32 (temp);
+  }
+  TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+5.RS1,5.RS2,5.RD,011,00000000,000001:NORMAL:32::ELT
+"elt  r<RD>,r<RS1>,r<RS2>"
+*brownie32_std:
+{
+//dbgprintf("##### ELT inst #####\n");
+  TRACE_ALU_INPUT2 (GPR[RS1], GPR[RS2]);
+  if ((signed_word) GPR[RS1] < (signed_word) GPR[RS2])
+    GPR[RD] = 1;
+  else
+    GPR[RD] = 0;
+  TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+5.RS1,5.RS2,5.RD,011,00000001,000001:NORMAL:32::ELTU
+"eltu r<RD>,r<RS1>,r<RS2>"
+*brownie32_std:
+{
+//dbgprintf("##### ELTU inst #####\n");
+  TRACE_ALU_INPUT2 (GPR[RS1], GPR[RS2]);
+  if ((unsigned_word) GPR[RS1] < (unsigned_word) GPR[RS2])
+    GPR[RD] = 1;
+  else
+    GPR[RD] = 0;
+  TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+5.RS1,5.RS2,5.RD,011,00000010,000001:NORMAL:32::EEQ
+"eeq  r<RD>,r<RS1>,r<RS2>"
+*brownie32_std:
+{
+//dbgprintf("##### EEQ inst #####\n");
+  TRACE_ALU_INPUT2 (GPR[RS1], GPR[RS2]);
+  if ((signed_word) GPR[RS1] == (signed_word) GPR[RS2])
+    GPR[RD] = 1;
+  else
+    GPR[RD] = 0;
+  TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+5.RS1,5.RS2,5.RD,011,00000011,000001:NORMAL:32::ENEQ
+"eneq r<RD>,r<RS1>,r<RS2>"
+*brownie32_std:
+{
+//dbgprintf("##### ENEQ inst #####\n");
+  TRACE_ALU_INPUT2 (GPR[RS1], GPR[RS2]);
+  if ((signed_word) GPR[RS1] == (signed_word) GPR[RS2])
+    GPR[RD] = 0;
+  else
+    GPR[RD] = 1;
+  TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+// Instruction Type = RI
+16.IMMEDIATE,5.RS1,5.RD,100000:NORMAL:32::ADDI
+"addi r<RD>,r<RS1>,<IMMEDIATE>"
+*brownie32_std:
+{
+//dbgprintf("##### ADDI inst #####\n");
+  TRACE_ALU_INPUT2 (GPR[RS1], IMMEDIATE);
+  {
+    signed32 temp = EXTEND16(IMMEDIATE);
+     ALU32_BEGIN (GPR[RS1]);
+     ALU32_ADD (temp);
+     ALU32_END (GPR[RD]);
+//    GPR[RD] = GPR[RS1] + temp;
+  }
+  TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+16.IMMEDIATE,5.RS1,5.RD,100001:NORMAL:32::SUBI
+"subi r<RD>,r<RS1>,<IMMEDIATE>"
+*brownie32_std:
+{
+//dbgprintf("##### SUBI inst #####\n");
+  TRACE_ALU_INPUT2 (GPR[RS1], IMMEDIATE);
+  {
+    signed32 temp = EXTEND16(IMMEDIATE);
+     ALU32_BEGIN (GPR[RS1]);
+//   ALU32_SUB (temp);
+     ALU32_SUBB(temp);
+     ALU32_END (GPR[RD]);
+//    GPR[RD] = GPR[RS1] - temp;
+  }
+  TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+16.IMMEDIATE,5.RS1,5.RD,100010:NORMAL:32::ANDI
+"andi r<RD>,r<RS1>,<IMMEDIATE>"
+*brownie32_std:
+{
+//dbgprintf("##### ANDI inst #####\n");
+  TRACE_ALU_INPUT2 (GPR[RS1], IMMEDIATE);
+  {
+    GPR[RD] = GPR[RS1] & IMMEDIATE;
+  }
+  TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+16.IMMEDIATE,5.RS1,5.RD,100011:NORMAL:32::ORI
+"ori  r<RD>,r<RS1>,<IMMEDIATE>"
+*brownie32_std:
+{
+//dbgprintf("##### ORI inst #####\n");
+    TRACE_ALU_INPUT2 (GPR[RS1], IMMEDIATE);
+    {
+      GPR[RD] = (GPR[RS1] | IMMEDIATE);
+    }
+    TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+16.IMMEDIATE,5.RS1,5.RD,100100:NORMAL:32::XORI
+"xori r<RD>,r<RS1>,<IMMEDIATE>"
+*brownie32_std:
+{
+//dbgprintf("##### XORI inst #####\n");
+    TRACE_ALU_INPUT2 (GPR[RS1], IMMEDIATE);
+    {
+      GPR[RD] = (GPR[RS1] ^ IMMEDIATE);
+    }
+    TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+16.IMMEDIATE,5.RS1,5.RD,100101:NORMAL:32::LLSI
+"llsi r<RD>,r<RS1>,<IMMEDIATE>"
+*brownie32_std:
+{
+//dbgprintf("##### LLSI inst #####\n");
+    TRACE_ALU_INPUT2 (GPR[RS1], IMMEDIATE);
+    {
+      int s = MASKED (IMMEDIATE, 4, 0);
+      unsigned32 temp = ((unsigned32)GPR[RS1] << s);
+      GPR[RD] = EXTEND32 (temp);
+    }
+    TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+16.IMMEDIATE,5.RS1,5.RD,100110:NORMAL:32::LRSI
+"lrsi r<RD>,r<RS1>,<IMMEDIATE>"
+*brownie32_std:
+{
+//dbgprintf("##### LRSI inst #####\n");
+    TRACE_ALU_INPUT2 (GPR[RS1], IMMEDIATE);
+    {
+      int s = MASKED (IMMEDIATE, 4, 0);
+      unsigned32 temp = ((unsigned32)GPR[RS1] >> s);
+      GPR[RD] = EXTEND32 (temp);
+    }
+    TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+16.IMMEDIATE,5.RS1,5.RD,100111:NORMAL:32::ARSI
+"arsi r<RD>,r<RS1>,<IMMEDIATE>"
+*brownie32_std:
+{
+//dbgprintf("##### ARSI inst #####\n");
+  TRACE_ALU_INPUT2 (GPR[RS1], IMMEDIATE);
+  {
+    int s = MASKED (IMMEDIATE, 4, 0);
+    signed32 temp = ((signed32)GPR[RS1] >> s);
+    GPR[RD] = EXTEND32 (temp);
+  }
+  TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+16.IMMEDIATE,5.RS1,5.RD,101000:NORMAL:32::LSOI
+"lsoi r<RD>,r<RS1>,<IMMEDIATE>"
+*brownie32_std:
+{
+//dbgprintf("##### LSOI inst #####\n");
+    TRACE_ALU_INPUT2 (GPR[RS1], IMMEDIATE);
+    {
+      unsigned32 temp = ((unsigned32)GPR[RS1] << 16);
+      GPR[RD] = (temp | IMMEDIATE);
+    }
+    TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+
+// Instruction Type = MA
+// LoadMemoryx
+
+//:function:::unsigned_word:do_load:unsigned access, address_word base, address_word offset
+:function:::void:do_load:unsigned access, address_word base, address_word offset, unsigned regno
+{
+  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
+  address_word bigendiancpu = (1 ? (mask ^ access) : 0);
+  address_word amask;
+  address_word reverseendian = 0;
+  unsigned int byte;
+  address_word paddr;
+  int uncached;
+  unsigned64 memval;
+  address_word vaddr;
+  int eff;
+  vaddr = loadstore_ea (SD_, base, offset);
+
+  amask = ~access;
+  vaddr&=amask;
+
+  if ((vaddr & access) != 0)
+    {
+      SIM_CORE_SIGNAL (SD, STATE_CPU (SD, 0), cia, read_map, access+1, vaddr, read_transfer, sim_core_unaligned_signal);
+    }
+  AddressTranslation (vaddr, isDATA, isLOAD, &paddr, &uncached, isTARGET, isREAL);
+  paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
+  LoadMemory (&memval, NULL, uncached, access, paddr, vaddr, isDATA, isREAL);
+
+#if 0
+  byte = ((vaddr & mask) ^ bigendiancpu);
+  return (memval >> (8 * byte));
+#else
+  byte = ((vaddr & mask) ^ bigendiancpu);
+//  DelayLoad_p(regno,memval,byte,access);
+  DelayLoad_p(regno,memval >> (8 * byte),byte,access);
+#endif
+}
+:function:::unsigned_word:re_load:
+{
+  unsigned int byte;
+  unsigned int regno;
+  unsigned64 memval;
+  unsigned int effect;
+
+  effect = DelayLoad_e(&regno,&memval,&byte);
+  if( effect == 1 )
+     GPR[regno] =  memval;
+//     GPR[regno] =  (memval >> (8 * byte));
+  return effect;
+}
+:function:::void:do_store:unsigned access, address_word base, address_word offset, unsigned_word word
+{
+  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
+  address_word reverseendian = 0;
+  address_word bigendiancpu = (1 ? (mask ^ access) : 0);
+  address_word amask;
+  unsigned int byte;
+  address_word paddr;
+  int uncached;
+  unsigned64 memval;
+  address_word vaddr;
+
+  vaddr = loadstore_ea (SD_, base, offset);
+
+  amask = ~access;
+  vaddr&=amask;
+
+  if ((vaddr & access) != 0)
+    {
+      SIM_CORE_SIGNAL (SD, STATE_CPU(SD, 0), cia, read_map, access+1, vaddr, write_transfer, sim_core_unaligned_signal);
+    }
+  AddressTranslation (vaddr, isDATA, isSTORE, &paddr, &uncached, isTARGET, isREAL);
+  paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
+  byte = ((vaddr & mask) ^ bigendiancpu);
+  memval = (word << (8 * byte));
+  StoreMemory (uncached, access, memval, 0, paddr, vaddr, isREAL);
+}
+
+
+16.OFFSET,5.RS1,5.RD,000010:NORMAL:32::LB
+"lb r<RD>,<OFFSET>(r<RS1>)"
+*brownie32_std:
+{
+//dbgprintf("##### LB inst #####\n");
+//  GPR[RD] = EXTEND8 (do_load (SD_, AccessLength_BYTE, GPR[RS1], EXTEND16 (OFFSET)));
+
+  do_load (SD_, AccessLength_BYTE, GPR[RS1], EXTEND16 (OFFSET),RD);
+  re_load (SD_ );
+}
+
+16.OFFSET,5.RS1,5.RD,000011:NORMAL:32::LH
+"lh r<RD>,<OFFSET>(r<RS1>)"
+*brownie32_std:
+{
+//dbgprintf("##### LH inst #####\n");
+//  GPR[RD] = EXTEND16 (do_load (SD_, AccessLength_HALFWORD, GPR[RS1], EXTEND16 (OFFSET),RD));
+  do_load (SD_, AccessLength_HALFWORD, GPR[RS1], EXTEND16 (OFFSET),RD);
+  re_load (SD_ );
+
+}
+
+16.OFFSET,5.RS1,5.RD,000100:NORMAL:32::LW
+"lw r<RD>,<OFFSET>(r<RS1>)"
+*brownie32_std:
+{
+//dbgprintf("##### LW inst #####\n");
+//  GPR[RD] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[RS1], EXTEND16 (OFFSET),RD));
+  do_load (SD_, AccessLength_WORD, GPR[RS1], EXTEND16 (OFFSET),RD);
+  re_load (SD_ );
+}
+
+16.OFFSET,5.RS1,5.RD,000101:NORMAL:32::SB
+"sb <OFFSET>(r<RD>),r<RS1>"
+*brownie32_std:
+{
+//dbgprintf("##### SB inst #####\n");
+  do_store (SD_, AccessLength_BYTE, GPR[RD], EXTEND16 (OFFSET), GPR[RS1]);
+  re_load (SD_ );
+}
+
+16.OFFSET,5.RS1,5.RD,000110:NORMAL:32::SH
+"sh <OFFSET>(r<RD>),r<RS1>"
+*brownie32_std:
+{
+//dbgprintf("##### SH inst #####\n");
+  do_store (SD_, AccessLength_HALFWORD, GPR[RD], EXTEND16 (OFFSET), GPR[RS1]);
+  re_load (SD_ );
+}
+
+16.OFFSET,5.RS1,5.RD,000111:NORMAL:32::SW
+"sw <OFFSET>(r<RD>),r<RS1>"
+*brownie32_std:
+{
+//dbgprintf("##### SW inst #####\n");
+  do_store (SD_, AccessLength_WORD, GPR[RD], EXTEND16 (OFFSET), GPR[RS1]);
+  re_load (SD_ );
+}
+
+// Instruction Type = BR
+16.OFFSET,5.RS1,00000,001001:NORMAL:32::BRZ
+"brz r<RS1>,<OFFSET>"
+*brownie32_std:
+{
+  address_word offset = EXTEND16 (OFFSET);// << 2;
+//dbgprintf("##### BRZ inst #####offset=0x%x NIA=0x%x\n",offset,NIA);
+  if ((signed_word) GPR[RS1] == (signed_word) 0)
+    {
+//      DELAY_SLOT (NIA -4 + offset);
+      DELAY_SLOT (NIA + offset);
+    }
+  re_load (SD_ );
+}
+
+16.OFFSET,5.RS1,00000,001010:NORMAL:32::BRNZ
+"brnz r<RS1>,<OFFSET>"
+*brownie32_std:
+{
+  address_word offset = EXTEND16 (OFFSET);// << 2;
+//dbgprintf("##### BRNZ inst #####offset=0x%x NIA=0x%x\n",offset,NIA);
+  if ((signed_word) GPR[RS1] != (signed_word) 0)
+    {
+//      DELAY_SLOT (NIA -4 + offset);
+      DELAY_SLOT (NIA + offset);
+    }
+  re_load (SD_ );
+}
+
+// Instruction Type = JP
+26.OFFSET,001011:NORMAL:32::JP
+"jp <OFFSET>"
+*brownie32_std:
+{
+  address_word offset = EXTEND26 (OFFSET); //<< 2;
+//dbgprintf("##### JP inst ##### NIA=0x%x offset=0x%x ",NIA,offset);
+//  DELAY_SLOT (NIA -4 + offset);
+  DELAY_SLOT (NIA + offset);
+  re_load (SD_ );
+}
+
+26.OFFSET,001100:NORMAL:32::JPL
+"jpl <OFFSET>"
+*brownie32_std:
+{
+  address_word offset = EXTEND26 (OFFSET);// << 2;
+
+//dbgprintf("##### JPL inst ##### OFFSET=0x%x NIA=0x%x PC=0x%x offset=0x%x ",OFFSET,NIA,PC,offset);
+//   GPR[3] = PC + 4;	   // Save link register.
+   GPR[3] = NIA;	   // Save link register.
+//   DELAY_SLOT (NIA -4 + offset);
+   DELAY_SLOT (NIA + offset);
+  re_load (SD_ );
+}
+
+26.OFFSET,001101:NORMAL:32::TRAP
+"trap <OFFSET>"
+*brownie32_std:
+{
+//  TRACE_ALU_INPUT1 (OFFSET);
+//  {
+    unsigned32 trapno = OFFSET;
+//printf("##### TRAP instr #####offset=0x%x %x PC=0x%x \n",trapno,OFFSET,PC);
+
+      if( trapno == 0x1400 )
+         SignalException (BreakPoint,0);
+      else if( trapno == 0x0000)
+         SignalException (0xfffffffe,0);
+      else if( trapno == 0x000a)
+         SignalException (trapno,0);
+      else if( trapno == 34 )
+//         SignalExceptionSyscall (trapno,GPR[7],GPR[8],GPR[9],GPR[10]);
+         SignalExceptionSyscall (trapno, GPR[FIRST_ARG_IDX],
+                                         GPR[FIRST_ARG_IDX + 1],
+                                         GPR[FIRST_ARG_IDX + 2],
+                                         GPR[FIRST_ARG_IDX + 3]);
+//         Syscall( GPR[11],GPR[12],GPR[13],GPR[14]);
+//    if( trapno == 0 )
+//    {
+//      SignalException (DebugBreakPoint, 0);
+//    }
+//    if( trapno == 0 )
+//    {
+//      SignalException (DebugBreakPoint,0);
+//    }
+//      SignalException (BreakPoint,0);
+//    if( trapno == 0 )
+//    {
+//      SignalException (BreakPoint,0);
+//    }
+//    else
+//    {
+//        //SignalExceptionTrap (trapno);
+//    }
+//  }
+//
+//    address_word offset = EXTEND32 ( OFFSET );
+//    {
+//        
+//    }
+}
+
+// Instruction Type = JPR
+21.OFFSET,5.RS1,001110:NORMAL:32::JPR
+"jpr  r<RS1>"
+*brownie32_std:
+{
+//dbgprintf("##### JPR inst #####\n");
+  DELAY_SLOT (GPR[RS1]);
+  re_load (SD_ );
+}
+
+21.OFFSET,5.RS1,001111:NORMAL:32::JPRL
+"jprl r<RS1>"
+*brownie32_std:
+{
+//dbgprintf("##### JPRL inst #####\n");
+//   GPR[3] = PC + 4;	   // Save link register.
+   GPR[3] = NIA;	   // Save link register.
+  DELAY_SLOT (GPR[RS1]);
+  re_load (SD_ );
+}
+
+// Instruction Type = SP
+000000000000000000000,00000,000000:NORMAL:32::NOP
+"nop"
+*brownie32_std:
+{
+//dbgprintf("##### NOP inst #####\n");
+  re_load (SD_ );
+}
+
+000000000000000000000,00001,000000:NORMAL:32::RETI
+"reti"
+*brownie32_std:
+{
+//dbgprintf("##### RETI inst #####\n");
+  GPR[1] &= ~status_EIEN;  // Interrupt Mask
+  GPR[1] &= ~status_IEN;  //
+  DELAY_SLOT (GPR[2]);
+  re_load (SD_ );
+}
+
+5.RD,5.RS1,0000000000000010000000:NORMAL:32::EXBW
+"exbw r<RD>,r<RS1>"
+*brownie32_std:
+{
+//dbgprintf("##### EXBW inst #####\n");
+  TRACE_ALU_INPUT1 (GPR[RS1]);
+  {
+    GPR[RD] = EXTEND8 (GPR[RS1] & 0xFF);
+  }
+  TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
+
+5.RD,5.RS1,0000000000100010000000:NORMAL:32::EXHW
+"exhw r<RD>,r<RS1>"
+*brownie32_std:
+{
+//dbgprintf("##### EXHW inst #####\n");
+  TRACE_ALU_INPUT1 (GPR[RS1]);
+  {
+    GPR[RD] = EXTEND16 (GPR[RS1] & 0xFFFF);
+  }
+  TRACE_ALU_RESULT (GPR[RD]);
+  re_load (SD_ );
+}
Index: sim/brownie32/brownie323264r2.igen
===================================================================
RCS file: sim/brownie32/brownie323264r2.igen
diff -N sim/brownie32/brownie323264r2.igen
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/brownie323264r2.igen	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,260 @@
+// -*- C -*-
+
+// Simulator definition for the MIPS 32/64 revision 2 instructions.
+// Copyright (C) 2004 Free Software Foundation, Inc.
+// Contributed by David Ung, of MIPS Technologies.
+//
+// This file is part of GDB, the GNU debugger.
+// 
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License along
+// with this program; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+
+011111,5.RS,5.RT,5.SIZE,5.LSB,000011::64::DEXT
+"dext r<RT>, r<RS>, <LSB>, <SIZE+1>"
+*brownie3264r2:
+{
+  check_u64 (SD_, instruction_0);
+  TRACE_ALU_INPUT3 (GPR[RS], LSB, SIZE);
+  GPR[RT] = EXTRACTED64 (GPR[RS], LSB + SIZE, LSB);
+  TRACE_ALU_RESULT1 (GPR[RT]);
+}
+
+011111,5.RS,5.RT,5.SIZE,5.LSB,000001::64::DEXTM
+"dextm r<RT>, r<RS>, <LSB>, <SIZE+33>"
+*brownie3264r2:
+{
+  check_u64 (SD_, instruction_0);
+  TRACE_ALU_INPUT3 (GPR[RS], LSB, SIZE);
+  GPR[RT] = EXTRACTED64 (GPR[RS], LSB + SIZE + 32, LSB);
+  TRACE_ALU_RESULT1 (GPR[RT]);
+}
+
+011111,5.RS,5.RT,5.SIZE,5.LSB,000010::64::DEXTU
+"dextu r<RT>, r<RS>, <LSB+32>, <SIZE+1>"
+*brownie3264r2:
+{
+  check_u64 (SD_, instruction_0);
+  TRACE_ALU_INPUT3 (GPR[RS], LSB, SIZE);
+  GPR[RT] = EXTRACTED64 (GPR[RS], LSB + 32 + SIZE, LSB + 32);
+  TRACE_ALU_RESULT1 (GPR[RT]);
+}
+
+
+010000,01011,5.RT,01100,00000,0,00,000::32::DI
+"di":RT == 0
+"di r<RT>"
+*brownie3232r2:
+*brownie3264r2:
+{
+  TRACE_ALU_INPUT0 ();
+  GPR[RT] = EXTEND32 (SR);
+  SR &= ~status_IE;
+  TRACE_ALU_RESULT1 (GPR[RT]);
+}
+
+
+011111,5.RS,5.RT,5.MSB,5.LSB,000111::64::DINS
+"dins r<RT>, r<RS>, <LSB>, <MSB-LSB+1>"
+*brownie3264r2:
+{
+  check_u64 (SD_, instruction_0);
+  TRACE_ALU_INPUT4 (GPR[RT], GPR[RS], LSB, MSB);
+  if (LSB <= MSB)
+    GPR[RT] ^= (GPR[RT] ^ (GPR[RS] << LSB)) & MASK64 (MSB, LSB);
+  TRACE_ALU_RESULT1 (GPR[RT]);
+}
+
+011111,5.RS,5.RT,5.MSB,5.LSB,000101::64::DINSM
+"dinsm r<RT>, r<RS>, <LSB>, <MSB+32-LSB+1>"
+*brownie3264r2:
+{
+  check_u64 (SD_, instruction_0);
+  TRACE_ALU_INPUT4 (GPR[RT], GPR[RS], LSB, MSB);
+  if (LSB <= MSB + 32)
+    GPR[RT] ^= (GPR[RT] ^ (GPR[RS] << LSB)) & MASK64 (MSB + 32, LSB);
+  TRACE_ALU_RESULT1 (GPR[RT]);
+}
+
+011111,5.RS,5.RT,5.MSB,5.LSB,000110::64::DINSU
+"dinsu r<RT>, r<RS>, <LSB+32>, <MSB-LSB+1>"
+*brownie3264r2:
+{
+  check_u64 (SD_, instruction_0);
+  TRACE_ALU_INPUT4 (GPR[RT], GPR[RS], LSB, MSB);
+  if (LSB <= MSB)
+    GPR[RT] ^= (GPR[RT] ^ (GPR[RS] << (LSB + 32)))
+      & MASK64 (MSB + 32, LSB + 32);
+  TRACE_ALU_RESULT1 (GPR[RT]);
+}
+
+
+011111,00000,5.RT,5.RD,00010,100100::64::DSBH
+"dsbh r<RD>, r<RT>"
+*brownie3264r2:
+{
+  union { unsigned64 d; unsigned16 h[4]; } u;
+  check_u64 (SD_, instruction_0);
+  TRACE_ALU_INPUT1 (GPR[RT]);
+  u.d = GPR[RT];
+  u.h[0] = SWAP_2 (u.h[0]);
+  u.h[1] = SWAP_2 (u.h[1]);
+  u.h[2] = SWAP_2 (u.h[2]);
+  u.h[3] = SWAP_2 (u.h[3]);
+  GPR[RD] = u.d;
+  TRACE_ALU_RESULT1 (GPR[RD]);
+}
+
+011111,00000,5.RT,5.RD,00101,100100::64::DSHD
+"dshd r<RD>, r<RT>"
+*brownie3264r2:
+{
+  unsigned64 d;
+  check_u64 (SD_, instruction_0);
+  TRACE_ALU_INPUT1 (GPR[RT]);
+  d = GPR[RT];
+  GPR[RD] = ((d >> 48)
+	     | (d << 48)
+	     | ((d & 0x0000ffff00000000) >> 16)
+	     | ((d & 0x00000000ffff0000) << 16));
+  TRACE_ALU_RESULT1 (GPR[RD]);
+}
+
+
+010000,01011,5.RT,01100,00000,1,00,000::32::EI
+"ei":RT == 0
+"ei r<RT>"
+*brownie3232r2:
+*brownie3264r2:
+{
+  TRACE_ALU_INPUT0 ();
+  GPR[RT] = EXTEND32 (SR);
+  SR |= status_IE;
+  TRACE_ALU_RESULT1 (GPR[RT]);
+}
+
+
+011111,5.RS,5.RT,5.SIZE,5.LSB,000000::32::EXT
+"ext r<RT>, r<RS>, <LSB>, <SIZE+1>"
+*brownie3232r2:
+*brownie3264r2:
+{
+  TRACE_ALU_INPUT3 (GPR[RS], LSB, SIZE);
+  GPR[RT] = EXTEND32 (EXTRACTED32 (GPR[RS], LSB + SIZE, LSB));
+  TRACE_ALU_RESULT1 (GPR[RT]);
+}
+
+
+010001,00011,5.RT,5.FS,00000000000:COP1Sa:32,f::MFHC1
+"mfhc1 r<RT>, f<FS>"
+*brownie3232r2:
+*brownie3264r2:
+{
+  check_fpu (SD_);
+  if (SizeFGR() == 64)
+    GPR[RT] = EXTEND32 (WORD64HI (FGR[FS]));
+  else if ((FS & 0x1) == 0)
+    GPR[RT] = EXTEND32 (FGR[FS + 1]);
+  else
+    {
+      if (STATE_VERBOSE_P(SD))
+	sim_io_eprintf (SD, 
+	         "Warning: PC 0x%lx: MFHC1 32-bit use of odd FPR number\n",
+			(long) CIA);
+      GPR[RT] = EXTEND32 (0xBADF00D);
+    }
+  TRACE_ALU_RESULT (GPR[RT]);
+}
+
+010001,00111,5.RT,5.FS,00000000000:COP1Sa:32,f::MTHC1
+"mthc1 r<RT>, f<FS>"
+*brownie3232r2:
+*brownie3264r2:
+{
+  check_fpu (SD_); 
+  if (SizeFGR() == 64)
+    StoreFPR (FS, fmt_uninterpreted_64, SET64HI (GPR[RT]) | VL4_8 (FGR[FS]));
+  else if ((FS & 0x1) == 0)
+    StoreFPR (FS + 1, fmt_uninterpreted_32, VL4_8 (GPR[RT]));
+  else
+    {
+      if (STATE_VERBOSE_P(SD))
+	sim_io_eprintf (SD, 
+	         "Warning: PC 0x%lx: MTHC1 32-bit use of odd FPR number\n",
+			(long) CIA);
+      StoreFPR (FS, fmt_uninterpreted_32, 0xDEADC0DE);
+    }
+  TRACE_FP_RESULT (GPR[RT]);
+}
+
+
+011111,5.RS,5.RT,5.MSB,5.LSB,000100::32::INS
+"ins r<RT>, r<RS>, <LSB>, <MSB-LSB+1>"
+*brownie3232r2:
+*brownie3264r2:
+{
+  TRACE_ALU_INPUT4 (GPR[RT], GPR[RS], LSB, MSB);
+  if (LSB <= MSB)
+    GPR[RT] = EXTEND32 (GPR[RT] ^
+			((GPR[RT] ^ (GPR[RS] << LSB)) & MASK32 (MSB, LSB)));
+  TRACE_ALU_RESULT1 (GPR[RT]);
+}
+
+
+011111,00000,5.RT,5.RD,10000,100000::32::SEB
+"seb r<RD>, r<RT>"
+*brownie3232r2:
+*brownie3264r2:
+{
+  TRACE_ALU_INPUT1 (GPR[RT]);
+  GPR[RD] = EXTEND8 (GPR[RT]);
+  TRACE_ALU_RESULT1 (GPR[RD]);
+}
+
+011111,00000,5.RT,5.RD,11000,100000::32::SEH
+"seh r<RD>, r<RT>"
+*brownie3232r2:
+*brownie3264r2:
+{
+  TRACE_ALU_INPUT1 (GPR[RT]);
+  GPR[RD] = EXTEND16 (GPR[RT]);
+  TRACE_ALU_RESULT1 (GPR[RD]);
+}
+
+
+000001,5.BASE,11111,16.OFFSET::32::SYNCI
+"synci <OFFSET>(r<BASE>)"
+*brownie3232r2:
+*brownie3264r2:
+{
+  // sync i-cache - nothing to do currently
+}
+
+
+011111,00000,5.RT,5.RD,00010,100000::32::WSBH
+"wsbh r<RD>, r<RT>"
+*brownie3232r2:
+*brownie3264r2:
+{
+  union { unsigned32 w; unsigned16 h[2]; } u;
+  TRACE_ALU_INPUT1 (GPR[RT]);
+  u.w = GPR[RT];
+  u.h[0] = SWAP_2 (u.h[0]);
+  u.h[1] = SWAP_2 (u.h[1]);
+  GPR[RD] = EXTEND32 (u.w);
+  TRACE_ALU_RESULT1 (GPR[RD]);
+}
+
+
+
Index: sim/brownie32/brownie323d.igen
===================================================================
RCS file: sim/brownie32/brownie323d.igen
diff -N sim/brownie32/brownie323d.igen
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/brownie323d.igen	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,177 @@
+// -*- C -*-
+
+// Simulator definition for the MIPS MIPS-3D ASE.
+// Copyright (C) 2002 Free Software Foundation, Inc.
+// Contributed by Ed Satterthwaite and Chris Demetriou, of Broadcom
+// Corporation (SiByte).
+//
+// This file is part of GDB, the GNU debugger.
+// 
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License along
+// with this program; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+//  Reference: MIPS64 Architecture for Programmers Volume IV-c:
+//             The MIPS-3D Application-Specific Extension to the
+//             MIPS64 Architecture.  (MIPS Document MD00099)
+
+
+010001,10,110,5.FT,5.FS,5.FD,011000:COP1:64,f::ADDR.PS
+"addr.ps f<FD>, f<FS>, f<FT>"
+*brownie323d:
+{
+  /* fd.PL = ft.PU + ft.PL;  fd.PU = fs.PU + fs.PL;  */
+  check_fpu (SD_);
+  check_u64 (SD_, instruction_0);
+  StoreFPR (FD, fmt_ps, AddR (ValueFPR (FS, fmt_ps),
+			      ValueFPR (FT, fmt_ps), fmt_ps));
+}
+
+
+010001,01001,3.CC,0,1.TF,16.OFFSET:COP1:64,f::BC1ANY2tf
+"bc1any2%s<TF> <CC>, %#lx<OFFSET>"
+*brownie323d:
+{
+  address_word offset;
+  int cc = CC;
+  check_fpu (SD_);
+  check_u64 (SD_, instruction_0);
+  if ((cc & 0x1) != 0)
+    Unpredictable ();
+  if ((GETFCC (cc) == TF) || (GETFCC (cc + 1) == TF))
+    {
+      offset = (EXTEND16 (OFFSET) << 2);
+      DELAY_SLOT (NIA + offset);
+    }
+}
+
+
+010001,01010,3.CC,0,1.TF,16.OFFSET:COP1:64,f::BC1ANY4tf
+"bc1any4%s<TF> <CC>, %#lx<OFFSET>"
+*brownie323d:
+{
+  address_word offset;
+  int cc = CC;
+  check_fpu (SD_);
+  check_u64 (SD_, instruction_0);
+  if ((cc & 0x3) != 0)
+    Unpredictable ();
+  if ((GETFCC (cc) == TF)
+      || (GETFCC (cc + 1) == TF)
+      || (GETFCC (cc + 2) == TF)
+      || (GETFCC (cc + 3) == TF))
+    {
+      offset = (EXTEND16 (OFFSET) << 2);
+      DELAY_SLOT (NIA + offset);
+    }
+}
+
+
+010001,10,3.FMT,5.FT,5.FS,3.CC,01,11,4.COND:COP1:64,f::CABS.cond.fmt
+"cabs.%s<COND>.%s<FMT> <CC>, f<FS>, f<FT>"
+*brownie323d:
+{
+  int fmt = FMT;
+  check_fpu (SD_);
+  check_u64 (SD_, instruction_0);
+  check_fmt_p (SD_, fmt, instruction_0);
+  CompareAbs (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt, COND, CC);
+  TRACE_ALU_RESULT (ValueFCR (31));
+}
+
+
+010001,10,110,00000,5.FS,5.FD,100100:COP1:64,f::CVT.PW.PS
+"cvt.pw.ps f<FD>, f<FS>"
+*brownie323d:
+{
+  /* fd.pu = cvt_rnd (fs.pu); fd.pl = cvt_rnd (fs.pl);  */
+  /* fmt_pw is fmt_long for 64 bit transfers, but cvt encoding is fmt_word.  */
+  check_fpu (SD_);
+  check_u64 (SD_, instruction_0);
+  StoreFPR (FD, fmt_pw, ConvertPS (GETRM (), ValueFPR (FS, fmt_ps),
+				   fmt_ps, fmt_word));
+}
+
+
+010001,10,100,00000,5.FS,5.FD,100110:COP1:64,f::CVT.PS.PW
+"cvt.ps.pw f<FD>, f<FS>"
+*brownie323d:
+{
+  /* fd.pl = cvt_rnd (fs.pl); fd.pu = cvt_rnd (fs.pu);  */
+  /* fmt_pw is fmt_long for 64 bit transfers, but cvt encoding is fmt_word.  */
+  check_fpu (SD_);
+  check_u64 (SD_, instruction_0);
+  StoreFPR (FD, fmt_ps, ConvertPS (GETRM (), ValueFPR (FS, fmt_pw),
+				   fmt_word, fmt_ps));
+}
+
+
+010001,10,110,5.FT,5.FS,5.FD,011010:COP1:64,f::MULR.PS
+"mulr.ps f<FD>, f<FS>, f<FT>"
+*brownie323d:
+{
+  /* fd.PL = ft.PU * ft.PL;  fd.PU = fs.PU * fs.PL;  */
+  check_fpu (SD_);
+  check_u64 (SD_, instruction_0);
+  StoreFPR (FD, fmt_ps, MultiplyR (ValueFPR (FS, fmt_ps),
+				   ValueFPR (FT, fmt_ps), fmt_ps));
+}
+
+
+010001,10,3.FMT,00000,5.FS,5.FD,011101:COP1:64,f::RECIP1.fmt
+"recip1.%s<FMT> f<FD>, f<FS>"
+*brownie323d:
+{
+  int fmt = FMT;
+  check_fpu (SD_);
+  check_u64 (SD_, instruction_0);
+  check_fmt_p (SD_, fmt, instruction_0);
+  StoreFPR (FD, fmt, Recip1 (ValueFPR (FS, fmt), fmt));
+}
+
+
+010001,10,3.FMT,5.FT,5.FS,5.FD,011100:COP1:64,f::RECIP2.fmt
+"recip2.%s<FMT> f<FD>, f<FS>, f<FT>"
+*brownie323d:
+{
+  int fmt = FMT;
+  check_fpu (SD_);
+  check_u64 (SD_, instruction_0);
+  check_fmt_p (SD_, fmt, instruction_0);
+  StoreFPR (FD, fmt, Recip2 (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
+}
+
+
+010001,10,3.FMT,00000,5.FS,5.FD,011110:COP1:64,f::RSQRT1.fmt
+"rsqrt1.%s<FMT> f<FD>, f<FS>"
+*brownie323d:
+{
+  int fmt = FMT;
+  check_fpu (SD_);
+  check_u64 (SD_, instruction_0);
+  check_fmt_p (SD_, fmt, instruction_0);
+  StoreFPR (FD, fmt, RSquareRoot1 (ValueFPR (FS, fmt), fmt));
+}
+
+
+010001,10,3.FMT,5.FT,5.FS,5.FD,011111:COP1:64,f::RSQRT2.fmt
+"rsqrt2.%s<FMT> f<FD>, f<FS>, f<FT>"
+*brownie323d:
+{
+  int fmt = FMT;
+  check_fpu (SD_);
+  check_u64 (SD_, instruction_0);
+  check_fmt_p (SD_, fmt, instruction_0);
+  StoreFPR (FD, fmt, RSquareRoot2 (ValueFPR (FS, fmt),
+				   ValueFPR (FT, fmt), fmt));
+}
Index: sim/brownie32/config.in
===================================================================
RCS file: sim/brownie32/config.in
diff -N sim/brownie32/config.in
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/config.in	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,229 @@
+/* config.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if NLS is requested.  */
+#undef ENABLE_NLS
+
+/* Define as 1 if you have catgets and don't want to use GNU gettext.  */
+#undef HAVE_CATGETS
+
+/* Define as 1 if you have gettext and don't want to use GNU gettext.  */
+#undef HAVE_GETTEXT
+
+/* Define as 1 if you have the stpcpy function.  */
+#undef HAVE_STPCPY
+
+/* Define if your locale.h file contains LC_MESSAGES.  */
+#undef HAVE_LC_MESSAGES
+
+/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
+   systems. This function is required for `alloca.c' support on those systems.
+   */
+#undef CRAY_STACKSEG_END
+
+/* Define to 1 if using `alloca.c'. */
+#undef C_ALLOCA
+
+/* Define to 1 if NLS is requested */
+#undef ENABLE_NLS
+
+/* Define to 1 if you have the `aint' function. */
+#undef HAVE_AINT
+
+/* Define to 1 if you have `alloca', as a function or macro. */
+#undef HAVE_ALLOCA
+
+/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
+   */
+#undef HAVE_ALLOCA_H
+
+/* Define to 1 if you have the `anint' function. */
+#undef HAVE_ANINT
+
+/* Define to 1 if you have the <argz.h> header file. */
+#undef HAVE_ARGZ_H
+
+/* Define to 1 if you have the `dcgettext' function. */
+#undef HAVE_DCGETTEXT
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you have the <errno.h> header file. */
+#undef HAVE_ERRNO_H
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#undef HAVE_FCNTL_H
+
+/* Define to 1 if you have the <fpu_control.h> header file. */
+#undef HAVE_FPU_CONTROL_H
+
+/* Define to 1 if you have the `getcwd' function. */
+#undef HAVE_GETCWD
+
+/* Define to 1 if you have the `getpagesize' function. */
+#undef HAVE_GETPAGESIZE
+
+/* Define to 1 if you have the `getrusage' function. */
+#undef HAVE_GETRUSAGE
+
+/* Define as 1 if you have gettext and don't want to use GNU gettext. */
+#undef HAVE_GETTEXT
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define if your locale.h file contains LC_MESSAGES. */
+#undef HAVE_LC_MESSAGES
+
+/* Define to 1 if you have the `m' library (-lm). */
+#undef HAVE_LIBM
+
+/* Define to 1 if you have the `nsl' library (-lnsl). */
+#undef HAVE_LIBNSL
+
+/* Define to 1 if you have the `socket' library (-lsocket). */
+#undef HAVE_LIBSOCKET
+
+/* Define to 1 if you have the <limits.h> header file. */
+#undef HAVE_LIMITS_H
+
+/* Define to 1 if you have the <locale.h> header file. */
+#undef HAVE_LOCALE_H
+
+/* Define to 1 if you have the <malloc.h> header file. */
+#undef HAVE_MALLOC_H
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have a working `mmap' system call. */
+#undef HAVE_MMAP
+
+/* Define to 1 if you have the `munmap' function. */
+#undef HAVE_MUNMAP
+
+/* Define to 1 if you have the <nl_types.h> header file. */
+#undef HAVE_NL_TYPES_H
+
+/* Define to 1 if you have the `putenv' function. */
+#undef HAVE_PUTENV
+
+/* Define to 1 if you have the `setenv' function. */
+#undef HAVE_SETENV
+
+/* Define to 1 if you have the `setlocale' function. */
+#undef HAVE_SETLOCALE
+
+/* Define to 1 if you have the `sigaction' function. */
+#undef HAVE_SIGACTION
+
+/* Define to 1 if you have the `sqrt' function. */
+#undef HAVE_SQRT
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define if you have the stpcpy function */
+#undef HAVE_STPCPY
+
+/* Define to 1 if you have the `strcasecmp' function. */
+#undef HAVE_STRCASECMP
+
+/* Define to 1 if you have the `strchr' function. */
+#undef HAVE_STRCHR
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#undef HAVE_SYS_PARAM_H
+
+/* Define to 1 if you have the <sys/resource.h> header file. */
+#undef HAVE_SYS_RESOURCE_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#undef HAVE_SYS_TIME_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the `time' function. */
+#undef HAVE_TIME
+
+/* Define to 1 if you have the <time.h> header file. */
+#undef HAVE_TIME_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define to 1 if you have the <values.h> header file. */
+#undef HAVE_VALUES_H
+
+/* Define to 1 if you have the `__argz_count' function. */
+#undef HAVE___ARGZ_COUNT
+
+/* Define to 1 if you have the `__argz_next' function. */
+#undef HAVE___ARGZ_NEXT
+
+/* Define to 1 if you have the `__argz_stringify' function. */
+#undef HAVE___ARGZ_STRINGIFY
+
+/* Define to 1 if you have the `__setfpucw' function. */
+#undef HAVE___SETFPUCW
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* Define as the return type of signal handlers (`int' or `void'). */
+#undef RETSIGTYPE
+
+/* If using the C implementation of alloca, define if you know the
+   direction of stack growth for your system; otherwise it will be
+   automatically deduced at run-time.
+	STACK_DIRECTION > 0 => grows toward higher addresses
+	STACK_DIRECTION < 0 => grows toward lower addresses
+	STACK_DIRECTION = 0 => direction of growth unknown */
+#undef STACK_DIRECTION
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* Define to 1 if your processor stores words with the most significant byte
+   first (like Motorola and SPARC, unlike Intel and VAX). */
+#undef WORDS_BIGENDIAN
+
+/* Define to empty if `const' does not conform to ANSI C. */
+#undef const
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+#undef inline
+#endif
+
+/* Define to `long' if <sys/types.h> does not define. */
+#undef off_t
+
+/* Define to `unsigned' if <sys/types.h> does not define. */
+#undef size_t
Index: sim/brownie32/configure
===================================================================
RCS file: sim/brownie32/configure
diff -N sim/brownie32/configure
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/configure	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,10165 @@
+#! /bin/sh
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.59.
+#
+# Copyright (C) 2003 Free Software Foundation, Inc.
+# Copyright (C) 2005,2006  Upwind technology, Inc.
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+
+# Name of the host.
+# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
+
+exec 6>&1
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_config_libobj_dir=.
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+# Maximum number of lines to put in a shell here document.
+# This variable seems obsolete.  It should probably be removed, and
+# only ac_max_sed_lines should be used.
+: ${ac_max_here_lines=38}
+
+# Identity of this package.
+PACKAGE_NAME=
+PACKAGE_TARNAME=
+PACKAGE_VERSION=
+PACKAGE_STRING=
+PACKAGE_BUGREPORT=
+
+ac_unique_file="Makefile.in"
+# Factoring default headers for most tests.
+ac_includes_default="\
+#include <stdio.h>
+#if HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#if HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# if HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#if HAVE_STRING_H
+# if !STDC_HEADERS && HAVE_MEMORY_H
+#  include <memory.h>
+# endif
+# include <string.h>
+#endif
+#if HAVE_STRINGS_H
+# include <strings.h>
+#endif
+#if HAVE_INTTYPES_H
+# include <inttypes.h>
+#else
+# if HAVE_STDINT_H
+#  include <stdint.h>
+# endif
+#endif
+#if HAVE_UNISTD_H
+# include <unistd.h>
+#endif"
+
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS sim_environment sim_alignment sim_assert sim_bitsize sim_endian sim_hostendian sim_float sim_scache sim_default_model sim_hw_cflags sim_hw_objs sim_hw sim_inline sim_packages sim_regparm sim_reserved_bits sim_smp sim_stdcall sim_xor_endian WARN_CFLAGS WERROR_CFLAGS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CC_FOR_BUILD HDEFINES AR RANLIB ac_ct_RANLIB SET_MAKE CPP EGREP ALLOCA USE_NLS MSGFMT GMSGFMT XGETTEXT USE_INCLUDED_LIBINTL CATALOGS CATOBJEXT DATADIRNAME GMOFILES INSTOBJEXT INTLDEPS INTLLIBS INTLOBJS POFILES POSUB INCLUDE_LOCALE_H GT_NO GT_YES MKINSTALLDIRS l MAINT sim_bswap sim_cflags sim_debug sim_stdio sim_trace sim_profile SIM_SUBTARGET sim_igen_flags sim_m16_flags sim_gen sim_multi_flags sim_multi_igen_configs sim_multi_src sim_multi_obj brownie32_extra_objs brownie32_igen_engine brownie32_extra_libs cgen_breaks LIBOBJS LTLIBOBJS'
+ac_subst_files=''
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can "make install exec_prefix=/foo"
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datadir='${prefix}/share'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+libdir='${exec_prefix}/lib'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+infodir='${prefix}/info'
+mandir='${prefix}/man'
+
+ac_prev=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval "$ac_prev=\$ac_option"
+    ac_prev=
+    continue
+  fi
+
+  ac_optarg=`expr "x$ac_option" : 'x[^=]*=\(.*\)'`
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_option in
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
+  | --da=*)
+    datadir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    eval "enable_$ac_feature=no" ;;
+
+  -enable-* | --enable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "enable_$ac_feature='$ac_optarg'" ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst \
+  | --locals | --local | --loca | --loc | --lo)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* \
+  | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_package=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "with_$ac_package='$ac_optarg'" ;;
+
+  -without-* | --without-*)
+    ac_package=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package | sed 's/-/_/g'`
+    eval "with_$ac_package=no" ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) { echo "$as_me: error: unrecognized option: $ac_option
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; }
+    ;;
+
+  *=*)
+    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid variable name: $ac_envvar" >&2
+   { (exit 1); exit 1; }; }
+    ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`
+    eval "$ac_envvar='$ac_optarg'"
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  { echo "$as_me: error: missing argument to $ac_option" >&2
+   { (exit 1); exit 1; }; }
+fi
+
+# Be sure to have absolute paths.
+for ac_var in exec_prefix prefix
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* | NONE | '' ) ;;
+    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# Be sure to have absolute paths.
+for ac_var in bindir sbindir libexecdir datadir sysconfdir sharedstatedir \
+	      localstatedir libdir includedir oldincludedir infodir mandir
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* ) ;;
+    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test "x$host_alias" != x; then
+  if test "x$build_alias" = x; then
+    cross_compiling=maybe
+    echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used." >&2
+  elif test "x$build_alias" != "x$host_alias"; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+test "$silent" = yes && exec 6>/dev/null
+
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then its parent.
+  ac_confdir=`(dirname "$0") 2>/dev/null ||
+$as_expr X"$0" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$0" : 'X\(//\)[^/]' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$0" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r $srcdir/$ac_unique_file; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r $srcdir/$ac_unique_file; then
+  if test "$ac_srcdir_defaulted" = yes; then
+    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $ac_confdir or .." >&2
+   { (exit 1); exit 1; }; }
+  else
+    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $srcdir" >&2
+   { (exit 1); exit 1; }; }
+  fi
+fi
+(cd $srcdir && test -r ./$ac_unique_file) 2>/dev/null ||
+  { echo "$as_me: error: sources are in $srcdir, but \`cd $srcdir' does not work" >&2
+   { (exit 1); exit 1; }; }
+srcdir=`echo "$srcdir" | sed 's%\([^\\/]\)[\\/]*$%\1%'`
+ac_env_build_alias_set=${build_alias+set}
+ac_env_build_alias_value=$build_alias
+ac_cv_env_build_alias_set=${build_alias+set}
+ac_cv_env_build_alias_value=$build_alias
+ac_env_host_alias_set=${host_alias+set}
+ac_env_host_alias_value=$host_alias
+ac_cv_env_host_alias_set=${host_alias+set}
+ac_cv_env_host_alias_value=$host_alias
+ac_env_target_alias_set=${target_alias+set}
+ac_env_target_alias_value=$target_alias
+ac_cv_env_target_alias_set=${target_alias+set}
+ac_cv_env_target_alias_value=$target_alias
+ac_env_CC_set=${CC+set}
+ac_env_CC_value=$CC
+ac_cv_env_CC_set=${CC+set}
+ac_cv_env_CC_value=$CC
+ac_env_CFLAGS_set=${CFLAGS+set}
+ac_env_CFLAGS_value=$CFLAGS
+ac_cv_env_CFLAGS_set=${CFLAGS+set}
+ac_cv_env_CFLAGS_value=$CFLAGS
+ac_env_LDFLAGS_set=${LDFLAGS+set}
+ac_env_LDFLAGS_value=$LDFLAGS
+ac_cv_env_LDFLAGS_set=${LDFLAGS+set}
+ac_cv_env_LDFLAGS_value=$LDFLAGS
+ac_env_CPPFLAGS_set=${CPPFLAGS+set}
+ac_env_CPPFLAGS_value=$CPPFLAGS
+ac_cv_env_CPPFLAGS_set=${CPPFLAGS+set}
+ac_cv_env_CPPFLAGS_value=$CPPFLAGS
+ac_env_CPP_set=${CPP+set}
+ac_env_CPP_value=$CPP
+ac_cv_env_CPP_set=${CPP+set}
+ac_cv_env_CPP_value=$CPP
+
+#
+# Report the --help message.
+#
+if test "$ac_init_help" = "long"; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat <<_ACEOF
+\`configure' configures this package to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+_ACEOF
+
+  cat <<_ACEOF
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+			  [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+			  [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR           user executables [EPREFIX/bin]
+  --sbindir=DIR          system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR       program executables [EPREFIX/libexec]
+  --datadir=DIR          read-only architecture-independent data [PREFIX/share]
+  --sysconfdir=DIR       read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR   modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR    modifiable single-machine data [PREFIX/var]
+  --libdir=DIR           object code libraries [EPREFIX/lib]
+  --includedir=DIR       C header files [PREFIX/include]
+  --oldincludedir=DIR    C header files for non-gcc [/usr/include]
+  --infodir=DIR          info documentation [PREFIX/info]
+  --mandir=DIR           man documentation [PREFIX/man]
+_ACEOF
+
+  cat <<\_ACEOF
+
+Program names:
+  --program-prefix=PREFIX            prepend PREFIX to installed program names
+  --program-suffix=SUFFIX            append SUFFIX to installed program names
+  --program-transform-name=PROGRAM   run sed PROGRAM on installed program names
+
+X features:
+  --x-includes=DIR    X include files are in DIR
+  --x-libraries=DIR   X library files are in DIR
+
+System types:
+  --build=BUILD     configure for building on BUILD [guessed]
+  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
+  --target=TARGET   configure for building compilers for TARGET [HOST]
+_ACEOF
+fi
+
+if test -n "$ac_init_help"; then
+
+  cat <<\_ACEOF
+
+Optional Features:
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --disable-nls           do not use Native Language Support
+  --enable-maintainer-mode		Enable developer functionality.
+  --enable-sim-bswap			Use Host specific BSWAP instruction.
+  --enable-sim-cflags=opts		Extra CFLAGS for use in building simulator
+  --enable-sim-debug=opts		Enable debugging flags
+  --enable-sim-stdio			Specify whether to use stdio for console input/output.
+  --enable-sim-trace=opts		Enable tracing flags
+  --enable-sim-profile=opts		Enable profiling flags
+  --enable-sim-inline=inlines		Specify which functions should be inlined.
+  --enable-sim-alignment=align		Specify strict,  nonstrict or forced alignment of memory accesses.
+  --enable-sim-hostendian=end		Specify host byte endian orientation.
+  --enable-build-warnings Enable build-time compiler warnings if gcc is used
+  --enable-gdb-build-warnings Enable SIM specific build-time compiler warnings if gcc is used
+  --enable-sim-reserved-bits		Specify whether to check reserved bits in instruction.
+  --enable-sim-endian=endian		Specify target byte endian orientation.
+  --enable-sim-bitsize=N		Specify target bitsize (32 or 64).
+  --enable-sim-float			Specify that the target processor has floating point hardware.
+  --enable-sim-smp=n			Specify number of processors to configure for (default ${default_sim_smp}).
+  --enable-sim-hardware=LIST		Specify the hardware to be included in the build.
+
+Optional Packages:
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --with-included-gettext use the GNU gettext library included here
+  --with-x                use the X Window System
+
+Some influential environment variables:
+  CC          C compiler command
+  CFLAGS      C compiler flags
+  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
+              nonstandard directory <lib dir>
+  CPPFLAGS    C/C++ preprocessor flags, e.g. -I<include dir> if you have
+              headers in a nonstandard directory <include dir>
+  CPP         C preprocessor
+
+Use these variables to override the choices made by `configure' or to help
+it to find libraries and programs with nonstandard names/locations.
+
+_ACEOF
+fi
+
+if test "$ac_init_help" = "recursive"; then
+  # If there are subdirs, report their specific --help.
+  ac_popdir=`pwd`
+  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
+    test -d $ac_dir || continue
+    ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+    cd $ac_dir
+    # Check for guested configure; otherwise get Cygnus style configure.
+    if test -f $ac_srcdir/configure.gnu; then
+      echo
+      $SHELL $ac_srcdir/configure.gnu  --help=recursive
+    elif test -f $ac_srcdir/configure; then
+      echo
+      $SHELL $ac_srcdir/configure  --help=recursive
+    elif test -f $ac_srcdir/configure.ac ||
+	   test -f $ac_srcdir/configure.in; then
+      echo
+      $ac_configure --help
+    else
+      echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+    fi
+    cd $ac_popdir
+  done
+fi
+
+test -n "$ac_init_help" && exit 0
+if $ac_init_version; then
+  cat <<\_ACEOF
+
+Copyright (C) 2003 Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit 0
+fi
+exec 5>config.log
+cat >&5 <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by $as_me, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+hostinfo               = `(hostinfo) 2>/dev/null               || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  echo "PATH: $as_dir"
+done
+
+} >&5
+
+cat >&5 <<_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_sep=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
+      ac_arg=`echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) ac_configure_args0="$ac_configure_args0 '$ac_arg'" ;;
+    2)
+      ac_configure_args1="$ac_configure_args1 '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case "$ac_configure_args0 " in
+	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      ac_configure_args="$ac_configure_args$ac_sep'$ac_arg'"
+      # Get rid of the leading space.
+      ac_sep=" "
+      ;;
+    esac
+  done
+done
+$as_unset ac_configure_args0 || test "${ac_configure_args0+set}" != set || { ac_configure_args0=; export ac_configure_args0; }
+$as_unset ac_configure_args1 || test "${ac_configure_args1+set}" != set || { ac_configure_args1=; export ac_configure_args1; }
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Be sure not to use single quotes in there, as some shells,
+# such as our DU 5.0 friend, will then `close' the trap.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    cat <<\_ASBOX
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+_ASBOX
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+{
+  (set) 2>&1 |
+    case `(ac_space='"'"' '"'"'; set | grep ac_space) 2>&1` in
+    *ac_space=\ *)
+      sed -n \
+	"s/'"'"'/'"'"'\\\\'"'"''"'"'/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='"'"'\\2'"'"'/p"
+      ;;
+    *)
+      sed -n \
+	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+      ;;
+    esac;
+}
+    echo
+
+    cat <<\_ASBOX
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+_ASBOX
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=$`echo $ac_var`
+      echo "$ac_var='"'"'$ac_val'"'"'"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      cat <<\_ASBOX
+## ------------- ##
+## Output files. ##
+## ------------- ##
+_ASBOX
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=$`echo $ac_var`
+	echo "$ac_var='"'"'$ac_val'"'"'"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      cat <<\_ASBOX
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+_ASBOX
+      echo
+      sed "/^$/d" confdefs.h | sort
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      echo "$as_me: caught signal $ac_signal"
+    echo "$as_me: exit $exit_status"
+  } >&5
+  rm -f core *.core &&
+  rm -rf conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+     ' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -rf conftest* confdefs.h
+# AIX cpp loses on an empty file, so make sure it contains at least a newline.
+echo >confdefs.h
+
+# Predefined preprocessor variables.
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_NAME "$PACKAGE_NAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_VERSION "$PACKAGE_VERSION"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_STRING "$PACKAGE_STRING"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer explicitly selected file to automatically selected ones.
+if test -z "$CONFIG_SITE"; then
+  if test "x$prefix" != xNONE; then
+    CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
+  else
+    CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
+  fi
+fi
+for ac_site_file in $CONFIG_SITE; do
+  if test -r "$ac_site_file"; then
+    { echo "$as_me:$LINENO: loading site script $ac_site_file" >&5
+echo "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file"
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special
+  # files actually), so we avoid doing that.
+  if test -f "$cache_file"; then
+    { echo "$as_me:$LINENO: loading cache $cache_file" >&5
+echo "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . $cache_file;;
+      *)                      . ./$cache_file;;
+    esac
+  fi
+else
+  { echo "$as_me:$LINENO: creating cache $cache_file" >&5
+echo "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in `(set) 2>&1 |
+	       sed -n 's/^ac_env_\([a-zA-Z_0-9]*\)_set=.*/\1/p'`; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val="\$ac_cv_env_${ac_var}_value"
+  eval ac_new_val="\$ac_env_${ac_var}_value"
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was not set in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+	{ echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
+echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+	{ echo "$as_me:$LINENO:   former value:  $ac_old_val" >&5
+echo "$as_me:   former value:  $ac_old_val" >&2;}
+	{ echo "$as_me:$LINENO:   current value: $ac_new_val" >&5
+echo "$as_me:   current value: $ac_new_val" >&2;}
+	ac_cache_corrupted=:
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
+      ac_arg=$ac_var=`echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) ac_configure_args="$ac_configure_args '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
+echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  { { echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
+echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+          ac_config_headers="$ac_config_headers config.h:config.in"
+
+
+# This file contains common code used by all simulators.
+#
+# SIM_AC_COMMON invokes AC macros used by all simulators and by the common
+# directory.  It is intended to be invoked before any target specific stuff.
+# SIM_AC_OUTPUT is a cover function to AC_OUTPUT to generate the Makefile.
+# It is intended to be invoked last.
+#
+# The simulator's configure.in should look like:
+#
+# dnl Process this file with autoconf to produce a configure script.
+# sinclude(../common/aclocal.m4)
+# AC_PREREQ(2.5)dnl
+# AC_INIT(Makefile.in)
+#
+# SIM_AC_COMMON
+#
+# ... target specific stuff ...
+#
+# SIM_AC_OUTPUT
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+sim_inline="-DDEFAULT_INLINE=0"
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# This file is derived from `gettext.m4'.  The difference is that the
+# included macros assume Cygnus-style source and build trees.
+
+# Macro to add for using GNU gettext.
+# Ulrich Drepper <drepper@cygnus.com>, 1995.
+#
+# This file file be copied and used freely without restrictions.  It can
+# be used in projects which are not available under the GNU Public License
+# but which still want to provide support for the GNU gettext functionality.
+# Please note that the actual code is *not* freely available.
+
+# serial 3
+
+
+
+
+
+# Search path for a program which passes the given test.
+# Ulrich Drepper <drepper@cygnus.com>, 1996.
+#
+# This file file be copied and used freely without restrictions.  It can
+# be used in projects which are not available under the GNU Public License
+# but which still want to provide support for the GNU gettext functionality.
+# Please note that the actual code is *not* freely available.
+
+# serial 1
+
+
+
+# Check whether LC_MESSAGES is available in <locale.h>.
+# Ulrich Drepper <drepper@cygnus.com>, 1995.
+#
+# This file file be copied and used freely without restrictions.  It can
+# be used in projects which are not available under the GNU Public License
+# but which still want to provide support for the GNU gettext functionality.
+# Please note that the actual code is *not* freely available.
+
+# serial 1
+
+
+
+
+
+
+
+# Bugs in autoconf 2.59 break the call to SIM_AC_COMMON, hack around
+# it by inlining the macro's contents.
+# This file contains common code used by all simulators.
+#
+# common.m4 invokes AC macros used by all simulators and by the common
+# directory.  It is intended to be included before any target specific
+# stuff.  SIM_AC_OUTPUT is a cover function to AC_OUTPUT to generate
+# the Makefile.  It is intended to be invoked last.
+#
+# The simulator's configure.in should look like:
+#
+# dnl Process this file with autoconf to produce a configure script.
+# AC_PREREQ(2.5)dnl
+# AC_INIT(Makefile.in)
+# AC_CONFIG_HEADER(config.h:config.in)
+#
+# sinclude(../common/aclocal.m4)
+# sinclude(../common/common.m4)
+#
+# ... target specific stuff ...
+
+ac_aux_dir=
+for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do
+  if test -f $ac_dir/install-sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f $ac_dir/install.sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  elif test -f $ac_dir/shtool; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/shtool install -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  { { echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." >&5
+echo "$as_me: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"
+ac_configure="$SHELL $ac_aux_dir/configure" # This should be Cygnus configure.
+
+# Make sure we can run config.sub.
+$ac_config_sub sun4 >/dev/null 2>&1 ||
+  { { echo "$as_me:$LINENO: error: cannot run $ac_config_sub" >&5
+echo "$as_me: error: cannot run $ac_config_sub" >&2;}
+   { (exit 1); exit 1; }; }
+
+echo "$as_me:$LINENO: checking build system type" >&5
+echo $ECHO_N "checking build system type... $ECHO_C" >&6
+if test "${ac_cv_build+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_build_alias=$build_alias
+test -z "$ac_cv_build_alias" &&
+  ac_cv_build_alias=`$ac_config_guess`
+test -z "$ac_cv_build_alias" &&
+  { { echo "$as_me:$LINENO: error: cannot guess build type; you must specify one" >&5
+echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
+   { (exit 1); exit 1; }; }
+ac_cv_build=`$ac_config_sub $ac_cv_build_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_build_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_build_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_build" >&5
+echo "${ECHO_T}$ac_cv_build" >&6
+build=$ac_cv_build
+build_cpu=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+build_vendor=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+build_os=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+echo "$as_me:$LINENO: checking host system type" >&5
+echo $ECHO_N "checking host system type... $ECHO_C" >&6
+if test "${ac_cv_host+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_host_alias=$host_alias
+test -z "$ac_cv_host_alias" &&
+  ac_cv_host_alias=$ac_cv_build_alias
+ac_cv_host=`$ac_config_sub $ac_cv_host_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_host_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_host_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_host" >&5
+echo "${ECHO_T}$ac_cv_host" >&6
+host=$ac_cv_host
+host_cpu=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+echo "$as_me:$LINENO: checking target system type" >&5
+echo $ECHO_N "checking target system type... $ECHO_C" >&6
+if test "${ac_cv_target+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_target_alias=$target_alias
+test "x$ac_cv_target_alias" = "x" &&
+  ac_cv_target_alias=$ac_cv_host_alias
+ac_cv_target=`$ac_config_sub $ac_cv_target_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_target_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_target_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_target" >&5
+echo "${ECHO_T}$ac_cv_target" >&6
+target=$ac_cv_target
+target_cpu=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+target_vendor=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+target_os=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+# The aliases save the names the user supplied, while $host etc.
+# will get canonicalized.
+test -n "$target_alias" &&
+  test "$program_prefix$program_suffix$program_transform_name" = \
+    NONENONEs,x,x, &&
+  program_prefix=${target_alias}-
+test "$program_prefix" != NONE &&
+  program_transform_name="s,^,$program_prefix,;$program_transform_name"
+# Use a double $ so make ignores it.
+test "$program_suffix" != NONE &&
+  program_transform_name="s,\$,$program_suffix,;$program_transform_name"
+# Double any \ or $.  echo might interpret backslashes.
+# By default was `s,x,x', remove it if useless.
+cat <<\_ACEOF >conftest.sed
+s/[\\$]/&&/g;s/;s,x,x,$//
+_ACEOF
+program_transform_name=`echo $program_transform_name | sed -f conftest.sed`
+rm conftest.sed
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}gcc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="gcc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  CC=$ac_ct_CC
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  CC=$ac_ct_CC
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+fi
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in cl
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+    test -n "$CC" && break
+  done
+fi
+if test -z "$CC"; then
+  ac_ct_CC=$CC
+  for ac_prog in cl
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  test -n "$ac_ct_CC" && break
+done
+
+  CC=$ac_ct_CC
+fi
+
+fi
+
+
+test -z "$CC" && { { echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&5
+echo "$as_me: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+
+# Provide some information about the compiler.
+echo "$as_me:$LINENO:" \
+     "checking for C compiler version" >&5
+ac_compiler=`set X $ac_compile; echo $2`
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler --version </dev/null >&5\"") >&5
+  (eval $ac_compiler --version </dev/null >&5) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler -v </dev/null >&5\"") >&5
+  (eval $ac_compiler -v </dev/null >&5) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler -V </dev/null >&5\"") >&5
+  (eval $ac_compiler -V </dev/null >&5) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files a.out a.exe b.out"
+# Try to create an executable without -o first, disregard a.out.
+# It will help us diagnose broken compilers, and finding out an intuition
+# of exeext.
+echo "$as_me:$LINENO: checking for C compiler default output file name" >&5
+echo $ECHO_N "checking for C compiler default output file name... $ECHO_C" >&6
+ac_link_default=`echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
+if { (eval echo "$as_me:$LINENO: \"$ac_link_default\"") >&5
+  (eval $ac_link_default) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  # Find the output, starting from the most likely.  This scheme is
+# not robust to junk in `.', hence go to wildcards (a.*) only as a last
+# resort.
+
+# Be careful to initialize this variable, since it used to be cached.
+# Otherwise an old cache value of `no' led to `EXEEXT = no' in a Makefile.
+ac_cv_exeext=
+# b.out is created by i960 compilers.
+for ac_file in a_out.exe a.exe conftest.exe a.out conftest a.* conftest.* b.out
+do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj )
+	;;
+    conftest.$ac_ext )
+	# This is the source file.
+	;;
+    [ab].out )
+	# We found the default executable, but exeext='' is most
+	# certainly right.
+	break;;
+    *.* )
+	ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	# FIXME: I believe we export ac_cv_exeext for Libtool,
+	# but it would be cool to find out if it's true.  Does anybody
+	# maintain Libtool? --akim.
+	export ac_cv_exeext
+	break;;
+    * )
+	break;;
+  esac
+done
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { echo "$as_me:$LINENO: error: C compiler cannot create executables
+See \`config.log' for more details." >&5
+echo "$as_me: error: C compiler cannot create executables
+See \`config.log' for more details." >&2;}
+   { (exit 77); exit 77; }; }
+fi
+
+ac_exeext=$ac_cv_exeext
+echo "$as_me:$LINENO: result: $ac_file" >&5
+echo "${ECHO_T}$ac_file" >&6
+
+# Check the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+echo "$as_me:$LINENO: checking whether the C compiler works" >&5
+echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6
+# FIXME: These cross compiler hacks should be removed for Autoconf 3.0
+# If not cross compiling, check that we can run a simple program.
+if test "$cross_compiling" != yes; then
+  if { ac_try='./$ac_file'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+    cross_compiling=no
+  else
+    if test "$cross_compiling" = maybe; then
+	cross_compiling=yes
+    else
+	{ { echo "$as_me:$LINENO: error: cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+    fi
+  fi
+fi
+echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+
+rm -f a.out a.exe conftest$ac_cv_exeext b.out
+ac_clean_files=$ac_clean_files_save
+# Check the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+echo "$as_me:$LINENO: checking whether we are cross compiling" >&5
+echo $ECHO_N "checking whether we are cross compiling... $ECHO_C" >&6
+echo "$as_me:$LINENO: result: $cross_compiling" >&5
+echo "${ECHO_T}$cross_compiling" >&6
+
+echo "$as_me:$LINENO: checking for suffix of executables" >&5
+echo $ECHO_N "checking for suffix of executables... $ECHO_C" >&6
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  # If both `conftest.exe' and `conftest' are `present' (well, observable)
+# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
+# work properly (i.e., refer to `conftest.exe'), while it won't with
+# `rm'.
+for ac_file in conftest.exe conftest conftest.*; do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj ) ;;
+    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	  export ac_cv_exeext
+	  break;;
+    * ) break;;
+  esac
+done
+else
+  { { echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+rm -f conftest$ac_cv_exeext
+echo "$as_me:$LINENO: result: $ac_cv_exeext" >&5
+echo "${ECHO_T}$ac_cv_exeext" >&6
+
+rm -f conftest.$ac_ext
+EXEEXT=$ac_cv_exeext
+ac_exeext=$EXEEXT
+echo "$as_me:$LINENO: checking for suffix of object files" >&5
+echo $ECHO_N "checking for suffix of object files... $ECHO_C" >&6
+if test "${ac_cv_objext+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.o conftest.obj
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  for ac_file in `(ls conftest.o conftest.obj; ls conftest.*) 2>/dev/null`; do
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg ) ;;
+    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
+       break;;
+  esac
+done
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+rm -f conftest.$ac_cv_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_objext" >&5
+echo "${ECHO_T}$ac_cv_objext" >&6
+OBJEXT=$ac_cv_objext
+ac_objext=$OBJEXT
+echo "$as_me:$LINENO: checking whether we are using the GNU C compiler" >&5
+echo $ECHO_N "checking whether we are using the GNU C compiler... $ECHO_C" >&6
+if test "${ac_cv_c_compiler_gnu+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_compiler_gnu=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_compiler_gnu=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_compiler_gnu" >&5
+echo "${ECHO_T}$ac_cv_c_compiler_gnu" >&6
+GCC=`test $ac_compiler_gnu = yes && echo yes`
+ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+CFLAGS="-g"
+echo "$as_me:$LINENO: checking whether $CC accepts -g" >&5
+echo $ECHO_N "checking whether $CC accepts -g... $ECHO_C" >&6
+if test "${ac_cv_prog_cc_g+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_prog_cc_g=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_prog_cc_g=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
+echo "${ECHO_T}$ac_cv_prog_cc_g" >&6
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+echo "$as_me:$LINENO: checking for $CC option to accept ANSI C" >&5
+echo $ECHO_N "checking for $CC option to accept ANSI C... $ECHO_C" >&6
+if test "${ac_cv_prog_cc_stdc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_prog_cc_stdc=no
+ac_save_CC=$CC
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdarg.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std1 is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std1.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
+_ACEOF
+# Don't try gcc -ansi; that turns off useful extensions and
+# breaks some systems' header files.
+# AIX			-qlanglvl=ansi
+# Ultrix and OSF/1	-std1
+# HP-UX 10.20 and later	-Ae
+# HP-UX older versions	-Aa -D_HPUX_SOURCE
+# SVR4			-Xc -D__EXTENSIONS__
+for ac_arg in "" -qlanglvl=ansi -std1 -Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_prog_cc_stdc=$ac_arg
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext
+done
+rm -f conftest.$ac_ext conftest.$ac_objext
+CC=$ac_save_CC
+
+fi
+
+case "x$ac_cv_prog_cc_stdc" in
+  x|xno)
+    echo "$as_me:$LINENO: result: none needed" >&5
+echo "${ECHO_T}none needed" >&6 ;;
+  *)
+    echo "$as_me:$LINENO: result: $ac_cv_prog_cc_stdc" >&5
+echo "${ECHO_T}$ac_cv_prog_cc_stdc" >&6
+    CC="$CC $ac_cv_prog_cc_stdc" ;;
+esac
+
+# Some people use a C++ compiler to compile C.  Since we use `exit',
+# in C++ we need to declare it.  In case someone uses the same compiler
+# for both compiling C and C++ we need to have the C++ compiler decide
+# the declaration of exit, since it's the most demanding environment.
+cat >conftest.$ac_ext <<_ACEOF
+#ifndef __cplusplus
+  choke me
+#endif
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  for ac_declaration in \
+   '' \
+   'extern "C" void std::exit (int) throw (); using std::exit;' \
+   'extern "C" void std::exit (int); using std::exit;' \
+   'extern "C" void exit (int) throw ();' \
+   'extern "C" void exit (int);' \
+   'void exit (int);'
+do
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_declaration
+#include <stdlib.h>
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+continue
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_declaration
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+done
+rm -f conftest*
+if test -n "$ac_declaration"; then
+  echo '#ifdef __cplusplus' >>confdefs.h
+  echo $ac_declaration      >>confdefs.h
+  echo '#endif'             >>confdefs.h
+fi
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
+# ./install, which can be erroneously created by make from ./install.sh.
+echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
+echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6
+if test -z "$INSTALL"; then
+if test "${ac_cv_path_install+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in
+  ./ | .// | /cC/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:\\/os2\\/install\\/* | ?:\\/OS2\\/INSTALL\\/* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+	if $as_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
+	  if test $ac_prog = install &&
+	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &&
+	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+	    break 3
+	  fi
+	fi
+      done
+    done
+    ;;
+esac
+done
+
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  We don't cache a
+    # path for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the path is relative.
+    INSTALL=$ac_install_sh
+  fi
+fi
+echo "$as_me:$LINENO: result: $INSTALL" >&5
+echo "${ECHO_T}$INSTALL" >&6
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+
+# Put a plausible default for CC_FOR_BUILD in Makefile.
+if test "x$cross_compiling" = "xno"; then
+  CC_FOR_BUILD='$(CC)'
+else
+  CC_FOR_BUILD=gcc
+fi
+
+
+
+
+AR=${AR-ar}
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ranlib; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_RANLIB+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$RANLIB"; then
+  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+RANLIB=$ac_cv_prog_RANLIB
+if test -n "$RANLIB"; then
+  echo "$as_me:$LINENO: result: $RANLIB" >&5
+echo "${ECHO_T}$RANLIB" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_RANLIB"; then
+  ac_ct_RANLIB=$RANLIB
+  # Extract the first word of "ranlib", so it can be a program name with args.
+set dummy ranlib; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_RANLIB"; then
+  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_RANLIB="ranlib"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  test -z "$ac_cv_prog_ac_ct_RANLIB" && ac_cv_prog_ac_ct_RANLIB=":"
+fi
+fi
+ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
+if test -n "$ac_ct_RANLIB"; then
+  echo "$as_me:$LINENO: result: $ac_ct_RANLIB" >&5
+echo "${ECHO_T}$ac_ct_RANLIB" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  RANLIB=$ac_ct_RANLIB
+else
+  RANLIB="$ac_cv_prog_RANLIB"
+fi
+
+
+ALL_LINGUAS=
+echo "$as_me:$LINENO: checking whether ${MAKE-make} sets \$(MAKE)" >&5
+echo $ECHO_N "checking whether ${MAKE-make} sets \$(MAKE)... $ECHO_C" >&6
+set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y,:./+-,___p_,'`
+if eval "test \"\${ac_cv_prog_make_${ac_make}_set+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.make <<\_ACEOF
+all:
+	@echo 'ac_maketemp="$(MAKE)"'
+_ACEOF
+# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+eval `${MAKE-make} -f conftest.make 2>/dev/null | grep temp=`
+if test -n "$ac_maketemp"; then
+  eval ac_cv_prog_make_${ac_make}_set=yes
+else
+  eval ac_cv_prog_make_${ac_make}_set=no
+fi
+rm -f conftest.make
+fi
+if eval "test \"`echo '$ac_cv_prog_make_'${ac_make}_set`\" = yes"; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  SET_MAKE=
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+  SET_MAKE="MAKE=${MAKE-make}"
+fi
+
+
+echo "$as_me:$LINENO: checking for library containing strerror" >&5
+echo $ECHO_N "checking for library containing strerror... $ECHO_C" >&6
+if test "${ac_cv_search_strerror+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+ac_cv_search_strerror=no
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char strerror ();
+int
+main ()
+{
+strerror ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_strerror="none required"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+if test "$ac_cv_search_strerror" = no; then
+  for ac_lib in cposix; do
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char strerror ();
+int
+main ()
+{
+strerror ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_strerror="-l$ac_lib"
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+  done
+fi
+LIBS=$ac_func_search_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_search_strerror" >&5
+echo "${ECHO_T}$ac_cv_search_strerror" >&6
+if test "$ac_cv_search_strerror" != no; then
+  test "$ac_cv_search_strerror" = "none required" || LIBS="$ac_cv_search_strerror $LIBS"
+
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+echo "$as_me:$LINENO: checking how to run the C preprocessor" >&5
+echo $ECHO_N "checking how to run the C preprocessor... $ECHO_C" >&6
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+  if test "${ac_cv_prog_CPP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+      # Double quotes because CPP needs to be expanded
+    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether non-existent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  # Broken: success on invalid input.
+continue
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  break
+fi
+
+    done
+    ac_cv_prog_CPP=$CPP
+
+fi
+  CPP=$ac_cv_prog_CPP
+else
+  ac_cv_prog_CPP=$CPP
+fi
+echo "$as_me:$LINENO: result: $CPP" >&5
+echo "${ECHO_T}$CPP" >&6
+ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether non-existent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  # Broken: success on invalid input.
+continue
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  :
+else
+  { { echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." >&5
+echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+echo "$as_me:$LINENO: checking for egrep" >&5
+echo $ECHO_N "checking for egrep... $ECHO_C" >&6
+if test "${ac_cv_prog_egrep+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if echo a | (grep -E '(a|b)') >/dev/null 2>&1
+    then ac_cv_prog_egrep='grep -E'
+    else ac_cv_prog_egrep='egrep'
+    fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_egrep" >&5
+echo "${ECHO_T}$ac_cv_prog_egrep" >&6
+ EGREP=$ac_cv_prog_egrep
+
+
+echo "$as_me:$LINENO: checking for ANSI C header files" >&5
+echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6
+if test "${ac_cv_header_stdc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_header_stdc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_header_stdc=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <string.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then
+  :
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ctype.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+		   (('a' <= (c) && (c) <= 'i') \
+		     || ('j' <= (c) && (c) <= 'r') \
+		     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+	|| toupper (i) != TOUPPER (i))
+      exit(2);
+  exit (0);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_header_stdc=no
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
+echo "${ECHO_T}$ac_cv_header_stdc" >&6
+if test $ac_cv_header_stdc = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define STDC_HEADERS 1
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for an ANSI C-conforming const" >&5
+echo $ECHO_N "checking for an ANSI C-conforming const... $ECHO_C" >&6
+if test "${ac_cv_c_const+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+/* FIXME: Include the comments suggested by Paul. */
+#ifndef __cplusplus
+  /* Ultrix mips cc rejects this.  */
+  typedef int charset[2];
+  const charset x;
+  /* SunOS 4.1.1 cc rejects this.  */
+  char const *const *ccp;
+  char **p;
+  /* NEC SVR4.0.2 mips cc rejects this.  */
+  struct point {int x, y;};
+  static struct point const zero = {0,0};
+  /* AIX XL C 1.02.0.0 rejects this.
+     It does not let you subtract one const X* pointer from another in
+     an arm of an if-expression whose if-part is not a constant
+     expression */
+  const char *g = "string";
+  ccp = &g + (g ? g-g : 0);
+  /* HPUX 7.0 cc rejects these. */
+  ++ccp;
+  p = (char**) ccp;
+  ccp = (char const *const *) p;
+  { /* SCO 3.2v4 cc rejects this.  */
+    char *t;
+    char const *s = 0 ? (char *) 0 : (char const *) 0;
+
+    *t++ = 0;
+  }
+  { /* Someone thinks the Sun supposedly-ANSI compiler will reject this.  */
+    int x[] = {25, 17};
+    const int *foo = &x[0];
+    ++foo;
+  }
+  { /* Sun SC1.0 ANSI compiler rejects this -- but not the above. */
+    typedef const int *iptr;
+    iptr p = 0;
+    ++p;
+  }
+  { /* AIX XL C 1.02.0.0 rejects this saying
+       "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
+    struct s { int j; const int *ap[3]; };
+    struct s *b; b->j = 5;
+  }
+  { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
+    const int foo = 10;
+  }
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_const=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_c_const=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_const" >&5
+echo "${ECHO_T}$ac_cv_c_const" >&6
+if test $ac_cv_c_const = no; then
+
+cat >>confdefs.h <<\_ACEOF
+#define const
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for inline" >&5
+echo $ECHO_N "checking for inline... $ECHO_C" >&6
+if test "${ac_cv_c_inline+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_c_inline=no
+for ac_kw in inline __inline__ __inline; do
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifndef __cplusplus
+typedef int foo_t;
+static $ac_kw foo_t static_foo () {return 0; }
+$ac_kw foo_t foo () {return 0; }
+#endif
+
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_inline=$ac_kw; break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+done
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_inline" >&5
+echo "${ECHO_T}$ac_cv_c_inline" >&6
+
+
+case $ac_cv_c_inline in
+  inline | yes) ;;
+  *)
+    case $ac_cv_c_inline in
+      no) ac_val=;;
+      *) ac_val=$ac_cv_c_inline;;
+    esac
+    cat >>confdefs.h <<_ACEOF
+#ifndef __cplusplus
+#define inline $ac_val
+#endif
+_ACEOF
+    ;;
+esac
+
+# On IRIX 5.3, sys/types and inttypes.h are conflicting.
+
+
+
+
+
+
+
+
+
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+		  inttypes.h stdint.h unistd.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_Header=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_Header=no"
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+echo "$as_me:$LINENO: checking for off_t" >&5
+echo $ECHO_N "checking for off_t... $ECHO_C" >&6
+if test "${ac_cv_type_off_t+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if ((off_t *) 0)
+  return 0;
+if (sizeof (off_t))
+  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_off_t=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_off_t=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_off_t" >&5
+echo "${ECHO_T}$ac_cv_type_off_t" >&6
+if test $ac_cv_type_off_t = yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define off_t long
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for size_t" >&5
+echo $ECHO_N "checking for size_t... $ECHO_C" >&6
+if test "${ac_cv_type_size_t+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if ((size_t *) 0)
+  return 0;
+if (sizeof (size_t))
+  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_size_t=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_size_t=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_size_t" >&5
+echo "${ECHO_T}$ac_cv_type_size_t" >&6
+if test $ac_cv_type_size_t = yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define size_t unsigned
+_ACEOF
+
+fi
+
+# The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
+# for constant arguments.  Useless!
+echo "$as_me:$LINENO: checking for working alloca.h" >&5
+echo $ECHO_N "checking for working alloca.h... $ECHO_C" >&6
+if test "${ac_cv_working_alloca_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <alloca.h>
+int
+main ()
+{
+char *p = (char *) alloca (2 * sizeof (int));
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_working_alloca_h=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_working_alloca_h=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_working_alloca_h" >&5
+echo "${ECHO_T}$ac_cv_working_alloca_h" >&6
+if test $ac_cv_working_alloca_h = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_ALLOCA_H 1
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for alloca" >&5
+echo $ECHO_N "checking for alloca... $ECHO_C" >&6
+if test "${ac_cv_func_alloca_works+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __GNUC__
+# define alloca __builtin_alloca
+#else
+# ifdef _MSC_VER
+#  include <malloc.h>
+#  define alloca _alloca
+# else
+#  if HAVE_ALLOCA_H
+#   include <alloca.h>
+#  else
+#   ifdef _AIX
+ #pragma alloca
+#   else
+#    ifndef alloca /* predefined by HP cc +Olibcalls */
+char *alloca ();
+#    endif
+#   endif
+#  endif
+# endif
+#endif
+
+int
+main ()
+{
+char *p = (char *) alloca (1);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_alloca_works=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_func_alloca_works=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_alloca_works" >&5
+echo "${ECHO_T}$ac_cv_func_alloca_works" >&6
+
+if test $ac_cv_func_alloca_works = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_ALLOCA 1
+_ACEOF
+
+else
+  # The SVR3 libPW and SVR4 libucb both contain incompatible functions
+# that cause trouble.  Some versions do not even contain alloca or
+# contain a buggy version.  If you still want to use their alloca,
+# use ar to extract alloca.o from them instead of compiling alloca.c.
+
+ALLOCA=alloca.$ac_objext
+
+cat >>confdefs.h <<\_ACEOF
+#define C_ALLOCA 1
+_ACEOF
+
+
+echo "$as_me:$LINENO: checking whether \`alloca.c' needs Cray hooks" >&5
+echo $ECHO_N "checking whether \`alloca.c' needs Cray hooks... $ECHO_C" >&6
+if test "${ac_cv_os_cray+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#if defined(CRAY) && ! defined(CRAY2)
+webecray
+#else
+wenotbecray
+#endif
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "webecray" >/dev/null 2>&1; then
+  ac_cv_os_cray=yes
+else
+  ac_cv_os_cray=no
+fi
+rm -f conftest*
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_os_cray" >&5
+echo "${ECHO_T}$ac_cv_os_cray" >&6
+if test $ac_cv_os_cray = yes; then
+  for ac_func in _getb67 GETB67 getb67; do
+    as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+
+cat >>confdefs.h <<_ACEOF
+#define CRAY_STACKSEG_END $ac_func
+_ACEOF
+
+    break
+fi
+
+  done
+fi
+
+echo "$as_me:$LINENO: checking stack direction for C alloca" >&5
+echo $ECHO_N "checking stack direction for C alloca... $ECHO_C" >&6
+if test "${ac_cv_c_stack_direction+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_c_stack_direction=0
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+int
+find_stack_direction ()
+{
+  static char *addr = 0;
+  auto char dummy;
+  if (addr == 0)
+    {
+      addr = &dummy;
+      return find_stack_direction ();
+    }
+  else
+    return (&dummy > addr) ? 1 : -1;
+}
+
+int
+main ()
+{
+  exit (find_stack_direction () < 0);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_stack_direction=1
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_c_stack_direction=-1
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_stack_direction" >&5
+echo "${ECHO_T}$ac_cv_c_stack_direction" >&6
+
+cat >>confdefs.h <<_ACEOF
+#define STACK_DIRECTION $ac_cv_c_stack_direction
+_ACEOF
+
+
+fi
+
+
+
+for ac_header in stdlib.h unistd.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+for ac_func in getpagesize
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+echo "$as_me:$LINENO: checking for working mmap" >&5
+echo $ECHO_N "checking for working mmap... $ECHO_C" >&6
+if test "${ac_cv_func_mmap_fixed_mapped+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_func_mmap_fixed_mapped=no
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+/* malloc might have been renamed as rpl_malloc. */
+#undef malloc
+
+/* Thanks to Mike Haertel and Jim Avera for this test.
+   Here is a matrix of mmap possibilities:
+	mmap private not fixed
+	mmap private fixed at somewhere currently unmapped
+	mmap private fixed at somewhere already mapped
+	mmap shared not fixed
+	mmap shared fixed at somewhere currently unmapped
+	mmap shared fixed at somewhere already mapped
+   For private mappings, we should verify that changes cannot be read()
+   back from the file, nor mmap's back from the file at a different
+   address.  (There have been systems where private was not correctly
+   implemented like the infamous i386 svr4.0, and systems where the
+   VM page cache was not coherent with the file system buffer cache
+   like early versions of FreeBSD and possibly contemporary NetBSD.)
+   For shared mappings, we should conversely verify that changes get
+   propagated back to all the places they're supposed to be.
+
+   Grep wants private fixed already mapped.
+   The main things grep needs to know about mmap are:
+   * does it exist and is it safe to write into the mmap'd area
+   * how to use it (BSD variants)  */
+
+#include <fcntl.h>
+#include <sys/mman.h>
+
+#if !STDC_HEADERS && !HAVE_STDLIB_H
+char *malloc ();
+#endif
+
+/* This mess was copied from the GNU getpagesize.h.  */
+#if !HAVE_GETPAGESIZE
+/* Assume that all systems that can run configure have sys/param.h.  */
+# if !HAVE_SYS_PARAM_H
+#  define HAVE_SYS_PARAM_H 1
+# endif
+
+# ifdef _SC_PAGESIZE
+#  define getpagesize() sysconf(_SC_PAGESIZE)
+# else /* no _SC_PAGESIZE */
+#  if HAVE_SYS_PARAM_H
+#   include <sys/param.h>
+#   ifdef EXEC_PAGESIZE
+#    define getpagesize() EXEC_PAGESIZE
+#   else /* no EXEC_PAGESIZE */
+#    ifdef NBPG
+#     define getpagesize() NBPG * CLSIZE
+#     ifndef CLSIZE
+#      define CLSIZE 1
+#     endif /* no CLSIZE */
+#    else /* no NBPG */
+#     ifdef NBPC
+#      define getpagesize() NBPC
+#     else /* no NBPC */
+#      ifdef PAGESIZE
+#       define getpagesize() PAGESIZE
+#      endif /* PAGESIZE */
+#     endif /* no NBPC */
+#    endif /* no NBPG */
+#   endif /* no EXEC_PAGESIZE */
+#  else /* no HAVE_SYS_PARAM_H */
+#   define getpagesize() 8192	/* punt totally */
+#  endif /* no HAVE_SYS_PARAM_H */
+# endif /* no _SC_PAGESIZE */
+
+#endif /* no HAVE_GETPAGESIZE */
+
+int
+main ()
+{
+  char *data, *data2, *data3;
+  int i, pagesize;
+  int fd;
+
+  pagesize = getpagesize ();
+
+  /* First, make a file with some known garbage in it. */
+  data = (char *) malloc (pagesize);
+  if (!data)
+    exit (1);
+  for (i = 0; i < pagesize; ++i)
+    *(data + i) = rand ();
+  umask (0);
+  fd = creat ("conftest.mmap", 0600);
+  if (fd < 0)
+    exit (1);
+  if (write (fd, data, pagesize) != pagesize)
+    exit (1);
+  close (fd);
+
+  /* Next, try to mmap the file at a fixed address which already has
+     something else allocated at it.  If we can, also make sure that
+     we see the same garbage.  */
+  fd = open ("conftest.mmap", O_RDWR);
+  if (fd < 0)
+    exit (1);
+  data2 = (char *) malloc (2 * pagesize);
+  if (!data2)
+    exit (1);
+  data2 += (pagesize - ((long) data2 & (pagesize - 1))) & (pagesize - 1);
+  if (data2 != mmap (data2, pagesize, PROT_READ | PROT_WRITE,
+		     MAP_PRIVATE | MAP_FIXED, fd, 0L))
+    exit (1);
+  for (i = 0; i < pagesize; ++i)
+    if (*(data + i) != *(data2 + i))
+      exit (1);
+
+  /* Finally, make sure that changes to the mapped area do not
+     percolate back to the file as seen by read().  (This is a bug on
+     some variants of i386 svr4.0.)  */
+  for (i = 0; i < pagesize; ++i)
+    *(data2 + i) = *(data2 + i) + 1;
+  data3 = (char *) malloc (pagesize);
+  if (!data3)
+    exit (1);
+  if (read (fd, data3, pagesize) != pagesize)
+    exit (1);
+  for (i = 0; i < pagesize; ++i)
+    if (*(data + i) != *(data3 + i))
+      exit (1);
+  close (fd);
+  exit (0);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_mmap_fixed_mapped=yes
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_func_mmap_fixed_mapped=no
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_mmap_fixed_mapped" >&5
+echo "${ECHO_T}$ac_cv_func_mmap_fixed_mapped" >&6
+if test $ac_cv_func_mmap_fixed_mapped = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_MMAP 1
+_ACEOF
+
+fi
+rm -f conftest.mmap
+
+
+
+
+
+
+
+
+
+
+
+for ac_header in argz.h limits.h locale.h nl_types.h malloc.h string.h \
+unistd.h values.h sys/param.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+
+
+
+
+
+
+
+
+for ac_func in getcwd munmap putenv setenv setlocale strchr strcasecmp \
+__argz_count __argz_stringify __argz_next
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+   if test "${ac_cv_func_stpcpy+set}" != "set"; then
+
+for ac_func in stpcpy
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+   fi
+   if test "${ac_cv_func_stpcpy}" = "yes"; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_STPCPY 1
+_ACEOF
+
+   fi
+
+   if test $ac_cv_header_locale_h = yes; then
+    echo "$as_me:$LINENO: checking for LC_MESSAGES" >&5
+echo $ECHO_N "checking for LC_MESSAGES... $ECHO_C" >&6
+if test "${am_cv_val_LC_MESSAGES+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <locale.h>
+int
+main ()
+{
+return LC_MESSAGES
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  am_cv_val_LC_MESSAGES=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+am_cv_val_LC_MESSAGES=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $am_cv_val_LC_MESSAGES" >&5
+echo "${ECHO_T}$am_cv_val_LC_MESSAGES" >&6
+    if test $am_cv_val_LC_MESSAGES = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_LC_MESSAGES 1
+_ACEOF
+
+    fi
+  fi
+   echo "$as_me:$LINENO: checking whether NLS is requested" >&5
+echo $ECHO_N "checking whether NLS is requested... $ECHO_C" >&6
+        # Check whether --enable-nls or --disable-nls was given.
+if test "${enable_nls+set}" = set; then
+  enableval="$enable_nls"
+  USE_NLS=$enableval
+else
+  USE_NLS=yes
+fi;
+    echo "$as_me:$LINENO: result: $USE_NLS" >&5
+echo "${ECHO_T}$USE_NLS" >&6
+
+
+    USE_INCLUDED_LIBINTL=no
+
+        if test "$USE_NLS" = "yes"; then
+      echo "$as_me:$LINENO: checking whether included gettext is requested" >&5
+echo $ECHO_N "checking whether included gettext is requested... $ECHO_C" >&6
+
+# Check whether --with-included-gettext or --without-included-gettext was given.
+if test "${with_included_gettext+set}" = set; then
+  withval="$with_included_gettext"
+  nls_cv_force_use_gnu_gettext=$withval
+else
+  nls_cv_force_use_gnu_gettext=no
+fi;
+      echo "$as_me:$LINENO: result: $nls_cv_force_use_gnu_gettext" >&5
+echo "${ECHO_T}$nls_cv_force_use_gnu_gettext" >&6
+
+      nls_cv_use_gnu_gettext="$nls_cv_force_use_gnu_gettext"
+      if test "$nls_cv_force_use_gnu_gettext" != "yes"; then
+                        		nls_cv_header_intl=
+	nls_cv_header_libgt=
+	CATOBJEXT=
+
+	if test "${ac_cv_header_libintl_h+set}" = set; then
+  echo "$as_me:$LINENO: checking for libintl.h" >&5
+echo $ECHO_N "checking for libintl.h... $ECHO_C" >&6
+if test "${ac_cv_header_libintl_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_libintl_h" >&5
+echo "${ECHO_T}$ac_cv_header_libintl_h" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking libintl.h usability" >&5
+echo $ECHO_N "checking libintl.h usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <libintl.h>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking libintl.h presence" >&5
+echo $ECHO_N "checking libintl.h presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <libintl.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: libintl.h: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: libintl.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: libintl.h: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: libintl.h: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: libintl.h: present but cannot be compiled" >&5
+echo "$as_me: WARNING: libintl.h: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: libintl.h:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: libintl.h:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: libintl.h: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: libintl.h: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: libintl.h:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: libintl.h:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: libintl.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: libintl.h: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: libintl.h: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: libintl.h: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for libintl.h" >&5
+echo $ECHO_N "checking for libintl.h... $ECHO_C" >&6
+if test "${ac_cv_header_libintl_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_header_libintl_h=$ac_header_preproc
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_libintl_h" >&5
+echo "${ECHO_T}$ac_cv_header_libintl_h" >&6
+
+fi
+if test $ac_cv_header_libintl_h = yes; then
+  echo "$as_me:$LINENO: checking for gettext in libc" >&5
+echo $ECHO_N "checking for gettext in libc... $ECHO_C" >&6
+if test "${gt_cv_func_gettext_libc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <libintl.h>
+int
+main ()
+{
+return (int) gettext ("")
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  gt_cv_func_gettext_libc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gt_cv_func_gettext_libc=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $gt_cv_func_gettext_libc" >&5
+echo "${ECHO_T}$gt_cv_func_gettext_libc" >&6
+
+	   if test "$gt_cv_func_gettext_libc" != "yes"; then
+	     echo "$as_me:$LINENO: checking for bindtextdomain in -lintl" >&5
+echo $ECHO_N "checking for bindtextdomain in -lintl... $ECHO_C" >&6
+if test "${ac_cv_lib_intl_bindtextdomain+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lintl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char bindtextdomain ();
+int
+main ()
+{
+bindtextdomain ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_intl_bindtextdomain=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_intl_bindtextdomain=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_intl_bindtextdomain" >&5
+echo "${ECHO_T}$ac_cv_lib_intl_bindtextdomain" >&6
+if test $ac_cv_lib_intl_bindtextdomain = yes; then
+  echo "$as_me:$LINENO: checking for gettext in libintl" >&5
+echo $ECHO_N "checking for gettext in libintl... $ECHO_C" >&6
+if test "${gt_cv_func_gettext_libintl+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+return (int) gettext ("")
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  gt_cv_func_gettext_libintl=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gt_cv_func_gettext_libintl=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $gt_cv_func_gettext_libintl" >&5
+echo "${ECHO_T}$gt_cv_func_gettext_libintl" >&6
+fi
+
+	   fi
+
+	   if test "$gt_cv_func_gettext_libc" = "yes" \
+	      || test "$gt_cv_func_gettext_libintl" = "yes"; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_GETTEXT 1
+_ACEOF
+
+	      # Extract the first word of "msgfmt", so it can be a program name with args.
+set dummy msgfmt; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_MSGFMT+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case "$MSGFMT" in
+  /*)
+  ac_cv_path_MSGFMT="$MSGFMT" # Let the user override the test with a path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if test -z "`$ac_dir/$ac_word -h 2>&1 | grep 'dv '`"; then
+	ac_cv_path_MSGFMT="$ac_dir/$ac_word"
+	break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_MSGFMT" && ac_cv_path_MSGFMT="no"
+  ;;
+esac
+fi
+MSGFMT="$ac_cv_path_MSGFMT"
+if test -n "$MSGFMT"; then
+  echo "$as_me:$LINENO: result: $MSGFMT" >&5
+echo "${ECHO_T}$MSGFMT" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+	      if test "$MSGFMT" != "no"; then
+
+for ac_func in dcgettext
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+		# Extract the first word of "gmsgfmt", so it can be a program name with args.
+set dummy gmsgfmt; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_GMSGFMT+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $GMSGFMT in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_GMSGFMT="$GMSGFMT" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_GMSGFMT="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  test -z "$ac_cv_path_GMSGFMT" && ac_cv_path_GMSGFMT="$MSGFMT"
+  ;;
+esac
+fi
+GMSGFMT=$ac_cv_path_GMSGFMT
+
+if test -n "$GMSGFMT"; then
+  echo "$as_me:$LINENO: result: $GMSGFMT" >&5
+echo "${ECHO_T}$GMSGFMT" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+		# Extract the first word of "xgettext", so it can be a program name with args.
+set dummy xgettext; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_XGETTEXT+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case "$XGETTEXT" in
+  /*)
+  ac_cv_path_XGETTEXT="$XGETTEXT" # Let the user override the test with a path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if test -z "`$ac_dir/$ac_word -h 2>&1 | grep '(HELP)'`"; then
+	ac_cv_path_XGETTEXT="$ac_dir/$ac_word"
+	break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_XGETTEXT" && ac_cv_path_XGETTEXT=":"
+  ;;
+esac
+fi
+XGETTEXT="$ac_cv_path_XGETTEXT"
+if test -n "$XGETTEXT"; then
+  echo "$as_me:$LINENO: result: $XGETTEXT" >&5
+echo "${ECHO_T}$XGETTEXT" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+		cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+extern int _nl_msg_cat_cntr;
+			       return _nl_msg_cat_cntr
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  CATOBJEXT=.gmo
+		   DATADIRNAME=share
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+CATOBJEXT=.mo
+		   DATADIRNAME=lib
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+		INSTOBJEXT=.mo
+	      fi
+	    fi
+
+fi
+
+
+
+
+        if test x"$CATOBJEXT" = x && test -d $srcdir/../intl; then
+	  # Neither gettext nor catgets in included in the C library.
+	  # Fall back on GNU gettext library (assuming it is present).
+	  nls_cv_use_gnu_gettext=yes
+        fi
+      fi
+
+      if test "$nls_cv_use_gnu_gettext" = "yes"; then
+                INTLOBJS="\$(GETTOBJS)"
+        # Extract the first word of "msgfmt", so it can be a program name with args.
+set dummy msgfmt; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_MSGFMT+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case "$MSGFMT" in
+  /*)
+  ac_cv_path_MSGFMT="$MSGFMT" # Let the user override the test with a path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if test -z "`$ac_dir/$ac_word -h 2>&1 | grep 'dv '`"; then
+	ac_cv_path_MSGFMT="$ac_dir/$ac_word"
+	break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_MSGFMT" && ac_cv_path_MSGFMT="msgfmt"
+  ;;
+esac
+fi
+MSGFMT="$ac_cv_path_MSGFMT"
+if test -n "$MSGFMT"; then
+  echo "$as_me:$LINENO: result: $MSGFMT" >&5
+echo "${ECHO_T}$MSGFMT" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+        # Extract the first word of "gmsgfmt", so it can be a program name with args.
+set dummy gmsgfmt; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_GMSGFMT+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $GMSGFMT in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_GMSGFMT="$GMSGFMT" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_GMSGFMT="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  test -z "$ac_cv_path_GMSGFMT" && ac_cv_path_GMSGFMT="$MSGFMT"
+  ;;
+esac
+fi
+GMSGFMT=$ac_cv_path_GMSGFMT
+
+if test -n "$GMSGFMT"; then
+  echo "$as_me:$LINENO: result: $GMSGFMT" >&5
+echo "${ECHO_T}$GMSGFMT" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+        # Extract the first word of "xgettext", so it can be a program name with args.
+set dummy xgettext; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_XGETTEXT+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case "$XGETTEXT" in
+  /*)
+  ac_cv_path_XGETTEXT="$XGETTEXT" # Let the user override the test with a path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if test -z "`$ac_dir/$ac_word -h 2>&1 | grep '(HELP)'`"; then
+	ac_cv_path_XGETTEXT="$ac_dir/$ac_word"
+	break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_XGETTEXT" && ac_cv_path_XGETTEXT=":"
+  ;;
+esac
+fi
+XGETTEXT="$ac_cv_path_XGETTEXT"
+if test -n "$XGETTEXT"; then
+  echo "$as_me:$LINENO: result: $XGETTEXT" >&5
+echo "${ECHO_T}$XGETTEXT" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+	USE_INCLUDED_LIBINTL=yes
+        CATOBJEXT=.gmo
+        INSTOBJEXT=.mo
+        DATADIRNAME=share
+	INTLDEPS='$(top_builddir)/../intl/libintl.a'
+	INTLLIBS=$INTLDEPS
+	LIBS=`echo $LIBS | sed -e 's/-lintl//'`
+        nls_cv_header_intl=libintl.h
+        nls_cv_header_libgt=libgettext.h
+      fi
+
+            if test "$XGETTEXT" != ":"; then
+			if $XGETTEXT --omit-header /dev/null 2> /dev/null; then
+	  : ;
+	else
+	  echo "$as_me:$LINENO: result: found xgettext programs is not GNU xgettext; ignore it" >&5
+echo "${ECHO_T}found xgettext programs is not GNU xgettext; ignore it" >&6
+	  XGETTEXT=":"
+	fi
+      fi
+
+      # We need to process the po/ directory.
+      POSUB=po
+    else
+      DATADIRNAME=share
+      nls_cv_header_intl=libintl.h
+      nls_cv_header_libgt=libgettext.h
+    fi
+
+    # If this is used in GNU gettext we have to set USE_NLS to `yes'
+    # because some of the sources are only built for this goal.
+    if test "$PACKAGE" = gettext; then
+      USE_NLS=yes
+      USE_INCLUDED_LIBINTL=yes
+    fi
+
+                for lang in $ALL_LINGUAS; do
+      GMOFILES="$GMOFILES $lang.gmo"
+      POFILES="$POFILES $lang.po"
+    done
+
+
+
+
+
+
+
+
+
+
+
+
+    if test "x$CATOBJEXT" != "x"; then
+
+cat >>confdefs.h <<\_ACEOF
+#define ENABLE_NLS 1
+_ACEOF
+
+    fi
+
+
+   if test "x$CATOBJEXT" != "x"; then
+     if test "x$ALL_LINGUAS" = "x"; then
+       LINGUAS=
+     else
+       echo "$as_me:$LINENO: checking for catalogs to be installed" >&5
+echo $ECHO_N "checking for catalogs to be installed... $ECHO_C" >&6
+       NEW_LINGUAS=
+       for lang in ${LINGUAS=$ALL_LINGUAS}; do
+         case "$ALL_LINGUAS" in
+          *$lang*) NEW_LINGUAS="$NEW_LINGUAS $lang" ;;
+         esac
+       done
+       LINGUAS=$NEW_LINGUAS
+       echo "$as_me:$LINENO: result: $LINGUAS" >&5
+echo "${ECHO_T}$LINGUAS" >&6
+     fi
+
+          if test -n "$LINGUAS"; then
+       for lang in $LINGUAS; do CATALOGS="$CATALOGS $lang$CATOBJEXT"; done
+     fi
+   fi
+
+            if test $ac_cv_header_locale_h = yes; then
+     INCLUDE_LOCALE_H="#include <locale.h>"
+   else
+     INCLUDE_LOCALE_H="\
+/* The system does not provide the header <locale.h>.  Take care yourself.  */"
+   fi
+
+
+            if test -f $srcdir/po2tbl.sed.in; then
+      if test "$CATOBJEXT" = ".cat"; then
+	 if test "${ac_cv_header_linux_version_h+set}" = set; then
+  echo "$as_me:$LINENO: checking for linux/version.h" >&5
+echo $ECHO_N "checking for linux/version.h... $ECHO_C" >&6
+if test "${ac_cv_header_linux_version_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_linux_version_h" >&5
+echo "${ECHO_T}$ac_cv_header_linux_version_h" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking linux/version.h usability" >&5
+echo $ECHO_N "checking linux/version.h usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <linux/version.h>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking linux/version.h presence" >&5
+echo $ECHO_N "checking linux/version.h presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <linux/version.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: linux/version.h: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: linux/version.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: linux/version.h: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: linux/version.h: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: linux/version.h: present but cannot be compiled" >&5
+echo "$as_me: WARNING: linux/version.h: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: linux/version.h:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: linux/version.h:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: linux/version.h: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: linux/version.h: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: linux/version.h:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: linux/version.h:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: linux/version.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: linux/version.h: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: linux/version.h: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: linux/version.h: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for linux/version.h" >&5
+echo $ECHO_N "checking for linux/version.h... $ECHO_C" >&6
+if test "${ac_cv_header_linux_version_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_header_linux_version_h=$ac_header_preproc
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_linux_version_h" >&5
+echo "${ECHO_T}$ac_cv_header_linux_version_h" >&6
+
+fi
+if test $ac_cv_header_linux_version_h = yes; then
+  msgformat=linux
+else
+  msgformat=xopen
+fi
+
+
+
+	          	 sed -e '/^#/d' $srcdir/$msgformat-msg.sed > po2msg.sed
+      fi
+            sed -e '/^#.*[^\\]$/d' -e '/^#$/d' \
+	 $srcdir/po2tbl.sed.in > po2tbl.sed
+   fi
+
+            if test "$PACKAGE" = "gettext"; then
+     GT_NO="#NO#"
+     GT_YES=
+   else
+     GT_NO=
+     GT_YES="#YES#"
+   fi
+
+
+
+   MKINSTALLDIRS="\$(srcdir)/../../mkinstalldirs"
+
+
+      l=
+
+
+            if test -f $srcdir/po/POTFILES.in; then
+      test -d po || mkdir po
+      if test "x$srcdir" != "x."; then
+	 if test "x`echo $srcdir | sed 's@/.*@@'`" = "x"; then
+	    posrcprefix="$srcdir/"
+	 else
+	    posrcprefix="../$srcdir/"
+	 fi
+      else
+	 posrcprefix="../"
+      fi
+      rm -f po/POTFILES
+      sed -e "/^#/d" -e "/^\$/d" -e "s,.*,	$posrcprefix& \\\\," -e "\$s/\(.*\) \\\\/\1/" \
+	 < $srcdir/po/POTFILES.in > po/POTFILES
+   fi
+
+
+# Check for common headers.
+# FIXME: Seems to me this can cause problems for i386-windows hosts.
+# At one point there were hardcoded AC_DEFINE's if ${host} = i386-*-windows*.
+
+
+
+
+
+for ac_header in stdlib.h string.h strings.h unistd.h time.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+for ac_header in sys/time.h sys/resource.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+for ac_header in fcntl.h fpu_control.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+
+for ac_header in dlfcn.h errno.h sys/stat.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+
+
+for ac_func in getrusage time sigaction __setfpucw
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+# Check for socket libraries
+
+echo "$as_me:$LINENO: checking for bind in -lsocket" >&5
+echo $ECHO_N "checking for bind in -lsocket... $ECHO_C" >&6
+if test "${ac_cv_lib_socket_bind+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsocket  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char bind ();
+int
+main ()
+{
+bind ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_socket_bind=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_socket_bind=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_socket_bind" >&5
+echo "${ECHO_T}$ac_cv_lib_socket_bind" >&6
+if test $ac_cv_lib_socket_bind = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBSOCKET 1
+_ACEOF
+
+  LIBS="-lsocket $LIBS"
+
+fi
+
+
+echo "$as_me:$LINENO: checking for gethostbyname in -lnsl" >&5
+echo $ECHO_N "checking for gethostbyname in -lnsl... $ECHO_C" >&6
+if test "${ac_cv_lib_nsl_gethostbyname+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lnsl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char gethostbyname ();
+int
+main ()
+{
+gethostbyname ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_nsl_gethostbyname=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_nsl_gethostbyname=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_gethostbyname" >&5
+echo "${ECHO_T}$ac_cv_lib_nsl_gethostbyname" >&6
+if test $ac_cv_lib_nsl_gethostbyname = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBNSL 1
+_ACEOF
+
+  LIBS="-lnsl $LIBS"
+
+fi
+
+
+. ${srcdir}/../../bfd/configure.host
+
+
+
+USE_MAINTAINER_MODE=no
+# Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.
+if test "${enable_maintainer_mode+set}" = set; then
+  enableval="$enable_maintainer_mode"
+  case "${enableval}" in
+  yes)	MAINT="" USE_MAINTAINER_MODE=yes ;;
+  no)	MAINT="#" ;;
+  *)	{ { echo "$as_me:$LINENO: error: \"--enable-maintainer-mode does not take a value\"" >&5
+echo "$as_me: error: \"--enable-maintainer-mode does not take a value\"" >&2;}
+   { (exit 1); exit 1; }; }; MAINT="#" ;;
+esac
+if test x"$silent" != x"yes" && test x"$MAINT" = x""; then
+  echo "Setting maintainer mode" 6>&1
+fi
+else
+  MAINT="#"
+fi;
+
+
+# Check whether --enable-sim-bswap or --disable-sim-bswap was given.
+if test "${enable_sim_bswap+set}" = set; then
+  enableval="$enable_sim_bswap"
+  case "${enableval}" in
+  yes)	sim_bswap="-DWITH_BSWAP=1 -DUSE_BSWAP=1";;
+  no)	sim_bswap="-DWITH_BSWAP=0";;
+  *)	{ { echo "$as_me:$LINENO: error: \"--enable-sim-bswap does not take a value\"" >&5
+echo "$as_me: error: \"--enable-sim-bswap does not take a value\"" >&2;}
+   { (exit 1); exit 1; }; }; sim_bswap="";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_bswap" != x""; then
+  echo "Setting bswap flags = $sim_bswap" 6>&1
+fi
+else
+  sim_bswap=""
+fi;
+
+
+# Check whether --enable-sim-cflags or --disable-sim-cflags was given.
+if test "${enable_sim_cflags+set}" = set; then
+  enableval="$enable_sim_cflags"
+  case "${enableval}" in
+  yes)	 sim_cflags="-O2 -fomit-frame-pointer";;
+  trace) { { echo "$as_me:$LINENO: error: \"Please use --enable-sim-debug instead.\"" >&5
+echo "$as_me: error: \"Please use --enable-sim-debug instead.\"" >&2;}
+   { (exit 1); exit 1; }; }; sim_cflags="";;
+  no)	 sim_cflags="";;
+  *)	 sim_cflags=`echo "${enableval}" | sed -e "s/,/ /g"`;;
+esac
+if test x"$silent" != x"yes" && test x"$sim_cflags" != x""; then
+  echo "Setting sim cflags = $sim_cflags" 6>&1
+fi
+else
+  sim_cflags=""
+fi;
+
+
+# Check whether --enable-sim-debug or --disable-sim-debug was given.
+if test "${enable_sim_debug+set}" = set; then
+  enableval="$enable_sim_debug"
+  case "${enableval}" in
+  yes) sim_debug="-DDEBUG=7 -DWITH_DEBUG=7";;
+  no)  sim_debug="-DDEBUG=0 -DWITH_DEBUG=0";;
+  *)   sim_debug="-DDEBUG='(${enableval})' -DWITH_DEBUG='(${enableval})'";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_debug" != x""; then
+  echo "Setting sim debug = $sim_debug" 6>&1
+fi
+else
+  sim_debug=""
+fi;
+
+
+# Check whether --enable-sim-stdio or --disable-sim-stdio was given.
+if test "${enable_sim_stdio+set}" = set; then
+  enableval="$enable_sim_stdio"
+  case "${enableval}" in
+  yes)	sim_stdio="-DWITH_STDIO=DO_USE_STDIO";;
+  no)	sim_stdio="-DWITH_STDIO=DONT_USE_STDIO";;
+  *)	{ { echo "$as_me:$LINENO: error: \"Unknown value $enableval passed to --enable-sim-stdio\"" >&5
+echo "$as_me: error: \"Unknown value $enableval passed to --enable-sim-stdio\"" >&2;}
+   { (exit 1); exit 1; }; }; sim_stdio="";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_stdio" != x""; then
+  echo "Setting stdio flags = $sim_stdio" 6>&1
+fi
+else
+  sim_stdio=""
+fi;
+
+
+# Check whether --enable-sim-trace or --disable-sim-trace was given.
+if test "${enable_sim_trace+set}" = set; then
+  enableval="$enable_sim_trace"
+  case "${enableval}" in
+  yes)	sim_trace="-DTRACE=1 -DWITH_TRACE=-1";;
+  no)	sim_trace="-DTRACE=0 -DWITH_TRACE=0";;
+  [-0-9]*)
+	sim_trace="-DTRACE='(${enableval})' -DWITH_TRACE='(${enableval})'";;
+  [a-z]*)
+	sim_trace=""
+	for x in `echo "$enableval" | sed -e "s/,/ /g"`; do
+	  if test x"$sim_trace" = x; then
+	    sim_trace="-DWITH_TRACE='(TRACE_$x"
+	  else
+	    sim_trace="${sim_trace}|TRACE_$x"
+	  fi
+	done
+	sim_trace="$sim_trace)'" ;;
+esac
+if test x"$silent" != x"yes" && test x"$sim_trace" != x""; then
+  echo "Setting sim trace = $sim_trace" 6>&1
+fi
+else
+  sim_trace=""
+fi;
+
+
+# Check whether --enable-sim-profile or --disable-sim-profile was given.
+if test "${enable_sim_profile+set}" = set; then
+  enableval="$enable_sim_profile"
+  case "${enableval}" in
+  yes)	sim_profile="-DPROFILE=1 -DWITH_PROFILE=-1";;
+  no)	sim_profile="-DPROFILE=0 -DWITH_PROFILE=0";;
+  [-0-9]*)
+	sim_profile="-DPROFILE='(${enableval})' -DWITH_PROFILE='(${enableval})'";;
+  [a-z]*)
+	sim_profile=""
+	for x in `echo "$enableval" | sed -e "s/,/ /g"`; do
+	  if test x"$sim_profile" = x; then
+	    sim_profile="-DWITH_PROFILE='(PROFILE_$x"
+	  else
+	    sim_profile="${sim_profile}|PROFILE_$x"
+	  fi
+	done
+	sim_profile="$sim_profile)'" ;;
+esac
+if test x"$silent" != x"yes" && test x"$sim_profile" != x""; then
+  echo "Setting sim profile = $sim_profile" 6>&1
+fi
+else
+  sim_profile="-DPROFILE=1 -DWITH_PROFILE=-1"
+fi;
+
+
+echo "$as_me:$LINENO: checking return type of signal handlers" >&5
+echo $ECHO_N "checking return type of signal handlers... $ECHO_C" >&6
+if test "${ac_cv_type_signal+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <signal.h>
+#ifdef signal
+# undef signal
+#endif
+#ifdef __cplusplus
+extern "C" void (*signal (int, void (*)(int)))(int);
+#else
+void (*signal ()) ();
+#endif
+
+int
+main ()
+{
+int i;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_signal=void
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_signal=int
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_signal" >&5
+echo "${ECHO_T}$ac_cv_type_signal" >&6
+
+cat >>confdefs.h <<_ACEOF
+#define RETSIGTYPE $ac_cv_type_signal
+_ACEOF
+
+
+
+
+
+sim_link_files=
+sim_link_links=
+
+sim_link_links=tconfig.h
+if test -f ${srcdir}/tconfig.in
+then
+  sim_link_files=tconfig.in
+else
+  sim_link_files=../common/tconfig.in
+fi
+
+# targ-vals.def points to the libc macro description file.
+case "${target}" in
+*-*-*) TARG_VALS_DEF=../common/nltvals.def ;;
+esac
+sim_link_files="${sim_link_files} ${TARG_VALS_DEF}"
+sim_link_links="${sim_link_links} targ-vals.def"
+
+
+
+default_sim_inline=""
+# Check whether --enable-sim-inline or --disable-sim-inline was given.
+if test "${enable_sim_inline+set}" = set; then
+  enableval="$enable_sim_inline"
+  sim_inline=""
+case "$enableval" in
+  no)		sim_inline="-DDEFAULT_INLINE=0";;
+  0)		sim_inline="-DDEFAULT_INLINE=0";;
+  yes | 2)	sim_inline="-DDEFAULT_INLINE=ALL_C_INLINE";;
+  1)		sim_inline="-DDEFAULT_INLINE=INLINE_LOCALS";;
+  *) for x in `echo "$enableval" | sed -e "s/,/ /g"`; do
+       new_flag=""
+       case "$x" in
+	 *_INLINE=*)	new_flag="-D$x";;
+	 *=*)		new_flag=`echo "$x" | sed -e "s/=/_INLINE=/" -e "s/^/-D/"`;;
+	 *_INLINE)	new_flag="-D$x=ALL_C_INLINE";;
+	 *)		new_flag="-D$x""_INLINE=ALL_C_INLINE";;
+       esac
+       if test x"$sim_inline" = x""; then
+	 sim_inline="$new_flag"
+       else
+	 sim_inline="$sim_inline $new_flag"
+       fi
+     done;;
+esac
+if test x"$silent" != x"yes" && test x"$sim_inline" != x""; then
+  echo "Setting inline flags = $sim_inline" 6>&1
+fi
+else
+
+if test "x$cross_compiling" = "xno"; then
+  if test x"$GCC" != "x" -a x"${default_sim_inline}" != "x" ; then
+    sim_inline="${default_sim_inline}"
+    if test x"$silent" != x"yes"; then
+      echo "Setting inline flags = $sim_inline" 6>&1
+    fi
+  else
+    sim_inline=""
+  fi
+else
+  sim_inline="-DDEFAULT_INLINE=0"
+fi
+fi;
+wire_alignment="NONSTRICT_ALIGNMENT"
+default_alignment=""
+
+# Check whether --enable-sim-alignment or --disable-sim-alignment was given.
+if test "${enable_sim_alignment+set}" = set; then
+  enableval="$enable_sim_alignment"
+  case "${enableval}" in
+  strict | STRICT)       sim_alignment="-DWITH_ALIGNMENT=STRICT_ALIGNMENT";;
+  nonstrict | NONSTRICT) sim_alignment="-DWITH_ALIGNMENT=NONSTRICT_ALIGNMENT";;
+  forced | FORCED)       sim_alignment="-DWITH_ALIGNMENT=FORCED_ALIGNMENT";;
+  yes) if test x"$wire_alignment" != x; then
+	 sim_alignment="-DWITH_ALIGNMENT=${wire_alignment}"
+       else
+         if test x"$default_alignment" != x; then
+           sim_alignment="-DWITH_ALIGNMENT=${default_alignment}"
+         else
+	   echo "No hard-wired alignment for target $target" 1>&6
+	   sim_alignment="-DWITH_ALIGNMENT=0"
+         fi
+       fi;;
+  no)  if test x"$default_alignment" != x; then
+	 sim_alignment="-DWITH_DEFAULT_ALIGNMENT=${default_alignment}"
+       else
+         if test x"$wire_alignment" != x; then
+	   sim_alignment="-DWITH_DEFAULT_ALIGNMENT=${wire_alignment}"
+         else
+           echo "No default alignment for target $target" 1>&6
+           sim_alignment="-DWITH_DEFAULT_ALIGNMENT=0"
+         fi
+       fi;;
+  *)   { { echo "$as_me:$LINENO: error: \"Unknown value $enableval passed to --enable-sim-alignment\"" >&5
+echo "$as_me: error: \"Unknown value $enableval passed to --enable-sim-alignment\"" >&2;}
+   { (exit 1); exit 1; }; }; sim_alignment="";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_alignment" != x""; then
+  echo "Setting alignment flags = $sim_alignment" 6>&1
+fi
+else
+  if test x"$default_alignment" != x; then
+  sim_alignment="-DWITH_DEFAULT_ALIGNMENT=${default_alignment}"
+else
+  if test x"$wire_alignment" != x; then
+    sim_alignment="-DWITH_ALIGNMENT=${wire_alignment}"
+  else
+    sim_alignment=
+  fi
+fi
+fi;
+
+# Check whether --enable-sim-hostendian or --disable-sim-hostendian was given.
+if test "${enable_sim_hostendian+set}" = set; then
+  enableval="$enable_sim_hostendian"
+  case "${enableval}" in
+  no)	 sim_hostendian="-DWITH_HOST_BYTE_ORDER=0";;
+  b*|B*) sim_hostendian="-DWITH_HOST_BYTE_ORDER=BIG_ENDIAN";;
+  l*|L*) sim_hostendian="-DWITH_HOST_BYTE_ORDER=LITTLE_ENDIAN";;
+  *)	 { { echo "$as_me:$LINENO: error: \"Unknown value $enableval for --enable-sim-hostendian\"" >&5
+echo "$as_me: error: \"Unknown value $enableval for --enable-sim-hostendian\"" >&2;}
+   { (exit 1); exit 1; }; }; sim_hostendian="";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_hostendian" != x""; then
+  echo "Setting hostendian flags = $sim_hostendian" 6>&1
+fi
+else
+
+if test "x$cross_compiling" = "xno"; then
+  echo "$as_me:$LINENO: checking whether byte ordering is bigendian" >&5
+echo $ECHO_N "checking whether byte ordering is bigendian... $ECHO_C" >&6
+if test "${ac_cv_c_bigendian+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  # See if sys/param.h defines the BYTE_ORDER macro.
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/param.h>
+
+int
+main ()
+{
+#if !BYTE_ORDER || !BIG_ENDIAN || !LITTLE_ENDIAN
+ bogus endian macros
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  # It does; now see whether it defined to BIG_ENDIAN or not.
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/param.h>
+
+int
+main ()
+{
+#if BYTE_ORDER != BIG_ENDIAN
+ not big endian
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_bigendian=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_c_bigendian=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+# It does not; compile a test program.
+if test "$cross_compiling" = yes; then
+  # try to guess the endianness by grepping values into an object file
+  ac_cv_c_bigendian=unknown
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+short ascii_mm[] = { 0x4249, 0x4765, 0x6E44, 0x6961, 0x6E53, 0x7953, 0 };
+short ascii_ii[] = { 0x694C, 0x5454, 0x656C, 0x6E45, 0x6944, 0x6E61, 0 };
+void _ascii () { char *s = (char *) ascii_mm; s = (char *) ascii_ii; }
+short ebcdic_ii[] = { 0x89D3, 0xE3E3, 0x8593, 0x95C5, 0x89C4, 0x9581, 0 };
+short ebcdic_mm[] = { 0xC2C9, 0xC785, 0x95C4, 0x8981, 0x95E2, 0xA8E2, 0 };
+void _ebcdic () { char *s = (char *) ebcdic_mm; s = (char *) ebcdic_ii; }
+int
+main ()
+{
+ _ascii (); _ebcdic ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  if grep BIGenDianSyS conftest.$ac_objext >/dev/null ; then
+  ac_cv_c_bigendian=yes
+fi
+if grep LiTTleEnDian conftest.$ac_objext >/dev/null ; then
+  if test "$ac_cv_c_bigendian" = unknown; then
+    ac_cv_c_bigendian=no
+  else
+    # finding both strings is unlikely to happen, but who knows?
+    ac_cv_c_bigendian=unknown
+  fi
+fi
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+int
+main ()
+{
+  /* Are we little or big endian?  From Harbison&Steele.  */
+  union
+  {
+    long l;
+    char c[sizeof (long)];
+  } u;
+  u.l = 1;
+  exit (u.c[sizeof (long) - 1] == 1);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_bigendian=no
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_c_bigendian=yes
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_bigendian" >&5
+echo "${ECHO_T}$ac_cv_c_bigendian" >&6
+case $ac_cv_c_bigendian in
+  yes)
+
+cat >>confdefs.h <<\_ACEOF
+#define WORDS_BIGENDIAN 1
+_ACEOF
+ ;;
+  no)
+     ;;
+  *)
+    { { echo "$as_me:$LINENO: error: unknown endianness
+presetting ac_cv_c_bigendian=no (or yes) will help" >&5
+echo "$as_me: error: unknown endianness
+presetting ac_cv_c_bigendian=no (or yes) will help" >&2;}
+   { (exit 1); exit 1; }; } ;;
+esac
+
+  if test $ac_cv_c_bigendian = yes; then
+    sim_hostendian="-DWITH_HOST_BYTE_ORDER=BIG_ENDIAN"
+  else
+    sim_hostendian="-DWITH_HOST_BYTE_ORDER=LITTLE_ENDIAN"
+  fi
+else
+  sim_hostendian="-DWITH_HOST_BYTE_ORDER=0"
+fi
+fi;
+
+# NOTE: Don't add -Wall or -Wunused, they both include
+# -Wunused-parameter which reports bogus warnings.
+# NOTE: If you add to this list, remember to update
+# gdb/doc/gdbint.texinfo.
+build_warnings="-Wimplicit -Wreturn-type -Wcomment -Wtrigraphs \
+-Wformat -Wparentheses -Wpointer-arith"
+# GCC supports -Wuninitialized only with -O or -On, n != 0.
+if test x${CFLAGS+set} = xset; then
+  case "${CFLAGS}" in
+    *"-O0"* ) ;;
+    *"-O"* )
+      build_warnings="${build_warnings} -Wuninitialized"
+    ;;
+  esac
+else
+  build_warnings="${build_warnings} -Wuninitialized"
+fi
+# Up for debate: -Wswitch -Wcomment -trigraphs -Wtrigraphs
+# -Wunused-function -Wunused-label -Wunused-variable -Wunused-value
+# -Wchar-subscripts -Wtraditional -Wshadow -Wcast-qual
+# -Wcast-align -Wwrite-strings -Wconversion -Wstrict-prototypes
+# -Wmissing-prototypes -Wmissing-declarations -Wredundant-decls
+# -Woverloaded-virtual -Winline -Werror"
+# Check whether --enable-build-warnings or --disable-build-warnings was given.
+if test "${enable_build_warnings+set}" = set; then
+  enableval="$enable_build_warnings"
+  case "${enableval}" in
+  yes)	;;
+  no)	build_warnings="-w";;
+  ,*)   t=`echo "${enableval}" | sed -e "s/,/ /g"`
+        build_warnings="${build_warnings} ${t}";;
+  *,)   t=`echo "${enableval}" | sed -e "s/,/ /g"`
+        build_warnings="${t} ${build_warnings}";;
+  *)    build_warnings=`echo "${enableval}" | sed -e "s/,/ /g"`;;
+esac
+if test x"$silent" != x"yes" && test x"$build_warnings" != x""; then
+  echo "Setting compiler warning flags = $build_warnings" 6>&1
+fi
+fi; # Check whether --enable-sim-build-warnings or --disable-sim-build-warnings was given.
+if test "${enable_sim_build_warnings+set}" = set; then
+  enableval="$enable_sim_build_warnings"
+  case "${enableval}" in
+  yes)	;;
+  no)	build_warnings="-w";;
+  ,*)   t=`echo "${enableval}" | sed -e "s/,/ /g"`
+        build_warnings="${build_warnings} ${t}";;
+  *,)   t=`echo "${enableval}" | sed -e "s/,/ /g"`
+        build_warnings="${t} ${build_warnings}";;
+  *)    build_warnings=`echo "${enableval}" | sed -e "s/,/ /g"`;;
+esac
+if test x"$silent" != x"yes" && test x"$build_warnings" != x""; then
+  echo "Setting GDB specific compiler warning flags = $build_warnings" 6>&1
+fi
+fi; WARN_CFLAGS=""
+WERROR_CFLAGS=""
+if test "x${build_warnings}" != x -a "x$GCC" = xyes
+then
+    echo "$as_me:$LINENO: checking compiler warning flags" >&5
+echo $ECHO_N "checking compiler warning flags... $ECHO_C" >&6
+    # Separate out the -Werror flag as some files just cannot be
+    # compiled with it enabled.
+    for w in ${build_warnings}; do
+	case $w in
+	-Werr*) WERROR_CFLAGS=-Werror ;;
+	*) # Check that GCC accepts it
+	    saved_CFLAGS="$CFLAGS"
+	    CFLAGS="$CFLAGS $w"
+	    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  WARN_CFLAGS="${WARN_CFLAGS} $w"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+	    CFLAGS="$saved_CFLAGS"
+	esac
+    done
+    echo "$as_me:$LINENO: result: ${WARN_CFLAGS}${WERROR_CFLAGS}" >&5
+echo "${ECHO_T}${WARN_CFLAGS}${WERROR_CFLAGS}" >&6
+fi
+
+
+default_sim_reserved_bits="1"
+# Check whether --enable-sim-reserved-bits or --disable-sim-reserved-bits was given.
+if test "${enable_sim_reserved_bits+set}" = set; then
+  enableval="$enable_sim_reserved_bits"
+  case "${enableval}" in
+  yes)	sim_reserved_bits="-DWITH_RESERVED_BITS=1";;
+  no)	sim_reserved_bits="-DWITH_RESERVED_BITS=0";;
+  *)	{ { echo "$as_me:$LINENO: error: \"--enable-sim-reserved-bits does not take a value\"" >&5
+echo "$as_me: error: \"--enable-sim-reserved-bits does not take a value\"" >&2;}
+   { (exit 1); exit 1; }; }; sim_reserved_bits="";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_reserved_bits" != x""; then
+  echo "Setting reserved flags = $sim_reserved_bits" 6>&1
+fi
+else
+  sim_reserved_bits="-DWITH_RESERVED_BITS=${default_sim_reserved_bits}"
+fi;
+
+# DEPRECATED
+#
+# Instead of defining a `subtarget' macro, code should be checking
+# the value of {STATE,CPU}_ARCHITECTURE to identify the architecture
+# in question.
+#
+case "${target}" in
+  brownie3264vr*-*-*)	SIM_SUBTARGET="-DTARGET_ENABLE_FR=1" ;;
+  brownie32*tx39*)           SIM_SUBTARGET="-DSUBTARGET_R3900=1";;
+  brownie32isa32*-*-*)       SIM_SUBTARGET="-DTARGET_ENABLE_FR=1";;
+  brownie32isa64*-*-*)       SIM_SUBTARGET="-DTARGET_ENABLE_FR=1";;
+  *)                    SIM_SUBTARGET="";;
+esac
+
+
+
+
+#
+# Select the byte order of the target
+#
+brownie32_endian=
+default_endian=
+case "${target}" in
+  brownie3264el*-*-*)	brownie32_endian=LITTLE_ENDIAN ;;
+  brownie3264vr*el-*-*)      default_endian=LITTLE_ENDIAN ;;
+  brownie3264*-*-*)          default_endian=BIG_ENDIAN ;;
+  brownie3216*-*-*)          default_endian=BIG_ENDIAN ;;
+  brownie32isa32*-*-*)       default_endian=BIG_ENDIAN ;;
+  brownie32isa64*-*-*)       default_endian=BIG_ENDIAN ;;
+  brownie32*-*-*)            default_endian=BIG_ENDIAN ;;
+  *)                    default_endian=BIG_ENDIAN ;;
+esac
+
+wire_endian="$brownie32_endian"
+default_endian="$default_endian"
+# Check whether --enable-sim-endian or --disable-sim-endian was given.
+if test "${enable_sim_endian+set}" = set; then
+  enableval="$enable_sim_endian"
+  case "${enableval}" in
+  b*|B*) sim_endian="-DWITH_TARGET_BYTE_ORDER=BIG_ENDIAN";;
+  l*|L*) sim_endian="-DWITH_TARGET_BYTE_ORDER=LITTLE_ENDIAN";;
+  yes)	 if test x"$wire_endian" != x; then
+	   sim_endian="-DWITH_TARGET_BYTE_ORDER=${wire_endian}"
+	 else
+           if test x"$default_endian" != x; then
+	     sim_endian="-DWITH_TARGET_BYTE_ORDER=${default_endian}"
+	   else
+	     echo "No hard-wired endian for target $target" 1>&6
+	     sim_endian="-DWITH_TARGET_BYTE_ORDER=0"
+	   fi
+	 fi;;
+  no)	 if test x"$default_endian" != x; then
+	   sim_endian="-DWITH_DEFAULT_TARGET_BYTE_ORDER=${default_endian}"
+	 else
+	   if test x"$wire_endian" != x; then
+	     sim_endian="-DWITH_DEFAULT_TARGET_BYTE_ORDER=${wire_endian}"
+	   else
+	     echo "No default endian for target $target" 1>&6
+	     sim_endian="-DWITH_DEFAULT_TARGET_BYTE_ORDER=0"
+	   fi
+	 fi;;
+  *)	 { { echo "$as_me:$LINENO: error: \"Unknown value $enableval for --enable-sim-endian\"" >&5
+echo "$as_me: error: \"Unknown value $enableval for --enable-sim-endian\"" >&2;}
+   { (exit 1); exit 1; }; }; sim_endian="";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_endian" != x""; then
+  echo "Setting endian flags = $sim_endian" 6>&1
+fi
+else
+  if test x"$default_endian" != x; then
+  sim_endian="-DWITH_DEFAULT_TARGET_BYTE_ORDER=${default_endian}"
+else
+  if test x"$wire_endian" != x; then
+    sim_endian="-DWITH_TARGET_BYTE_ORDER=${wire_endian}"
+  else
+    sim_endian=
+  fi
+fi
+fi;
+
+
+
+#
+# Select the bitsize of the target
+#
+brownie32_addr_bitsize=
+case "${target}" in
+  brownie3264*-*-*)          brownie32_bitsize=64 ; brownie32_msb=63 ;;
+  brownie3216*-*-*)          brownie32_bitsize=64 ; brownie32_msb=63 ;;
+  brownie32isa32*-*-*)       brownie32_bitsize=32 ; brownie32_msb=31 ;;
+  brownie32isa64*-*-*)       brownie32_bitsize=64 ; brownie32_msb=63 ;;
+  brownie32*-*-*)            brownie32_bitsize=32 ; brownie32_msb=31 ;;
+  *)                    brownie32_bitsize=64 ; brownie32_msb=63 ;;
+esac
+wire_word_bitsize="$brownie32_bitsize"
+wire_word_msb="$brownie32_msb"
+wire_address_bitsize="$brownie32_addr_bitsize"
+wire_cell_bitsize=""
+# Check whether --enable-sim-bitsize or --disable-sim-bitsize was given.
+if test "${enable_sim_bitsize+set}" = set; then
+  enableval="$enable_sim_bitsize"
+  sim_bitsize=
+case "${enableval}" in
+  64,63 | 64,63,* ) sim_bitsize="-DWITH_TARGET_WORD_BITSIZE=64 -DWITH_TARGET_WORD_MSB=63";;
+  32,31 | 32,31,* ) sim_bitsize="-DWITH_TARGET_WORD_BITSIZE=32 -DWITH_TARGET_WORD_MSB=31";;
+  64,0 | 64,0,* ) sim_bitsize="-DWITH_TARGET_WORD_BITSIZE=32 -DWITH_TARGET_WORD_MSB=0";;
+  32,0 | 64,0,* ) sim_bitsize="-DWITH_TARGET_WORD_BITSIZE=32 -DWITH_TARGET_WORD_MSB=0";;
+  32) if test x"$wire_word_msb" != x -a x"$wire_word_msb" != x0; then
+        sim_bitsize="-DWITH_TARGET_WORD_BITSIZE=32 -DWITH_TARGET_WORD_MSB=31"
+      else
+        sim_bitsize="-DWITH_TARGET_WORD_BITSIZE=32 -DWITH_TARGET_WORD_MSB=0"
+      fi ;;
+  64) if test x"$wire_word_msb" != x -a x"$wire_word_msb" != x0; then
+        sim_bitsize="-DWITH_TARGET_WORD_BITSIZE=64 -DWITH_TARGET_WORD_MSB=63"
+      else
+        sim_bitsize="-DWITH_TARGET_WORD_BITSIZE=64 -DWITH_TARGET_WORD_MSB=0"
+      fi ;;
+  *)  { { echo "$as_me:$LINENO: error: \"--enable-sim-bitsize was given $enableval.  Expected 32 or 64\"" >&5
+echo "$as_me: error: \"--enable-sim-bitsize was given $enableval.  Expected 32 or 64\"" >&2;}
+   { (exit 1); exit 1; }; } ;;
+esac
+# address bitsize
+tmp=`echo "${enableval}" | sed -e "s/^[0-9]*,*[0-9]*,*//"`
+case x"${tmp}" in
+  x ) ;;
+  x32 | x32,* ) sim_bitsize="${sim_bitsize} -DWITH_TARGET_ADDRESS_BITSIZE=32" ;;
+  x64 | x64,* ) sim_bitsize="${sim_bitsize} -DWITH_TARGET_ADDRESS_BITSIZE=64" ;;
+  * ) { { echo "$as_me:$LINENO: error: \"--enable-sim-bitsize was given address size $enableval.  Expected 32 or 64\"" >&5
+echo "$as_me: error: \"--enable-sim-bitsize was given address size $enableval.  Expected 32 or 64\"" >&2;}
+   { (exit 1); exit 1; }; } ;;
+esac
+# cell bitsize
+tmp=`echo "${enableval}" | sed -e "s/^[0-9]*,*[0-9*]*,*[0-9]*,*//"`
+case x"${tmp}" in
+  x ) ;;
+  x32 | x32,* ) sim_bitsize="${sim_bitsize} -DWITH_TARGET_CELL_BITSIZE=32" ;;
+  x64 | x64,* ) sim_bitsize="${sim_bitsize} -DWITH_TARGET_CELL_BITSIZE=64" ;;
+  * ) { { echo "$as_me:$LINENO: error: \"--enable-sim-bitsize was given cell size $enableval.  Expected 32 or 64\"" >&5
+echo "$as_me: error: \"--enable-sim-bitsize was given cell size $enableval.  Expected 32 or 64\"" >&2;}
+   { (exit 1); exit 1; }; } ;;
+esac
+if test x"$silent" != x"yes" && test x"$sim_bitsize" != x""; then
+  echo "Setting bitsize flags = $sim_bitsize" 6>&1
+fi
+else
+  sim_bitsize=""
+if test x"$wire_word_bitsize" != x; then
+  sim_bitsize="$sim_bitsize -DWITH_TARGET_WORD_BITSIZE=$wire_word_bitsize"
+fi
+if test x"$wire_word_msb" != x; then
+  sim_bitsize="$sim_bitsize -DWITH_TARGET_WORD_MSB=$wire_word_msb"
+fi
+if test x"$wire_address_bitsize" != x; then
+  sim_bitsize="$sim_bitsize -DWITH_TARGET_ADDRESS_BITSIZE=$wire_address_bitsize"
+fi
+if test x"$wire_cell_bitsize" != x; then
+  sim_bitsize="$sim_bitsize -DWITH_TARGET_CELL_BITSIZE=$wire_cell_bitsize"
+fi
+fi;
+
+
+
+#
+# Select the floating hardware support of the target
+#
+brownie32_fpu=HARDWARE_FLOATING_POINT
+brownie32_fpu_bitsize=
+case "${target}" in
+  brownie32*tx39*)		brownie32_fpu=HARD_FLOATING_POINT
+			brownie32_fpu_bitsize=32
+			;;
+  brownie3264*-*-*)          brownie32_fpu=HARD_FLOATING_POINT ;;
+  brownie3216*-*-*)          brownie32_fpu=HARD_FLOATING_POINT ;;
+  brownie32isa32*-*-*)       brownie32_fpu=HARD_FLOATING_POINT ; brownie32_fpu_bitsize=64 ;;
+  brownie32isa64*-*-*)       brownie32_fpu=HARD_FLOATING_POINT ; brownie32_fpu_bitsize=64 ;;
+  brownie32*-*-*)            brownie32_fpu=HARD_FLOATING_POINT ; brownie32_fpu_bitsize=32 ;;
+  *)                    brownie32_fpu=HARD_FLOATING_POINT ;;
+esac
+
+default_sim_float="$brownie32_fpu"
+default_sim_float_bitsize="$brownie32_fpu_bitsize"
+# Check whether --enable-sim-float or --disable-sim-float was given.
+if test "${enable_sim_float+set}" = set; then
+  enableval="$enable_sim_float"
+  case "${enableval}" in
+  yes | hard)	sim_float="-DWITH_FLOATING_POINT=HARD_FLOATING_POINT";;
+  no | soft)	sim_float="-DWITH_FLOATING_POINT=SOFT_FLOATING_POINT";;
+  32)           sim_float="-DWITH_FLOATING_POINT=HARD_FLOATING_POINT -DWITH_TARGET_FLOATING_POINT_BITSIZE=32";;
+  64)           sim_float="-DWITH_FLOATING_POINT=HARD_FLOATING_POINT -DWITH_TARGET_FLOATING_POINT_BITSIZE=64";;
+  *)		{ { echo "$as_me:$LINENO: error: \"Unknown value $enableval passed to --enable-sim-float\"" >&5
+echo "$as_me: error: \"Unknown value $enableval passed to --enable-sim-float\"" >&2;}
+   { (exit 1); exit 1; }; }; sim_float="";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_float" != x""; then
+  echo "Setting float flags = $sim_float" 6>&1
+fi
+else
+
+sim_float=
+if test x"${default_sim_float}" != x""; then
+  sim_float="-DWITH_FLOATING_POINT=${default_sim_float}"
+fi
+if test x"${default_sim_float_bitsize}" != x""; then
+  sim_float="$sim_float -DWITH_TARGET_FLOATING_POINT_BITSIZE=${default_sim_float_bitsize}"
+fi
+
+fi;
+
+
+
+#
+# Select the level of SMP support
+#
+case "${target}" in
+  *)                    brownie32_smp=0 ;;
+esac
+
+default_sim_smp="$brownie32_smp"
+# Check whether --enable-sim-smp or --disable-sim-smp was given.
+if test "${enable_sim_smp+set}" = set; then
+  enableval="$enable_sim_smp"
+  case "${enableval}" in
+  yes)	sim_smp="-DWITH_SMP=5" ; sim_igen_smp="-N 5";;
+  no)	sim_smp="-DWITH_SMP=0" ; sim_igen_smp="-N 0";;
+  *)	sim_smp="-DWITH_SMP=$enableval" ; sim_igen_smp="-N $enableval";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_smp" != x""; then
+  echo "Setting smp flags = $sim_smp" 6>&1
+fi
+else
+  sim_smp="-DWITH_SMP=${default_sim_smp}" ; sim_igen_smp="-N ${default_sim_smp}"
+if test x"$silent" != x"yes"; then
+  echo "Setting smp flags = $sim_smp" 6>&1
+fi
+fi;
+
+
+
+#
+# Select the IGEN architecture
+#
+#
+# Select the IGEN architecture
+#
+sim_gen=IGEN
+sim_igen_machine="-M brownie32_std"
+sim_igen_filter="32,f"
+sim_mach_default="brownie32_std"
+
+case "${target}" in
+  brownie32*std*)		sim_gen=IGEN
+			sim_igen_filter="32,f"
+			sim_igen_machine="-M brownie32_std"
+			;;
+esac
+
+# The MULTI generator can combine several simulation engines into one.
+# executable.  A configuration which uses the MULTI should set two
+# variables: ${sim_multi_configs} and ${sim_multi_default}.
+#
+# ${sim_multi_configs} is the list of engines to build.  Each
+# space-separated entry has the form NAME:MACHINE:FILTER:BFDMACHS,
+# where:
+#
+# - NAME is a C-compatible prefix for the engine,
+# - MACHINE is a -M argument,
+# - FILTER is a -F argument, and
+# - BFDMACHS is a comma-separated list of bfd machines that the
+#     simulator can run.
+#
+# Each entry will have a separate simulation engine whose prefix is
+# m32<NAME>.  If the machine list includes "brownie3216", there will also
+# be a brownie3216 engine, prefix m16<NAME>.  The brownie3216 engine will be
+# generated using the same machine list as the 32-bit version,
+# but the filter will be "16" instead of FILTER.
+#
+# The simulator compares the bfd mach against BFDMACHS to decide
+# which engine to use.  Entries in BFDMACHS should be bfd_mach
+# values with "bfd_mach_" removed.  ${sim_multi_default} says
+# which entry should be the default.
+if test ${sim_gen} = MULTI; then
+
+  # Simple sanity check.
+  if test -z "${sim_multi_configs}" || test -z "${sim_multi_default}"; then
+    { { echo "$as_me:$LINENO: error: Error in configure.in: MULTI simulator not set up correctly" >&5
+echo "$as_me: error: Error in configure.in: MULTI simulator not set up correctly" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+
+  # Start in a known state.
+  rm -f multi-include.h multi-run.c
+  sim_multi_flags=
+  sim_multi_src=
+  sim_multi_obj=multi-run.o
+  sim_multi_igen_configs=
+  sim_seen_default=no
+
+  cat << __EOF__ > multi-run.c
+/* Main entry point for MULTI simulators.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+   --
+
+   This file was generated by sim/brownie32/configure.  */
+
+#include "sim-main.h"
+#include "multi-include.h"
+
+#define SD sd
+#define CPU cpu
+
+void
+sim_engine_run (SIM_DESC sd,
+		int next_cpu_nr,
+		int nr_cpus,
+		int signal) /* ignore */
+{
+  int mach;
+
+  if (STATE_ARCHITECTURE (sd) == NULL)
+    mach = bfd_mach_${sim_multi_default};
+  else
+    mach = STATE_ARCHITECTURE (SD)->mach;
+
+  switch (mach)
+    {
+__EOF__
+
+  for fc in ${sim_multi_configs}; do
+
+    # Split up the entry.  ${c} contains the first three elements.
+    # Note: outer sqaure brackets are m4 quotes.
+    c=`echo ${fc} | sed 's/:[^:]*$//'`
+    bfdmachs=`echo ${fc} | sed 's/.*://'`
+    name=`echo ${c} | sed 's/:.*//'`
+    machine=`echo ${c} | sed 's/.*:\(.*\):.*/\1/'`
+    filter=`echo ${c} | sed 's/.*://'`
+
+    # Build the following lists:
+    #
+    #   sim_multi_flags: all -M and -F flags used by the simulator
+    #   sim_multi_src: all makefile-generated source files
+    #   sim_multi_obj: the objects for ${sim_multi_src}
+    #   sim_multi_igen_configs: igen configuration strings.
+    #
+    # Each entry in ${sim_multi_igen_configs} is a prefix (m32
+    # or m16) followed by the NAME, MACHINE and FILTER part of
+    # the ${sim_multi_configs} entry.
+    sim_multi_flags="${sim_multi_flags} -F ${filter} -M ${machine}"
+
+    # Check whether brownie3216 handling is needed.
+    case ${c} in
+      *:*brownie3216*:*)
+	# Run igen twice, once for normal mode and once for brownie3216.
+	ws="m32 m16"
+
+	# The top-level function for the brownie3216 simulator is
+	# in a file m16${name}_run.c, generated by the
+	# tmp-run-multi Makefile rule.
+	sim_multi_src="${sim_multi_src} m16${name}_run.c"
+	sim_multi_obj="${sim_multi_obj} m16${name}_run.o"
+	sim_multi_flags="${sim_multi_flags} -F 16"
+	;;
+      *)
+	ws=m32
+	;;
+    esac
+
+    # Now add the list of igen-generated files to ${sim_multi_src}
+    # and ${sim_multi_obj}.
+    for w in ${ws}; do
+      for base in engine icache idecode model semantics support; do
+	sim_multi_src="${sim_multi_src} ${w}${name}_${base}.c"
+	sim_multi_src="${sim_multi_src} ${w}${name}_${base}.h"
+	sim_multi_obj="${sim_multi_obj} ${w}${name}_${base}.o"
+      done
+      sim_multi_igen_configs="${sim_multi_igen_configs} ${w}${c}"
+    done
+
+    # Add an include for the engine.h file.  This file declares the
+    # top-level foo_engine_run() function.
+    echo "#include \"${w}${name}_engine.h\"" >> multi-include.h
+
+    # Add case statements for this engine to sim_engine_run().
+    for mach in `echo ${bfdmachs} | sed 's/,/ /g'`; do
+      echo "    case bfd_mach_${mach}:" >> multi-run.c
+      if test ${mach} = ${sim_multi_default}; then
+	echo "    default:" >> multi-run.c
+	sim_seen_default=yes
+      fi
+    done
+    echo "      ${w}${name}_engine_run (sd, next_cpu_nr, nr_cpus, signal);" \
+      >> multi-run.c
+    echo "      break;" >> multi-run.c
+  done
+
+  # Check whether we added a 'default:' label.
+  if test ${sim_seen_default} = no; then
+    { { echo "$as_me:$LINENO: error: Error in configure.in: \${sim_multi_configs} doesn't have an entry for \${sim_multi_default}" >&5
+echo "$as_me: error: Error in configure.in: \${sim_multi_configs} doesn't have an entry for \${sim_multi_default}" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+
+  cat << __EOF__ >> multi-run.c
+    }
+}
+
+int
+brownie32_mach_multi (SIM_DESC sd)
+{
+  if (STATE_ARCHITECTURE (sd) == NULL)
+    return bfd_mach_${sim_multi_default};
+
+  switch (STATE_ARCHITECTURE (SD)->mach)
+    {
+__EOF__
+
+  # Add case statements for this engine to brownie32_mach_multi().
+  for fc in ${sim_multi_configs}; do
+
+    # Split up the entry.  ${c} contains the first three elements.
+    # Note: outer sqaure brackets are m4 quotes.
+    c=`echo ${fc} | sed 's/:[^:]*$//'`
+    bfdmachs=`echo ${fc} | sed 's/.*://'`
+
+    for mach in `echo ${bfdmachs} | sed 's/,/ /g'`; do
+      echo "    case bfd_mach_${mach}:" >> multi-run.c
+    done
+  done
+
+  cat << __EOF__ >> multi-run.c
+      return (STATE_ARCHITECTURE (SD)->mach);
+    default:
+      return bfd_mach_${sim_multi_default};
+    }
+}
+__EOF__
+
+  SIM_SUBTARGET="$SIM_SUBTARGET -DBROWNIE32_MACH_MULTI"
+else
+  # For clean-extra
+  sim_multi_src=doesnt-exist.c
+
+  if test x"${sim_mach_default}" = x""; then
+    { { echo "$as_me:$LINENO: error: Error in configure.in: \${sim_mach_default} not defined" >&5
+echo "$as_me: error: Error in configure.in: \${sim_mach_default} not defined" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+  SIM_SUBTARGET="$SIM_SUBTARGET -DBROWNIE32_MACH_DEFAULT=bfd_mach_${sim_mach_default}"
+fi
+sim_igen_flags="-F ${sim_igen_filter} ${sim_igen_machine} ${sim_igen_smp}"
+sim_m16_flags=" -F ${sim_m16_filter}  ${sim_m16_machine}  ${sim_igen_smp}"
+
+
+
+
+
+
+
+
+
+#
+# Add simulated hardware devices
+#
+hw_enabled=no
+case "${target}" in
+  brownie32*tx39*)
+	hw_enabled=yes
+	hw_extra_devices="tx3904cpu tx3904irc tx3904tmr tx3904sio"
+	brownie32_extra_objs="dv-sockser.o"
+	SIM_SUBTARGET="$SIM_SUBTARGET -DTARGET_TX3904=1"
+	;;
+  *)
+	brownie32_extra_objs=""
+	;;
+esac
+
+if test x"$hw_enabled" = x"yes"; then
+  sim_hw_p=yes
+else
+  sim_hw_p=no
+fi
+if test "$hw_devices"; then
+  hardware="core pal glue"
+else
+  hardware="core pal glue $hw_extra_devices"
+fi
+sim_hw_cflags="-DWITH_HW=1"
+sim_hw="$hardware"
+sim_hw_objs="\$(SIM_COMMON_HW_OBJS) `echo $sim_hw | sed -e 's/\([^ ][^ ]*\)/dv-\1.o/g'`"
+# Check whether --enable-sim-hardware or --disable-sim-hardware was given.
+if test "${enable_sim_hardware+set}" = set; then
+  enableval="$enable_sim_hardware"
+
+case "${enableval}" in
+  yes)	sim_hw_p=yes;;
+  no)	sim_hw_p=no;;
+  ,*)   sim_hw_p=yes; hardware="${hardware} `echo ${enableval} | sed -e 's/,/ /'`";;
+  *,)   sim_hw_p=yes; hardware="`echo ${enableval} | sed -e 's/,/ /'` ${hardware}";;
+  *)	sim_hw_p=yes; hardware="`echo ${enableval} | sed -e 's/,/ /'`"'';;
+esac
+if test "$sim_hw_p" != yes; then
+  sim_hw_objs=
+  sim_hw_cflags="-DWITH_HW=0"
+  sim_hw=
+else
+  sim_hw_cflags="-DWITH_HW=1"
+  # remove duplicates
+  sim_hw=""
+  sim_hw_objs="\$(SIM_COMMON_HW_OBJS)"
+  for i in x $hardware ; do
+    case " $f " in
+      x) ;;
+      *" $i "*) ;;
+      *) sim_hw="$sim_hw $i" ; sim_hw_objs="$sim_hw_objs dv-$i.o";;
+    esac
+  done
+fi
+if test x"$silent" != x"yes" && test "$sim_hw_p" = "yes"; then
+  echo "Setting hardware to $sim_hw_cflags, $sim_hw, $sim_hw_objs"
+fi
+else
+
+if test "$sim_hw_p" != yes; then
+  sim_hw_objs=
+  sim_hw_cflags="-DWITH_HW=0"
+  sim_hw=
+fi
+if test x"$silent" != x"yes"; then
+  echo "Setting hardware to $sim_hw_cflags, $sim_hw, $sim_hw_objs"
+fi
+fi;
+
+
+
+# Choose simulator engine
+case "${target}" in
+  *)    brownie32_igen_engine="engine.o"
+	;;
+esac
+
+
+
+echo "$as_me:$LINENO: checking for X" >&5
+echo $ECHO_N "checking for X... $ECHO_C" >&6
+
+
+# Check whether --with-x or --without-x was given.
+if test "${with_x+set}" = set; then
+  withval="$with_x"
+
+fi;
+# $have_x is `yes', `no', `disabled', or empty when we do not yet know.
+if test "x$with_x" = xno; then
+  # The user explicitly disabled X.
+  have_x=disabled
+else
+  if test "x$x_includes" != xNONE && test "x$x_libraries" != xNONE; then
+    # Both variables are already set.
+    have_x=yes
+  else
+    if test "${ac_cv_have_x+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  # One or both of the vars are not set, and there is no cached value.
+ac_x_includes=no ac_x_libraries=no
+rm -fr conftest.dir
+if mkdir conftest.dir; then
+  cd conftest.dir
+  # Make sure to not put "make" in the Imakefile rules, since we grep it out.
+  cat >Imakefile <<'_ACEOF'
+acfindx:
+	@echo 'ac_im_incroot="${INCROOT}"; ac_im_usrlibdir="${USRLIBDIR}"; ac_im_libdir="${LIBDIR}"'
+_ACEOF
+  if (xmkmf) >/dev/null 2>/dev/null && test -f Makefile; then
+    # GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+    eval `${MAKE-make} acfindx 2>/dev/null | grep -v make`
+    # Open Windows xmkmf reportedly sets LIBDIR instead of USRLIBDIR.
+    for ac_extension in a so sl; do
+      if test ! -f $ac_im_usrlibdir/libX11.$ac_extension &&
+	 test -f $ac_im_libdir/libX11.$ac_extension; then
+	ac_im_usrlibdir=$ac_im_libdir; break
+      fi
+    done
+    # Screen out bogus values from the imake configuration.  They are
+    # bogus both because they are the default anyway, and because
+    # using them would break gcc on systems where it needs fixed includes.
+    case $ac_im_incroot in
+	/usr/include) ;;
+	*) test -f "$ac_im_incroot/X11/Xos.h" && ac_x_includes=$ac_im_incroot;;
+    esac
+    case $ac_im_usrlibdir in
+	/usr/lib | /lib) ;;
+	*) test -d "$ac_im_usrlibdir" && ac_x_libraries=$ac_im_usrlibdir ;;
+    esac
+  fi
+  cd ..
+  rm -fr conftest.dir
+fi
+
+# Standard set of common directories for X headers.
+# Check X11 before X11Rn because it is often a symlink to the current release.
+ac_x_header_dirs='
+/usr/X11/include
+/usr/X11R6/include
+/usr/X11R5/include
+/usr/X11R4/include
+
+/usr/include/X11
+/usr/include/X11R6
+/usr/include/X11R5
+/usr/include/X11R4
+
+/usr/local/X11/include
+/usr/local/X11R6/include
+/usr/local/X11R5/include
+/usr/local/X11R4/include
+
+/usr/local/include/X11
+/usr/local/include/X11R6
+/usr/local/include/X11R5
+/usr/local/include/X11R4
+
+/usr/X386/include
+/usr/x386/include
+/usr/XFree86/include/X11
+
+/usr/include
+/usr/local/include
+/usr/unsupported/include
+/usr/athena/include
+/usr/local/x11r5/include
+/usr/lpp/Xamples/include
+
+/usr/openwin/include
+/usr/openwin/share/include'
+
+if test "$ac_x_includes" = no; then
+  # Guess where to find include files, by looking for Intrinsic.h.
+  # First, try using that file with no special directory specified.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <X11/Intrinsic.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  # We can compile using X headers with no special include directory.
+ac_x_includes=
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  for ac_dir in $ac_x_header_dirs; do
+  if test -r "$ac_dir/X11/Intrinsic.h"; then
+    ac_x_includes=$ac_dir
+    break
+  fi
+done
+fi
+rm -f conftest.err conftest.$ac_ext
+fi # $ac_x_includes = no
+
+if test "$ac_x_libraries" = no; then
+  # Check for the libraries.
+  # See if we find them without any special options.
+  # Don't add to $LIBS permanently.
+  ac_save_LIBS=$LIBS
+  LIBS="-lXt $LIBS"
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <X11/Intrinsic.h>
+int
+main ()
+{
+XtMalloc (0)
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  LIBS=$ac_save_LIBS
+# We can link X programs with no special library path.
+ac_x_libraries=
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+LIBS=$ac_save_LIBS
+for ac_dir in `echo "$ac_x_includes $ac_x_header_dirs" | sed s/include/lib/g`
+do
+  # Don't even attempt the hair of trying to link an X program!
+  for ac_extension in a so sl; do
+    if test -r $ac_dir/libXt.$ac_extension; then
+      ac_x_libraries=$ac_dir
+      break 2
+    fi
+  done
+done
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi # $ac_x_libraries = no
+
+if test "$ac_x_includes" = no || test "$ac_x_libraries" = no; then
+  # Didn't find X anywhere.  Cache the known absence of X.
+  ac_cv_have_x="have_x=no"
+else
+  # Record where we found X for the cache.
+  ac_cv_have_x="have_x=yes \
+		ac_x_includes=$ac_x_includes ac_x_libraries=$ac_x_libraries"
+fi
+fi
+
+  fi
+  eval "$ac_cv_have_x"
+fi # $with_x != no
+
+if test "$have_x" != yes; then
+  echo "$as_me:$LINENO: result: $have_x" >&5
+echo "${ECHO_T}$have_x" >&6
+  no_x=yes
+else
+  # If each of the values was on the command line, it overrides each guess.
+  test "x$x_includes" = xNONE && x_includes=$ac_x_includes
+  test "x$x_libraries" = xNONE && x_libraries=$ac_x_libraries
+  # Update the cache value to reflect the command line values.
+  ac_cv_have_x="have_x=yes \
+		ac_x_includes=$x_includes ac_x_libraries=$x_libraries"
+  echo "$as_me:$LINENO: result: libraries $x_libraries, headers $x_includes" >&5
+echo "${ECHO_T}libraries $x_libraries, headers $x_includes" >&6
+fi
+
+brownie32_extra_libs=""
+
+
+
+
+
+
+for ac_header in string.h strings.h stdlib.h stdlib.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+echo "$as_me:$LINENO: checking for fabs in -lm" >&5
+echo $ECHO_N "checking for fabs in -lm... $ECHO_C" >&6
+if test "${ac_cv_lib_m_fabs+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lm  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char fabs ();
+int
+main ()
+{
+fabs ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_m_fabs=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_m_fabs=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_m_fabs" >&5
+echo "${ECHO_T}$ac_cv_lib_m_fabs" >&6
+if test $ac_cv_lib_m_fabs = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBM 1
+_ACEOF
+
+  LIBS="-lm $LIBS"
+
+fi
+
+
+
+
+for ac_func in aint anint sqrt
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+
+ac_sources="$sim_link_files"
+ac_dests="$sim_link_links"
+while test -n "$ac_sources"; do
+  set $ac_dests; ac_dest=$1; shift; ac_dests=$*
+  set $ac_sources; ac_source=$1; shift; ac_sources=$*
+  ac_config_links_1="$ac_config_links_1 $ac_dest:$ac_source"
+done
+          ac_config_links="$ac_config_links $ac_config_links_1"
+
+cgen_breaks=""
+if grep CGEN_MAINT $srcdir/Makefile.in >/dev/null; then
+cgen_breaks="break cgen_rtx_error";
+fi
+
+          ac_config_files="$ac_config_files Makefile.sim:Makefile.in"
+
+          ac_config_files="$ac_config_files Make-common.sim:../common/Make-common.in"
+
+          ac_config_files="$ac_config_files .gdbinit:../common/gdbinit.in"
+
+          ac_config_commands="$ac_config_commands Makefile"
+
+          ac_config_commands="$ac_config_commands stamp-h"
+
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, don't put newlines in cache variables' values.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+{
+  (set) 2>&1 |
+    case `(ac_space=' '; set | grep ac_space) 2>&1` in
+    *ac_space=\ *)
+      # `set' does not quote correctly, so add quotes (double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \).
+      sed -n \
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;;
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n \
+	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+      ;;
+    esac;
+} |
+  sed '
+     t clear
+     : clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     /^ac_cv_env/!s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     : end' >>confcache
+if diff $cache_file confcache >/dev/null 2>&1; then :; else
+  if test -w $cache_file; then
+    test "x$cache_file" != "x/dev/null" && echo "updating cache $cache_file"
+    cat confcache >$cache_file
+  else
+    echo "not updating unwritable cache $cache_file"
+  fi
+fi
+rm -f confcache
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+# VPATH may cause trouble with some makes, so we remove $(srcdir),
+# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/;
+s/:*\${srcdir}:*/:/;
+s/:*@srcdir@:*/:/;
+s/^\([^=]*=[	 ]*\):*/\1/;
+s/:*$//;
+s/^[^=]*=[	 ]*$//;
+}'
+fi
+
+DEFS=-DHAVE_CONFIG_H
+
+ac_libobjs=
+ac_ltlibobjs=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_i=`echo "$ac_i" |
+	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+
+: ${CONFIG_STATUS=./config.status}
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ echo "$as_me:$LINENO: creating $CONFIG_STATUS" >&5
+echo "$as_me: creating $CONFIG_STATUS" >&6;}
+cat >$CONFIG_STATUS <<_ACEOF
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+SHELL=\${CONFIG_SHELL-$SHELL}
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { { echo "$as_me:$LINENO: error: cannot find myself; rerun with an absolute path" >&5
+echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { { echo "$as_me:$LINENO: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&5
+echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2;}
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+exec 6>&1
+
+# Open the log real soon, to keep \$[0] and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.  Logging --version etc. is OK.
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+} >&5
+cat >&5 <<_CSEOF
+
+This file was extended by $as_me, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+_CSEOF
+echo "on `(hostname || uname -n) 2>/dev/null | sed 1q`" >&5
+echo >&5
+_ACEOF
+
+# Files that config.status was made for.
+if test -n "$ac_config_files"; then
+  echo "config_files=\"$ac_config_files\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_headers"; then
+  echo "config_headers=\"$ac_config_headers\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_links"; then
+  echo "config_links=\"$ac_config_links\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_commands"; then
+  echo "config_commands=\"$ac_config_commands\"" >>$CONFIG_STATUS
+fi
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+ac_cs_usage="\
+\`$as_me' instantiates files from templates according to the
+current configuration.
+
+Usage: $0 [OPTIONS] [FILE]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number, then exit
+  -q, --quiet      do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+  --file=FILE[:TEMPLATE]
+		   instantiate the configuration file FILE
+  --header=FILE[:TEMPLATE]
+		   instantiate the configuration header FILE
+
+Configuration files:
+$config_files
+
+Configuration headers:
+$config_headers
+
+Configuration links:
+$config_links
+
+Configuration commands:
+$config_commands
+
+Report bugs to <bug-autoconf@gnu.org>."
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+ac_cs_version="\\
+config.status
+configured by $0, generated by GNU Autoconf 2.59,
+  with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
+
+Copyright (C) 2003 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+srcdir=$srcdir
+INSTALL="$INSTALL"
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+# If no file are specified by the user, then we need to provide default
+# value.  By we need to know if files were specified by the user.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr "x$1" : 'x\([^=]*\)='`
+    ac_optarg=`expr "x$1" : 'x[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  -*)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  *) # This is not an option, so the user has probably given explicit
+     # arguments.
+     ac_option=$1
+     ac_need_defaults=false;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --vers* | -V )
+    echo "$ac_cs_version"; exit 0 ;;
+  --he | --h)
+    # Conflict between --help and --header
+    { { echo "$as_me:$LINENO: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; };;
+  --help | --hel | -h )
+    echo "$ac_cs_usage"; exit 0 ;;
+  --debug | --d* | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    CONFIG_FILES="$CONFIG_FILES $ac_optarg"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    CONFIG_HEADERS="$CONFIG_HEADERS $ac_optarg"
+    ac_need_defaults=false;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) { { echo "$as_me:$LINENO: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; } ;;
+
+  *) ac_config_targets="$ac_config_targets $1" ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+if \$ac_cs_recheck; then
+  echo "running $SHELL $0 " $ac_configure_args \$ac_configure_extra_args " --no-create --no-recursion" >&6
+  exec $SHELL $0 $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+fi
+
+_ACEOF
+
+
+
+
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+for ac_config_target in $ac_config_targets
+do
+  case "$ac_config_target" in
+  # Handling of arguments.
+  "Makefile.sim" ) CONFIG_FILES="$CONFIG_FILES Makefile.sim:Makefile.in" ;;
+  "Make-common.sim" ) CONFIG_FILES="$CONFIG_FILES Make-common.sim:../common/Make-common.in" ;;
+  ".gdbinit" ) CONFIG_FILES="$CONFIG_FILES .gdbinit:../common/gdbinit.in" ;;
+  "$ac_config_links_1" ) CONFIG_LINKS="$CONFIG_LINKS $ac_config_links_1" ;;
+  "Makefile" ) CONFIG_COMMANDS="$CONFIG_COMMANDS Makefile" ;;
+  "stamp-h" ) CONFIG_COMMANDS="$CONFIG_COMMANDS stamp-h" ;;
+  "config.h" ) CONFIG_HEADERS="$CONFIG_HEADERS config.h:config.in" ;;
+  *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
+echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
+  test "${CONFIG_LINKS+set}" = set || CONFIG_LINKS=$config_links
+  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason to put it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Create a temporary directory, and hook for its removal unless debugging.
+$debug ||
+{
+  trap 'exit_status=$?; rm -rf $tmp && exit $exit_status' 0
+  trap '{ (exit 1); exit 1; }' 1 2 13 15
+}
+
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d -q "./confstatXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=./confstat$$-$RANDOM
+  (umask 077 && mkdir $tmp)
+} ||
+{
+   echo "$me: cannot create a temporary directory in ." >&2
+   { (exit 1); exit 1; }
+}
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+
+#
+# CONFIG_FILES section.
+#
+
+# No need to generate the scripts if there are no CONFIG_FILES.
+# This happens for instance when ./config.status config.h
+if test -n "\$CONFIG_FILES"; then
+  # Protect against being on the right side of a sed subst in config.status.
+  sed 's/,@/@@/; s/@,/@@/; s/,;t t\$/@;t t/; /@;t t\$/s/[\\\\&,]/\\\\&/g;
+   s/@@/,@/; s/@@/@,/; s/@;t t\$/,;t t/' >\$tmp/subs.sed <<\\CEOF
+s,@SHELL@,$SHELL,;t t
+s,@PATH_SEPARATOR@,$PATH_SEPARATOR,;t t
+s,@PACKAGE_NAME@,$PACKAGE_NAME,;t t
+s,@PACKAGE_TARNAME@,$PACKAGE_TARNAME,;t t
+s,@PACKAGE_VERSION@,$PACKAGE_VERSION,;t t
+s,@PACKAGE_STRING@,$PACKAGE_STRING,;t t
+s,@PACKAGE_BUGREPORT@,$PACKAGE_BUGREPORT,;t t
+s,@exec_prefix@,$exec_prefix,;t t
+s,@prefix@,$prefix,;t t
+s,@program_transform_name@,$program_transform_name,;t t
+s,@bindir@,$bindir,;t t
+s,@sbindir@,$sbindir,;t t
+s,@libexecdir@,$libexecdir,;t t
+s,@datadir@,$datadir,;t t
+s,@sysconfdir@,$sysconfdir,;t t
+s,@sharedstatedir@,$sharedstatedir,;t t
+s,@localstatedir@,$localstatedir,;t t
+s,@libdir@,$libdir,;t t
+s,@includedir@,$includedir,;t t
+s,@oldincludedir@,$oldincludedir,;t t
+s,@infodir@,$infodir,;t t
+s,@mandir@,$mandir,;t t
+s,@build_alias@,$build_alias,;t t
+s,@host_alias@,$host_alias,;t t
+s,@target_alias@,$target_alias,;t t
+s,@DEFS@,$DEFS,;t t
+s,@ECHO_C@,$ECHO_C,;t t
+s,@ECHO_N@,$ECHO_N,;t t
+s,@ECHO_T@,$ECHO_T,;t t
+s,@LIBS@,$LIBS,;t t
+s,@sim_environment@,$sim_environment,;t t
+s,@sim_alignment@,$sim_alignment,;t t
+s,@sim_assert@,$sim_assert,;t t
+s,@sim_bitsize@,$sim_bitsize,;t t
+s,@sim_endian@,$sim_endian,;t t
+s,@sim_hostendian@,$sim_hostendian,;t t
+s,@sim_float@,$sim_float,;t t
+s,@sim_scache@,$sim_scache,;t t
+s,@sim_default_model@,$sim_default_model,;t t
+s,@sim_hw_cflags@,$sim_hw_cflags,;t t
+s,@sim_hw_objs@,$sim_hw_objs,;t t
+s,@sim_hw@,$sim_hw,;t t
+s,@sim_inline@,$sim_inline,;t t
+s,@sim_packages@,$sim_packages,;t t
+s,@sim_regparm@,$sim_regparm,;t t
+s,@sim_reserved_bits@,$sim_reserved_bits,;t t
+s,@sim_smp@,$sim_smp,;t t
+s,@sim_stdcall@,$sim_stdcall,;t t
+s,@sim_xor_endian@,$sim_xor_endian,;t t
+s,@WARN_CFLAGS@,$WARN_CFLAGS,;t t
+s,@WERROR_CFLAGS@,$WERROR_CFLAGS,;t t
+s,@build@,$build,;t t
+s,@build_cpu@,$build_cpu,;t t
+s,@build_vendor@,$build_vendor,;t t
+s,@build_os@,$build_os,;t t
+s,@host@,$host,;t t
+s,@host_cpu@,$host_cpu,;t t
+s,@host_vendor@,$host_vendor,;t t
+s,@host_os@,$host_os,;t t
+s,@target@,$target,;t t
+s,@target_cpu@,$target_cpu,;t t
+s,@target_vendor@,$target_vendor,;t t
+s,@target_os@,$target_os,;t t
+s,@CC@,$CC,;t t
+s,@CFLAGS@,$CFLAGS,;t t
+s,@LDFLAGS@,$LDFLAGS,;t t
+s,@CPPFLAGS@,$CPPFLAGS,;t t
+s,@ac_ct_CC@,$ac_ct_CC,;t t
+s,@EXEEXT@,$EXEEXT,;t t
+s,@OBJEXT@,$OBJEXT,;t t
+s,@INSTALL_PROGRAM@,$INSTALL_PROGRAM,;t t
+s,@INSTALL_SCRIPT@,$INSTALL_SCRIPT,;t t
+s,@INSTALL_DATA@,$INSTALL_DATA,;t t
+s,@CC_FOR_BUILD@,$CC_FOR_BUILD,;t t
+s,@HDEFINES@,$HDEFINES,;t t
+s,@AR@,$AR,;t t
+s,@RANLIB@,$RANLIB,;t t
+s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
+s,@SET_MAKE@,$SET_MAKE,;t t
+s,@CPP@,$CPP,;t t
+s,@EGREP@,$EGREP,;t t
+s,@ALLOCA@,$ALLOCA,;t t
+s,@USE_NLS@,$USE_NLS,;t t
+s,@MSGFMT@,$MSGFMT,;t t
+s,@GMSGFMT@,$GMSGFMT,;t t
+s,@XGETTEXT@,$XGETTEXT,;t t
+s,@USE_INCLUDED_LIBINTL@,$USE_INCLUDED_LIBINTL,;t t
+s,@CATALOGS@,$CATALOGS,;t t
+s,@CATOBJEXT@,$CATOBJEXT,;t t
+s,@DATADIRNAME@,$DATADIRNAME,;t t
+s,@GMOFILES@,$GMOFILES,;t t
+s,@INSTOBJEXT@,$INSTOBJEXT,;t t
+s,@INTLDEPS@,$INTLDEPS,;t t
+s,@INTLLIBS@,$INTLLIBS,;t t
+s,@INTLOBJS@,$INTLOBJS,;t t
+s,@POFILES@,$POFILES,;t t
+s,@POSUB@,$POSUB,;t t
+s,@INCLUDE_LOCALE_H@,$INCLUDE_LOCALE_H,;t t
+s,@GT_NO@,$GT_NO,;t t
+s,@GT_YES@,$GT_YES,;t t
+s,@MKINSTALLDIRS@,$MKINSTALLDIRS,;t t
+s,@l@,$l,;t t
+s,@MAINT@,$MAINT,;t t
+s,@sim_bswap@,$sim_bswap,;t t
+s,@sim_cflags@,$sim_cflags,;t t
+s,@sim_debug@,$sim_debug,;t t
+s,@sim_stdio@,$sim_stdio,;t t
+s,@sim_trace@,$sim_trace,;t t
+s,@sim_profile@,$sim_profile,;t t
+s,@SIM_SUBTARGET@,$SIM_SUBTARGET,;t t
+s,@sim_igen_flags@,$sim_igen_flags,;t t
+s,@sim_m16_flags@,$sim_m16_flags,;t t
+s,@sim_gen@,$sim_gen,;t t
+s,@sim_multi_flags@,$sim_multi_flags,;t t
+s,@sim_multi_igen_configs@,$sim_multi_igen_configs,;t t
+s,@sim_multi_src@,$sim_multi_src,;t t
+s,@sim_multi_obj@,$sim_multi_obj,;t t
+s,@brownie32_extra_objs@,$brownie32_extra_objs,;t t
+s,@brownie32_igen_engine@,$brownie32_igen_engine,;t t
+s,@brownie32_extra_libs@,$brownie32_extra_libs,;t t
+s,@cgen_breaks@,$cgen_breaks,;t t
+s,@LIBOBJS@,$LIBOBJS,;t t
+s,@LTLIBOBJS@,$LTLIBOBJS,;t t
+CEOF
+
+_ACEOF
+
+  cat >>$CONFIG_STATUS <<\_ACEOF
+  # Split the substitutions into bite-sized pieces for seds with
+  # small command number limits, like on Digital OSF/1 and HP-UX.
+  ac_max_sed_lines=48
+  ac_sed_frag=1 # Number of current file.
+  ac_beg=1 # First line for current file.
+  ac_end=$ac_max_sed_lines # Line after last line for current file.
+  ac_more_lines=:
+  ac_sed_cmds=
+  while $ac_more_lines; do
+    if test $ac_beg -gt 1; then
+      sed "1,${ac_beg}d; ${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    else
+      sed "${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    fi
+    if test ! -s $tmp/subs.frag; then
+      ac_more_lines=false
+    else
+      # The purpose of the label and of the branching condition is to
+      # speed up the sed processing (if there are no `@' at all, there
+      # is no need to browse any of the substitutions).
+      # These are the two extra sed commands mentioned above.
+      (echo ':t
+  /@[a-zA-Z_][a-zA-Z_0-9]*@/!b' && cat $tmp/subs.frag) >$tmp/subs-$ac_sed_frag.sed
+      if test -z "$ac_sed_cmds"; then
+	ac_sed_cmds="sed -f $tmp/subs-$ac_sed_frag.sed"
+      else
+	ac_sed_cmds="$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed"
+      fi
+      ac_sed_frag=`expr $ac_sed_frag + 1`
+      ac_beg=$ac_end
+      ac_end=`expr $ac_end + $ac_max_sed_lines`
+    fi
+  done
+  if test -z "$ac_sed_cmds"; then
+    ac_sed_cmds=cat
+  fi
+fi # test -n "$CONFIG_FILES"
+
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+for ac_file in : $CONFIG_FILES; do test "x$ac_file" = x: && continue
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+	cat >$tmp/stdin
+	ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
+  esac
+
+  # Compute @srcdir@, @top_srcdir@, and @INSTALL@ for subdirectories.
+  ac_dir=`(dirname "$ac_file") 2>/dev/null ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
+  esac
+
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x"$ac_file" = x-; then
+    configure_input=
+  else
+    configure_input="$ac_file.  "
+  fi
+  configure_input=$configure_input"Generated from `echo $ac_file_in |
+				     sed 's,.*/,,'` by configure."
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+	 # Absolute (can't be DOS-style, as IFS=:)
+	 test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 echo "$f";;
+      *) # Relative
+	 if test -f "$f"; then
+	   # Build tree
+	   echo "$f"
+	 elif test -f "$srcdir/$f"; then
+	   # Source tree
+	   echo "$srcdir/$f"
+	 else
+	   # /dev/null tree
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+  sed "$ac_vpsub
+$extrasub
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s,@configure_input@,$configure_input,;t t
+s,@srcdir@,$ac_srcdir,;t t
+s,@abs_srcdir@,$ac_abs_srcdir,;t t
+s,@top_srcdir@,$ac_top_srcdir,;t t
+s,@abs_top_srcdir@,$ac_abs_top_srcdir,;t t
+s,@builddir@,$ac_builddir,;t t
+s,@abs_builddir@,$ac_abs_builddir,;t t
+s,@top_builddir@,$ac_top_builddir,;t t
+s,@abs_top_builddir@,$ac_abs_top_builddir,;t t
+s,@INSTALL@,$ac_INSTALL,;t t
+" $ac_file_inputs | (eval "$ac_sed_cmds") >$tmp/out
+  rm -f $tmp/stdin
+  if test x"$ac_file" != x-; then
+    mv $tmp/out $ac_file
+  else
+    cat $tmp/out
+    rm -f $tmp/out
+  fi
+
+done
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+#
+# CONFIG_HEADER section.
+#
+
+# These sed commands are passed to sed as "A NAME B NAME C VALUE D", where
+# NAME is the cpp macro being defined and VALUE is the value it is being given.
+#
+# ac_d sets the value in "#define NAME VALUE" lines.
+ac_dA='s,^\([	 ]*\)#\([	 ]*define[	 ][	 ]*\)'
+ac_dB='[	 ].*$,\1#\2'
+ac_dC=' '
+ac_dD=',;t'
+# ac_u turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
+ac_uA='s,^\([	 ]*\)#\([	 ]*\)undef\([	 ][	 ]*\)'
+ac_uB='$,\1#\2define\3'
+ac_uC=' '
+ac_uD=',;t'
+
+for ac_file in : $CONFIG_HEADERS; do test "x$ac_file" = x: && continue
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+	cat >$tmp/stdin
+	ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
+  esac
+
+  test x"$ac_file" != x- && { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+	 # Absolute (can't be DOS-style, as IFS=:)
+	 test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 # Do quote $f, to prevent DOS paths from being IFS'd.
+	 echo "$f";;
+      *) # Relative
+	 if test -f "$f"; then
+	   # Build tree
+	   echo "$f"
+	 elif test -f "$srcdir/$f"; then
+	   # Source tree
+	   echo "$srcdir/$f"
+	 else
+	   # /dev/null tree
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+  # Remove the trailing spaces.
+  sed 's/[	 ]*$//' $ac_file_inputs >$tmp/in
+
+_ACEOF
+
+# Transform confdefs.h into two sed scripts, `conftest.defines' and
+# `conftest.undefs', that substitutes the proper values into
+# config.h.in to produce config.h.  The first handles `#define'
+# templates, and the second `#undef' templates.
+# And first: Protect against being on the right side of a sed subst in
+# config.status.  Protect against being in an unquoted here document
+# in config.status.
+rm -f conftest.defines conftest.undefs
+# Using a here document instead of a string reduces the quoting nightmare.
+# Putting comments in sed scripts is not portable.
+#
+# `end' is used to avoid that the second main sed command (meant for
+# 0-ary CPP macros) applies to n-ary macro definitions.
+# See the Autoconf documentation for `clear'.
+cat >confdef2sed.sed <<\_ACEOF
+s/[\\&,]/\\&/g
+s,[\\$`],\\&,g
+t clear
+: clear
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 (][^	 (]*\)\(([^)]*)\)[	 ]*\(.*\)$,${ac_dA}\1${ac_dB}\1\2${ac_dC}\3${ac_dD},gp
+t end
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 ][^	 ]*\)[	 ]*\(.*\)$,${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD},gp
+: end
+_ACEOF
+# If some macros were called several times there might be several times
+# the same #defines, which is useless.  Nevertheless, we may not want to
+# sort them, since we want the *last* AC-DEFINE to be honored.
+uniq confdefs.h | sed -n -f confdef2sed.sed >conftest.defines
+sed 's/ac_d/ac_u/g' conftest.defines >conftest.undefs
+rm -f confdef2sed.sed
+
+# This sed command replaces #undef with comments.  This is necessary, for
+# example, in the case of _POSIX_SOURCE, which is predefined and required
+# on some systems where configure will not decide to define it.
+cat >>conftest.undefs <<\_ACEOF
+s,^[	 ]*#[	 ]*undef[	 ][	 ]*[a-zA-Z_][a-zA-Z_0-9]*,/* & */,
+_ACEOF
+
+# Break up conftest.defines because some shells have a limit on the size
+# of here documents, and old seds have small limits too (100 cmds).
+echo '  # Handle all the #define templates only if necessary.' >>$CONFIG_STATUS
+echo '  if grep "^[	 ]*#[	 ]*define" $tmp/in >/dev/null; then' >>$CONFIG_STATUS
+echo '  # If there are no defines, we may have an empty if/fi' >>$CONFIG_STATUS
+echo '  :' >>$CONFIG_STATUS
+rm -f conftest.tail
+while grep . conftest.defines >/dev/null
+do
+  # Write a limited-size here document to $tmp/defines.sed.
+  echo '  cat >$tmp/defines.sed <<CEOF' >>$CONFIG_STATUS
+  # Speed up: don't consider the non `#define' lines.
+  echo '/^[	 ]*#[	 ]*define/!b' >>$CONFIG_STATUS
+  # Work around the forget-to-reset-the-flag bug.
+  echo 't clr' >>$CONFIG_STATUS
+  echo ': clr' >>$CONFIG_STATUS
+  sed ${ac_max_here_lines}q conftest.defines >>$CONFIG_STATUS
+  echo 'CEOF
+  sed -f $tmp/defines.sed $tmp/in >$tmp/out
+  rm -f $tmp/in
+  mv $tmp/out $tmp/in
+' >>$CONFIG_STATUS
+  sed 1,${ac_max_here_lines}d conftest.defines >conftest.tail
+  rm -f conftest.defines
+  mv conftest.tail conftest.defines
+done
+rm -f conftest.defines
+echo '  fi # grep' >>$CONFIG_STATUS
+echo >>$CONFIG_STATUS
+
+# Break up conftest.undefs because some shells have a limit on the size
+# of here documents, and old seds have small limits too (100 cmds).
+echo '  # Handle all the #undef templates' >>$CONFIG_STATUS
+rm -f conftest.tail
+while grep . conftest.undefs >/dev/null
+do
+  # Write a limited-size here document to $tmp/undefs.sed.
+  echo '  cat >$tmp/undefs.sed <<CEOF' >>$CONFIG_STATUS
+  # Speed up: don't consider the non `#undef'
+  echo '/^[	 ]*#[	 ]*undef/!b' >>$CONFIG_STATUS
+  # Work around the forget-to-reset-the-flag bug.
+  echo 't clr' >>$CONFIG_STATUS
+  echo ': clr' >>$CONFIG_STATUS
+  sed ${ac_max_here_lines}q conftest.undefs >>$CONFIG_STATUS
+  echo 'CEOF
+  sed -f $tmp/undefs.sed $tmp/in >$tmp/out
+  rm -f $tmp/in
+  mv $tmp/out $tmp/in
+' >>$CONFIG_STATUS
+  sed 1,${ac_max_here_lines}d conftest.undefs >conftest.tail
+  rm -f conftest.undefs
+  mv conftest.tail conftest.undefs
+done
+rm -f conftest.undefs
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x"$ac_file" = x-; then
+    echo "/* Generated by configure.  */" >$tmp/config.h
+  else
+    echo "/* $ac_file.  Generated by configure.  */" >$tmp/config.h
+  fi
+  cat $tmp/in >>$tmp/config.h
+  rm -f $tmp/in
+  if test x"$ac_file" != x-; then
+    if diff $ac_file $tmp/config.h >/dev/null 2>&1; then
+      { echo "$as_me:$LINENO: $ac_file is unchanged" >&5
+echo "$as_me: $ac_file is unchanged" >&6;}
+    else
+      ac_dir=`(dirname "$ac_file") 2>/dev/null ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+      { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+      rm -f $ac_file
+      mv $tmp/config.h $ac_file
+    fi
+  else
+    cat $tmp/config.h
+    rm -f $tmp/config.h
+  fi
+done
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+#
+# CONFIG_LINKS section.
+#
+
+for ac_file in : $CONFIG_LINKS; do test "x$ac_file" = x: && continue
+  ac_dest=`echo "$ac_file" | sed 's,:.*,,'`
+  ac_source=`echo "$ac_file" | sed 's,[^:]*:,,'`
+
+  { echo "$as_me:$LINENO: linking $srcdir/$ac_source to $ac_dest" >&5
+echo "$as_me: linking $srcdir/$ac_source to $ac_dest" >&6;}
+
+  if test ! -r $srcdir/$ac_source; then
+    { { echo "$as_me:$LINENO: error: $srcdir/$ac_source: file not found" >&5
+echo "$as_me: error: $srcdir/$ac_source: file not found" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+  rm -f $ac_dest
+
+  # Make relative symlinks.
+  ac_dest_dir=`(dirname "$ac_dest") 2>/dev/null ||
+$as_expr X"$ac_dest" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_dest" : 'X\(//\)[^/]' \| \
+	 X"$ac_dest" : 'X\(//\)$' \| \
+	 X"$ac_dest" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_dest" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dest_dir"
+  else
+    as_dir="$ac_dest_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dest_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dest_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test "$ac_dest_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dest_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dest_dir";;
+*)
+  case "$ac_dest_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dest_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dest_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+
+  case $srcdir in
+  [\\/$]* | ?:[\\/]* ) ac_rel_source=$srcdir/$ac_source ;;
+      *) ac_rel_source=$ac_top_builddir$srcdir/$ac_source ;;
+  esac
+
+  # Try a symlink, then a hard link, then a copy.
+  ln -s $ac_rel_source $ac_dest 2>/dev/null ||
+    ln $srcdir/$ac_source $ac_dest 2>/dev/null ||
+    cp -p $srcdir/$ac_source $ac_dest ||
+    { { echo "$as_me:$LINENO: error: cannot link or copy $srcdir/$ac_source to $ac_dest" >&5
+echo "$as_me: error: cannot link or copy $srcdir/$ac_source to $ac_dest" >&2;}
+   { (exit 1); exit 1; }; }
+done
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+#
+# CONFIG_COMMANDS section.
+#
+for ac_file in : $CONFIG_COMMANDS; do test "x$ac_file" = x: && continue
+  ac_dest=`echo "$ac_file" | sed 's,:.*,,'`
+  ac_source=`echo "$ac_file" | sed 's,[^:]*:,,'`
+  ac_dir=`(dirname "$ac_dest") 2>/dev/null ||
+$as_expr X"$ac_dest" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_dest" : 'X\(//\)[^/]' \| \
+	 X"$ac_dest" : 'X\(//\)$' \| \
+	 X"$ac_dest" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_dest" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+
+  { echo "$as_me:$LINENO: executing $ac_dest commands" >&5
+echo "$as_me: executing $ac_dest commands" >&6;}
+  case $ac_dest in
+    Makefile ) echo "Merging Makefile.sim+Make-common.sim into Makefile ..."
+ rm -f Makesim1.tmp Makesim2.tmp Makefile
+ sed -n -e '/^## COMMON_PRE_/,/^## End COMMON_PRE_/ p' <Make-common.sim >Makesim1.tmp
+ sed -n -e '/^## COMMON_POST_/,/^## End COMMON_POST_/ p' <Make-common.sim >Makesim2.tmp
+ sed -e '/^## COMMON_PRE_/ r Makesim1.tmp' \
+	-e '/^## COMMON_POST_/ r Makesim2.tmp' \
+	<Makefile.sim >Makefile
+ rm -f Makefile.sim Make-common.sim Makesim1.tmp Makesim2.tmp
+ ;;
+    stamp-h ) echo > stamp-h ;;
+  esac
+done
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+{ (exit 0); exit 0; }
+_ACEOF
+chmod +x $CONFIG_STATUS
+ac_clean_files=$ac_clean_files_save
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test "$no_create" != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
+  exec 5>/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5>>config.log
+  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || { (exit 1); exit 1; }
+fi
+
+
Index: sim/brownie32/configure.ac
===================================================================
RCS file: sim/brownie32/configure.ac
diff -N sim/brownie32/configure.ac
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/configure.ac	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,364 @@
+dnl Process this file with autoconf to produce a configure script.
+AC_PREREQ(2.59)dnl
+AC_INIT(Makefile.in)
+AC_CONFIG_HEADER(config.h:config.in)
+
+sinclude(../common/aclocal.m4)
+
+# Bugs in autoconf 2.59 break the call to SIM_AC_COMMON, hack around
+# it by inlining the macro's contents.
+sinclude(../common/common.m4)
+
+dnl Options available in this module
+SIM_AC_OPTION_INLINE()
+SIM_AC_OPTION_ALIGNMENT(NONSTRICT_ALIGNMENT)
+SIM_AC_OPTION_HOSTENDIAN
+SIM_AC_OPTION_WARNINGS
+SIM_AC_OPTION_RESERVED_BITS(1)
+
+# DEPRECATED
+#
+# Instead of defining a `subtarget' macro, code should be checking
+# the value of {STATE,CPU}_ARCHITECTURE to identify the architecture
+# in question.
+#
+case "${target}" in
+  brownie3264vr*-*-*)	SIM_SUBTARGET="-DTARGET_ENABLE_FR=1" ;;
+  brownie32*tx39*)           SIM_SUBTARGET="-DSUBTARGET_R3900=1";;
+  brownie32isa32*-*-*)       SIM_SUBTARGET="-DTARGET_ENABLE_FR=1";;
+  brownie32isa64*-*-*)       SIM_SUBTARGET="-DTARGET_ENABLE_FR=1";;
+  *)                    SIM_SUBTARGET="";;
+esac
+AC_SUBST(SIM_SUBTARGET)
+
+
+
+#
+# Select the byte order of the target
+#
+brownie32_endian=
+default_endian=
+case "${target}" in
+  brownie3264el*-*-*)	brownie32_endian=LITTLE_ENDIAN ;;
+  brownie3264vr*el-*-*)      default_endian=LITTLE_ENDIAN ;;
+  brownie3264*-*-*)          default_endian=BIG_ENDIAN ;;
+  brownie3216*-*-*)          default_endian=BIG_ENDIAN ;;
+  brownie32isa32*-*-*)       default_endian=BIG_ENDIAN ;;
+  brownie32isa64*-*-*)       default_endian=BIG_ENDIAN ;;
+  brownie32*-*-*)            default_endian=BIG_ENDIAN ;;
+  *)                    default_endian=BIG_ENDIAN ;;
+esac
+SIM_AC_OPTION_ENDIAN($brownie32_endian,$default_endian)
+
+
+
+#
+# Select the bitsize of the target
+#
+brownie32_addr_bitsize=
+case "${target}" in
+  brownie3264*-*-*)          brownie32_bitsize=64 ; brownie32_msb=63 ;;
+  brownie3216*-*-*)          brownie32_bitsize=64 ; brownie32_msb=63 ;;
+  brownie32isa32*-*-*)       brownie32_bitsize=32 ; brownie32_msb=31 ;;
+  brownie32isa64*-*-*)       brownie32_bitsize=64 ; brownie32_msb=63 ;;
+  brownie32*-*-*)            brownie32_bitsize=32 ; brownie32_msb=31 ;;
+  *)                    brownie32_bitsize=64 ; brownie32_msb=63 ;;
+esac
+SIM_AC_OPTION_BITSIZE($brownie32_bitsize,$brownie32_msb,$brownie32_addr_bitsize)
+
+
+
+#
+# Select the floating hardware support of the target
+#
+brownie32_fpu=HARDWARE_FLOATING_POINT
+brownie32_fpu_bitsize=
+case "${target}" in
+  brownie32*tx39*)		brownie32_fpu=HARD_FLOATING_POINT
+			brownie32_fpu_bitsize=32
+			;;
+  brownie3264*-*-*)          brownie32_fpu=HARD_FLOATING_POINT ;;
+  brownie3216*-*-*)          brownie32_fpu=HARD_FLOATING_POINT ;;
+  brownie32isa32*-*-*)       brownie32_fpu=HARD_FLOATING_POINT ; brownie32_fpu_bitsize=64 ;;
+  brownie32isa64*-*-*)       brownie32_fpu=HARD_FLOATING_POINT ; brownie32_fpu_bitsize=64 ;;
+  brownie32*-*-*)            brownie32_fpu=HARD_FLOATING_POINT ; brownie32_fpu_bitsize=32 ;;
+  *)                    brownie32_fpu=HARD_FLOATING_POINT ;;
+esac
+SIM_AC_OPTION_FLOAT($brownie32_fpu,$brownie32_fpu_bitsize)
+
+
+
+#
+# Select the level of SMP support
+#
+case "${target}" in
+  *)                    brownie32_smp=0 ;;
+esac
+SIM_AC_OPTION_SMP($brownie32_smp)
+
+
+
+#
+# Select the IGEN architecture
+#
+sim_gen=IGEN
+sim_igen_machine="-M brownie32_std"
+sim_igen_filter="32,f"
+sim_mach_default="brownie32_std"
+
+case "${target}" in
+  brownie32*std*)		sim_gen=IGEN
+			sim_igen_filter="32,f"
+			sim_igen_machine="-M brownie32_std"
+			;;
+esac
+
+# The MULTI generator can combine several simulation engines into one.
+# executable.  A configuration which uses the MULTI should set two
+# variables: ${sim_multi_configs} and ${sim_multi_default}.
+#
+# ${sim_multi_configs} is the list of engines to build.  Each
+# space-separated entry has the form NAME:MACHINE:FILTER:BFDMACHS,
+# where:
+#
+# - NAME is a C-compatible prefix for the engine,
+# - MACHINE is a -M argument,
+# - FILTER is a -F argument, and
+# - BFDMACHS is a comma-separated list of bfd machines that the
+#     simulator can run.
+#
+# Each entry will have a separate simulation engine whose prefix is
+# m32<NAME>.  If the machine list includes "brownie3216", there will also
+# be a brownie3216 engine, prefix m16<NAME>.  The brownie3216 engine will be
+# generated using the same machine list as the 32-bit version,
+# but the filter will be "16" instead of FILTER.
+#
+# The simulator compares the bfd mach against BFDMACHS to decide
+# which engine to use.  Entries in BFDMACHS should be bfd_mach
+# values with "bfd_mach_" removed.  ${sim_multi_default} says
+# which entry should be the default.
+if test ${sim_gen} = MULTI; then
+
+  # Simple sanity check.
+  if test -z "${sim_multi_configs}" || test -z "${sim_multi_default}"; then
+    AC_MSG_ERROR(Error in configure.in: MULTI simulator not set up correctly)
+  fi
+
+  # Start in a known state.
+  rm -f multi-include.h multi-run.c
+  sim_multi_flags=
+  sim_multi_src=
+  sim_multi_obj=multi-run.o
+  sim_multi_igen_configs=
+  sim_seen_default=no
+
+  cat << __EOF__ > multi-run.c
+/* Main entry point for MULTI simulators.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+   --
+
+   This file was generated by sim/brownie32/configure.  */
+
+#include "sim-main.h"
+#include "multi-include.h"
+
+#define SD sd
+#define CPU cpu
+
+void
+sim_engine_run (SIM_DESC sd,
+		int next_cpu_nr,
+		int nr_cpus,
+		int signal) /* ignore */
+{
+  int mach;
+
+  if (STATE_ARCHITECTURE (sd) == NULL)
+    mach = bfd_mach_${sim_multi_default};
+  else
+    mach = STATE_ARCHITECTURE (SD)->mach;
+
+  switch (mach)
+    {
+__EOF__
+
+  for fc in ${sim_multi_configs}; do
+
+    # Split up the entry.  ${c} contains the first three elements.
+    # Note: outer sqaure brackets are m4 quotes.
+    c=`echo ${fc} | sed ['s/:[^:]*$//']`
+    bfdmachs=`echo ${fc} | sed 's/.*://'`
+    name=`echo ${c} | sed 's/:.*//'`
+    machine=`echo ${c} | sed 's/.*:\(.*\):.*/\1/'`
+    filter=`echo ${c} | sed 's/.*://'`
+
+    # Build the following lists:
+    #
+    #   sim_multi_flags: all -M and -F flags used by the simulator
+    #   sim_multi_src: all makefile-generated source files
+    #   sim_multi_obj: the objects for ${sim_multi_src}
+    #   sim_multi_igen_configs: igen configuration strings.
+    #
+    # Each entry in ${sim_multi_igen_configs} is a prefix (m32
+    # or m16) followed by the NAME, MACHINE and FILTER part of
+    # the ${sim_multi_configs} entry.
+    sim_multi_flags="${sim_multi_flags} -F ${filter} -M ${machine}"
+
+    # Check whether brownie3216 handling is needed.
+    case ${c} in
+      *:*brownie3216*:*)
+	# Run igen twice, once for normal mode and once for brownie3216.
+	ws="m32 m16"
+
+	# The top-level function for the brownie3216 simulator is
+	# in a file m16${name}_run.c, generated by the
+	# tmp-run-multi Makefile rule.
+	sim_multi_src="${sim_multi_src} m16${name}_run.c"
+	sim_multi_obj="${sim_multi_obj} m16${name}_run.o"
+	sim_multi_flags="${sim_multi_flags} -F 16"
+	;;
+      *)
+	ws=m32
+	;;
+    esac
+
+    # Now add the list of igen-generated files to ${sim_multi_src}
+    # and ${sim_multi_obj}.
+    for w in ${ws}; do
+      for base in engine icache idecode model semantics support; do
+	sim_multi_src="${sim_multi_src} ${w}${name}_${base}.c"
+	sim_multi_src="${sim_multi_src} ${w}${name}_${base}.h"
+	sim_multi_obj="${sim_multi_obj} ${w}${name}_${base}.o"
+      done
+      sim_multi_igen_configs="${sim_multi_igen_configs} ${w}${c}"
+    done
+
+    # Add an include for the engine.h file.  This file declares the
+    # top-level foo_engine_run() function.
+    echo "#include \"${w}${name}_engine.h\"" >> multi-include.h
+
+    # Add case statements for this engine to sim_engine_run().
+    for mach in `echo ${bfdmachs} | sed 's/,/ /g'`; do
+      echo "    case bfd_mach_${mach}:" >> multi-run.c
+      if test ${mach} = ${sim_multi_default}; then
+	echo "    default:" >> multi-run.c
+	sim_seen_default=yes
+      fi
+    done
+    echo "      ${w}${name}_engine_run (sd, next_cpu_nr, nr_cpus, signal);" \
+      >> multi-run.c
+    echo "      break;" >> multi-run.c
+  done
+
+  # Check whether we added a 'default:' label.
+  if test ${sim_seen_default} = no; then
+    AC_MSG_ERROR(Error in configure.in: \${sim_multi_configs} doesn't have an entry for \${sim_multi_default})
+  fi
+
+  cat << __EOF__ >> multi-run.c
+    }
+}
+
+int
+brownie32_mach_multi (SIM_DESC sd)
+{
+  if (STATE_ARCHITECTURE (sd) == NULL)
+    return bfd_mach_${sim_multi_default};
+
+  switch (STATE_ARCHITECTURE (SD)->mach)
+    {
+__EOF__
+
+  # Add case statements for this engine to brownie32_mach_multi().
+  for fc in ${sim_multi_configs}; do
+
+    # Split up the entry.  ${c} contains the first three elements.
+    # Note: outer sqaure brackets are m4 quotes.
+    c=`echo ${fc} | sed ['s/:[^:]*$//']`
+    bfdmachs=`echo ${fc} | sed 's/.*://'`
+
+    for mach in `echo ${bfdmachs} | sed 's/,/ /g'`; do
+      echo "    case bfd_mach_${mach}:" >> multi-run.c
+    done
+  done
+
+  cat << __EOF__ >> multi-run.c
+      return (STATE_ARCHITECTURE (SD)->mach);
+    default:
+      return bfd_mach_${sim_multi_default};
+    }
+}
+__EOF__
+
+  SIM_SUBTARGET="$SIM_SUBTARGET -DBROWNIE32_MACH_MULTI"
+else
+  # For clean-extra
+  sim_multi_src=doesnt-exist.c
+
+  if test x"${sim_mach_default}" = x""; then
+    AC_MSG_ERROR(Error in configure.in: \${sim_mach_default} not defined)
+  fi
+  SIM_SUBTARGET="$SIM_SUBTARGET -DBROWNIE32_MACH_DEFAULT=bfd_mach_${sim_mach_default}"
+fi
+sim_igen_flags="-F ${sim_igen_filter} ${sim_igen_machine} ${sim_igen_smp}"
+sim_m16_flags=" -F ${sim_m16_filter}  ${sim_m16_machine}  ${sim_igen_smp}"
+AC_SUBST(sim_igen_flags)
+AC_SUBST(sim_m16_flags)
+AC_SUBST(sim_gen)
+AC_SUBST(sim_multi_flags)
+AC_SUBST(sim_multi_igen_configs)
+AC_SUBST(sim_multi_src)
+AC_SUBST(sim_multi_obj)
+
+
+#
+# Add simulated hardware devices
+#
+hw_enabled=no
+case "${target}" in
+  brownie32*tx39*)
+	hw_enabled=yes
+	hw_extra_devices="tx3904cpu tx3904irc tx3904tmr tx3904sio" 
+	brownie32_extra_objs="dv-sockser.o"
+	SIM_SUBTARGET="$SIM_SUBTARGET -DTARGET_TX3904=1"
+	;;
+  *)
+	brownie32_extra_objs="" 
+	;;
+esac
+SIM_AC_OPTION_HARDWARE($hw_enabled,$hw_devices,$hw_extra_devices)
+AC_SUBST(brownie32_extra_objs)
+
+
+# Choose simulator engine
+case "${target}" in
+  *)    brownie32_igen_engine="engine.o"
+	;;
+esac
+AC_SUBST(brownie32_igen_engine)
+
+
+AC_PATH_X
+brownie32_extra_libs=""
+AC_SUBST(brownie32_extra_libs)
+
+AC_CHECK_HEADERS(string.h strings.h stdlib.h stdlib.h)
+AC_CHECK_LIB(m, fabs)
+AC_CHECK_FUNCS(aint anint sqrt)
+
+SIM_AC_OUTPUT
Index: sim/brownie32/cp1.c
===================================================================
RCS file: sim/brownie32/cp1.c
diff -N sim/brownie32/cp1.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/cp1.c	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,1585 @@
+/*> cp1.c <*/
+/* MIPS Simulator FPU (CoProcessor 1) support.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   Originally created by Cygnus Solutions.  Extensive modifications,
+   including paired-single operation support and MIPS-3D support
+   contributed by Ed Satterthwaite and Chris Demetriou, of Broadcom
+   Corporation (SiByte).
+
+This file is part of GDB, the GNU debugger.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* XXX: The following notice should be removed as soon as is practical:  */
+/* Floating Point Support for gdb MIPS simulators
+
+   This file is part of the MIPS sim
+
+		THIS SOFTWARE IS NOT COPYRIGHTED
+   (by Cygnus.)
+
+   Cygnus offers the following for use in the public domain.  Cygnus
+   makes no warranty with regard to the software or it's performance
+   and the user accepts the software "AS IS" with all faults.
+
+   CYGNUS DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD TO
+   THIS SOFTWARE INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+
+   (Originally, this code was in interp.c)
+*/
+#if 0
+#include "sim-main.h"
+
+/* Within cp1.c we refer to sim_cpu directly.  */
+#define CPU cpu
+#define SD CPU_STATE(cpu)
+
+/*-- FPU support routines ---------------------------------------------------*/
+
+/* Numbers are held in normalized form. The SINGLE and DOUBLE binary
+   formats conform to ANSI/IEEE Std 754-1985.
+
+   SINGLE precision floating:
+      seeeeeeeefffffffffffffffffffffff
+        s =  1bit  = sign
+        e =  8bits = exponent
+        f = 23bits = fraction
+
+   SINGLE precision fixed:
+      siiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
+        s =  1bit  = sign
+        i = 31bits = integer
+
+   DOUBLE precision floating:
+      seeeeeeeeeeeffffffffffffffffffffffffffffffffffffffffffffffffffff
+        s =  1bit  = sign
+        e = 11bits = exponent
+        f = 52bits = fraction
+
+   DOUBLE precision fixed:
+      siiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
+        s =  1bit  = sign
+        i = 63bits = integer
+
+   PAIRED SINGLE precision floating:
+      seeeeeeeefffffffffffffffffffffffseeeeeeeefffffffffffffffffffffff
+      |         upper                ||         lower                |
+        s =  1bit  = sign
+        e =  8bits = exponent
+        f = 23bits = fraction
+    Note: upper = [63..32], lower = [31..0]
+ */
+
+/* Extract packed single values:  */
+#define FP_PS_upper(v) (((v) >> 32) & (unsigned)0xFFFFFFFF)
+#define FP_PS_lower(v) ((v) & (unsigned)0xFFFFFFFF)
+#define FP_PS_cat(u,l) (((unsigned64)((u) & (unsigned)0xFFFFFFFF) << 32) \
+                        | (unsigned64)((l) & 0xFFFFFFFF))
+
+/* Explicit QNaN values.  */
+#define FPQNaN_SINGLE   (0x7FBFFFFF)
+#define FPQNaN_WORD     (0x7FFFFFFF)
+#define FPQNaN_DOUBLE   (UNSIGNED64 (0x7FF7FFFFFFFFFFFF))
+#define FPQNaN_LONG     (UNSIGNED64 (0x7FFFFFFFFFFFFFFF))
+#define FPQNaN_PS       (FP_PS_cat (FPQNaN_SINGLE, FPQNaN_SINGLE))
+
+static const char *fpu_format_name (FP_formats fmt);
+#ifdef DEBUG
+static const char *fpu_rounding_mode_name (int rm);
+#endif
+
+uword64
+value_fpr (sim_cpu *cpu,
+	   address_word cia,
+	   int fpr,
+	   FP_formats fmt)
+{
+  uword64 value = 0;
+  int err = 0;
+
+  /* Treat unused register values, as fixed-point 64bit values.  */
+  if ((fmt == fmt_uninterpreted) || (fmt == fmt_unknown))
+    {
+#if 1
+      /* If request to read data as "uninterpreted", then use the current
+	 encoding:  */
+      fmt = FPR_STATE[fpr];
+#else
+      fmt = fmt_long;
+#endif
+    }
+
+  /* For values not yet accessed, set to the desired format.  */
+  if (FPR_STATE[fpr] == fmt_uninterpreted)
+    {
+      FPR_STATE[fpr] = fmt;
+#ifdef DEBUG
+      printf ("DBG: Register %d was fmt_uninterpreted. Now %s\n", fpr,
+	      fpu_format_name (fmt));
+#endif /* DEBUG */
+    }
+  if (fmt != FPR_STATE[fpr])
+    {
+      sim_io_eprintf (SD, "FPR %d (format %s) being accessed with format %s - setting to unknown (PC = 0x%s)\n",
+		      fpr, fpu_format_name (FPR_STATE[fpr]),
+		      fpu_format_name (fmt), pr_addr (cia));
+      FPR_STATE[fpr] = fmt_unknown;
+    }
+
+  if (FPR_STATE[fpr] == fmt_unknown)
+    {
+      /* Set QNaN value:  */
+      switch (fmt)
+	{
+	case fmt_single:  value = FPQNaN_SINGLE;  break;
+	case fmt_double:  value = FPQNaN_DOUBLE;  break;
+	case fmt_word:    value = FPQNaN_WORD;    break;
+	case fmt_long:    value = FPQNaN_LONG;    break;
+	case fmt_ps:      value = FPQNaN_PS;      break;
+	default:          err = -1;               break;
+	}
+    }
+  else if (SizeFGR () == 64)
+    {
+      switch (fmt)
+	{
+	case fmt_single:
+	case fmt_word:
+	  value = (FGR[fpr] & 0xFFFFFFFF);
+	  break;
+
+	case fmt_uninterpreted:
+	case fmt_double:
+	case fmt_long:
+	case fmt_ps:
+	  value = FGR[fpr];
+	  break;
+
+	default:
+	  err = -1;
+	  break;
+	}
+    }
+  else
+    {
+      switch (fmt)
+	{
+	case fmt_single:
+	case fmt_word:
+	  value = (FGR[fpr] & 0xFFFFFFFF);
+	  break;
+
+	case fmt_uninterpreted:
+	case fmt_double:
+	case fmt_long:
+	  if ((fpr & 1) == 0)
+	    {
+	      /* Even register numbers only.  */
+#ifdef DEBUG
+	      printf ("DBG: ValueFPR: FGR[%d] = %s, FGR[%d] = %s\n",
+		      fpr + 1, pr_uword64 ((uword64) FGR[fpr+1]),
+		      fpr, pr_uword64 ((uword64) FGR[fpr]));
+#endif
+	      value = ((((uword64) FGR[fpr+1]) << 32)
+		       | (FGR[fpr] & 0xFFFFFFFF));
+	    }
+	  else
+	    {
+	      SignalException (ReservedInstruction, 0);
+	    }
+	  break;
+
+	case fmt_ps:
+	  SignalException (ReservedInstruction, 0);
+	  break;
+
+	default:
+	  err = -1;
+	  break;
+	}
+    }
+
+  if (err)
+    SignalExceptionSimulatorFault ("Unrecognised FP format in ValueFPR ()");
+
+#ifdef DEBUG
+  printf ("DBG: ValueFPR: fpr = %d, fmt = %s, value = 0x%s : PC = 0x%s : SizeFGR () = %d\n",
+	  fpr, fpu_format_name (fmt), pr_uword64 (value), pr_addr (cia),
+	  SizeFGR ());
+#endif /* DEBUG */
+
+  return (value);
+}
+
+void
+store_fpr (sim_cpu *cpu,
+	   address_word cia,
+	   int fpr,
+	   FP_formats fmt,
+	   uword64 value)
+{
+  int err = 0;
+
+#ifdef DEBUG
+  printf ("DBG: StoreFPR: fpr = %d, fmt = %s, value = 0x%s : PC = 0x%s : SizeFGR () = %d, \n",
+	  fpr, fpu_format_name (fmt), pr_uword64 (value), pr_addr (cia),
+	  SizeFGR ());
+#endif /* DEBUG */
+
+  if (SizeFGR () == 64)
+    {
+      switch (fmt)
+	{
+	case fmt_uninterpreted_32:
+	  fmt = fmt_uninterpreted;
+	case fmt_single:
+	case fmt_word:
+	  if (STATE_VERBOSE_P (SD))
+	    sim_io_eprintf (SD,
+			    "Warning: PC 0x%s: interp.c store_fpr DEADCODE\n",
+			    pr_addr (cia));
+	  FGR[fpr] = (((uword64) 0xDEADC0DE << 32) | (value & 0xFFFFFFFF));
+	  FPR_STATE[fpr] = fmt;
+	  break;
+
+	case fmt_uninterpreted_64:
+	  fmt = fmt_uninterpreted;
+	case fmt_uninterpreted:
+	case fmt_double:
+	case fmt_long:
+	case fmt_ps:
+	  FGR[fpr] = value;
+	  FPR_STATE[fpr] = fmt;
+	  break;
+
+	default:
+	  FPR_STATE[fpr] = fmt_unknown;
+	  err = -1;
+	  break;
+	}
+    }
+  else
+    {
+      switch (fmt)
+	{
+	case fmt_uninterpreted_32:
+	  fmt = fmt_uninterpreted;
+	case fmt_single:
+	case fmt_word:
+	  FGR[fpr] = (value & 0xFFFFFFFF);
+	  FPR_STATE[fpr] = fmt;
+	  break;
+
+	case fmt_uninterpreted_64:
+	  fmt = fmt_uninterpreted;
+	case fmt_uninterpreted:
+	case fmt_double:
+	case fmt_long:
+	  if ((fpr & 1) == 0)
+	    {
+	      /* Even register numbers only.  */
+	      FGR[fpr+1] = (value >> 32);
+	      FGR[fpr] = (value & 0xFFFFFFFF);
+	      FPR_STATE[fpr + 1] = fmt;
+	      FPR_STATE[fpr] = fmt;
+	    }
+	  else
+	    {
+	      FPR_STATE[fpr] = fmt_unknown;
+	      FPR_STATE[fpr + 1] = fmt_unknown;
+	      SignalException (ReservedInstruction, 0);
+	    }
+	  break;
+
+	case fmt_ps:
+	  FPR_STATE[fpr] = fmt_unknown;
+	  SignalException (ReservedInstruction, 0);
+	  break;
+
+	default:
+	  FPR_STATE[fpr] = fmt_unknown;
+	  err = -1;
+	  break;
+	}
+    }
+
+  if (err)
+    SignalExceptionSimulatorFault ("Unrecognised FP format in StoreFPR ()");
+
+#ifdef DEBUG
+  printf ("DBG: StoreFPR: fpr[%d] = 0x%s (format %s)\n",
+	  fpr, pr_uword64 (FGR[fpr]), fpu_format_name (fmt));
+#endif /* DEBUG */
+
+  return;
+}
+
+
+/* CP1 control/status register access functions.  */
+
+void
+test_fcsr (sim_cpu *cpu,
+	   address_word cia)
+{
+  unsigned int cause;
+
+  cause = (FCSR & fcsr_CAUSE_mask) >> fcsr_CAUSE_shift;
+  if ((cause & ((FCSR & fcsr_ENABLES_mask) >> fcsr_ENABLES_shift)) != 0
+      || (cause & (1 << UO)))
+    {
+      SignalExceptionFPE();
+    }
+}
+
+unsigned_word
+value_fcr(sim_cpu *cpu,
+	  address_word cia,
+	  int fcr)
+{
+  unsigned32 value = 0;
+
+  switch (fcr)
+    {
+    case 0:  /* FP Implementation and Revision Register.  */
+      value = FCR0;
+      break;
+    case 25:  /* FP Condition Codes Register (derived from FCSR).  */
+      value = (FCR31 & fcsr_FCC_mask) >> fcsr_FCC_shift;
+      value = (value & 0x1) | (value >> 1);   /* Close FCC gap.  */
+      break;
+    case 26:  /* FP Exceptions Register (derived from FCSR).  */
+      value = FCR31 & (fcsr_CAUSE_mask | fcsr_FLAGS_mask);
+      break;
+    case 28:  /* FP Enables Register (derived from FCSR).  */
+      value = FCR31 & (fcsr_ENABLES_mask | fcsr_RM_mask);
+      if ((FCR31 & fcsr_FS) != 0)
+	value |= fenr_FS;
+      break;
+    case 31:  /* FP Control/Status Register (FCSR).  */
+      value = FCR31 & ~fcsr_ZERO_mask;
+      break;
+    }
+
+  return (EXTEND32 (value));
+}
+
+void
+store_fcr(sim_cpu *cpu,
+	  address_word cia,
+	  int fcr,
+	  unsigned_word value)
+{
+  unsigned32 v;
+
+  v = VL4_8(value);
+  switch (fcr)
+    {
+    case 25:  /* FP Condition Codes Register (stored into FCSR).  */
+      v = (v << 1) | (v & 0x1);             /* Adjust for FCC gap.  */
+      FCR31 &= ~fcsr_FCC_mask;
+      FCR31 |= ((v << fcsr_FCC_shift) & fcsr_FCC_mask);
+      break;
+    case 26:  /* FP Exceptions Register (stored into FCSR).  */
+      FCR31 &= ~(fcsr_CAUSE_mask | fcsr_FLAGS_mask);
+      FCR31 |= (v & (fcsr_CAUSE_mask | fcsr_FLAGS_mask));
+      test_fcsr(cpu, cia);
+      break;
+    case 28:  /* FP Enables Register (stored into FCSR).  */
+      if ((v & fenr_FS) != 0)
+	v |= fcsr_FS;
+      else
+	v &= ~fcsr_FS;
+      FCR31 &= (fcsr_FCC_mask | fcsr_CAUSE_mask | fcsr_FLAGS_mask);
+      FCR31 |= (v & (fcsr_FS | fcsr_ENABLES_mask | fcsr_RM_mask));
+      test_fcsr(cpu, cia);
+      break;
+    case 31:  /* FP Control/Status Register (FCSR).  */
+      FCR31 = v & ~fcsr_ZERO_mask;
+      test_fcsr(cpu, cia);
+      break;
+    }
+}
+
+void
+update_fcsr (sim_cpu *cpu,
+	     address_word cia,
+	     sim_fpu_status status)
+{
+  FCSR &= ~fcsr_CAUSE_mask;
+
+  if (status != 0)
+    {
+      unsigned int cause = 0;
+
+      /* map between sim_fpu codes and MIPS FCSR */
+      if (status & (sim_fpu_status_invalid_snan
+		    | sim_fpu_status_invalid_isi
+		    | sim_fpu_status_invalid_idi
+		    | sim_fpu_status_invalid_zdz
+		    | sim_fpu_status_invalid_imz
+		    | sim_fpu_status_invalid_cmp
+		    | sim_fpu_status_invalid_sqrt
+		    | sim_fpu_status_invalid_cvi))
+	cause |= (1 << IO);
+      if (status & sim_fpu_status_invalid_div0)
+	cause |= (1 << DZ);
+      if (status & sim_fpu_status_overflow)
+	cause |= (1 << OF);
+      if (status & sim_fpu_status_underflow)
+	cause |= (1 << UF);
+      if (status & sim_fpu_status_inexact)
+	cause |= (1 << IR);
+#if 0 /* Not yet.  */
+      /* Implicit clearing of other bits by unimplemented done by callers.  */
+      if (status & sim_fpu_status_unimplemented)
+	cause |= (1 << UO);
+#endif
+
+      FCSR |= (cause << fcsr_CAUSE_shift);
+      test_fcsr (cpu, cia);
+      FCSR |= ((cause & ~(1 << UO)) << fcsr_FLAGS_shift);
+    }
+  return;
+}
+
+static sim_fpu_round
+rounding_mode(int rm)
+{
+  sim_fpu_round round;
+
+  switch (rm)
+    {
+    case FP_RM_NEAREST:
+      /* Round result to nearest representable value. When two
+	 representable values are equally near, round to the value
+	 that has a least significant bit of zero (i.e. is even).  */
+      round = sim_fpu_round_near;
+      break;
+    case FP_RM_TOZERO:
+      /* Round result to the value closest to, and not greater in
+	 magnitude than, the result.  */
+      round = sim_fpu_round_zero;
+      break;
+    case FP_RM_TOPINF:
+      /* Round result to the value closest to, and not less than,
+	 the result.  */
+      round = sim_fpu_round_up;
+      break;
+    case FP_RM_TOMINF:
+      /* Round result to the value closest to, and not greater than,
+	 the result.  */
+      round = sim_fpu_round_down;
+      break;
+    default:
+      round = 0;
+      fprintf (stderr, "Bad switch\n");
+      abort ();
+    }
+  return round;
+}
+
+/* When the FS bit is set, MIPS processors return zero for
+   denormalized results and optionally replace denormalized inputs
+   with zero.  When FS is clear, some implementation trap on input
+   and/or output, while other perform the operation in hardware.  */
+static sim_fpu_denorm
+denorm_mode(sim_cpu *cpu)
+{
+  sim_fpu_denorm denorm;
+
+  /* XXX: FIXME: Eventually should be CPU model dependent.  */
+  if (GETFS())
+    denorm = sim_fpu_denorm_zero;
+  else
+    denorm = 0;
+  return denorm;
+}
+
+
+/* Comparison operations.  */
+
+static sim_fpu_status
+fp_test(unsigned64 op1,
+	unsigned64 op2,
+	FP_formats fmt,
+	int abs,
+	int cond,
+	int *condition)
+{
+  sim_fpu wop1;
+  sim_fpu wop2;
+  sim_fpu_status status = 0;
+  int  less, equal, unordered;
+
+  /* The format type has already been checked:  */
+  switch (fmt)
+    {
+    case fmt_single:
+      {
+	sim_fpu_32to (&wop1, op1);
+	sim_fpu_32to (&wop2, op2);
+	break;
+      }
+    case fmt_double:
+      {
+	sim_fpu_64to (&wop1, op1);
+	sim_fpu_64to (&wop2, op2);
+	break;
+      }
+    default:
+      fprintf (stderr, "Bad switch\n");
+      abort ();
+    }
+
+  if (sim_fpu_is_nan (&wop1) || sim_fpu_is_nan (&wop2))
+    {
+      if ((cond & (1 << 3)) ||
+	  sim_fpu_is_snan (&wop1) || sim_fpu_is_snan (&wop2))
+	status = sim_fpu_status_invalid_snan;
+      less = 0;
+      equal = 0;
+      unordered = 1;
+    }
+  else
+    {
+      if (abs)
+	{
+	  status |= sim_fpu_abs (&wop1, &wop1);
+	  status |= sim_fpu_abs (&wop2, &wop2);
+	}
+      equal = sim_fpu_is_eq (&wop1, &wop2);
+      less = !equal && sim_fpu_is_lt (&wop1, &wop2);
+      unordered = 0;
+    }
+  *condition = (((cond & (1 << 2)) && less)
+		|| ((cond & (1 << 1)) && equal)
+		|| ((cond & (1 << 0)) && unordered));
+  return status;
+}
+
+void
+fp_cmp(sim_cpu *cpu,
+       address_word cia,
+       unsigned64 op1,
+       unsigned64 op2,
+       FP_formats fmt,
+       int abs,
+       int cond,
+       int cc)
+{
+  sim_fpu_status status = 0;
+
+  /* The format type should already have been checked.  The FCSR is
+     updated before the condition codes so that any exceptions will
+     be signalled before the condition codes are changed.  */
+  switch (fmt)
+    {
+    case fmt_single:
+    case fmt_double:
+      {
+	int result;
+	status = fp_test(op1, op2, fmt, abs, cond, &result);
+	update_fcsr (cpu, cia, status);
+	SETFCC (cc, result);
+	break;
+      }
+    case fmt_ps:
+      {
+	int result0, result1;
+	status  = fp_test(FP_PS_lower (op1), FP_PS_lower (op2), fmt_single,
+			  abs, cond, &result0);
+	status |= fp_test(FP_PS_upper (op1), FP_PS_upper (op2), fmt_single,
+			  abs, cond, &result1);
+	update_fcsr (cpu, cia, status);
+	SETFCC (cc, result0);
+	SETFCC (cc+1, result1);
+	break;
+      }
+    default:
+      sim_io_eprintf (SD, "Bad switch\n");
+      abort ();
+    }
+}
+
+
+/* Basic arithmetic operations.  */
+
+static unsigned64
+fp_unary(sim_cpu *cpu,
+	 address_word cia,
+	 int (*sim_fpu_op)(sim_fpu *, const sim_fpu *),
+	 unsigned64 op,
+	 FP_formats fmt)
+{
+  sim_fpu wop;
+  sim_fpu ans;
+  sim_fpu_round round = rounding_mode (GETRM());
+  sim_fpu_denorm denorm = denorm_mode (cpu);
+  sim_fpu_status status = 0;
+  unsigned64 result = 0;
+
+  /* The format type has already been checked: */
+  switch (fmt)
+    {
+    case fmt_single:
+      {
+	unsigned32 res;
+	sim_fpu_32to (&wop, op);
+	status |= (*sim_fpu_op) (&ans, &wop);
+	status |= sim_fpu_round_32 (&ans, round, denorm);
+	sim_fpu_to32 (&res, &ans);
+	result = res;
+	break;
+      }
+    case fmt_double:
+      {
+	unsigned64 res;
+	sim_fpu_64to (&wop, op);
+	status |= (*sim_fpu_op) (&ans, &wop);
+	status |= sim_fpu_round_64 (&ans, round, denorm);
+	sim_fpu_to64 (&res, &ans);
+	result = res;
+	break;
+      }
+    case fmt_ps:
+      {
+	int status_u = 0, status_l = 0;
+	unsigned32 res_u, res_l;
+	sim_fpu_32to (&wop, FP_PS_upper(op));
+	status_u |= (*sim_fpu_op) (&ans, &wop);
+	sim_fpu_to32 (&res_u, &ans);
+	sim_fpu_32to (&wop, FP_PS_lower(op));
+	status_l |= (*sim_fpu_op) (&ans, &wop);
+	sim_fpu_to32 (&res_l, &ans);
+	result = FP_PS_cat(res_u, res_l);
+	status = status_u | status_l;
+	break;
+      }
+    default:
+      sim_io_eprintf (SD, "Bad switch\n");
+      abort ();
+    }
+
+  update_fcsr (cpu, cia, status);
+  return result;
+}
+
+static unsigned64
+fp_binary(sim_cpu *cpu,
+	  address_word cia,
+	  int (*sim_fpu_op)(sim_fpu *, const sim_fpu *, const sim_fpu *),
+	  unsigned64 op1,
+	  unsigned64 op2,
+	  FP_formats fmt)
+{
+  sim_fpu wop1;
+  sim_fpu wop2;
+  sim_fpu ans;
+  sim_fpu_round round = rounding_mode (GETRM());
+  sim_fpu_denorm denorm = denorm_mode (cpu);
+  sim_fpu_status status = 0;
+  unsigned64 result = 0;
+
+  /* The format type has already been checked: */
+  switch (fmt)
+    {
+    case fmt_single:
+      {
+	unsigned32 res;
+	sim_fpu_32to (&wop1, op1);
+	sim_fpu_32to (&wop2, op2);
+	status |= (*sim_fpu_op) (&ans, &wop1, &wop2);
+	status |= sim_fpu_round_32 (&ans, round, denorm);
+	sim_fpu_to32 (&res, &ans);
+	result = res;
+	break;
+      }
+    case fmt_double:
+      {
+	unsigned64 res;
+	sim_fpu_64to (&wop1, op1);
+	sim_fpu_64to (&wop2, op2);
+	status |= (*sim_fpu_op) (&ans, &wop1, &wop2);
+	status |= sim_fpu_round_64 (&ans, round, denorm);
+	sim_fpu_to64 (&res, &ans);
+	result = res;
+	break;
+      }
+    case fmt_ps:
+      {
+	int status_u = 0, status_l = 0;
+	unsigned32 res_u, res_l;
+	sim_fpu_32to (&wop1, FP_PS_upper(op1));
+	sim_fpu_32to (&wop2, FP_PS_upper(op2));
+	status_u |= (*sim_fpu_op) (&ans, &wop1, &wop2);
+	sim_fpu_to32 (&res_u, &ans);
+	sim_fpu_32to (&wop1, FP_PS_lower(op1));
+	sim_fpu_32to (&wop2, FP_PS_lower(op2));
+	status_l |= (*sim_fpu_op) (&ans, &wop1, &wop2);
+	sim_fpu_to32 (&res_l, &ans);
+	result = FP_PS_cat(res_u, res_l);
+	status = status_u | status_l;
+	break;
+      }
+    default:
+      sim_io_eprintf (SD, "Bad switch\n");
+      abort ();
+    }
+
+  update_fcsr (cpu, cia, status);
+  return result;
+}
+
+/* Common MAC code for single operands (.s or .d), defers setting FCSR.  */
+static sim_fpu_status
+inner_mac(int (*sim_fpu_op)(sim_fpu *, const sim_fpu *, const sim_fpu *),
+	  unsigned64 op1,
+	  unsigned64 op2,
+	  unsigned64 op3,
+	  int scale,
+	  int negate,
+	  FP_formats fmt,
+	  sim_fpu_round round,
+	  sim_fpu_denorm denorm,
+	  unsigned64 *result)
+{
+  sim_fpu wop1;
+  sim_fpu wop2;
+  sim_fpu ans;
+  sim_fpu_status status = 0;
+  sim_fpu_status op_status;
+  unsigned64 temp = 0;
+
+  switch (fmt)
+    {
+    case fmt_single:
+      {
+	unsigned32 res;
+	sim_fpu_32to (&wop1, op1);
+	sim_fpu_32to (&wop2, op2);
+	status |= sim_fpu_mul (&ans, &wop1, &wop2);
+	if (scale != 0 && sim_fpu_is_number (&ans))  /* number or denorm */
+	  ans.normal_exp += scale;
+	status |= sim_fpu_round_32 (&ans, round, denorm);
+	wop1 = ans;
+        op_status = 0;
+	sim_fpu_32to (&wop2, op3);
+	op_status |= (*sim_fpu_op) (&ans, &wop1, &wop2);
+	op_status |= sim_fpu_round_32 (&ans, round, denorm);
+	status |= op_status;
+	if (negate)
+	  {
+	    wop1 = ans;
+	    op_status = sim_fpu_neg (&ans, &wop1);
+	    op_status |= sim_fpu_round_32 (&ans, round, denorm);
+	    status |= op_status;
+	  }
+	sim_fpu_to32 (&res, &ans);
+	temp = res;
+	break;
+      }
+    case fmt_double:
+      {
+	unsigned64 res;
+	sim_fpu_64to (&wop1, op1);
+	sim_fpu_64to (&wop2, op2);
+	status |= sim_fpu_mul (&ans, &wop1, &wop2);
+	if (scale != 0 && sim_fpu_is_number (&ans))  /* number or denorm */
+	  ans.normal_exp += scale;
+	status |= sim_fpu_round_64 (&ans, round, denorm);
+	wop1 = ans;
+        op_status = 0;
+	sim_fpu_64to (&wop2, op3);
+	op_status |= (*sim_fpu_op) (&ans, &wop1, &wop2);
+	op_status |= sim_fpu_round_64 (&ans, round, denorm);
+	status |= op_status;
+	if (negate)
+	  {
+	    wop1 = ans;
+	    op_status = sim_fpu_neg (&ans, &wop1);
+	    op_status |= sim_fpu_round_64 (&ans, round, denorm);
+	    status |= op_status;
+	  }
+	sim_fpu_to64 (&res, &ans);
+	temp = res;
+	break;
+      }
+    default:
+      fprintf (stderr, "Bad switch\n");
+      abort ();
+    }
+  *result = temp;
+  return status;
+}
+
+/* Common implementation of madd, nmadd, msub, nmsub that does
+   intermediate rounding per spec.  Also used for recip2 and rsqrt2,
+   which are transformed into equivalent nmsub operations.  The scale
+   argument is an adjustment to the exponent of the intermediate
+   product op1*op2.  It is currently non-zero for rsqrt2 (-1), which
+   requires an effective division by 2. */
+static unsigned64
+fp_mac(sim_cpu *cpu,
+       address_word cia,
+       int (*sim_fpu_op)(sim_fpu *, const sim_fpu *, const sim_fpu *),
+       unsigned64 op1,
+       unsigned64 op2,
+       unsigned64 op3,
+       int scale,
+       int negate,
+       FP_formats fmt)
+{
+  sim_fpu_round round = rounding_mode (GETRM());
+  sim_fpu_denorm denorm = denorm_mode (cpu);
+  sim_fpu_status status = 0;
+  unsigned64 result = 0;
+
+  /* The format type has already been checked: */
+  switch (fmt)
+    {
+    case fmt_single:
+    case fmt_double:
+      status = inner_mac(sim_fpu_op, op1, op2, op3, scale,
+			 negate, fmt, round, denorm, &result);
+      break;
+    case fmt_ps:
+      {
+	int status_u, status_l;
+	unsigned64 result_u, result_l;
+	status_u = inner_mac(sim_fpu_op, FP_PS_upper(op1), FP_PS_upper(op2),
+			     FP_PS_upper(op3), scale, negate, fmt_single,
+			     round, denorm, &result_u);
+	status_l = inner_mac(sim_fpu_op, FP_PS_lower(op1), FP_PS_lower(op2),
+			     FP_PS_lower(op3), scale, negate, fmt_single,
+			     round, denorm, &result_l);
+	result = FP_PS_cat(result_u, result_l);
+	status = status_u | status_l;
+	break;
+      }
+    default:
+      sim_io_eprintf (SD, "Bad switch\n");
+      abort ();
+    }
+
+  update_fcsr (cpu, cia, status);
+  return result;
+}
+
+/* Common rsqrt code for single operands (.s or .d), intermediate rounding.  */
+static sim_fpu_status
+inner_rsqrt(unsigned64 op1,
+	    FP_formats fmt,
+	    sim_fpu_round round,
+	    sim_fpu_denorm denorm,
+	    unsigned64 *result)
+{
+  sim_fpu wop1;
+  sim_fpu ans;
+  sim_fpu_status status = 0;
+  sim_fpu_status op_status;
+  unsigned64 temp = 0;
+
+  switch (fmt)
+    {
+    case fmt_single:
+      {
+	unsigned32 res;
+	sim_fpu_32to (&wop1, op1);
+	status |= sim_fpu_sqrt (&ans, &wop1);
+	status |= sim_fpu_round_32 (&ans, status, round);
+	wop1 = ans;
+	op_status = sim_fpu_inv (&ans, &wop1);
+	op_status |= sim_fpu_round_32 (&ans, round, denorm);
+	sim_fpu_to32 (&res, &ans);
+	temp = res;
+	status |= op_status;
+	break;
+      }
+    case fmt_double:
+      {
+	unsigned64 res;
+	sim_fpu_64to (&wop1, op1);
+	status |= sim_fpu_sqrt (&ans, &wop1);
+	status |= sim_fpu_round_64 (&ans, round, denorm);
+	wop1 = ans;
+	op_status = sim_fpu_inv (&ans, &wop1);
+	op_status |= sim_fpu_round_64 (&ans, round, denorm);
+	sim_fpu_to64 (&res, &ans);
+	temp = res;
+	status |= op_status;
+	break;
+      }
+    default:
+      fprintf (stderr, "Bad switch\n");
+      abort ();
+    }
+  *result = temp;
+  return status;
+}
+
+static unsigned64
+fp_inv_sqrt(sim_cpu *cpu,
+	    address_word cia,
+	    unsigned64 op1,
+	    FP_formats fmt)
+{
+  sim_fpu_round round = rounding_mode (GETRM());
+  sim_fpu_round denorm = denorm_mode (cpu);
+  sim_fpu_status status = 0;
+  unsigned64 result = 0;
+
+  /* The format type has already been checked: */
+  switch (fmt)
+    {
+    case fmt_single:
+    case fmt_double:
+      status = inner_rsqrt (op1, fmt, round, denorm, &result);
+      break;
+    case fmt_ps:
+      {
+	int status_u, status_l;
+	unsigned64 result_u, result_l;
+	status_u = inner_rsqrt (FP_PS_upper(op1), fmt_single, round, denorm,
+				&result_u);
+	status_l = inner_rsqrt (FP_PS_lower(op1), fmt_single, round, denorm,
+				&result_l);
+	result = FP_PS_cat(result_u, result_l);
+	status = status_u | status_l;
+	break;
+      }
+    default:
+      sim_io_eprintf (SD, "Bad switch\n");
+      abort ();
+    }
+
+  update_fcsr (cpu, cia, status);
+  return result;
+}
+
+
+unsigned64
+fp_abs(sim_cpu *cpu,
+       address_word cia,
+       unsigned64 op,
+       FP_formats fmt)
+{
+  return fp_unary(cpu, cia, &sim_fpu_abs, op, fmt);
+}
+
+unsigned64
+fp_neg(sim_cpu *cpu,
+       address_word cia,
+       unsigned64 op,
+       FP_formats fmt)
+{
+  return fp_unary(cpu, cia, &sim_fpu_neg, op, fmt);
+}
+
+unsigned64
+fp_add(sim_cpu *cpu,
+       address_word cia,
+       unsigned64 op1,
+       unsigned64 op2,
+       FP_formats fmt)
+{
+  return fp_binary(cpu, cia, &sim_fpu_add, op1, op2, fmt);
+}
+
+unsigned64
+fp_sub(sim_cpu *cpu,
+       address_word cia,
+       unsigned64 op1,
+       unsigned64 op2,
+       FP_formats fmt)
+{
+  return fp_binary(cpu, cia, &sim_fpu_sub, op1, op2, fmt);
+}
+
+unsigned64
+fp_mul(sim_cpu *cpu,
+       address_word cia,
+       unsigned64 op1,
+       unsigned64 op2,
+       FP_formats fmt)
+{
+  return fp_binary(cpu, cia, &sim_fpu_mul, op1, op2, fmt);
+}
+
+unsigned64
+fp_div(sim_cpu *cpu,
+       address_word cia,
+       unsigned64 op1,
+       unsigned64 op2,
+       FP_formats fmt)
+{
+  return fp_binary(cpu, cia, &sim_fpu_div, op1, op2, fmt);
+}
+
+unsigned64
+fp_recip(sim_cpu *cpu,
+         address_word cia,
+         unsigned64 op,
+         FP_formats fmt)
+{
+  return fp_unary(cpu, cia, &sim_fpu_inv, op, fmt);
+}
+
+unsigned64
+fp_sqrt(sim_cpu *cpu,
+        address_word cia,
+        unsigned64 op,
+        FP_formats fmt)
+{
+  return fp_unary(cpu, cia, &sim_fpu_sqrt, op, fmt);
+}
+
+unsigned64
+fp_rsqrt(sim_cpu *cpu,
+         address_word cia,
+         unsigned64 op,
+         FP_formats fmt)
+{
+  return fp_inv_sqrt(cpu, cia, op, fmt);
+}
+
+unsigned64
+fp_madd(sim_cpu *cpu,
+        address_word cia,
+        unsigned64 op1,
+        unsigned64 op2,
+        unsigned64 op3,
+        FP_formats fmt)
+{
+  return fp_mac(cpu, cia, &sim_fpu_add, op1, op2, op3, 0, 0, fmt);
+}
+
+unsigned64
+fp_msub(sim_cpu *cpu,
+        address_word cia,
+        unsigned64 op1,
+        unsigned64 op2,
+        unsigned64 op3,
+        FP_formats fmt)
+{
+  return fp_mac(cpu, cia, &sim_fpu_sub, op1, op2, op3, 0, 0, fmt);
+}
+
+unsigned64
+fp_nmadd(sim_cpu *cpu,
+         address_word cia,
+         unsigned64 op1,
+         unsigned64 op2,
+         unsigned64 op3,
+         FP_formats fmt)
+{
+  return fp_mac(cpu, cia, &sim_fpu_add, op1, op2, op3, 0, 1, fmt);
+}
+
+unsigned64
+fp_nmsub(sim_cpu *cpu,
+         address_word cia,
+         unsigned64 op1,
+         unsigned64 op2,
+         unsigned64 op3,
+         FP_formats fmt)
+{
+  return fp_mac(cpu, cia, &sim_fpu_sub, op1, op2, op3, 0, 1, fmt);
+}
+
+
+/* MIPS-3D ASE operations.  */
+
+/* Variant of fp_binary for *r.ps MIPS-3D operations. */
+static unsigned64
+fp_binary_r(sim_cpu *cpu,
+	    address_word cia,
+	    int (*sim_fpu_op)(sim_fpu *, const sim_fpu *, const sim_fpu *),
+	    unsigned64 op1,
+	    unsigned64 op2) 
+{
+  sim_fpu wop1;
+  sim_fpu wop2;
+  sim_fpu ans;
+  sim_fpu_round round = rounding_mode (GETRM ());
+  sim_fpu_denorm denorm = denorm_mode (cpu);
+  sim_fpu_status status_u, status_l;
+  unsigned64 result;
+  unsigned32 res_u, res_l;
+
+  /* The format must be fmt_ps.  */
+  status_u = 0;
+  sim_fpu_32to (&wop1, FP_PS_upper (op1));
+  sim_fpu_32to (&wop2, FP_PS_lower (op1));
+  status_u |= (*sim_fpu_op) (&ans, &wop1, &wop2);
+  status_u |= sim_fpu_round_32 (&ans, round, denorm);
+  sim_fpu_to32 (&res_u, &ans);
+  status_l = 0;
+  sim_fpu_32to (&wop1, FP_PS_upper (op2));
+  sim_fpu_32to (&wop2, FP_PS_lower (op2));
+  status_l |= (*sim_fpu_op) (&ans, &wop1, &wop2);
+  status_l |= sim_fpu_round_32 (&ans, round, denorm);
+  sim_fpu_to32 (&res_l, &ans);
+  result = FP_PS_cat (res_u, res_l);
+
+  update_fcsr (cpu, cia, status_u | status_l);
+  return result;
+}
+
+unsigned64
+fp_add_r(sim_cpu *cpu,
+         address_word cia,
+         unsigned64 op1,
+         unsigned64 op2,
+         FP_formats fmt)
+{
+  return fp_binary_r (cpu, cia, &sim_fpu_add, op1, op2);
+}
+
+unsigned64
+fp_mul_r(sim_cpu *cpu,
+         address_word cia,
+         unsigned64 op1,
+         unsigned64 op2,
+         FP_formats fmt)
+{
+  return fp_binary_r (cpu, cia, &sim_fpu_mul, op1, op2);
+}
+
+#define NR_FRAC_GUARD   (60)
+#define IMPLICIT_1 LSBIT64 (NR_FRAC_GUARD)
+
+static int
+fpu_inv1(sim_fpu *f, const sim_fpu *l)
+{
+  static const sim_fpu sim_fpu_one = {
+    sim_fpu_class_number, 0, IMPLICIT_1, 0
+  };
+  int  status = 0;
+  sim_fpu t;
+
+  if (sim_fpu_is_zero (l))
+    {
+      *f = sim_fpu_maxfp;
+      f->sign = l->sign;
+      return sim_fpu_status_invalid_div0;
+    }
+  if (sim_fpu_is_infinity (l))
+    {
+      *f = sim_fpu_zero;
+      f->sign = l->sign;
+      return status;
+    }
+  status |= sim_fpu_div (f, &sim_fpu_one, l);
+  return status;
+}
+
+static int
+fpu_inv1_32(sim_fpu *f, const sim_fpu *l)
+{
+  if (sim_fpu_is_zero (l))
+    {
+      *f = sim_fpu_max32;
+      f->sign = l->sign;
+      return sim_fpu_status_invalid_div0;
+    }
+  return fpu_inv1 (f, l);
+}
+
+static int
+fpu_inv1_64(sim_fpu *f, const sim_fpu *l)
+{
+  if (sim_fpu_is_zero (l))
+    {
+      *f = sim_fpu_max64;
+      f->sign = l->sign;
+      return sim_fpu_status_invalid_div0;
+    }
+  return fpu_inv1 (f, l);
+}
+
+unsigned64
+fp_recip1(sim_cpu *cpu,
+          address_word cia,
+          unsigned64 op,
+          FP_formats fmt)
+{
+  switch (fmt)
+    {
+    case fmt_single:
+    case fmt_ps:
+      return fp_unary (cpu, cia, &fpu_inv1_32, op, fmt);
+    case fmt_double:
+      return fp_unary (cpu, cia, &fpu_inv1_64, op, fmt);
+    }
+  return 0;
+}
+
+unsigned64
+fp_recip2(sim_cpu *cpu,
+          address_word cia,
+          unsigned64 op1,
+          unsigned64 op2,
+          FP_formats fmt)
+{
+  static const unsigned64 one_single = UNSIGNED64 (0x3F800000);
+  static const unsigned64 one_double = UNSIGNED64 (0x3FF0000000000000);
+  static const unsigned64 one_ps = (UNSIGNED64 (0x3F800000) << 32 | UNSIGNED64 (0x3F800000));
+  unsigned64 one;
+
+  /* Implemented as nmsub fd, 1, fs, ft.  */
+  switch (fmt)
+    {
+    case fmt_single:  one = one_single;  break;
+    case fmt_double:  one = one_double;  break;
+    case fmt_ps:      one = one_ps;      break;
+    default:          one = 0;           abort ();
+    }
+  return fp_mac (cpu, cia, &sim_fpu_sub, op1, op2, one, 0, 1, fmt);
+}
+
+static int
+fpu_inv_sqrt1(sim_fpu *f, const sim_fpu *l)
+{
+  static const sim_fpu sim_fpu_one = {
+    sim_fpu_class_number, 0, IMPLICIT_1, 0
+  };
+  int  status = 0;
+  sim_fpu t;
+
+  if (sim_fpu_is_zero (l))
+    {
+      *f = sim_fpu_maxfp;
+      f->sign = l->sign;
+      return sim_fpu_status_invalid_div0;
+    }
+  if (sim_fpu_is_infinity (l))
+    {
+      if (!l->sign)
+	{
+	  f->class = sim_fpu_class_zero;
+	  f->sign = 0;
+	}
+      else
+	{
+	  *f = sim_fpu_qnan;
+	  status = sim_fpu_status_invalid_sqrt;
+	}
+      return status;
+    }
+  status |= sim_fpu_sqrt (&t, l);
+  status |= sim_fpu_div (f, &sim_fpu_one, &t);
+  return status;
+}
+
+static int
+fpu_inv_sqrt1_32(sim_fpu *f, const sim_fpu *l)
+{
+  if (sim_fpu_is_zero (l))
+    {
+      *f = sim_fpu_max32;
+      f->sign = l->sign;
+      return sim_fpu_status_invalid_div0;
+    }
+  return fpu_inv_sqrt1 (f, l);
+}
+
+static int
+fpu_inv_sqrt1_64(sim_fpu *f, const sim_fpu *l)
+{
+  if (sim_fpu_is_zero (l))
+    {
+      *f = sim_fpu_max64;
+      f->sign = l->sign;
+      return sim_fpu_status_invalid_div0;
+    }
+  return fpu_inv_sqrt1 (f, l);
+}
+
+unsigned64
+fp_rsqrt1(sim_cpu *cpu,
+          address_word cia,
+          unsigned64 op,
+          FP_formats fmt)
+{
+  switch (fmt)
+    {
+    case fmt_single:
+    case fmt_ps:
+      return fp_unary (cpu, cia, &fpu_inv_sqrt1_32, op, fmt);
+    case fmt_double:
+      return fp_unary (cpu, cia, &fpu_inv_sqrt1_64, op, fmt);
+    }
+  return 0;
+}
+
+unsigned64
+fp_rsqrt2(sim_cpu *cpu,
+          address_word cia,
+          unsigned64 op1,
+          unsigned64 op2,
+          FP_formats fmt)
+{
+  static const unsigned64 half_single = UNSIGNED64 (0x3F000000);
+  static const unsigned64 half_double = UNSIGNED64 (0x3FE0000000000000);
+  static const unsigned64 half_ps = (UNSIGNED64 (0x3F000000) << 32 | UNSIGNED64 (0x3F000000));
+  unsigned64 half;
+
+  /* Implemented as (nmsub fd, 0.5, fs, ft)/2, where the divide is
+     done by scaling the exponent during multiply.  */
+  switch (fmt)
+    {
+    case fmt_single:  half = half_single;  break;
+    case fmt_double:  half = half_double;  break;
+    case fmt_ps:      half = half_ps;      break;
+    default:          half = 0;            abort ();
+    }
+  return fp_mac (cpu, cia, &sim_fpu_sub, op1, op2, half, -1, 1, fmt);
+}
+
+
+/* Conversion operations.  */
+
+uword64
+convert (sim_cpu *cpu,
+	 address_word cia,
+	 int rm,
+	 uword64 op,
+	 FP_formats from,
+	 FP_formats to)
+{
+  sim_fpu wop;
+  sim_fpu_round round = rounding_mode (rm);
+  sim_fpu_denorm denorm = denorm_mode (cpu);
+  unsigned32 result32;
+  unsigned64 result64;
+  sim_fpu_status status = 0;
+
+  /* Convert the input to sim_fpu internal format */
+  switch (from)
+    {
+    case fmt_double:
+      sim_fpu_64to (&wop, op);
+      break;
+    case fmt_single:
+      sim_fpu_32to (&wop, op);
+      break;
+    case fmt_word:
+      status = sim_fpu_i32to (&wop, op, round);
+      break;
+    case fmt_long:
+      status = sim_fpu_i64to (&wop, op, round);
+      break;
+    default:
+      sim_io_eprintf (SD, "Bad switch\n");
+      abort ();
+    }
+
+  /* Convert sim_fpu format into the output */
+  /* The value WOP is converted to the destination format, rounding
+     using mode RM. When the destination is a fixed-point format, then
+     a source value of Infinity, NaN or one which would round to an
+     integer outside the fixed point range then an IEEE Invalid Operation
+     condition is raised.  Not used if destination format is PS.  */
+  switch (to)
+    {
+    case fmt_single:
+      status |= sim_fpu_round_32 (&wop, round, denorm);
+      /* For a NaN, normalize mantissa bits (cvt.s.d can't preserve them) */
+      if (sim_fpu_is_qnan (&wop))
+	wop = sim_fpu_qnan;
+      sim_fpu_to32 (&result32, &wop);
+      result64 = result32;
+      break;
+    case fmt_double:
+      status |= sim_fpu_round_64 (&wop, round, denorm);
+      /* For a NaN, normalize mantissa bits (make cvt.d.s consistent) */
+      if (sim_fpu_is_qnan (&wop))
+	wop = sim_fpu_qnan;
+      sim_fpu_to64 (&result64, &wop);
+      break;
+    case fmt_word:
+      status |= sim_fpu_to32i (&result32, &wop, round);
+      result64 = result32;
+      break;
+    case fmt_long:
+      status |= sim_fpu_to64i (&result64, &wop, round);
+      break;
+    default:
+      result64 = 0;
+      sim_io_eprintf (SD, "Bad switch\n");
+      abort ();
+    }
+
+  update_fcsr (cpu, cia, status);
+  return result64;
+}
+
+unsigned64
+ps_lower(sim_cpu *cpu,
+         address_word cia,
+         unsigned64 op)
+{
+  return FP_PS_lower (op);
+}
+
+unsigned64
+ps_upper(sim_cpu *cpu,
+         address_word cia,
+         unsigned64 op)
+{
+  return FP_PS_upper(op);
+}
+
+unsigned64
+pack_ps(sim_cpu *cpu,
+        address_word cia,
+        unsigned64 op1,
+        unsigned64 op2,
+        FP_formats fmt)
+{
+  unsigned64 result = 0;
+
+  /* The registers must specify FPRs valid for operands of type
+     "fmt". If they are not valid, the result is undefined. */
+
+  /* The format type should already have been checked: */
+  switch (fmt)
+    {
+    case fmt_single:
+      {
+	sim_fpu wop;
+	unsigned32 res_u, res_l;
+	sim_fpu_32to (&wop, op1);
+	sim_fpu_to32 (&res_u, &wop);
+	sim_fpu_32to (&wop, op2);
+	sim_fpu_to32 (&res_l, &wop);
+	result = FP_PS_cat(res_u, res_l);
+	break;
+      }
+    default:
+      sim_io_eprintf (SD, "Bad switch\n");
+      abort ();
+    }
+
+  return result;
+}
+
+unsigned64
+convert_ps (sim_cpu *cpu,
+            address_word cia,
+            int rm,
+            unsigned64 op,
+            FP_formats from,
+            FP_formats to)
+{
+  sim_fpu wop_u, wop_l;
+  sim_fpu_round round = rounding_mode (rm);
+  sim_fpu_denorm denorm = denorm_mode (cpu);
+  unsigned32 res_u, res_l;
+  unsigned64 result;
+  sim_fpu_status status_u = 0, status_l = 0;
+
+  /* As convert, but used only for paired values (formats PS, PW) */
+
+  /* Convert the input to sim_fpu internal format */
+  switch (from)
+    {
+    case fmt_word:   /* fmt_pw */
+      sim_fpu_i32to (&wop_u, (op >> 32) & (unsigned)0xFFFFFFFF, round);
+      sim_fpu_i32to (&wop_l, op & (unsigned)0xFFFFFFFF, round);
+      break;
+    case fmt_ps:
+      sim_fpu_32to (&wop_u, FP_PS_upper(op));
+      sim_fpu_32to (&wop_l, FP_PS_lower(op));
+      break;
+    default:
+      sim_io_eprintf (SD, "Bad switch\n");
+      abort ();
+    }
+
+  /* Convert sim_fpu format into the output */
+  switch (to)
+    {
+    case fmt_word:   /* fmt_pw */
+      status_u |= sim_fpu_to32i (&res_u, &wop_u, round);
+      status_l |= sim_fpu_to32i (&res_l, &wop_l, round);
+      result = (((unsigned64)res_u) << 32) | (unsigned64)res_l;
+      break;
+    case fmt_ps:
+      status_u |= sim_fpu_round_32 (&wop_u, 0, round);
+      status_l |= sim_fpu_round_32 (&wop_l, 0, round);
+      sim_fpu_to32 (&res_u, &wop_u);
+      sim_fpu_to32 (&res_l, &wop_l);
+      result = FP_PS_cat(res_u, res_l);
+      break;
+    default:
+      result = 0;
+      sim_io_eprintf (SD, "Bad switch\n");
+      abort ();
+    }
+
+  update_fcsr (cpu, cia, status_u | status_l);
+  return result;
+}
+
+static const char *
+fpu_format_name (FP_formats fmt)
+{
+  switch (fmt)
+    {
+    case fmt_single:
+      return "single";
+    case fmt_double:
+      return "double";
+    case fmt_word:
+      return "word";
+    case fmt_long:
+      return "long";
+    case fmt_ps:
+      return "ps";
+    case fmt_unknown:
+      return "<unknown>";
+    case fmt_uninterpreted:
+      return "<uninterpreted>";
+    case fmt_uninterpreted_32:
+      return "<uninterpreted_32>";
+    case fmt_uninterpreted_64:
+      return "<uninterpreted_64>";
+    default:
+      return "<format error>";
+    }
+}
+
+#ifdef DEBUG
+static const char *
+fpu_rounding_mode_name (int rm)
+{
+  switch (rm)
+    {
+    case FP_RM_NEAREST:
+      return "Round";
+    case FP_RM_TOZERO:
+      return "Trunc";
+    case FP_RM_TOPINF:
+      return "Ceil";
+    case FP_RM_TOMINF:
+      return "Floor";
+    default:
+      return "<rounding mode error>";
+    }
+}
+#endif /* DEBUG */
+#endif
Index: sim/brownie32/cp1.h
===================================================================
RCS file: sim/brownie32/cp1.h
diff -N sim/brownie32/cp1.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/cp1.h	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,83 @@
+/*> cp1.h <*/
+/* MIPS Simulator FPU (CoProcessor 1) definitions.
+   Copyright (C) 1997, 1998, 2002 Free Software Foundation, Inc.
+   Derived from sim-main.h contributed by Cygnus Solutions,
+   modified substantially by Ed Satterthwaite of Broadcom Corporation
+   (SiByte).
+
+This file is part of GDB, the GNU debugger.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#ifndef CP1_H
+#define CP1_H
+
+/* See sim-main.h for allocation of registers FCR0 and FCR31 (FCSR) 
+   in CPU state (struct sim_cpu), and for FPU functions.  */
+
+#define fcsr_FCC_mask      (0xFE800000)
+#define fcsr_FCC_shift     (23)
+#define	fcsr_FCC_bit(cc)   ((cc) == 0 ? 23 : (24 + (cc)))
+#define fcsr_FS            (1 << 24) /* MIPS III onwards : Flush to Zero */
+#define fcsr_ZERO_mask     (0x007C0000)
+#define fcsr_CAUSE_mask    (0x0003F000)
+#define fcsr_CAUSE_shift   (12)
+#define fcsr_ENABLES_mask  (0x00000F80)
+#define fcsr_ENABLES_shift (7)
+#define fcsr_FLAGS_mask    (0x0000007C)
+#define fcsr_FLAGS_shift   (2)
+#define fcsr_RM_mask       (0x00000003)
+#define fcsr_RM_shift      (0)
+
+#define fenr_FS            (0x00000004)
+
+/* Macros to update and retrieve the FCSR condition-code bits.  This
+   is complicated by the fact that there is a hole in the index range
+   of the bits within the FCSR register.  (Note that the number of bits
+   visible depends on the ISA in use, but that is handled elsewhere.)  */
+#define SETFCC(cc,v) \
+  do { \
+    (FCSR = ((FCSR & ~(1 << fcsr_FCC_bit(cc))) | ((v) << fcsr_FCC_bit(cc)))); \
+  } while (0)
+#define GETFCC(cc) ((FCSR & (1 << fcsr_FCC_bit(cc))) != 0 ? 1 : 0)
+
+
+/* Read flush-to-zero bit (not right-justified).  */
+#define GETFS()            ((int)(FCSR & fcsr_FS))
+
+
+/* FCSR flag bits definitions and access macros.  */
+#define IR            0   /* I: Inexact Result */
+#define UF            1   /* U: UnderFlow */
+#define OF            2   /* O: OverFlow */
+#define DZ            3   /* Z: Division by Zero */
+#define IO            4   /* V: Invalid Operation */
+#define UO            5   /* E: Unimplemented Operation (CAUSE field only) */
+
+#define FP_FLAGS(b)   (1 << ((b) + fcsr_FLAGS_shift))
+#define FP_ENABLE(b)  (1 << ((b) + fcsr_ENABLES_shift))
+#define FP_CAUSE(b)   (1 << ((b) + fcsr_CAUSE_shift))
+
+
+/* Rounding mode bit definitions and access macros.  */
+#define FP_RM_NEAREST 0   /* Round to nearest (Round).  */
+#define FP_RM_TOZERO  1   /* Round to zero (Trunc).  */
+#define FP_RM_TOPINF  2   /* Round to Plus infinity (Ceil).  */
+#define FP_RM_TOMINF  3   /* Round to Minus infinity (Floor).  */
+
+#define GETRM()       ((FCSR >> fcsr_RM_shift) & fcsr_RM_mask)
+
+
+#endif /* CP1_H */
Index: sim/brownie32/interp.c
===================================================================
RCS file: sim/brownie32/interp.c
diff -N sim/brownie32/interp.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/interp.c	24 Feb 2008 14:52:46 -0000	1.3
@@ -0,0 +1,2762 @@
+/*> interp.c <*/
+/* Simulator for the Brownie32 architecture.
+
+   This file is part of the Brownie32 sim
+
+		THIS SOFTWARE IS NOT COPYRIGHTED
+
+   Cygnus offers the following for use in the public domain.  Cygnus
+   makes no warranty with regard to the software or it's performance
+   and the user accepts the software "AS IS" with all faults.
+
+   CYGNUS DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD TO
+   THIS SOFTWARE INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+
+NOTEs:
+
+The IDT monitor (found on the VR4300 board), seems to lie about
+register contents. It seems to treat the registers as sign-extended
+32-bit values. This cause *REAL* problems when single-stepping 64-bit
+code on the hardware.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+*/
+
+/* The TRACE manifests enable the provision of extra features. If they
+   are not defined then a simpler (quicker) simulator is constructed
+   without the required run-time checks, etc. */
+#if 1 /* 0 to allow user build selection, 1 to force inclusion */
+#define TRACE (1)
+#endif
+
+#include "bfd.h"
+#include "sim-main.h"
+#include "sim-utils.h"
+#include "sim-options.h"
+#include "sim-assert.h"
+#include "sim-hw.h"
+
+#include "itable.h"
+
+
+#include "config.h"
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <ansidecl.h>
+#include <ctype.h>
+#include <limits.h>
+#include <math.h>
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_STRING_H
+#include <string.h>
+#else
+#ifdef HAVE_STRINGS_H
+#include <strings.h>
+#endif
+#endif
+
+#include "getopt.h"
+#include "libiberty.h"
+#include "bfd.h"
+#include "gdb/callback.h"   /* GDB simulator callback interface */
+#include "gdb/remote-sim.h" /* GDB simulator interface */
+
+#include "sysdep.h"
+
+#ifndef PARAMS
+#define PARAMS(x) 
+#endif
+
+char* pr_addr PARAMS ((SIM_ADDR addr));
+char* pr_uword64 PARAMS ((uword64 addr));
+
+static host_callback *callback = &default_callback;  // Add C.Katano 07.01.18
+/* Within interp.c we refer to the sim_state and sim_cpu directly. */
+#define CPU cpu
+#define SD sd
+
+
+/* The following reserved instruction value is used when a simulator
+   trap is required. NOTE: Care must be taken, since this value may be
+   used in later revisions of the MIPS ISA. */
+
+#define RSVD_INSTRUCTION           (0x00000005)
+#define RSVD_INSTRUCTION_MASK      (0xFC00003F)
+
+#define RSVD_INSTRUCTION_ARG_SHIFT 6
+#define RSVD_INSTRUCTION_ARG_MASK  0xFFFFF  
+
+
+/* Bits in the Debug register */
+#define Debug_DBD 0x80000000   /* Debug Branch Delay */
+#define Debug_DM  0x40000000   /* Debug Mode         */
+#define Debug_DBp 0x00000002   /* Debug Breakpoint indicator */
+
+/*---------------------------------------------------------------------------*/
+/*-- GDB simulator interface ------------------------------------------------*/
+/*---------------------------------------------------------------------------*/
+
+static void ColdReset PARAMS((SIM_DESC sd));
+
+/*---------------------------------------------------------------------------*/
+
+
+
+#define DELAYSLOT()     {\
+                          if (STATE & simDELAYSLOT)\
+                            sim_io_eprintf(sd,"Delay slot already activated (branch in delay slot?)\n");\
+                          STATE |= simDELAYSLOT;\
+                        }
+
+#define JALDELAYSLOT()	{\
+			  DELAYSLOT ();\
+			  STATE |= simJALDELAYSLOT;\
+			}
+
+#define NULLIFY()       {\
+                          STATE &= ~simDELAYSLOT;\
+                          STATE |= simSKIPNEXT;\
+                        }
+
+#define CANCELDELAYSLOT() {\
+                            DSSTATE = 0;\
+                            STATE &= ~(simDELAYSLOT | simJALDELAYSLOT);\
+                          }
+
+#define INDELAYSLOT()	((STATE & simDELAYSLOT) != 0)
+#define INJALDELAYSLOT() ((STATE & simJALDELAYSLOT) != 0)
+
+/* Note that the monitor code essentially assumes this layout of memory.
+   If you change these, change the monitor code, too.  */
+#if 0
+#define K0BASE  (0x00000000)
+#define K0SIZE  (0x10000000)
+#define K1BASE  (0xA0000000)
+#define K1SIZE  (0x20000000)
+#else
+#define K0BASE  (0x00000000)
+#define K0SIZE  (0x10000000)
+#define K1BASE  (0x10000000)
+#define K1SIZE  (0x20000000)
+#endif
+/* Simple run-time monitor support.
+   
+   We emulate the monitor by placing magic reserved instructions at
+   the monitor's entry points; when we hit these instructions, instead
+   of raising an exception (as we would normally), we look at the
+   instruction and perform the appropriate monitory operation.
+   
+   `*_monitor_base' are the physical addresses at which the corresponding 
+        monitor vectors are located.  `0' means none.  By default,
+        install all three.
+    The RSVD_INSTRUCTION... macros specify the magic instructions we
+    use at the monitor entry points.  */
+static int firmware_option_p = 0;
+#if 0
+static SIM_ADDR idt_monitor_base =     0xBFC00000;
+static SIM_ADDR pmon_monitor_base =    0xBFC00500;
+static SIM_ADDR lsipmon_monitor_base = 0xBFC00200;
+#endif
+
+static SIM_RC sim_firmware_command (SIM_DESC sd, char* arg);
+
+
+#define MEM_SIZE (2 << 20)
+
+#if defined(TRACE)
+static char *tracefile = "trace.din"; /* default filename for trace log */
+FILE *tracefh = NULL;
+static void open_trace PARAMS((SIM_DESC sd));
+#endif /* TRACE */
+
+static const char * get_insn_name (sim_cpu *, int);
+
+/* simulation target board.  NULL=canonical */
+static char* board = NULL;
+
+
+static DECLARE_OPTION_HANDLER (brownie32_option_handler);
+
+enum {
+  OPTION_DINERO_TRACE = OPTION_START,
+  OPTION_DINERO_FILE,
+  OPTION_FIRMWARE,
+  OPTION_BOARD
+};
+
+
+static SIM_RC
+brownie32_option_handler (sd, cpu, opt, arg, is_command)
+     SIM_DESC sd;
+     sim_cpu *cpu;
+     int opt;
+     char *arg;
+     int is_command;
+{
+  int cpu_nr;
+  switch (opt)
+    {
+    case OPTION_DINERO_TRACE: /* ??? */
+#if defined(TRACE)
+      /* Eventually the simTRACE flag could be treated as a toggle, to
+	 allow external control of the program points being traced
+	 (i.e. only from main onwards, excluding the run-time setup,
+	 etc.). */
+      for (cpu_nr = 0; cpu_nr < MAX_NR_PROCESSORS; cpu_nr++)
+	{
+	  sim_cpu *cpu = STATE_CPU (sd, cpu_nr);
+	  if (arg == NULL)
+	    STATE |= simTRACE;
+	  else if (strcmp (arg, "yes") == 0)
+	    STATE |= simTRACE;
+	  else if (strcmp (arg, "no") == 0)
+	    STATE &= ~simTRACE;
+	  else if (strcmp (arg, "on") == 0)
+	    STATE |= simTRACE;
+	  else if (strcmp (arg, "off") == 0)
+	    STATE &= ~simTRACE;
+	  else
+	    {
+	      fprintf (stderr, "Unrecognized dinero-trace option `%s'\n", arg);
+	      return SIM_RC_FAIL;
+	    }
+	}
+      return SIM_RC_OK;
+#else /* !TRACE */
+      fprintf(stderr,"\
+Simulator constructed without dinero tracing support (for performance).\n\
+Re-compile simulator with \"-DTRACE\" to enable this option.\n");
+      return SIM_RC_FAIL;
+#endif /* !TRACE */
+
+    case OPTION_DINERO_FILE:
+#if defined(TRACE)
+      if (optarg != NULL) {
+	char *tmp;
+	tmp = (char *)malloc(strlen(optarg) + 1);
+	if (tmp == NULL)
+	  {
+	    sim_io_printf(sd,"Failed to allocate buffer for tracefile name \"%s\"\n",optarg);
+	    return SIM_RC_FAIL;
+	  }
+	else {
+	  strcpy(tmp,optarg);
+	  tracefile = tmp;
+	  sim_io_printf(sd,"Placing trace information into file \"%s\"\n",tracefile);
+	}
+      }
+#endif /* TRACE */
+      return SIM_RC_OK;
+
+    case OPTION_FIRMWARE:
+      return sim_firmware_command (sd, arg);
+
+    case OPTION_BOARD:
+      {
+	if (arg)
+	  {
+	    board = zalloc(strlen(arg) + 1);
+	    strcpy(board, arg);
+	  }
+	return SIM_RC_OK;
+      }
+    }
+  
+  return SIM_RC_OK;
+}
+
+
+static const OPTION brownie32_options[] =
+{
+  { {"dinero-trace", optional_argument, NULL, OPTION_DINERO_TRACE},
+      '\0', "on|off", "Enable dinero tracing",
+      brownie32_option_handler },
+  { {"dinero-file", required_argument, NULL, OPTION_DINERO_FILE},
+      '\0', "FILE", "Write dinero trace to FILE",
+      brownie32_option_handler },
+  { {"firmware", required_argument, NULL, OPTION_FIRMWARE},
+    '\0', "[idt|pmon|lsipmon|none][@ADDRESS]", "Emulate ROM monitor",
+    brownie32_option_handler },
+  { {"board", required_argument, NULL, OPTION_BOARD},
+     '\0', "none" /* rely on compile-time string concatenation for other options */
+
+#define BOARD_JMR3904 "jmr3904"
+           "|" BOARD_JMR3904
+#define BOARD_JMR3904_PAL "jmr3904pal"
+           "|" BOARD_JMR3904_PAL
+#define BOARD_JMR3904_DEBUG "jmr3904debug"
+           "|" BOARD_JMR3904_DEBUG
+#define BOARD_BSP "bsp"
+           "|" BOARD_BSP
+
+    , "Customize simulation for a particular board.", brownie32_option_handler },
+
+  { {NULL, no_argument, NULL, 0}, '\0', NULL, NULL, NULL }
+};
+
+
+int interrupt_pending;
+
+void
+interrupt_event (SIM_DESC sd, void *data)
+{
+  sim_cpu *cpu = STATE_CPU (sd, 0); /* FIXME */
+  address_word cia = CIA_GET (cpu);
+  if ( (SR & status_IEN) || (SR & status_EIEN))
+    {
+      interrupt_pending = 0;
+      SignalExceptionInterrupt (1); /* interrupt "1" */
+    }
+  else if (!interrupt_pending)
+    sim_events_schedule (sd, 1, interrupt_event, data);
+}
+
+
+/*---------------------------------------------------------------------------*/
+/*-- Device registration hook -----------------------------------------------*/
+/*---------------------------------------------------------------------------*/
+static void device_init(SIM_DESC sd) {
+#ifdef DEVICE_INIT
+  extern void register_devices(SIM_DESC);
+  register_devices(sd);
+#endif
+}
+
+/*---------------------------------------------------------------------------*/
+/*-- GDB simulator interface ------------------------------------------------*/
+/*---------------------------------------------------------------------------*/
+
+SIM_DESC
+sim_open (kind, cb, abfd, argv)
+     SIM_OPEN_KIND kind;
+     host_callback *cb;
+     struct bfd *abfd;
+     char **argv;
+{
+  SIM_DESC sd = sim_state_alloc (kind, cb);
+  sim_cpu *cpu = STATE_CPU (sd, 0); /* FIXME */
+  SIM_ASSERT (STATE_MAGIC (sd) == SIM_MAGIC_NUMBER);
+
+  /* FIXME: watchpoints code shouldn't need this */
+  STATE_WATCHPOINTS (sd)->pc = &(PC);
+  STATE_WATCHPOINTS (sd)->sizeof_pc = sizeof (PC);
+  STATE_WATCHPOINTS (sd)->interrupt_handler = interrupt_event;
+
+  /* Initialize the mechanism for doing insn profiling.  */
+  CPU_INSN_NAME (cpu) = get_insn_name;
+  CPU_MAX_INSNS (cpu) = nr_itable_entries;
+
+  STATE = 0;
+  
+  if (sim_pre_argv_init (sd, argv[0]) != SIM_RC_OK)
+    return 0;
+  sim_add_option_table (sd, NULL, brownie32_options);
+
+
+  /* getopt will print the error message so we just have to exit if this fails.
+     FIXME: Hmmm...  in the case of gdb we need getopt to call
+     print_filtered.  */
+  if (sim_parse_args (sd, argv) != SIM_RC_OK)
+    {
+      /* Uninstall the modules to avoid memory leaks,
+	 file descriptor leaks, etc.  */
+      sim_module_uninstall (sd);
+      return 0;
+    }
+
+  /* handle board-specific memory maps */
+  if (board == NULL)
+    {
+      /* Allocate core managed memory */
+      
+
+      /* For compatibility with the old code - under this (at level one)
+	 are the kernel spaces K0 & K1.  Both of these map to a single
+	 smaller sub region */
+#if 0  //--------------------------
+#if 0
+      sim_do_command(sd," memory region 0x7fff8000,0x8000") ; /* MTZ- 32 k stack */
+#else
+      sim_do_command(sd," memory region 0x20000000,0x8000") ; 
+#endif
+#if 1
+      sim_do_commandf (sd, "memory alias 0x%lx@1,0x%lx%%0x%lx,0x%0x",
+		       K1BASE, K0SIZE,
+		       MEM_SIZE, /* actual size */
+		       K0BASE);
+#endif      
+#else  //---------------------------
+//      /* ROM: 0x1000_0000 - 0x11ff_ffff */
+//      sim_do_commandf (sd, "memory alias 0x%lx@1,0x%lx,0x%0x",
+//		       0x10000000, 
+//		       16 * 1024 * 1024, /* 16 MB */
+//		       0x11000000);
+      sim_do_commandf (sd, "memory alias 0x%lx@1,0x%lx", 0x10000000, 0x10000000); /* ROM */
+      sim_do_commandf (sd, "memory alias 0x%lx@1,0x%lx", 0x20000000, 0x01000000); /* SRAM */
+      sim_do_commandf (sd, "memory alias 0x%lx@1,0x%lx", 0xffff0000, 0x00010000); /* DRAM */
+      sim_do_commandf (sd, "memory alias 0x%lx@1,0x%lx", 0x00000000, 0x00010000); /* DRAM */
+
+#endif //---------------------------
+      device_init(sd);
+    }
+  else if (board != NULL
+	   && (strcmp(board, BOARD_BSP) == 0))
+    {
+      int i;
+
+      STATE_ENVIRONMENT (sd) = OPERATING_ENVIRONMENT;
+
+      /* ROM: 0x9FC0_0000 - 0x9FFF_FFFF and 0xBFC0_0000 - 0xBFFF_FFFF */
+      sim_do_commandf (sd, "memory alias 0x%lx@1,0x%lx,0x%0x",
+		       0x9FC00000, 
+		       4 * 1024 * 1024, /* 4 MB */
+		       0xBFC00000);
+
+      /* SRAM: 0x8000_0000 - 0x803F_FFFF and 0xA000_0000 - 0xA03F_FFFF */
+      sim_do_commandf (sd, "memory alias 0x%lx@1,0x%lx,0x%0x",
+		       0x80000000, 
+		       4 * 1024 * 1024, /* 4 MB */
+		       0xA0000000);
+
+      /* DRAM: 0x8800_0000 - 0x89FF_FFFF and 0xA800_0000 - 0xA9FF_FFFF */
+      for (i=0; i<8; i++) /* 32 MB total */
+	{
+	  unsigned size = 4 * 1024 * 1024;  /* 4 MB */
+	  sim_do_commandf (sd, "memory alias 0x%lx@1,0x%lx,0x%0x",
+			   0x88000000 + (i * size), 
+			   size, 
+			   0xA8000000 + (i * size));
+	}
+    }
+#if (WITH_HW)
+  else if (board != NULL
+	   && (strcmp(board, BOARD_JMR3904) == 0 ||
+	       strcmp(board, BOARD_JMR3904_PAL) == 0 ||
+	       strcmp(board, BOARD_JMR3904_DEBUG) == 0))
+    {
+      /* match VIRTUAL memory layout of JMR-TX3904 board */
+      int i;
+
+      /* --- disable monitor unless forced on by user --- */
+#if 0
+      if (! firmware_option_p)
+	{
+	  idt_monitor_base = 0;
+	  pmon_monitor_base = 0;
+	  lsipmon_monitor_base = 0;
+	}
+#endif
+      /* --- environment --- */
+
+      STATE_ENVIRONMENT (sd) = OPERATING_ENVIRONMENT;
+
+      /* --- memory --- */
+
+      /* ROM: 0x9FC0_0000 - 0x9FFF_FFFF and 0xBFC0_0000 - 0xBFFF_FFFF */
+      sim_do_commandf (sd, "memory alias 0x%lx@1,0x%lx,0x%0x",
+		       0x9FC00000, 
+		       4 * 1024 * 1024, /* 4 MB */
+		       0xBFC00000);
+
+      /* SRAM: 0x8000_0000 - 0x803F_FFFF and 0xA000_0000 - 0xA03F_FFFF */
+      sim_do_commandf (sd, "memory alias 0x%lx@1,0x%lx,0x%0x",
+		       0x80000000, 
+		       4 * 1024 * 1024, /* 4 MB */
+		       0xA0000000);
+
+      /* DRAM: 0x8800_0000 - 0x89FF_FFFF and 0xA800_0000 - 0xA9FF_FFFF */
+      for (i=0; i<8; i++) /* 32 MB total */
+	{
+	  unsigned size = 4 * 1024 * 1024;  /* 4 MB */
+	  sim_do_commandf (sd, "memory alias 0x%lx@1,0x%lx,0x%0x",
+			   0x88000000 + (i * size), 
+			   size, 
+			   0xA8000000 + (i * size));
+	}
+
+      /* Dummy memory regions for unsimulated devices - sorted by address */
+
+      sim_do_commandf (sd, "memory alias 0x%lx@1,0x%lx", 0xB1000000, 0x400); /* ISA I/O */
+      sim_do_commandf (sd, "memory alias 0x%lx@1,0x%lx", 0xB2100000, 0x004); /* ISA ctl */
+      sim_do_commandf (sd, "memory alias 0x%lx@1,0x%lx", 0xB2500000, 0x004); /* LED/switch */
+      sim_do_commandf (sd, "memory alias 0x%lx@1,0x%lx", 0xB2700000, 0x004); /* RTC */
+      sim_do_commandf (sd, "memory alias 0x%lx@1,0x%lx", 0xB3C00000, 0x004); /* RTC */
+      sim_do_commandf (sd, "memory alias 0x%lx@1,0x%lx", 0xFFFF8000, 0x900); /* DRAMC */
+      sim_do_commandf (sd, "memory alias 0x%lx@1,0x%lx", 0xFFFF9000, 0x200); /* EBIF */
+      sim_do_commandf (sd, "memory alias 0x%lx@1,0x%lx", 0xFFFFE000, 0x01c); /* EBIF */
+      sim_do_commandf (sd, "memory alias 0x%lx@1,0x%lx", 0xFFFFF500, 0x300); /* PIO */
+
+
+      /* --- simulated devices --- */
+      sim_hw_parse (sd, "/tx3904irc@0xffffc000/reg 0xffffc000 0x20");
+      sim_hw_parse (sd, "/tx3904cpu");
+      sim_hw_parse (sd, "/tx3904tmr@0xfffff000/reg 0xfffff000 0x100");
+      sim_hw_parse (sd, "/tx3904tmr@0xfffff100/reg 0xfffff100 0x100");
+      sim_hw_parse (sd, "/tx3904tmr@0xfffff200/reg 0xfffff200 0x100");
+      sim_hw_parse (sd, "/tx3904sio@0xfffff300/reg 0xfffff300 0x100");
+      {
+	/* FIXME: poking at dv-sockser internals, use tcp backend if
+	 --sockser_addr option was given.*/
+	extern char* sockser_addr;
+	if(sockser_addr == NULL)
+	  sim_hw_parse (sd, "/tx3904sio@0xfffff300/backend stdio");
+	else
+	  sim_hw_parse (sd, "/tx3904sio@0xfffff300/backend tcp");
+      }
+      sim_hw_parse (sd, "/tx3904sio@0xfffff400/reg 0xfffff400 0x100");
+      sim_hw_parse (sd, "/tx3904sio@0xfffff400/backend stdio");
+
+      /* -- device connections --- */
+      sim_hw_parse (sd, "/tx3904irc > ip level /tx3904cpu");
+      sim_hw_parse (sd, "/tx3904tmr@0xfffff000 > int tmr0 /tx3904irc");
+      sim_hw_parse (sd, "/tx3904tmr@0xfffff100 > int tmr1 /tx3904irc");
+      sim_hw_parse (sd, "/tx3904tmr@0xfffff200 > int tmr2 /tx3904irc");
+      sim_hw_parse (sd, "/tx3904sio@0xfffff300 > int sio0 /tx3904irc");
+      sim_hw_parse (sd, "/tx3904sio@0xfffff400 > int sio1 /tx3904irc");
+
+      /* add PAL timer & I/O module */
+      if(! strcmp(board, BOARD_JMR3904_PAL))
+	{
+	 /* the device */
+	 sim_hw_parse (sd, "/pal@0xffff0000");
+	 sim_hw_parse (sd, "/pal@0xffff0000/reg 0xffff0000 64");
+
+	 /* wire up interrupt ports to irc */
+	 sim_hw_parse (sd, "/pal@0x31000000 > countdown tmr0 /tx3904irc");
+	 sim_hw_parse (sd, "/pal@0x31000000 > timer tmr1 /tx3904irc");
+	 sim_hw_parse (sd, "/pal@0x31000000 > int int0 /tx3904irc");
+	}
+
+      if(! strcmp(board, BOARD_JMR3904_DEBUG))
+	{
+	  /* -- DEBUG: glue interrupt generators --- */
+	  sim_hw_parse (sd, "/glue@0xffff0000/reg 0xffff0000 0x50");
+	  sim_hw_parse (sd, "/glue@0xffff0000 > int0 int0 /tx3904irc");
+	  sim_hw_parse (sd, "/glue@0xffff0000 > int1 int1 /tx3904irc");
+	  sim_hw_parse (sd, "/glue@0xffff0000 > int2 int2 /tx3904irc");
+	  sim_hw_parse (sd, "/glue@0xffff0000 > int3 int3 /tx3904irc");
+	  sim_hw_parse (sd, "/glue@0xffff0000 > int4 int4 /tx3904irc");
+	  sim_hw_parse (sd, "/glue@0xffff0000 > int5 int5 /tx3904irc");
+	  sim_hw_parse (sd, "/glue@0xffff0000 > int6 int6 /tx3904irc");
+	  sim_hw_parse (sd, "/glue@0xffff0000 > int7 int7 /tx3904irc");
+	  sim_hw_parse (sd, "/glue@0xffff0000 > int8 dmac0 /tx3904irc");
+	  sim_hw_parse (sd, "/glue@0xffff0000 > int9 dmac1 /tx3904irc");
+	  sim_hw_parse (sd, "/glue@0xffff0000 > int10 dmac2 /tx3904irc");
+	  sim_hw_parse (sd, "/glue@0xffff0000 > int11 dmac3 /tx3904irc");
+	  sim_hw_parse (sd, "/glue@0xffff0000 > int12 sio0 /tx3904irc");
+	  sim_hw_parse (sd, "/glue@0xffff0000 > int13 sio1 /tx3904irc");
+	  sim_hw_parse (sd, "/glue@0xffff0000 > int14 tmr0 /tx3904irc");
+	  sim_hw_parse (sd, "/glue@0xffff0000 > int15 tmr1 /tx3904irc");
+	  sim_hw_parse (sd, "/glue@0xffff0000 > int16 tmr2 /tx3904irc");
+	  sim_hw_parse (sd, "/glue@0xffff0000 > int17 nmi /tx3904cpu");
+	}
+
+      device_init(sd);
+    }
+#endif
+
+
+  /* check for/establish the a reference program image */
+  if (sim_analyze_program (sd,
+			   (STATE_PROG_ARGV (sd) != NULL
+			    ? *STATE_PROG_ARGV (sd)
+			    : NULL),
+			   abfd) != SIM_RC_OK)
+    {
+      sim_module_uninstall (sd);
+      return 0;
+    }
+
+  /* Configure/verify the target byte order and other runtime
+     configuration options */
+  if (sim_config (sd) != SIM_RC_OK)
+    {
+      sim_module_uninstall (sd);
+      return 0;
+    }
+
+  if (sim_post_argv_init (sd) != SIM_RC_OK)
+    {
+      /* Uninstall the modules to avoid memory leaks,
+	 file descriptor leaks, etc.  */
+      sim_module_uninstall (sd);
+      return 0;
+    }
+
+  /* verify assumptions the simulator made about the host type system.
+     This macro does not return if there is a problem */
+  SIM_ASSERT (sizeof(int) == (4 * sizeof(char)));
+  SIM_ASSERT (sizeof(word64) == (8 * sizeof(char)));
+
+  /* This is NASTY, in that we are assuming the size of specific
+     registers: */
+  {
+    int rn;
+     for (rn = 0; (rn < (LAST_EMBED_REGNUM + 1)); rn++)
+      {
+//	if (rn < 32)
+	  cpu->register_widths[rn] = WITH_TARGET_WORD_BITSIZE;
+//#if 0 // Delete C.Katano
+//	else if ((rn >= FGR_BASE) && (rn < (FGR_BASE + NR_FGR)))
+//	  cpu->register_widths[rn] = WITH_TARGET_FLOATING_POINT_BITSIZE;
+//#endif
+//	else if ((rn >= 33) && (rn <= 37))
+//	  cpu->register_widths[rn] = WITH_TARGET_WORD_BITSIZE;
+//#if 0  // Delete Katano
+//	else if ((rn == SRIDX)
+//		 || (rn == FCR0IDX)
+//		 || (rn == FCR31IDX)
+//		 || ((rn >= 72) && (rn <= 89)))
+//	  cpu->register_widths[rn] = 32;
+//#endif
+//	else
+//	  cpu->register_widths[rn] = 0;
+      }
+
+
+  }
+
+#if defined(TRACE)
+  if (STATE & simTRACE)
+    open_trace(sd);
+#endif /* TRACE */
+
+  /*
+  sim_io_eprintf (sd, "idt@%x pmon@%x lsipmon@%x\n", 
+		  idt_monitor_base,
+		  pmon_monitor_base, 
+		  lsipmon_monitor_base);
+  */
+
+  /* Write the monitor trap address handlers into the monitor (eeprom)
+     address space.  This can only be done once the target endianness
+     has been determined. */
+#if 0
+  if (idt_monitor_base != 0)
+    {
+      unsigned loop;
+      unsigned idt_monitor_size = 1 << 11;
+
+      /* the default monitor region */
+      sim_do_commandf (sd, "memory region 0x%x,0x%x",
+		       idt_monitor_base, idt_monitor_size);
+
+      /* Entry into the IDT monitor is via fixed address vectors, and
+	 not using machine instructions. To avoid clashing with use of
+	 the MIPS TRAP system, we place our own (simulator specific)
+	 "undefined" instructions into the relevant vector slots. */
+      for (loop = 0; (loop < idt_monitor_size); loop += 4)
+	{
+	  address_word vaddr = (idt_monitor_base + loop);
+	  unsigned32 insn = (RSVD_INSTRUCTION |
+			     (((loop >> 2) & RSVD_INSTRUCTION_ARG_MASK)
+			      << RSVD_INSTRUCTION_ARG_SHIFT));
+	  H2T (insn);
+	  sim_write (sd, vaddr, (char *)&insn, sizeof (insn));
+	}
+    }
+  if ((pmon_monitor_base != 0) || (lsipmon_monitor_base != 0))
+    {
+    /* The PMON monitor uses the same address space, but rather than
+       branching into it the address of a routine is loaded. We can
+       cheat for the moment, and direct the PMON routine to IDT style
+       instructions within the monitor space. This relies on the IDT
+       monitor not using the locations from 0xBFC00500 onwards as its
+       entry points.*/
+      unsigned loop;
+      for (loop = 0; (loop < 24); loop++)
+	{
+	  unsigned32 value = ((0x500 - 8) / 8); /* default UNDEFINED reason code */
+	  switch (loop)
+	    {
+            case 0: /* read */
+              value = 7;
+              break;
+            case 1: /* write */
+              value = 8;
+              break;
+            case 2: /* open */
+              value = 6;
+              break;
+            case 3: /* close */
+              value = 10;
+              break;
+            case 5: /* printf */
+              value = ((0x500 - 16) / 8); /* not an IDT reason code */
+              break;
+            case 8: /* cliexit */
+              value = 17;
+              break;
+            case 11: /* flush_cache */
+              value = 28;
+              break;
+          }
+
+	SIM_ASSERT (idt_monitor_base != 0);
+        value = ((unsigned int) idt_monitor_base + (value * 8));
+	H2T (value);
+
+	if (pmon_monitor_base != 0)
+	  {
+	    address_word vaddr = (pmon_monitor_base + (loop * 4));
+	    sim_write (sd, vaddr, (char *)&value, sizeof (value));
+	  }
+
+	if (lsipmon_monitor_base != 0)
+	  {
+	    address_word vaddr = (lsipmon_monitor_base + (loop * 4));
+	    sim_write (sd, vaddr, (char *)&value, sizeof (value));
+	  }
+      }
+
+  /* Write an abort sequence into the TRAP (common) exception vector
+     addresses.  This is to catch code executing a TRAP (et.al.)
+     instruction without installing a trap handler. */
+  if ((idt_monitor_base != 0) || 
+      (pmon_monitor_base != 0) || 
+      (lsipmon_monitor_base != 0))
+    {
+      unsigned32 halt[2] = { 0x2404002f /* addiu r4, r0, 47 */,
+			     HALT_INSTRUCTION /* BREAK */ };
+      H2T (halt[0]);
+      H2T (halt[1]);
+      sim_write (sd, 0x80000000, (char *) halt, sizeof (halt));
+      sim_write (sd, 0x80000180, (char *) halt, sizeof (halt));
+      sim_write (sd, 0x80000200, (char *) halt, sizeof (halt));
+      /* XXX: Write here unconditionally? */
+      sim_write (sd, 0xBFC00200, (char *) halt, sizeof (halt));
+      sim_write (sd, 0xBFC00380, (char *) halt, sizeof (halt));
+      sim_write (sd, 0xBFC00400, (char *) halt, sizeof (halt));
+    }
+  }
+#endif
+
+
+
+  return sd;
+}
+
+#if defined(TRACE)
+static void
+open_trace(sd)
+     SIM_DESC sd;
+{
+  tracefh = fopen(tracefile,"wb+");
+  if (tracefh == NULL)
+    {
+      sim_io_eprintf(sd,"Failed to create file \"%s\", writing trace information to stderr.\n",tracefile);
+      tracefh = stderr;
+  }
+}
+#endif /* TRACE */
+
+/* Return name of an insn, used by insn profiling.  */
+static const char *
+get_insn_name (sim_cpu *cpu, int i)
+{
+  return itable[i].name;
+}
+
+void
+sim_close (sd, quitting)
+     SIM_DESC sd;
+     int quitting;
+{
+#ifdef DEBUG
+  printf("DBG: sim_close: entered (quitting = %d)\n",quitting);
+#endif
+
+
+  /* "quitting" is non-zero if we cannot hang on errors */
+
+  /* shut down modules */
+  sim_module_uninstall (sd);
+
+  /* Ensure that any resources allocated through the callback
+     mechanism are released: */
+  sim_io_shutdown (sd);
+
+#if defined(TRACE)
+  if (tracefh != NULL && tracefh != stderr)
+   fclose(tracefh);
+  tracefh = NULL;
+#endif /* TRACE */
+
+  /* FIXME - free SD */
+
+  return;
+}
+
+
+int
+sim_write (sd,addr,buffer,size)
+     SIM_DESC sd;
+     SIM_ADDR addr;
+     unsigned char *buffer;
+     int size;
+{
+  int index;
+  sim_cpu *cpu = STATE_CPU (sd, 0); /* FIXME */
+
+  /* Return the number of bytes written, or zero if error. */
+#ifdef DEBUG
+  sim_io_printf(sd,"sim_write(0x%s,buffer,%d);\n",pr_addr(addr),size);
+#endif
+
+  /* We use raw read and write routines, since we do not want to count
+     the GDB memory accesses in our statistics gathering. */
+
+#if 0  // 20060612 not vertual memory Brownie32  C.Katano
+  for (index = 0; index < size; index++)
+    {
+      address_word vaddr = (address_word)addr + index;
+      address_word paddr;
+      int cca;
+      if (!address_translation (SD, CPU, NULL_CIA, vaddr, isDATA, isSTORE, &paddr, &cca, isRAW))
+	break;
+      if (sim_core_write_buffer (SD, CPU, read_map, buffer + index, paddr, 1) != 1)
+	break;
+    }
+#else
+  for (index = 0; index < size; index++)
+    {
+      address_word paddr = (address_word)addr + index;
+      int cca;
+      if (sim_core_write_buffer (SD, CPU, read_map, buffer + index, paddr, 1) != 1)
+	break;
+    }
+#endif
+
+  return(index);
+}
+
+int
+sim_read (sd,addr,buffer,size)
+     SIM_DESC sd;
+     SIM_ADDR addr;
+     unsigned char *buffer;
+     int size;
+{
+  int index;
+  sim_cpu *cpu = STATE_CPU (sd, 0); /* FIXME */
+
+  /* Return the number of bytes read, or zero if error. */
+#ifdef DEBUG 
+  sim_io_printf(sd,"sim_read(0x%s,buffer,%d);\n",pr_addr(addr),size);
+#endif /* DEBUG */
+
+#if 1  // 20060612 not vertual memory Brownie32  C.Katano
+  for (index = 0; (index < size); index++)
+    {
+      address_word vaddr = (address_word)addr + index;
+      address_word paddr;
+      int cca;
+      if (!address_translation (SD, CPU, NULL_CIA, vaddr, isDATA, isLOAD, &paddr, &cca, isRAW))
+      {
+	break;
+      }
+      if (sim_core_read_buffer (SD, CPU, read_map, buffer + index, paddr, 1) != 1)
+      {
+	break;
+      }
+    }
+#else
+  for (index = 0; (index < size); index++)
+    {
+      address_word paddr = (address_word)addr + index;
+      int cca;
+      if (sim_core_read_buffer (SD, CPU, read_map, buffer + index, paddr, 1) != 1)
+	break;
+    }
+#endif
+  return(index);
+}
+
+int
+sim_store_register (sd,rn,memory,length)
+     SIM_DESC sd;
+     int rn;
+     unsigned char *memory;
+     int length;
+{
+  sim_cpu *cpu = STATE_CPU (sd, 0); /* FIXME */
+  /* NOTE: gdb (the client) stores registers in target byte order
+     while the simulator uses host byte order */
+#ifdef DEBUG
+  sim_io_printf(sd,"sim_store_register(%d,*memory=0x%s);\n",rn,pr_addr(*((SIM_ADDR *)memory)));
+#endif /* DEBUG */
+
+  /* Unfortunately this suffers from the same problem as the register
+     numbering one. We need to know what the width of each logical
+     register number is for the architecture being simulated. */
+
+  if (cpu->register_widths[rn] == 0)
+    {
+      sim_io_eprintf(sd,"Invalid register width for %d (register store ignored)\n",rn);
+      return 0;
+    }
+
+
+#if 0 // Delete C.Katano FPU
+  if (rn >= FGR_BASE && rn < FGR_BASE + NR_FGR)
+    {
+      cpu->fpr_state[rn - FGR_BASE] = fmt_uninterpreted;
+      if (cpu->register_widths[rn] == 32)
+	{
+	  if (length == 8)
+	    {
+	      cpu->fgr[rn - FGR_BASE] = 
+		(unsigned32) T2H_8 (*(unsigned64*)memory);
+	      return 8;
+	    }
+	  else
+	    {
+	      cpu->fgr[rn - FGR_BASE] = T2H_4 (*(unsigned32*)memory);
+	      return 4;
+	    }
+	}
+      else
+	{
+	  cpu->fgr[rn - FGR_BASE] = T2H_8 (*(unsigned64*)memory);
+	  return 8;
+	}
+    }
+#endif
+  if (cpu->register_widths[rn] == 32)
+    {
+      if (length == 8)
+	{
+	  cpu->registers[rn] =
+	    (unsigned32) T2H_8 (*(unsigned64*)memory);
+	  return 8;
+	}
+      else
+	{
+	  cpu->registers[rn] = T2H_4 (*(unsigned32*)memory);
+	  return 4;
+	}
+    }
+  else
+    {
+      cpu->registers[rn] = T2H_8 (*(unsigned64*)memory);
+      return 8;
+    }
+
+  return 0;
+}
+
+int
+sim_fetch_register (sd,rn,memory,length)
+     SIM_DESC sd;
+     int rn;
+     unsigned char *memory;
+     int length;
+{
+  sim_cpu *cpu = STATE_CPU (sd, 0); /* FIXME */
+  /* NOTE: gdb (the client) stores registers in target byte order
+     while the simulator uses host byte order */
+#ifdef DEBUG
+#if 0  /* FIXME: doesn't compile */
+  sim_io_printf(sd,"sim_fetch_register(%d=0x%s,mem) : place simulator registers into memory\n",rn,pr_addr(registers[rn]));
+#endif
+#endif /* DEBUG */
+
+  if (cpu->register_widths[rn] == 0)
+    {
+      sim_io_eprintf (sd, "Invalid register width for %d (register fetch ignored)\n",rn);
+      return 0;
+    }
+
+
+#if 0 // Delete C.Katano 
+  /* Any floating point register */
+  if (rn >= FGR_BASE && rn < FGR_BASE + NR_FGR)
+    {
+      if (cpu->register_widths[rn] == 32)
+	{
+	  if (length == 8)
+	    {
+	      *(unsigned64*)memory =
+		H2T_8 ((unsigned32) (cpu->fgr[rn - FGR_BASE]));
+	      return 8;
+	    }
+	  else
+	    {
+	      *(unsigned32*)memory = H2T_4 (cpu->fgr[rn - FGR_BASE]);
+	      return 4;
+	    }
+	}
+      else
+	{
+	  *(unsigned64*)memory = H2T_8 (cpu->fgr[rn - FGR_BASE]);
+	  return 8;
+	}
+    }
+#endif
+  if (cpu->register_widths[rn] == 32)
+    {
+      if (length == 8)
+	{
+	  *(unsigned64*)memory =
+	    H2T_8 ((unsigned32) (cpu->registers[rn]));
+	  return 8;
+	}
+      else
+	{
+	  *(unsigned32*)memory = H2T_4 ((unsigned32)(cpu->registers[rn]));
+	  return 4;
+	}
+    }
+  else
+    {
+      *(unsigned64*)memory = H2T_8 ((unsigned64)(cpu->registers[rn]));
+      return 8;
+    }
+
+  return 0;
+}
+
+
+SIM_RC
+sim_create_inferior (sd, abfd, argv,env)
+     SIM_DESC sd;
+     struct bfd *abfd;
+     char **argv;
+     char **env;
+{
+
+#ifdef DEBUG
+#if 0 /* FIXME: doesn't compile */
+  printf("DBG: sim_create_inferior entered: start_address = 0x%s\n",
+	 pr_addr(PC));
+#endif
+#endif /* DEBUG */
+
+  ColdReset(sd);
+
+  if (abfd != NULL)
+    {
+      /* override PC value set by ColdReset () */
+      int cpu_nr;
+      for (cpu_nr = 0; cpu_nr < sim_engine_nr_cpus (sd); cpu_nr++)
+	{
+	  sim_cpu *cpu = STATE_CPU (sd, cpu_nr);
+	  CIA_SET (cpu, (unsigned64) bfd_get_start_address (abfd));
+	}
+    }
+
+#if 0 /* def DEBUG */
+  if (argv || env)
+    {
+      /* We should really place the argv slot values into the argument
+	 registers, and onto the stack as required. However, this
+	 assumes that we have a stack defined, which is not
+	 necessarily true at the moment. */
+      char **cptr;
+      sim_io_printf(sd,"sim_create_inferior() : passed arguments ignored\n");
+      for (cptr = argv; (cptr && *cptr); cptr++)
+	printf("DBG: arg \"%s\"\n",*cptr);
+    }
+#endif /* DEBUG */
+
+  return SIM_RC_OK;
+}
+
+void
+sim_do_command (sd,cmd)
+     SIM_DESC sd;
+     char *cmd;
+{
+  if (sim_args_command (sd, cmd) != SIM_RC_OK)
+    sim_io_printf (sd, "Error: \"%s\" is not a valid Brownie32 simulator command.\n",
+		   cmd);
+}
+
+/*---------------------------------------------------------------------------*/
+/*-- Private simulator support interface ------------------------------------*/
+/*---------------------------------------------------------------------------*/
+
+/* Read a null terminated string from memory, return in a buffer */
+static char *
+fetch_str (SIM_DESC sd,
+	   address_word addr)
+{
+  char *buf;
+  int nr = 0;
+  char null;
+  while (sim_read (sd, addr + nr, &null, 1) == 1 && null != 0)
+    nr++;
+  buf = NZALLOC (char, nr + 1);
+  sim_read (sd, addr, buf, nr);
+  return buf;
+}
+
+
+/* Implements the "sim firmware" command:
+	sim firmware NAME[@ADDRESS] --- emulate ROM monitor named NAME.
+		NAME can be idt, pmon, or lsipmon.  If omitted, ADDRESS
+		defaults to the normal address for that monitor.
+	sim firmware none --- don't emulate any ROM monitor.  Useful
+		if you need a clean address space.  */
+static SIM_RC
+sim_firmware_command (SIM_DESC sd, char *arg)
+{
+  int address_present = 0;
+  SIM_ADDR address;
+
+  /* Signal occurrence of this option. */
+//  firmware_option_p = 1;
+
+  /* Parse out the address, if present.  */
+  {
+    char *p = strchr (arg, '@');
+    if (p)
+      {
+	char *q;
+	address_present = 1;
+	p ++; /* skip over @ */
+
+	address = strtoul (p, &q, 0);
+	if (*q != '\0') 
+	  {
+	    sim_io_printf (sd, "Invalid address given to the"
+			   "`sim firmware NAME@ADDRESS' command: %s\n",
+			   p);
+	    return SIM_RC_FAIL;
+	  }
+      }
+    else
+      {
+	address_present = 0;
+	address = -1; /* Dummy value.  */
+      }
+  }
+#if 0
+  if (! strncmp (arg, "idt", 3))
+    {
+      idt_monitor_base = address_present ? address : 0xBFC00000;
+      pmon_monitor_base = 0;
+      lsipmon_monitor_base = 0;
+    }
+  else if (! strncmp (arg, "pmon", 4))
+    {
+      /* pmon uses indirect calls.  Hook into implied idt. */
+      pmon_monitor_base = address_present ? address : 0xBFC00500;
+      idt_monitor_base = pmon_monitor_base - 0x500;
+      lsipmon_monitor_base = 0;
+    }
+  else if (! strncmp (arg, "lsipmon", 7))
+    {
+      /* lsipmon uses indirect calls.  Hook into implied idt. */
+      pmon_monitor_base = 0;
+      lsipmon_monitor_base = address_present ? address : 0xBFC00200;
+      idt_monitor_base = lsipmon_monitor_base - 0x200;
+    }
+  else if (! strncmp (arg, "none", 4))
+    {
+      if (address_present)
+	{
+	  sim_io_printf (sd,
+			 "The `sim firmware none' command does "
+			 "not take an `ADDRESS' argument.\n");
+	  return SIM_RC_FAIL;
+	}
+      idt_monitor_base = 0;
+      pmon_monitor_base = 0;
+      lsipmon_monitor_base = 0;
+    }
+  else
+    {
+      sim_io_printf (sd, "\
+Unrecognized name given to the `sim firmware NAME' command: %s\n\
+Recognized firmware names are: `idt', `pmon', `lsipmon', and `none'.\n",
+		     arg);
+      return SIM_RC_FAIL;
+    }
+#endif  
+  return SIM_RC_OK;
+}
+
+
+
+/* Simple monitor interface (currently setup for the IDT and PMON monitors) */
+#if 0  // Katano No support
+int
+sim_monitor (SIM_DESC sd,
+	     sim_cpu *cpu,
+	     address_word cia,
+	     unsigned int reason)
+{
+#ifdef DEBUG
+  printf("DBG: sim_monitor: entered (reason = %d)\n",reason);
+#endif /* DEBUG */
+
+  /* The IDT monitor actually allows two instructions per vector
+     slot. However, the simulator currently causes a trap on each
+     individual instruction. We cheat, and lose the bottom bit. */
+  reason >>= 1;
+
+  /* The following callback functions are available, however the
+     monitor we are simulating does not make use of them: get_errno,
+     isatty, lseek, rename, system, time and unlink */
+  switch (reason)
+    {
+
+    case 6: /* int open(char *path,int flags) */
+      {
+	char *path = fetch_str (sd, A0);
+	V0 = sim_io_open (sd, path, (int)A1);
+	zfree (path);
+	break;
+      }
+
+    case 7: /* int read(int file,char *ptr,int len) */
+      {
+	int fd = A0;
+	int nr = A2;
+	char *buf = zalloc (nr);
+	V0 = sim_io_read (sd, fd, buf, nr);
+	sim_write (sd, A1, buf, nr);
+	zfree (buf);
+      }
+      break;
+
+    case 8: /* int write(int file,char *ptr,int len) */
+      {
+	int fd = A0;
+	int nr = A2;
+	char *buf = zalloc (nr);
+	sim_read (sd, A1, buf, nr);
+	V0 = sim_io_write (sd, fd, buf, nr);
+	zfree (buf);
+	break;
+      }
+
+    case 10: /* int close(int file) */
+      {
+	V0 = sim_io_close (sd, (int)A0);
+	break;
+      }
+
+    case 2:  /* Densan monitor: char inbyte(int waitflag) */
+      {
+	if (A0 == 0)	/* waitflag == NOWAIT */
+	  V0 = (unsigned_word)-1;
+      }
+     /* Drop through to case 11 */
+
+    case 11: /* char inbyte(void) */
+      {
+        char tmp;
+	/* ensure that all output has gone... */
+	sim_io_flush_stdout (sd);
+        if (sim_io_read_stdin (sd, &tmp, sizeof(char)) != sizeof(char))
+	  {
+	    sim_io_error(sd,"Invalid return from character read");
+	    V0 = (unsigned_word)-1;
+	  }
+        else
+	  V0 = (unsigned_word)tmp;
+	break;
+      }
+
+    case 3:  /* Densan monitor: void co(char chr) */
+    case 12: /* void outbyte(char chr) : write a byte to "stdout" */
+      {
+        char tmp = (char)(A0 & 0xFF);
+        sim_io_write_stdout (sd, &tmp, sizeof(char));
+	break;
+      }
+
+    case 17: /* void _exit() */
+      {
+	sim_io_eprintf (sd, "sim_monitor(17): _exit(int reason) to be coded\n");
+	sim_engine_halt (SD, CPU, NULL, NULL_CIA, sim_exited,
+			 (unsigned int)(A0 & 0xFFFFFFFF));
+	break;
+      }
+
+    case 28: /* PMON flush_cache */
+      break;
+
+    case 55: /* void get_mem_info(unsigned int *ptr) */
+      /* in:  A0 = pointer to three word memory location */
+      /* out: [A0 + 0] = size */
+      /*      [A0 + 4] = instruction cache size */
+      /*      [A0 + 8] = data cache size */
+      {
+	unsigned_4 value = MEM_SIZE /* FIXME STATE_MEM_SIZE (sd) */;
+	unsigned_4 zero = 0;
+	H2T (value);
+	sim_write (sd, A0 + 0, (char *)&value, 4);
+	sim_write (sd, A0 + 4, (char *)&zero, 4);
+	sim_write (sd, A0 + 8, (char *)&zero, 4);
+	/* sim_io_eprintf (sd, "sim: get_mem_info() deprecated\n"); */
+	break;
+      }
+    
+    case 158: /* PMON printf */
+      /* in:  A0 = pointer to format string */
+      /*      A1 = optional argument 1 */
+      /*      A2 = optional argument 2 */
+      /*      A3 = optional argument 3 */
+      /* out: void */
+      /* The following is based on the PMON printf source */
+      {
+	address_word s = A0;
+	char c;
+	signed_word *ap = &A1; /* 1st argument */
+        /* This isn't the quickest way, since we call the host print
+           routine for every character almost. But it does avoid
+           having to allocate and manage a temporary string buffer. */
+	/* TODO: Include check that we only use three arguments (A1,
+           A2 and A3) */
+	while (sim_read (sd, s++, &c, 1) && c != '\0')
+	  {
+            if (c == '%')
+	      {
+		char tmp[40];
+		enum {FMT_RJUST, FMT_LJUST, FMT_RJUST0, FMT_CENTER} fmt = FMT_RJUST;
+		int width = 0, trunc = 0, haddot = 0, longlong = 0;
+		while (sim_read (sd, s++, &c, 1) && c != '\0')
+		  {
+		    if (strchr ("dobxXulscefg%", c))
+		      break;
+		    else if (c == '-')
+		      fmt = FMT_LJUST;
+		    else if (c == '0')
+		      fmt = FMT_RJUST0;
+		    else if (c == '~')
+		      fmt = FMT_CENTER;
+		    else if (c == '*')
+		      {
+			if (haddot)
+			  trunc = (int)*ap++;
+			else
+			  width = (int)*ap++;
+		      }
+		    else if (c >= '1' && c <= '9')
+		      {
+			address_word t = s;
+			unsigned int n;
+			while (sim_read (sd, s++, &c, 1) == 1 && isdigit (c))
+			  tmp[s - t] = c;
+			tmp[s - t] = '\0';
+			n = (unsigned int)strtol(tmp,NULL,10);
+			if (haddot)
+			  trunc = n;
+			else
+			  width = n;
+			s--;
+		      }
+		    else if (c == '.')
+		      haddot = 1;
+		  }
+		switch (c)
+		  {
+		  case '%':
+		    sim_io_printf (sd, "%%");
+		    break;
+		  case 's':
+		    if ((int)*ap != 0)
+		      {
+			address_word p = *ap++;
+			char ch;
+			while (sim_read (sd, p++, &ch, 1) == 1 && ch != '\0')
+			  sim_io_printf(sd, "%c", ch);
+		      }
+		    else
+		      sim_io_printf(sd,"(null)");
+		    break;
+		  case 'c':
+		    sim_io_printf (sd, "%c", (int)*ap++);
+		    break;
+		  default:
+		    if (c == 'l')
+		      {
+			sim_read (sd, s++, &c, 1);
+			if (c == 'l')
+			  {
+			    longlong = 1;
+			    sim_read (sd, s++, &c, 1);
+			  }
+		      }
+		    if (strchr ("dobxXu", c))
+		      {
+			word64 lv = (word64) *ap++;
+			if (c == 'b')
+			  sim_io_printf(sd,"<binary not supported>");
+			else
+			  {
+			    sprintf (tmp, "%%%s%c", longlong ? "ll" : "", c);
+			    if (longlong)
+			      sim_io_printf(sd, tmp, lv);
+			    else
+			      sim_io_printf(sd, tmp, (int)lv);
+			  }
+		      }
+		    else if (strchr ("eEfgG", c))
+		      {
+			double dbl = *(double*)(ap++);
+			sprintf (tmp, "%%%d.%d%c", width, trunc, c);
+			sim_io_printf (sd, tmp, dbl);
+			trunc = 0;
+		      }
+		  }
+	      }
+	    else
+	      sim_io_printf(sd, "%c", c);
+	  }
+	break;
+      }
+
+    default:
+      /* Unknown reason.  */
+      return 0;
+  }
+  return 1;
+}
+#endif
+/* Store a word into memory.  */
+
+static void
+store_word (SIM_DESC sd,
+	    sim_cpu *cpu,
+	    address_word cia,
+	    uword64 vaddr,
+	    signed_word val)
+{
+  address_word paddr;
+  int uncached;
+
+  if ((vaddr & 3) != 0)
+  {
+//    SignalExceptionAddressStore ();
+  }
+  else
+    {
+      if (AddressTranslation (vaddr, isDATA, isSTORE, &paddr, &uncached,
+			      isTARGET, isREAL))
+	{
+	  const uword64 mask = 7;
+	  uword64 memval;
+	  unsigned int byte;
+
+	  paddr = (paddr & ~mask) | (paddr & mask); //^ (ReverseEndian << 2));
+	  byte = (vaddr & mask) ^ (BigEndianCPU << 2);
+	  memval = ((uword64) val) << (8 * byte);
+	  StoreMemory (uncached, AccessLength_WORD, memval, 0, paddr, vaddr,
+		       isREAL);
+	}
+    }
+}
+
+/* Load a word from memory.  */
+
+static signed_word
+load_word (SIM_DESC sd,
+	   sim_cpu *cpu,
+	   address_word cia,
+	   uword64 vaddr)
+{
+
+  if ((vaddr & 3) != 0)
+    {
+      SIM_CORE_SIGNAL (SD, cpu, cia, read_map, AccessLength_WORD+1, vaddr, read_transfer, sim_core_unaligned_signal);
+    }
+  else
+    {
+      address_word paddr;
+      int uncached;
+
+      if (AddressTranslation (vaddr, isDATA, isLOAD, &paddr, &uncached,
+			      isTARGET, isREAL))
+	{
+	  const uword64 mask = 0x7;
+	  const unsigned int reverse = 0;//ReverseEndian ? 1 : 0;
+	  const unsigned int bigend = BigEndianCPU ? 1 : 0;
+	  uword64 memval;
+	  unsigned int byte;
+
+	  paddr = (paddr & ~mask) | ((paddr & mask) ^ (reverse << 2));
+	  LoadMemory (&memval,NULL,uncached, AccessLength_WORD, paddr, vaddr,
+			       isDATA, isREAL);
+	  byte = (vaddr & mask) ^ (bigend << 2);
+	  return EXTEND32 (memval >> (8 * byte));
+	}
+    }
+
+  return 0;
+}
+
+/* Simulate the brownie3216 entry and exit pseudo-instructions.  These
+   would normally be handled by the reserved instruction exception
+   code, but for ease of simulation we just handle them directly.  */
+#if 0 // Delete C.Katano
+static void
+brownie3216_entry (SIM_DESC sd,
+	      sim_cpu *cpu,
+	      address_word cia,
+	      unsigned int insn)
+{
+  int aregs, sregs, rreg;
+
+#ifdef DEBUG
+  gprintf("DBG: brownie3216_entry: entered (insn = 0x%08X)\n",insn);
+#endif /* DEBUG */
+
+  aregs = (insn & 0x700) >> 8;
+  sregs = (insn & 0x0c0) >> 6;
+  rreg =  (insn & 0x020) >> 5;
+
+  /* This should be checked by the caller.  */
+  if (sregs == 3)
+    abort ();
+
+  if (aregs < 5)
+    {
+      int i;
+      signed_word tsp;
+
+      /* This is the entry pseudo-instruction.  */
+
+      for (i = 0; i < aregs; i++)
+	store_word (SD, CPU, cia, (uword64) (SP + 4 * i), GPR[i + 4]);
+
+      tsp = SP;
+      SP -= 32;
+
+      if (rreg)
+	{
+	  tsp -= 4;
+	  store_word (SD, CPU, cia, (uword64) tsp, RA);
+	}
+
+      for (i = 0; i < sregs; i++)
+	{
+	  tsp -= 4;
+	  store_word (SD, CPU, cia, (uword64) tsp, GPR[16 + i]);
+	}
+    }
+  else
+    {
+      int i;
+      signed_word tsp;
+
+      /* This is the exit pseudo-instruction.  */
+
+      tsp = SP + 32;
+
+      if (rreg)
+	{
+	  tsp -= 4;
+	  RA = load_word (SD, CPU, cia, (uword64) tsp);
+	}
+
+      for (i = 0; i < sregs; i++)
+	{
+	  tsp -= 4;
+	  GPR[i + 16] = load_word (SD, CPU, cia, (uword64) tsp);
+	}
+
+      SP += 32;
+
+      if (CURRENT_FLOATING_POINT == HARD_FLOATING_POINT)
+	{
+	  if (aregs == 5)
+	    {
+	      FGR[0] = WORD64LO (GPR[4]);
+	      FPR_STATE[0] = fmt_uninterpreted;
+	    }
+	  else if (aregs == 6)
+	    {
+	      FGR[0] = WORD64LO (GPR[5]);
+	      FGR[1] = WORD64LO (GPR[4]);
+	      FPR_STATE[0] = fmt_uninterpreted;
+	      FPR_STATE[1] = fmt_uninterpreted;
+	    }
+	}	  
+
+      PC = RA;
+    }
+  
+}
+#endif
+/*-- trace support ----------------------------------------------------------*/
+
+/* The TRACE support is provided (if required) in the memory accessing
+   routines. Since we are also providing the architecture specific
+   features, the architecture simulation code can also deal with
+   notifying the TRACE world of cache flushes, etc. Similarly we do
+   not need to provide profiling support in the simulator engine,
+   since we can sample in the instruction fetch control loop. By
+   defining the TRACE manifest, we add tracing as a run-time
+   option. */
+
+#if defined(TRACE)
+/* Tracing by default produces "din" format (as required by
+   dineroIII). Each line of such a trace file *MUST* have a din label
+   and address field. The rest of the line is ignored, so comments can
+   be included if desired. The first field is the label which must be
+   one of the following values:
+
+	0       read data
+        1       write data
+        2       instruction fetch
+        3       escape record (treated as unknown access type)
+        4       escape record (causes cache flush)
+
+   The address field is a 32bit (lower-case) hexadecimal address
+   value. The address should *NOT* be preceded by "0x".
+
+   The size of the memory transfer is not important when dealing with
+   cache lines (as long as no more than a cache line can be
+   transferred in a single operation :-), however more information
+   could be given following the dineroIII requirement to allow more
+   complete memory and cache simulators to provide better
+   results. i.e. the University of Pisa has a cache simulator that can
+   also take bus size and speed as (variable) inputs to calculate
+   complete system performance (a much more useful ability when trying
+   to construct an end product, rather than a processor). They
+   currently have an ARM version of their tool called ChARM. */
+
+
+void
+dotrace (SIM_DESC sd,
+	 sim_cpu *cpu,
+	 FILE *tracefh,
+	 int type,
+	 SIM_ADDR address,
+	 int width,
+	 char *comment,...)
+{
+  if (STATE & simTRACE) {
+    va_list ap;
+    fprintf(tracefh,"%d %s ; width %d ; ", 
+		type,
+		pr_addr(address),
+		width);
+    va_start(ap,comment);
+    vfprintf(tracefh,comment,ap);
+    va_end(ap);
+    fprintf(tracefh,"\n");
+  }
+  /* NOTE: Since the "din" format will only accept 32bit addresses, and
+     we may be generating 64bit ones, we should put the hi-32bits of the
+     address into the comment field. */
+
+  /* TODO: Provide a buffer for the trace lines. We can then avoid
+     performing writes until the buffer is filled, or the file is
+     being closed. */
+
+  /* NOTE: We could consider adding a comment field to the "din" file
+     produced using type 3 markers (unknown access). This would then
+     allow information about the program that the "din" is for, and
+     the MIPs world that was being simulated, to be placed into the
+     trace file. */
+
+  return;
+}
+#endif /* TRACE */
+
+/*---------------------------------------------------------------------------*/
+/*-- simulator engine -------------------------------------------------------*/
+/*---------------------------------------------------------------------------*/
+
+static void
+ColdReset (SIM_DESC sd)
+{
+  int cpu_nr;
+  for (cpu_nr = 0; cpu_nr < sim_engine_nr_cpus (sd); cpu_nr++)
+    {
+      sim_cpu *cpu = STATE_CPU (sd, cpu_nr);
+#if 0 // Katano
+      /* RESET: Fixed PC address: */
+      PC = (unsigned_word) UNSIGNED64 (0xFFFFFFFFBFC00000);
+      /* The reset vector address is in the unmapped, uncached memory space. */
+      
+      SR &= ~(status_SR | status_TS | status_RP);
+      SR |= (status_ERL | status_BEV);
+      
+      /* Cheat and allow access to the complete register set immediately */
+      if (CURRENT_FLOATING_POINT == HARD_FLOATING_POINT
+	  && WITH_TARGET_WORD_BITSIZE == 64)
+	SR |= status_FR; /* 64bit registers */
+      
+      /* Ensure that any instructions with pending register updates are
+	 cleared: */
+      PENDING_INVALIDATE();
+      
+      /* Initialise the FPU registers to the unknown state */
+      if (CURRENT_FLOATING_POINT == HARD_FLOATING_POINT)
+	{
+	  int rn;
+	  for (rn = 0; (rn < 32); rn++)
+	    FPR_STATE[rn] = fmt_uninterpreted;
+	}
+#else
+    PC = 0;
+    SR = 0;
+#endif      
+    }
+}
+
+
+
+
+/* Description from page A-26 of the "MIPS IV Instruction Set" manual (revision 3.1) */
+/* Signal an exception condition. This will result in an exception
+   that aborts the instruction. The instruction operation pseudocode
+   will never see a return from this function call. */
+static char *
+ptr (x)
+     int x;
+{
+//  return (char *) (x + saved_state.asregs.memory);
+  return (char *) (x);
+}
+
+static void
+strnswap (str, len)
+     int str;
+     int len;
+{
+  int *start, *end;
+
+  start = (int *) ptr (str & ~3);
+  end = (int *) ptr (str + len);
+  do
+    {
+      int old = *start;
+      *start = (old << 24 | (old & 0xff00) << 8
+		| (old & 0xff0000) >> 8 | (old & 0xff000000) >> 24);
+      start++;
+    }
+  while (start < end);
+}
+#define	SYS_write	4
+#define	SYS_open	5
+#define	SYS_close	6
+
+void
+signal_exception (SIM_DESC sd,
+		  sim_cpu *cpu,
+		  address_word cia,
+		  int exception,...)
+{
+  /* int vector; */
+
+#ifdef DEBUG
+  sim_io_printf(sd,"DBG: SignalException(%d) PC = 0x%s\n",exception,pr_addr(cia));
+#endif /* DEBUG */
+
+//#if 0 //Katano
+//  /* Ensure that any active atomic read/modify/write operation will fail: */
+//  LLBIT = 0;
+//#endif
+  /* Save registers before interrupt dispatching */
+#ifdef SIM_CPU_EXCEPTION_TRIGGER
+  SIM_CPU_EXCEPTION_TRIGGER(sd, cpu, cia);
+#endif
+
+  switch (exception) {
+
+    case 34:  // Syscalls
+    {
+       va_list ap;
+       unsigned int o1,f2,l4;
+       char *p3;
+       va_start(ap,exception);
+       o1 = va_arg(ap,unsigned int);
+       f2 = va_arg(ap,unsigned int);
+       p3 = (char *)va_arg(ap,address_word);
+//       p3 = va_arg(ap,char *);
+       l4 = va_arg(ap,unsigned int);
+       va_end(ap);
+  //sim_io_printf(sd,"Syscalls? exc=%d o1=%d f2=0x%x p3=%x l4=%d \n",exception,o1,f2,(unsigned int)p3,l4);
+       switch( o1 )
+       {
+		 case SYS_write:
+		 {
+//sim_io_printf("TRAPTRAPTRAP=%d\n",0);
+  	      char *buf = zalloc(l4);
+	      sim_read (sd, p3, buf, l4);
+
+	    if (f2 == 1)
+	      callback->write_stdout (callback, //"he\n", sizeof("he\n"));
+						     buf, l4);
+	    else
+	      callback->write (callback, f2, "hello",5);
+//						      p3, l4);
+
+   	      zfree (buf);
+          break;
+       }
+      case 1: /* SYS_exit */
+        //sim_io_printf(sd, "SYS_exit=%d\n",0);
+        sim_engine_halt (SD, CPU, NULL, NULL_CIA, sim_exited,
+                        (unsigned int)(0x0));
+        break;
+#if 0
+         case SYS_open:
+          callback->open( callback, f2,sizeof
+         case SYS_close:
+#endif
+       }
+
+	}
+	break;
+//#if 0 // Katano
+    case DebugBreakPoint:
+    {
+		  if (INDELAYSLOT())
+            {
+              CANCELDELAYSLOT();
+              EPC = cia - 4;      /* reference the branch instruction */
+            }
+          else
+            {
+              EPC = cia;
+            }
+          PC = 0x0ffe0000;
+          sim_engine_restart (SD, CPU, NULL, NULL_CIA);
+    }
+    break;
+//#else
+//    case 0x0a:
+    case Trap:
+    {
+       va_list ap;
+       unsigned int trapno;
+       va_start(ap,exception);
+       trapno = va_arg(ap,unsigned int);
+       va_end(ap);
+sim_io_printf("TRAPTRAPTRAP=%d\n",trapno);
+       switch(trapno)
+       {
+	   case 0:
+	      PC=0x0;
+              sim_engine_restart (SD, CPU, NULL, NULL_CIA);
+              break;
+           default:
+              break;
+       }
+     }	      
+//#endif
+      break;
+#if 0
+//  case ReservedInstruction:
+//     {
+//       va_list ap;
+//       unsigned int instruction;
+//       va_start(ap,exception);
+//       instruction = va_arg(ap,unsigned int);
+//       va_end(ap);
+//       /* Provide simple monitor support using ReservedInstruction
+//          exceptions. The following code simulates the fixed vector
+//          entry points into the IDT monitor by causing a simulator
+//          trap, performing the monitor operation, and returning to
+//          the address held in the $ra register (standard PCS return
+//          address). This means we only need to pre-load the vector
+//          space with suitable instruction values. For systems were
+//          actual trap instructions are used, we would not need to
+//          perform this magic. */
+//       if ((instruction & RSVD_INSTRUCTION_MASK) == RSVD_INSTRUCTION)
+//	 {
+//	   int reason = (instruction >> RSVD_INSTRUCTION_ARG_SHIFT) & RSVD_INSTRUCTION_ARG_MASK;
+//	   if (!sim_monitor (SD, CPU, cia, reason))
+//	     sim_io_error (sd, "sim_monitor: unhandled reason = %d, pc = 0x%s\n", reason, pr_addr (cia));
+//
+//	   /* NOTE: This assumes that a branch-and-link style
+//	      instruction was used to enter the vector (which is the
+//	      case with the current IDT monitor). */
+//	   sim_engine_restart (SD, CPU, NULL, RA);
+//	 }
+//       /* Look for the brownie3216 entry and exit instructions, and
+//          simulate a handler for them.  */
+//#if 0 // Delete C.Katano
+//       else if ((cia & 1) != 0
+//		&& (instruction & 0xf81f) == 0xe809
+//		&& (instruction & 0x0c0) != 0x0c0)
+//	 {
+//	   brownie3216_entry (SD, CPU, cia, instruction);
+//	   sim_engine_restart (sd, NULL, NULL, NULL_CIA);
+//	 }
+//#endif
+//       /* else fall through to normal exception processing */
+//       sim_io_eprintf(sd,"ReservedInstruction at PC = 0x%s inst=0x%x\n", pr_addr (cia),instruction);
+//     }
+#endif
+//-----------------------------------------------------------------------------------    default:
+     /* Store exception code into current exception id variable (used
+        by exit code): */
+
+     /* TODO: If not simulating exceptions then stop the simulator
+        execution. At the moment we always stop the simulation. */
+
+     /* See figure 5-17 for an outline of the code below */
+//   if (! (SR & status_EXL))
+//       {
+//printf("::::::::-1\n");
+//	 CAUSE = (exception << 2);
+//	 if (STATE & simDELAYSLOT)
+//	   {
+//	     STATE &= ~simDELAYSLOT;
+//	     CAUSE |= cause_BD;
+	   //-------------------------------------------------------------------------  EPC = (cia - 4); /* reference the branch instruction */
+//printf("::::::::-2\n");
+//	   }
+//	 else
+//	   EPC = cia;
+//	 /* FIXME: TLB et.al. */
+//	 /* vector = 0x180; */
+//       }
+//     else
+//       {
+//	 CAUSE = (exception << 2);
+//	 /* vector = 0x180; */
+//printf("::::::::-4\n");
+//       }
+//     SR |= status_EXL;
+     /* Store exception code into current exception id variable (used
+        by exit code): */
+//#if 0
+//     if (SR & status_BEV)
+//       PC = (signed)0xBFC00200 + 0x180;
+//     else
+//       PC = (signed)0x80000000 + 0x180;
+//#else
+//      PC = (signed)0xBFC00200 + 0x180;
+       //-----------------------------------------------------------------PC = (signed)0x00000000;
+//#endif
+//printf("(CAUSE >> 2) & 0x1F = 0x%x\n",(CAUSE >> 2) & 0x1F);
+//#if 0
+//     switch ((CAUSE >> 2) & 0x1F)
+//       {
+//       case Interrupt:
+//	 /* Interrupts arrive during event processing, no need to
+//            restart */
+//	 return;
+//
+//       case NMIReset:
+//	 /* Ditto */
+//#ifdef SUBTARGET_3900
+//	 /* Exception vector: BEV=0 BFC00000 / BEF=1 BFC00000  */
+//	 PC = (signed)0xBFC00000;
+//#endif /* SUBTARGET_3900 */
+//	 return;
+//
+//       case TLBModification:
+//       case TLBLoad:
+//       case TLBStore:
+//       case AddressLoad:
+//       case AddressStore:
+//       case InstructionFetch:
+//       case DataReference:
+//	 /* The following is so that the simulator will continue from the
+//	    exception handler address. */
+//printf("=====>SIM_SIGBUS 0x%x\n",(CAUSE >> 2) & 0x1F );
+//	 sim_engine_halt (SD, CPU, NULL, PC,
+//			  sim_stopped, SIM_SIGBUS);
+//       case ReservedInstruction:
+//       case CoProcessorUnusable:
+//printf("=====>SIM_SIGILL 0x%x\n",(CAUSE >> 2) & 0x1F );
+////	 PC = EPC;
+//	 sim_engine_halt (SD, CPU, NULL, PC,
+//			  sim_stopped, SIM_SIGILL);
+//
+//       case IntegerOverflow:
+//       case FPE:
+//	 sim_engine_halt (SD, CPU, NULL, PC,
+//			  sim_stopped, SIM_SIGFPE);
+//	 
+       case BreakPoint:
+     EPC=cia-4;
+//printf("%s<%d> SIM_SIGTRAP\n",__FILE__,__LINE__);
+	 sim_engine_halt (SD, CPU, NULL, PC, sim_stopped, SIM_SIGTRAP);
+//printf("%s<%d> SIM_SIGTRAP2\n",__FILE__,__LINE__);
+	 break;
+       case 0xfffffffe:
+         sim_engine_halt (SD, CPU, NULL, NULL_CIA, sim_exited,
+//      	        (unsigned int)(A0 & 0xFFFFFFFF));
+                    (unsigned int)(0x0));
+        break;
+//
+//       case SystemCall:
+//       case Trap:
+//	 sim_engine_restart (SD, CPU, NULL, PC);
+//	 break;
+//
+//       case Watch:
+//	 PC = EPC;
+//	 sim_engine_halt (SD, CPU, NULL, PC,
+//			  sim_stopped, SIM_SIGTRAP);
+//
+//       default: /* Unknown internal exception */
+//	 PC = EPC;
+//	 sim_engine_halt (SD, CPU, NULL, PC,
+//			  sim_stopped, SIM_SIGABRT);
+//
+//       }
+//#endif
+    case SimulatorFault:
+     {
+       va_list ap;
+       char *msg;
+       va_start(ap,exception);
+       msg = va_arg(ap,char *);
+       va_end(ap);
+       sim_engine_abort (SD, CPU, NULL_CIA,
+			 "FATAL: Simulator error \"%s\"\n",msg);
+     }
+   }
+
+  return;
+}
+
+//SYS_write, file, ptr, len
+static int Syscall( int ope, int file, int p, int l)
+{
+	extern int errno;
+	int perrno = errno;
+	errno = 0;
+
+//  sim_io_printf(sd,"Syscall ope=0x%x file=0x%x p=0x%x l=0x%x\n",ope,file,p,l);
+#ifdef DEBUG
+  gprintf("Syscall ope=0x%x file=0x%x p=0x%x l=0x%x\n",ope,file,p,l);
+#endif
+#if 0
+	switch (ope)
+	  {
+
+#if !defined(__GO32__) && !defined(_WIN32)
+	  case SYS_fork:
+	    regs[0] = fork ();
+	    break;
+/* This would work only if endianness matched between host and target.
+   Besides, it's quite dangerous.  */
+#if 0
+	  case SYS_execve:
+	    regs[0] = execve (ptr (regs[5]), (char **) ptr (regs[6]), 
+			      (char **) ptr (regs[7]));
+	    break;
+	  case SYS_execv:
+	    regs[0] = execve (ptr (regs[5]), (char **) ptr (regs[6]), 0);
+	    break;
+#endif
+	  case SYS_pipe:
+	    {
+	      regs[0] = (BUSERROR (regs[5], maskl)
+			 ? -EINVAL
+			 : pipe ((int *) ptr (regs[5])));
+	    }
+	    break;
+
+	  case SYS_wait:
+	    regs[0] = wait (ptr (regs[5]));
+	    break;
+#endif /* !defined(__GO32__) && !defined(_WIN32) */
+
+	  case SYS_read:
+	    strnswap (regs[6], regs[7]);
+	    regs[0]
+	      = callback->read (callback, regs[5], ptr (regs[6]), regs[7]);
+	    strnswap (regs[6], regs[7]);
+	    break;
+	  case SYS_write:
+	    strnswap (regs[6], regs[7]);
+	    if (regs[5] == 1)
+	      regs[0] = (int) callback->write_stdout (callback, 
+						      ptr (regs[6]), regs[7]);
+	    else
+	      regs[0] = (int) callback->write (callback, regs[5], 
+					       ptr (regs[6]), regs[7]);
+	    strnswap (regs[6], regs[7]);
+	    break;
+	  case SYS_lseek:
+	    regs[0] = callback->lseek (callback,regs[5], regs[6], regs[7]);
+	    break;
+	  case SYS_close:
+	    regs[0] = callback->close (callback,regs[5]);
+	    break;
+	  case SYS_open:
+	    {
+	      int len = strswaplen (regs[5]);
+	      strnswap (regs[5], len);
+	      regs[0] = callback->open (callback, ptr (regs[5]), regs[6]);
+	      strnswap (regs[5], len);
+	      break;
+	    }
+	  case SYS_exit:
+#if 000
+	    /* EXIT - caller can look in r5 to work out the reason */
+	    raise_exception (SIGQUIT);
+	    regs[0] = regs[5];
+#endif /* 000 */
+           /* regs[8] :: r8 :: register passing parameter 1st */
+           sim_engine_halt (SD, CPU, NULL, NULL_CIA, sim_exited,
+                            regs[8]);
+	    break;
+
+	  case SYS_stat:	/* added at hmsi */
+	    /* stat system call */
+	    {
+	      struct stat host_stat;
+	      int buf;
+	      int len = strswaplen (regs[5]);
+
+	      strnswap (regs[5], len);
+	      regs[0] = stat (ptr (regs[5]), &host_stat);
+	      strnswap (regs[5], len);
+
+	      buf = regs[6];
+
+	      WWAT (buf, host_stat.st_dev);
+	      buf += 2;
+	      WWAT (buf, host_stat.st_ino);
+	      buf += 2;
+	      WLAT (buf, host_stat.st_mode);
+	      buf += 4;
+	      WWAT (buf, host_stat.st_nlink);
+	      buf += 2;
+	      WWAT (buf, host_stat.st_uid);
+	      buf += 2;
+	      WWAT (buf, host_stat.st_gid);
+	      buf += 2;
+	      WWAT (buf, host_stat.st_rdev);
+	      buf += 2;
+	      WLAT (buf, host_stat.st_size);
+	      buf += 4;
+	      WLAT (buf, host_stat.st_atime);
+	      buf += 4;
+	      WLAT (buf, 0);
+	      buf += 4;
+	      WLAT (buf, host_stat.st_mtime);
+	      buf += 4;
+	      WLAT (buf, 0);
+	      buf += 4;
+	      WLAT (buf, host_stat.st_ctime);
+	      buf += 4;
+	      WLAT (buf, 0);
+	      buf += 4;
+	      WLAT (buf, 0);
+	      buf += 4;
+	      WLAT (buf, 0);
+	      buf += 4;
+	    }
+	    break;
+
+#ifndef _WIN32
+	  case SYS_chown:
+	    {
+	      int len = strswaplen (regs[5]);
+
+	      strnswap (regs[5], len);
+	      regs[0] = chown (ptr (regs[5]), regs[6], regs[7]);
+	      strnswap (regs[5], len);
+	      break;
+	    }
+#endif /* _WIN32 */
+	  case SYS_chmod:
+	    {
+	      int len = strswaplen (regs[5]);
+
+	      strnswap (regs[5], len);
+	      regs[0] = chmod (ptr (regs[5]), regs[6]);
+	      strnswap (regs[5], len);
+	      break;
+	    }
+	  case SYS_utime:
+	    {
+	      /* Cast the second argument to void *, to avoid type mismatch
+		 if a prototype is present.  */
+	      int len = strswaplen (regs[5]);
+
+	      strnswap (regs[5], len);
+	      regs[0] = utime (ptr (regs[5]), (void *) ptr (regs[6]));
+	      strnswap (regs[5], len);
+	      break;
+	    }
+	  case SYS_argc:
+	    regs[0] = count_argc (prog_argv);
+	    break;
+	  case SYS_argnlen:
+	    if (regs[5] < count_argc (prog_argv))
+	      regs[0] = strlen (prog_argv[regs[5]]);
+	    else
+	      regs[0] = -1;
+	    break;
+	  case SYS_argn:
+	    if (regs[5] < count_argc (prog_argv))
+	      {
+		/* Include the termination byte.  */
+		int i = strlen (prog_argv[regs[5]]) + 1;
+		regs[0] = sim_write (0, regs[6], prog_argv[regs[5]], i);
+	      }
+	    else
+	      regs[0] = -1;
+	    break;
+	  case SYS_time:
+	    regs[0] = get_now ();
+	    break;
+	  case SYS_ftruncate:
+	    regs[0] = callback->ftruncate (callback, regs[5], regs[6]);
+	    break;
+	  case SYS_truncate:
+	    {
+	      int len = strswaplen (regs[5]);
+	      strnswap (regs[5], len);
+	      regs[0] = callback->truncate (callback, ptr (regs[5]), regs[6]);
+	      strnswap (regs[5], len);
+	      break;
+	    }
+	  default:
+	    regs[0] = -1;
+	    break;
+	  }
+#endif
+//	regs[4] = callback->get_errno (callback);
+	errno = perrno;
+}
+
+
+/* This function implements what the MIPS32 and MIPS64 ISAs define as
+   "UNPREDICTABLE" behaviour.
+
+   About UNPREDICTABLE behaviour they say: "UNPREDICTABLE results
+   may vary from processor implementation to processor implementation,
+   instruction to instruction, or as a function of time on the same
+   implementation or instruction.  Software can never depend on results
+   that are UNPREDICTABLE. ..."  (MIPS64 Architecture for Programmers
+   Volume II, The MIPS64 Instruction Set.  MIPS Document MD00087 revision
+   0.95, page 2.)
+  
+   For UNPREDICTABLE behaviour, we print a message, if possible print
+   the offending instructions brownie32.igen instruction name (provided by
+   the caller), and stop the simulator.
+
+   XXX FIXME: eventually, stopping the simulator should be made conditional
+   on a command-line option.  */
+void
+unpredictable_action(sim_cpu *cpu, address_word cia)
+{
+  SIM_DESC sd = CPU_STATE(cpu);
+
+  sim_io_eprintf(sd, "UNPREDICTABLE: PC = 0x%s\n", pr_addr (cia));
+  sim_engine_halt (SD, CPU, NULL, cia, sim_stopped, SIM_SIGABRT);
+}
+
+
+/*-- co-processor support routines ------------------------------------------*/
+#if 0 // No co-proc Katano
+
+static int UNUSED
+CoProcPresent(unsigned int coproc_number)
+{
+  /* Return TRUE if simulator provides a model for the given co-processor number */
+  return(0);
+}
+
+void
+cop_lw (SIM_DESC sd,
+	sim_cpu *cpu,
+	address_word cia,
+	int coproc_num,
+	int coproc_reg,
+	unsigned int memword)
+{
+  switch (coproc_num)
+    {
+    case 1:
+      if (CURRENT_FLOATING_POINT == HARD_FLOATING_POINT)
+	{
+#ifdef DEBUG
+	  printf("DBG: COP_LW: memword = 0x%08X (uword64)memword = 0x%s\n",memword,pr_addr(memword));
+#endif
+	  StoreFPR(coproc_reg,fmt_word,(uword64)memword);
+	  FPR_STATE[coproc_reg] = fmt_uninterpreted;
+	  break;
+	}
+
+    default:
+#if 0 /* this should be controlled by a configuration option */
+      sim_io_printf(sd,"COP_LW(%d,%d,0x%08X) at PC = 0x%s : TODO (architecture specific)\n",coproc_num,coproc_reg,memword,pr_addr(cia));
+#endif
+      break;
+    }
+
+  return;
+}
+
+void
+cop_ld (SIM_DESC sd,
+	sim_cpu *cpu,
+	address_word cia,
+	int coproc_num,
+	int coproc_reg,
+	uword64 memword)
+{
+
+#ifdef DEBUG
+  printf("DBG: COP_LD: coproc_num = %d, coproc_reg = %d, value = 0x%s : PC = 0x%s\n", coproc_num, coproc_reg, pr_uword64(memword), pr_addr(cia) );
+#endif
+
+  switch (coproc_num) {
+    case 1:
+      if (CURRENT_FLOATING_POINT == HARD_FLOATING_POINT)
+	{
+	  StoreFPR(coproc_reg,fmt_uninterpreted,memword);
+	  break;
+	}
+
+    default:
+#if 0 /* this message should be controlled by a configuration option */
+     sim_io_printf(sd,"COP_LD(%d,%d,0x%s) at PC = 0x%s : TODO (architecture specific)\n",coproc_num,coproc_reg,pr_addr(memword),pr_addr(cia));
+#endif
+     break;
+  }
+
+  return;
+}
+
+
+
+
+unsigned int
+cop_sw (SIM_DESC sd,
+	sim_cpu *cpu,
+	address_word cia,
+	int coproc_num,
+	int coproc_reg)
+{
+  unsigned int value = 0;
+
+  switch (coproc_num)
+    {
+    case 1:
+      if (CURRENT_FLOATING_POINT == HARD_FLOATING_POINT)
+	{
+	  FP_formats hold;
+	  hold = FPR_STATE[coproc_reg];
+	  FPR_STATE[coproc_reg] = fmt_word;
+	  value = (unsigned int)ValueFPR(coproc_reg,fmt_uninterpreted);
+	  FPR_STATE[coproc_reg] = hold;
+	  break;
+	}
+
+    default:
+#if 0 /* should be controlled by configuration option */
+      sim_io_printf(sd,"COP_SW(%d,%d) at PC = 0x%s : TODO (architecture specific)\n",coproc_num,coproc_reg,pr_addr(cia));
+#endif
+      break;
+    }
+
+  return(value);
+}
+
+uword64
+cop_sd (SIM_DESC sd,
+	sim_cpu *cpu,
+	address_word cia,
+	int coproc_num,
+	int coproc_reg)
+{
+  uword64 value = 0;
+  switch (coproc_num)
+    {
+    case 1:
+      if (CURRENT_FLOATING_POINT == HARD_FLOATING_POINT)
+	{
+	  value = ValueFPR(coproc_reg,fmt_uninterpreted);
+	  break;
+	}
+
+    default:
+#if 0 /* should be controlled by configuration option */
+      sim_io_printf(sd,"COP_SD(%d,%d) at PC = 0x%s : TODO (architecture specific)\n",coproc_num,coproc_reg,pr_addr(cia));
+#endif
+      break;
+    }
+
+  return(value);
+}
+
+
+
+void
+decode_coproc (SIM_DESC sd,
+	       sim_cpu *cpu,
+	       address_word cia,
+	       unsigned int instruction)
+{
+	
+  int coprocnum = ((instruction >> 26) & 3);
+  switch (coprocnum)
+    {
+    case 0: /* standard CPU control and cache registers */
+      {
+        int code = ((instruction >> 21) & 0x1F);
+	int rt = ((instruction >> 16) & 0x1F);
+	int rd = ((instruction >> 11) & 0x1F);
+	int tail = instruction & 0x3ff;
+        /* R4000 Users Manual (second edition) lists the following CP0
+           instructions:
+	                                                           CODE><-RT><RD-><--TAIL--->
+	   DMFC0   Doubleword Move From CP0        (VR4100 = 01000000001 tttttddddd00000000000)
+	   DMTC0   Doubleword Move To CP0          (VR4100 = 01000000101 tttttddddd00000000000)
+	   MFC0    word Move From CP0              (VR4100 = 01000000000 tttttddddd00000000000)
+	   MTC0    word Move To CP0                (VR4100 = 01000000100 tttttddddd00000000000)
+	   TLBR    Read Indexed TLB Entry          (VR4100 = 01000010000 000000000000000000001)
+	   TLBWI   Write Indexed TLB Entry         (VR4100 = 01000010000 000000000000000000010)
+	   TLBWR   Write Random TLB Entry          (VR4100 = 01000010000 000000000000000000110)
+	   TLBP    Probe TLB for Matching Entry    (VR4100 = 01000010000 000000000000000001000)
+	   CACHE   Cache operation                 (VR4100 = 101111bbbbb pppppiiiiiiiiiiiiiiii)
+	   ERET    Exception return                (VR4100 = 01000010000 000000000000000011000)
+	   */
+        if (((code == 0x00) || (code == 0x04)      /* MFC0  /  MTC0  */        
+	     || (code == 0x01) || (code == 0x05))  /* DMFC0 / DMTC0  */        
+	    && tail == 0)
+	  {
+	    /* Clear double/single coprocessor move bit. */
+	    code &= ~1;
+
+	    /* M[TF]C0 (32 bits) | DM[TF]C0 (64 bits) */
+	    
+	    switch (rd)  /* NOTEs: Standard CP0 registers */
+	      {
+		/* 0 = Index               R4000   VR4100  VR4300 */
+		/* 1 = Random              R4000   VR4100  VR4300 */
+		/* 2 = EntryLo0            R4000   VR4100  VR4300 */
+		/* 3 = EntryLo1            R4000   VR4100  VR4300 */
+		/* 4 = Context             R4000   VR4100  VR4300 */
+		/* 5 = PageMask            R4000   VR4100  VR4300 */
+		/* 6 = Wired               R4000   VR4100  VR4300 */
+		/* 8 = BadVAddr            R4000   VR4100  VR4300 */
+		/* 9 = Count               R4000   VR4100  VR4300 */
+		/* 10 = EntryHi            R4000   VR4100  VR4300 */
+		/* 11 = Compare            R4000   VR4100  VR4300 */
+		/* 12 = SR                 R4000   VR4100  VR4300 */
+#ifdef SUBTARGET_R3900
+	      case 3:
+		/* 3 = Config              R3900                  */
+	      case 7:
+		/* 7 = Cache               R3900                  */
+	      case 15:
+		/* 15 = PRID               R3900                  */
+
+		/* ignore */
+		break;
+
+	      case 8:
+		/* 8 = BadVAddr            R4000   VR4100  VR4300 */
+		if (code == 0x00)
+		  GPR[rt] = (signed_word) (signed_address) COP0_BADVADDR;
+		else
+		  COP0_BADVADDR = GPR[rt];
+		break;
+
+#endif /* SUBTARGET_R3900 */
+	      case 12:
+		if (code == 0x00)
+		  GPR[rt] = SR;
+		else
+		  SR = GPR[rt];
+		break;
+		/* 13 = Cause              R4000   VR4100  VR4300 */
+	      case 13:
+		if (code == 0x00)
+		  GPR[rt] = CAUSE;
+		else
+		  CAUSE = GPR[rt];
+		break;
+		/* 14 = EPC                R4000   VR4100  VR4300 */
+	      case 14:
+		if (code == 0x00)
+		  GPR[rt] = (signed_word) (signed_address) EPC;
+		else
+		  EPC = GPR[rt];
+		break;
+		/* 15 = PRId               R4000   VR4100  VR4300 */
+#ifdef SUBTARGET_R3900
+                /* 16 = Debug */
+              case 16:
+                if (code == 0x00)
+                  GPR[rt] = Debug;
+                else
+                  Debug = GPR[rt];
+                break;
+#else
+		/* 16 = Config             R4000   VR4100  VR4300 */
+              case 16:
+                if (code == 0x00)
+                  GPR[rt] = C0_CONFIG;
+                else
+                  C0_CONFIG = GPR[rt];
+                break;
+#endif
+#ifdef SUBTARGET_R3900
+                /* 17 = Debug */
+              case 17:
+                if (code == 0x00)
+                  GPR[rt] = DEPC;
+                else
+                  DEPC = GPR[rt];
+                break;
+#else
+		/* 17 = LLAddr             R4000   VR4100  VR4300 */
+#endif
+		/* 18 = WatchLo            R4000   VR4100  VR4300 */
+		/* 19 = WatchHi            R4000   VR4100  VR4300 */
+		/* 20 = XContext           R4000   VR4100  VR4300 */
+		/* 26 = PErr or ECC        R4000   VR4100  VR4300 */
+		/* 27 = CacheErr           R4000   VR4100 */
+		/* 28 = TagLo              R4000   VR4100  VR4300 */
+		/* 29 = TagHi              R4000   VR4100  VR4300 */
+		/* 30 = ErrorEPC           R4000   VR4100  VR4300 */
+		if (STATE_VERBOSE_P(SD))
+		  sim_io_eprintf (SD, 
+				  "Warning: PC 0x%lx:interp.c decode_coproc DEADC0DE\n",
+				  (unsigned long)cia);
+		GPR[rt] = 0xDEADC0DE; /* CPR[0,rd] */
+		/* CPR[0,rd] = GPR[rt]; */
+	      default:
+		if (code == 0x00)
+		  GPR[rt] = (signed_word) (signed32) COP0_GPR[rd];
+		else
+		  COP0_GPR[rd] = GPR[rt];
+#if 0
+		if (code == 0x00)
+		  sim_io_printf(sd,"Warning: MFC0 %d,%d ignored, PC=%08x (architecture specific)\n",rt,rd, (unsigned)cia);
+		else
+		  sim_io_printf(sd,"Warning: MTC0 %d,%d ignored, PC=%08x (architecture specific)\n",rt,rd, (unsigned)cia);
+#endif
+	      }
+	  }
+	else if (code == 0x10 && (tail & 0x3f) == 0x18)
+	  {
+	    /* ERET */
+	    if (SR & status_ERL)
+	      {
+		/* Oops, not yet available */
+		sim_io_printf(sd,"Warning: ERET when SR[ERL] set not handled yet");
+		PC = EPC;
+		SR &= ~status_ERL;
+	      }
+	    else
+	      {
+		PC = EPC;
+		SR &= ~status_EXL;
+	      }
+	  }
+        else if (code == 0x10 && (tail & 0x3f) == 0x10)
+          {
+            /* RFE */
+#ifdef SUBTARGET_R3900
+	    /* TX39: Copy IEp/KUp -> IEc/KUc, and IEo/KUo -> IEp/KUp */
+
+	    /* shift IE/KU history bits right */
+	    SR = LSMASKED32(SR, 31, 4) | LSINSERTED32(LSEXTRACTED32(SR, 5, 2), 3, 0);
+
+	    /* TODO: CACHE register */
+#endif /* SUBTARGET_R3900 */
+          }
+        else if (code == 0x10 && (tail & 0x3f) == 0x1F)
+          {
+            /* DERET */
+            Debug &= ~Debug_DM;
+            DELAYSLOT();
+            DSPC = DEPC;
+          }
+	else
+	  sim_io_eprintf(sd,"Unrecognised COP0 instruction 0x%08X at PC = 0x%s : No handler present\n",instruction,pr_addr(cia));
+        /* TODO: When executing an ERET or RFE instruction we should
+           clear LLBIT, to ensure that any out-standing atomic
+           read/modify/write sequence fails. */
+      }
+    break;
+    
+    case 2: /* co-processor 2 */
+      {
+	int handle = 0;
+
+
+	if(! handle)
+	  {
+	    sim_io_eprintf(sd, "COP2 instruction 0x%08X at PC = 0x%s : No handler present\n",
+			   instruction,pr_addr(cia));
+	  }
+      }
+    break;
+    
+    case 1: /* should not occur (FPU co-processor) */
+    case 3: /* should not occur (FPU co-processor) */
+      SignalException(ReservedInstruction,instruction);
+      break;
+    }
+  
+  return;
+}
+#endif
+
+/* This code copied from gdb's utils.c.  Would like to share this code,
+   but don't know of a common place where both could get to it. */
+
+/* Temporary storage using circular buffer */
+#define NUMCELLS 16
+#define CELLSIZE 32
+static char*
+get_cell (void)
+{
+  static char buf[NUMCELLS][CELLSIZE];
+  static int cell=0;
+  if (++cell>=NUMCELLS) cell=0;
+  return buf[cell];
+}     
+
+/* Print routines to handle variable size regs, etc */
+
+/* Eliminate warning from compiler on 32-bit systems */
+static int thirty_two = 32;	
+
+char* 
+pr_addr(addr)
+  SIM_ADDR addr;
+{
+  char *paddr_str=get_cell();
+  switch (sizeof(addr))
+    {
+      case 8:
+        sprintf(paddr_str,"%08lx%08lx",
+		(unsigned long)(addr>>thirty_two),(unsigned long)(addr&0xffffffff));
+	break;
+      case 4:
+        sprintf(paddr_str,"%08lx",(unsigned long)addr);
+	break;
+      case 2:
+        sprintf(paddr_str,"%04x",(unsigned short)(addr&0xffff));
+	break;
+      default:
+        sprintf(paddr_str,"%x",addr);
+    }
+  return paddr_str;
+}
+
+char* 
+pr_uword64(addr)
+  uword64 addr;
+{
+  char *paddr_str=get_cell();
+  sprintf(paddr_str,"%08lx%08lx",
+          (unsigned long)(addr>>thirty_two),(unsigned long)(addr&0xffffffff));
+  return paddr_str;
+}
+
+
+void
+brownie32_core_signal (SIM_DESC sd,
+                 sim_cpu *cpu,
+                 sim_cia cia,
+                 unsigned map,
+                 int nr_bytes,
+                 address_word addr,
+                 transfer_type transfer,
+                 sim_core_signals sig)
+{
+  const char *copy = (transfer == read_transfer ? "read" : "write");
+  address_word ip = CIA_ADDR (cia);
+  switch (sig)
+    {
+    case sim_core_unmapped_signal:
+
+      sim_io_eprintf (sd, "brownie32-core: %d byte %s to unmapped address 0x%lx at 0x%lx\n",
+                      nr_bytes, copy, 
+		      (unsigned long) addr, (unsigned long) ip);
+//      COP0_BADVADDR = addr;
+//    SignalExceptionDataReference();
+      break;
+
+    case sim_core_unaligned_signal:
+      sim_io_eprintf (sd, "brownie32-core: %d byte %s to unaligned address 0x%lx at 0x%lx\n",
+                      nr_bytes, copy, 
+		      (unsigned long) addr, (unsigned long) ip);
+//      COP0_BADVADDR = addr;
+      if(transfer == read_transfer) 
+      {
+//	SignalExceptionAddressLoad();
+      }
+      else
+      {
+//	SignalExceptionAddressStore();
+      }
+      break;
+
+    default:
+      sim_engine_abort (sd, cpu, cia,
+                        "brownie32_core_signal - internal error - bad switch");
+    }
+}
+
+
+void
+brownie32_cpu_exception_trigger(SIM_DESC sd, sim_cpu* cpu, address_word cia)
+{
+  ASSERT(cpu != NULL);
+
+  if(cpu->exc_suspended > 0)
+    sim_io_eprintf(sd, "Warning, nested exception triggered (%d)\n", cpu->exc_suspended); 
+
+  PC = cia;
+  memcpy(cpu->exc_trigger_registers, cpu->registers, sizeof(cpu->exc_trigger_registers));
+  cpu->exc_suspended = 0;
+}
+
+void
+brownie32_cpu_exception_suspend(SIM_DESC sd, sim_cpu* cpu, int exception)
+{
+  ASSERT(cpu != NULL);
+
+  if(cpu->exc_suspended > 0)
+    sim_io_eprintf(sd, "Warning, nested exception signal (%d then %d)\n", 
+		   cpu->exc_suspended, exception); 
+
+  memcpy(cpu->exc_suspend_registers, cpu->registers, sizeof(cpu->exc_suspend_registers));
+  memcpy(cpu->registers, cpu->exc_trigger_registers, sizeof(cpu->registers));
+  cpu->exc_suspended = exception;
+}
+
+void
+brownie32_cpu_exception_resume(SIM_DESC sd, sim_cpu* cpu, int exception)
+{
+  ASSERT(cpu != NULL);
+
+  if(exception == 0 && cpu->exc_suspended > 0)
+    {
+      /* warn not for breakpoints */
+//printf("%s<%d> SIM_SIGTRAP\n",__FILE__,__LINE__);
+      if(cpu->exc_suspended != sim_signal_to_host(sd, SIM_SIGTRAP))
+	sim_io_eprintf(sd, "Warning, resuming but ignoring pending exception signal (%d)\n",
+		       cpu->exc_suspended); 
+    }
+  else if(exception != 0 && cpu->exc_suspended > 0)
+    {
+      if(exception != cpu->exc_suspended) 
+	sim_io_eprintf(sd, "Warning, resuming with mismatched exception signal (%d vs %d)\n",
+		       cpu->exc_suspended, exception); 
+      
+      memcpy(cpu->registers, cpu->exc_suspend_registers, sizeof(cpu->registers)); 
+    }
+  else if(exception != 0 && cpu->exc_suspended == 0)
+    {
+      sim_io_eprintf(sd, "Warning, ignoring spontanous exception signal (%d)\n", exception); 
+    }
+  cpu->exc_suspended = 0; 
+}
+
+
+/*---------------------------------------------------------------------------*/
+/*> EOF interp.c <*/
Index: sim/brownie32/m16.dc
===================================================================
RCS file: sim/brownie32/m16.dc
diff -N sim/brownie32/m16.dc
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/m16.dc	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,25 @@
+# most instructions
+# ------ options ------ : Fst : Lst : ff : fl : fe : word : --- fmt --- : model ...
+# { : mask : value : word }
+
+# Top level - create a very big switch statement.
+
+  padded-switch,combine :  15 :  11 :    :    :    :      :             :
+
+  switch,combine        :  10 :   8 :    :    :    :      :             :
+
+  switch,combine        :   4 :   0 :    :    :    :      :             :
+
+  switch,combine        :   7 :   5 :    :    :    :      :             :
+
+
+# Extended instructions, decode the same way
+
+  padded-switch,combine :  15 :  11 :    :    :    :    1 :             :
+
+  switch,combine        :  10 :   8 :    :    :    :    1 :             :
+
+  switch,combine        :   4 :   0 :    :    :    :    1 :             :
+
+  switch,combine        :   7 :   5 :    :    :    :    1 :             :
+
Index: sim/brownie32/m16.igen
===================================================================
RCS file: sim/brownie32/m16.igen
diff -N sim/brownie32/m16.igen
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/m16.igen	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,1236 @@
+// -*- C -*-
+//
+//
+// MIPS Architecture:
+//
+//        CPU Instruction Set (brownie3216)
+//
+
+// The instructions in this section are ordered according
+// to http://www.sgi.com/MIPS/arch/MIPS16/brownie3216.pdf.
+
+
+// The MIPS16 codes registers in a special way, map from one to the other.
+// :<type>:<flags>:<models>:<typedef>:<name>:<field>:<expression>
+:compute:::int:TRX:RX:((RX < 2) ? (16 + RX) \: RX)
+:compute:::int:TRY:RY:((RY < 2) ? (16 + RY) \: RY)
+:compute:::int:TRZ:RZ:((RZ < 2) ? (16 + RZ) \: RZ)
+:compute:::int:SHIFT:SHAMT:((SHAMT == 0) ? 8 \: SHAMT)
+
+:compute:::int:SHAMT:SHAMT_4_0,S5:(LSINSERTED (S5, 5, 5) | SHAMT_4_0)
+
+:compute:::address_word:IMMEDIATE:IMM_25_21,IMM_20_16,IMMED_15_0:(LSINSERTED (IMM_25_21, 25, 21) | LSINSERTED (IMM_20_16, 20, 16) | LSINSERTED (IMMED_15_0, 15, 0))
+:compute:::int:R32:R32L,R32H:((R32H << 3) | R32L)
+
+:compute:::address_word:IMMEDIATE:IMM_10_5,IMM_15_11,IMM_4_0:(LSINSERTED (IMM_10_5, 10, 5) | LSINSERTED (IMM_15_11, 15, 11) | LSINSERTED (IMM_4_0, 4, 0))
+
+:compute:::address_word:IMMEDIATE:IMM_10_4,IMM_14_11,IMM_3_0:(LSINSERTED (IMM_10_4, 10, 4) | LSINSERTED (IMM_14_11, 14, 11) | LSINSERTED (IMM_3_0, 3, 0))
+
+
+// Load and Store Instructions
+
+
+10000,3.RX,3.RY,5.IMMED:RRI:16::LB
+"lb r<TRY>, <IMMED> (r<TRX>)"
+*brownie3216:
+*vr4100:
+{
+  GPR[TRY] = EXTEND8 (do_load (SD_, AccessLength_BYTE, GPR[TRX], IMMED));
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 10000,3.RX,3.RY,5.IMM_4_0:EXT-RRI:16::LB
+"lb r<TRY>, <IMMEDIATE> (r<TRX>)"
+*brownie3216:
+*vr4100:
+{
+  GPR[TRY] = EXTEND8 (do_load (SD_, AccessLength_BYTE, GPR[TRX], EXTEND16 (IMMEDIATE)));
+}
+
+
+
+10100,3.RX,3.RY,5.IMMED:RRI:16::LBU
+"lbu r<TRY>, <IMMED> (r<TRX>)"
+*brownie3216:
+*vr4100:
+{
+  GPR[TRY] = do_load (SD_, AccessLength_BYTE, GPR[TRX], IMMED);
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 10100,3.RX,3.RY,5.IMM_4_0:EXT-RRI:16::LBU
+"lbu r<TRY>, <IMMEDIATE> (r<TRX>)"
+*brownie3216:
+*vr4100:
+{
+  GPR[TRY] = do_load (SD_, AccessLength_BYTE, GPR[TRX], EXTEND16 (IMMEDIATE));
+}
+
+
+
+10001,3.RX,3.RY,5.IMMED:RRI:16::LH
+"lh r<TRY>, <IMMED> (r<TRX>)"
+*brownie3216:
+*vr4100:
+{
+  GPR[TRY] = EXTEND16 (do_load (SD_, AccessLength_HALFWORD, GPR[TRX], IMMED << 1));
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 10001,3.RX,3.RY,5.IMM_4_0:EXT-RRI:16::LH
+"lh r<TRY>, <IMMEDIATE> (r<TRX>)"
+*brownie3216:
+*vr4100:
+{
+  GPR[TRY] = EXTEND16 (do_load (SD_, AccessLength_HALFWORD, GPR[TRX], EXTEND16 (IMMEDIATE)));
+}
+
+
+
+10101,3.RX,3.RY,5.IMMED:RRI:16::LHU
+"lhu r<TRY>, <IMMED> (r<TRX>)"
+*brownie3216:
+*vr4100:
+{
+  GPR[TRY] = do_load (SD_, AccessLength_HALFWORD, GPR[TRX], IMMED << 1);
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 10101,3.RX,3.RY,5.IMM_4_0:EXT-RRI:16::LHU
+"lhu r<TRY>, <IMMEDIATE> (r<TRX>)"
+*brownie3216:
+*vr4100:
+{
+  GPR[TRY] = do_load (SD_, AccessLength_HALFWORD, GPR[TRX], EXTEND16 (IMMEDIATE));
+}
+
+
+
+10011,3.RX,3.RY,5.IMMED:RRI:16::LW
+"lw r<TRY>, <IMMED> (r<TRX>)"
+*brownie3216:
+*vr4100:
+{
+  GPR[TRY] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[TRX], IMMED << 2));
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 10011,3.RX,3.RY,5.IMM_4_0:EXT-RRI:16::LW
+"lw r<TRY>, <IMMEDIATE> (r<TRX>)"
+*brownie3216:
+*vr4100:
+{
+  GPR[TRY] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[TRX], EXTEND16 (IMMEDIATE)));
+}
+
+
+
+10110,3.RX,8.IMMED:RI:16::LWPC
+"lw r<TRX>, <IMMED> (PC)"
+*brownie3216:
+*vr4100:
+{
+  GPR[TRX] = EXTEND32 (do_load (SD_, AccessLength_WORD,
+				basepc (SD_) & ~3, IMMED << 2));
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 10110,3.RX,000,5.IMM_4_0:EXT-RI:16::LWPC
+"lw r<TRX>, <IMMEDIATE> (PC)"
+*brownie3216:
+*vr4100:
+{
+  GPR[TRX] = EXTEND32 (do_load (SD_, AccessLength_WORD, basepc (SD_) & ~3, EXTEND16 (IMMEDIATE)));
+}
+
+
+
+10010,3.RX,8.IMMED:RI:16::LWSP
+"lw r<TRX>, <IMMED> (SP)"
+*brownie3216:
+*vr4100:
+{
+  GPR[TRX] = EXTEND32 (do_load (SD_, AccessLength_WORD, SP, IMMED << 2));
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 10010,3.RX,000,5.IMM_4_0:EXT-RI:16::LWSP
+"lw r<TRX>, <IMMEDIATE> (SP)"
+*brownie3216:
+*vr4100:
+{
+  GPR[TRX] = EXTEND32 (do_load (SD_, AccessLength_WORD, SP, EXTEND16 (IMMEDIATE)));
+}
+
+
+
+10111,3.RX,3.RY,5.IMMED:RRI:16::LWU
+"lwu r<TRY>, <IMMED> (r<TRX>)"
+*brownie3216:
+*vr4100:
+{
+  GPR[TRY] = do_load (SD_, AccessLength_WORD, GPR[TRX], IMMED << 2);
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 10111,3.RX,3.RY,5.IMM_4_0:EXT-RRI:16::LWU
+"lwu r<TRY>, <IMMEDIATE> (r<TRX>)"
+*brownie3216:
+*vr4100:
+{
+  GPR[TRY] = do_load (SD_, AccessLength_WORD, GPR[TRX], EXTEND16 (IMMEDIATE));
+}
+
+
+
+00111,3.RX,3.RY,5.IMMED:RRI:16::LD
+"ld r<TRY>, <IMMED> (r<TRX>)"
+*brownie3216:
+*vr4100:
+{
+  GPR[TRY] = do_load (SD_, AccessLength_DOUBLEWORD, GPR[TRX], IMMED << 3);
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 00111,3.RX,3.RY,5.IMM_4_0:EXT-RRI:16::LD
+"ld r<TRY>, <IMMEDIATE> (r<TRX>)"
+*brownie3216:
+*vr4100:
+{
+  GPR[TRY] = do_load (SD_, AccessLength_DOUBLEWORD, GPR[TRX], EXTEND16 (IMMEDIATE));
+}
+
+
+
+11111,100,3.RY,5.IMMED:RI64:16::LDPC
+"ld r<TRY>, <IMMED> (PC)"
+*brownie3216:
+*vr4100:
+{
+  GPR[TRY] = do_load (SD_, AccessLength_DOUBLEWORD,
+		      basepc (SD_) & ~7, IMMED << 3);
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 11111,100,3.RY,5.IMM_4_0:EXT-RI64:16::LDPC
+"ld r<TRY>, <IMMEDIATE> (PC)"
+*brownie3216:
+*vr4100:
+{
+  GPR[TRY] = do_load (SD_, AccessLength_DOUBLEWORD, basepc (SD_) & ~7, EXTEND16 (IMMEDIATE));
+}
+
+
+
+11111,000,3.RY,5.IMMED:RI64:16::LDSP
+"ld r<TRY>, <IMMED> (SP)"
+*brownie3216:
+*vr4100:
+{
+  GPR[TRY] = do_load (SD_, AccessLength_DOUBLEWORD, SP, IMMED << 3);
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 11111,000,3.RY,5.IMM_4_0:EXT-RI64:16::LDSP
+"ld r<TRY>, <IMMEDIATE> (SP)"
+*brownie3216:
+*vr4100:
+{
+  GPR[TRY] = do_load (SD_, AccessLength_DOUBLEWORD, SP, EXTEND16 (IMMEDIATE));
+}
+
+
+
+11000,3.RX,3.RY,5.IMMED:RRI:16::SB
+"sb r<TRY>, <IMMED> (r<TRX>)"
+*brownie3216:
+*vr4100:
+{
+  do_store (SD_, AccessLength_BYTE, GPR[TRX], IMMED, GPR[TRY]);
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 11000,3.RX,3.RY,5.IMM_4_0:EXT-RRI:16::SB
+"sb r<TRY>, <IMMEDIATE> (r<TRX>)"
+*brownie3216:
+*vr4100:
+{
+  do_store (SD_, AccessLength_BYTE, GPR[TRX], EXTEND16 (IMMEDIATE), GPR[TRY]);
+}
+
+
+
+11001,3.RX,3.RY,5.IMMED:RRI:16::SH
+"sh r<TRY>, <IMMED> (r<TRX>)"
+*brownie3216:
+*vr4100:
+{
+  do_store (SD_, AccessLength_HALFWORD, GPR[TRX], IMMED << 1, GPR[TRY]);
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 11001,3.RX,3.RY,5.IMM_4_0:EXT-RRI:16::SH
+"sh r<TRY>, <IMMEDIATE> (r<TRX>)"
+*brownie3216:
+*vr4100:
+{
+  do_store (SD_, AccessLength_HALFWORD, GPR[TRX], EXTEND16 (IMMEDIATE), GPR[TRY]);
+}
+
+
+
+11011,3.RX,3.RY,5.IMMED:RRI:16::SW
+"sw r<TRY>, <IMMED> (r<TRX>)"
+*brownie3216:
+*vr4100:
+{
+  do_store (SD_, AccessLength_WORD, GPR[TRX], IMMED << 2, GPR[TRY]);
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 11011,3.RX,3.RY,5.IMM_4_0:EXT-RRI:16::SW
+"sw r<TRY>, <IMMEDIATE> (r<TRX>)"
+*brownie3216:
+*vr4100:
+{
+  do_store (SD_, AccessLength_WORD, GPR[TRX], EXTEND16 (IMMEDIATE), GPR[TRY]);
+}
+
+
+
+11010,3.RX,8.IMMED:RI:16::SWSP
+"sw r<TRX>, <IMMED> (SP)"
+*brownie3216:
+*vr4100:
+{
+  do_store (SD_, AccessLength_WORD, SP, IMMED << 2, GPR[TRX]);
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 11010,3.RX,000,5.IMM_4_0:EXT-RI:16::SWSP
+"sw r<TRX>, <IMMEDIATE> (SP)"
+*brownie3216:
+*vr4100:
+{
+  do_store (SD_, AccessLength_WORD, SP, EXTEND16 (IMMEDIATE), GPR[TRX]);
+}
+
+
+
+01100,010,8.IMMED:I8:16::SWRASP
+"sw r<RAIDX>, <IMMED> (SP)"
+*brownie3216:
+*vr4100:
+{
+  do_store (SD_, AccessLength_WORD, SP, IMMED << 2, RA);
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 01100,010,000,5.IMM_4_0:EXT-I8:16::SWRASP
+"sw r<RAIDX>, <IMMEDIATE> (SP)"
+*brownie3216:
+*vr4100:
+{
+  do_store (SD_, AccessLength_WORD, SP, EXTEND16 (IMMEDIATE), RA);
+}
+
+
+
+01111,3.RX,3.RY,5.IMMED:RRI:16::SD
+"sd r<TRY>, <IMMED> (r<TRX>)"
+*brownie3216:
+*vr4100:
+{
+  do_store (SD_, AccessLength_DOUBLEWORD, GPR[TRX], IMMED << 3, GPR[TRY]);
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 01111,3.RX,3.RY,5.IMM_4_0:EXT-RRI:16::SD
+"sd r<TRY>, <IMMEDIATE> (r<TRX>)"
+*brownie3216:
+*vr4100:
+{
+  do_store (SD_, AccessLength_DOUBLEWORD, GPR[TRX], EXTEND16 (IMMEDIATE), GPR[TRY]);
+}
+
+
+
+11111,001,3.RY,5.IMMED:RI64:16::SDSP
+"sd r<TRY>, <IMMED> (SP)"
+*brownie3216:
+*vr4100:
+{
+  do_store (SD_, AccessLength_DOUBLEWORD, SP, IMMED << 3, GPR[TRY]);
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 11111,001,3.RY,5.IMM_4_0:EXT-RI64:16::SDSP
+"sd r<TRY>, <IMMEDIATE> (SP)"
+*brownie3216:
+*vr4100:
+{
+  do_store (SD_, AccessLength_DOUBLEWORD, SP, EXTEND16 (IMMEDIATE), GPR[TRY]);
+}
+
+
+
+11111,010,8.IMMED:I64:16::SDRASP
+"sd r<RAIDX>, <IMMED> (SP)"
+*brownie3216:
+*vr4100:
+{
+  do_store (SD_, AccessLength_DOUBLEWORD, SP, IMMED << 3, RA);
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 11111,010,000,5.IMM_4_0:EXT-I64:16::SDRASP
+"sd r<RAIDX>, <IMMEDIATE> (SP)"
+*brownie3216:
+*vr4100:
+{
+  do_store (SD_, AccessLength_DOUBLEWORD, SP, EXTEND16 (IMMEDIATE), RA);
+}
+
+
+
+// ALU Immediate Instructions
+
+
+01101,3.RX,8.IMMED:RI:16::LI
+"li r<TRX>, <IMMED>"
+*brownie3216:
+*vr4100:
+{
+  do_ori (SD_, 0, TRX, IMMED);
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 01101,3.RX,000,5.IMM_4_0:EXT-RI:16::LI
+"li r<TRX>, <IMMEDIATE>"
+*brownie3216:
+*vr4100:
+{
+  do_ori (SD_, 0, TRX, IMMEDIATE);
+}
+
+
+
+01000,3.RX,3.RY,0,4.IMMED:RRI-A:16::ADDIU
+"addiu r<TRY>, r<TRX>, <IMMED>"
+*brownie3216:
+*vr4100:
+{
+  do_addiu (SD_, TRX, TRY, EXTEND4 (IMMED));
+}
+
+11110,7.IMM_10_4,4.IMM_14_11 + 01000,3.RX,3.RY,0,4.IMM_3_0:EXT-RRI-A:16::ADDIU
+"addiu r<TRY>, r<TRX>, <IMMEDIATE>"
+*brownie3216:
+*vr4100:
+{
+  do_addiu (SD_, TRX, TRY, EXTEND15 (IMMEDIATE));
+}
+
+
+
+01001,3.RX,8.IMMED:RI:16::ADDIU8
+"addiu r<TRX>, <IMMED>"
+*brownie3216:
+*vr4100:
+{
+  do_addiu (SD_, TRX, TRX, EXTEND8 (IMMED));
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 01001,3.RX,000,5.IMM_4_0:EXT-RI:16::ADDIU8
+"addiu r<TRX>, <IMMEDIATE>"
+*brownie3216:
+*vr4100:
+{
+  do_addiu (SD_, TRX, TRX, EXTEND16 (IMMEDIATE));
+}
+
+
+
+01100,011,8.IMMED:I8:16::ADJSP
+"addiu SP, <IMMED>"
+*brownie3216:
+*vr4100:
+{
+  do_addiu (SD_, SPIDX, SPIDX, EXTEND8 (IMMED) << 3);
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 01100,011,000,5.IMM_4_0:EXT-I8:16::ADJSP
+"addiu SP, <IMMEDIATE>"
+*brownie3216:
+*vr4100:
+{
+  do_addiu (SD_, SPIDX, SPIDX, EXTEND16 (IMMEDIATE));
+}
+
+
+
+00001,3.RX,8.IMMED:RI:16::ADDIUPC
+"addiu r<TRX>, PC, <IMMED>"
+*brownie3216:
+*vr4100:
+{
+  unsigned32 temp = (basepc (SD_) & ~3) + (IMMED << 2);
+  GPR[TRX] = EXTEND32 (temp);
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 00001,3.RX,000,5.IMM_4_0:EXT-RI:16::ADDIUPC
+"addiu r<TRX>, PC, <IMMEDIATE>"
+*brownie3216:
+*vr4100:
+{
+  unsigned32 temp = (basepc (SD_) & ~3) + EXTEND16 (IMMEDIATE);
+  GPR[TRX] = EXTEND32 (temp);
+}
+
+
+
+00000,3.RX,8.IMMED:RI:16::ADDIUSP
+"addiu r<TRX>, SP, <IMMED>"
+*brownie3216:
+*vr4100:
+{
+  do_addiu (SD_, SPIDX, TRX, IMMED << 2);
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 00000,3.RX,000,5.IMM_4_0:EXT-RI:16::ADDIUSP
+"addiu r<TRX>, SP, <IMMEDIATE>"
+*brownie3216:
+*vr4100:
+{
+  do_addiu (SD_, SPIDX, TRX, EXTEND16 (IMMEDIATE));
+}
+
+
+
+01000,3.RX,3.RY,1,4.IMMED:RRI-A:16::DADDIU
+"daddiu r<TRY>, r<TRX>, <IMMED>"
+*brownie3216:
+*vr4100:
+{
+  do_daddiu (SD_, TRX, TRY, EXTEND4 (IMMED));
+}
+
+11110,7.IMM_10_4,4.IMM_14_11 + 01000,3.RX,3.RY,1,4.IMM_3_0:EXT-RRI-A:16::DADDIU
+"daddiu r<TRY>, r<TRX>, <IMMEDIATE>"
+*brownie3216:
+*vr4100:
+{
+  do_daddiu (SD_, TRX, TRY, EXTEND15 (IMMEDIATE));
+}
+
+
+
+11111,101,3.RY,5.IMMED:RI64:16::DADDIU5
+"daddiu r<TRY>, <IMMED>"
+*brownie3216:
+*vr4100:
+{
+  do_daddiu (SD_, TRY, TRY, EXTEND5 (IMMED));
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 11111,101,3.RY,5.IMM_4_0:EXT-RI64:16::DADDIU5
+"daddiu r<TRY>, <IMMEDIATE>"
+*brownie3216:
+*vr4100:
+{
+  do_daddiu (SD_, TRY, TRY, EXTEND16 (IMMEDIATE));
+}
+
+
+
+11111,011,8.IMMED:I64:16::DADJSP
+"daddiu SP, <IMMED>"
+*brownie3216:
+*vr4100:
+{
+  do_daddiu (SD_, SPIDX, SPIDX, EXTEND8 (IMMED) << 3);
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 11111,011,000,5.IMM_4_0:EXT-I64:16::DADJSP
+"daddiu SP, <IMMEDIATE>"
+*brownie3216:
+*vr4100:
+{
+  do_daddiu (SD_, SPIDX, SPIDX, EXTEND16 (IMMEDIATE));
+}
+
+
+
+11111,110,3.RY,5.IMMED:RI64:16::DADDIUPC
+"daddiu r<TRY>, PC, <IMMED>"
+*brownie3216:
+*vr4100:
+{
+  GPR[TRY] = (basepc (SD_) & ~3) + (IMMED << 2);
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 11111,110,3.RY,5.IMM_4_0:EXT-RI64:16::DADDIUPC
+"daddiu r<TRY>, PC, <IMMEDIATE>"
+*brownie3216:
+*vr4100:
+{
+  GPR[TRY] = (basepc (SD_) & ~3) + EXTEND16 (IMMEDIATE);
+}
+
+
+
+11111,111,3.RY,5.IMMED:RI64:16::DADDIUSP
+"daddiu r<TRY>, SP, <IMMED>"
+*brownie3216:
+*vr4100:
+{
+  do_daddiu (SD_, SPIDX, TRY, IMMED << 2);
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 11111,111,3.RY,5.IMM_4_0:EXT-RI64:16::DADDIUSP
+"daddiu r<TRY>, SP, <IMMEDIATE>"
+*brownie3216:
+*vr4100:
+{
+  do_daddiu (SD_, SPIDX, TRY, EXTEND16 (IMMEDIATE));
+}
+
+
+
+01010,3.RX,8.IMMED:RI:16::SLTI
+"slti r<TRX>, <IMMED>"
+*brownie3216:
+*vr4100:
+{
+  do_slti (SD_, TRX, T8IDX, IMMED);
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 01010,3.RX,000,5.IMM_4_0:EXT-RI:16::SLTI
+"slti r<TRX>, <IMMEDIATE>"
+*brownie3216:
+*vr4100:
+{
+  do_slti (SD_, TRX, T8IDX, IMMEDIATE);
+}
+
+
+
+01011,3.RX,8.IMMED:RI:16::SLTIU
+"sltiu r<TRX>, <IMMED>"
+*brownie3216:
+*vr4100:
+{
+  do_sltiu (SD_, TRX, T8IDX, IMMED);
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 01011,3.RX,000,5.IMM_4_0:EXT-RI:16::SLTIU
+"sltiu r<TRX>, <IMMEDIATE>"
+*brownie3216:
+*vr4100:
+{
+  do_sltiu (SD_, TRX, T8IDX, IMMEDIATE);
+}
+
+
+
+11101,3.RX,3.RY,01010:RR:16::CMP
+"cmp r<TRX>, r<TRY>"
+*brownie3216:
+*vr4100:
+{
+  do_xor (SD_, TRX, TRY, T8IDX);
+}
+
+
+01110,3.RX,8.IMMED:RI:16::CMPI
+"cmpi r<TRX>, <IMMED>"
+*brownie3216:
+*vr4100:
+{
+  do_xori (SD_, TRX, T8IDX, IMMED);
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 01110,3.RX,000,5.IMM_4_0:EXT-RI:16::CMPI
+"sltiu r<TRX>, <IMMEDIATE>"
+*brownie3216:
+*vr4100:
+{
+  do_xori (SD_, TRX, T8IDX, IMMEDIATE);
+}
+
+
+
+// Two/Three Operand, Register-Type
+
+
+
+11100,3.RX,3.RY,3.RZ,01:RRR:16::ADDU
+"addu r<TRZ>, r<TRX>, r<TRY>"
+*brownie3216:
+*vr4100:
+{
+  do_addu (SD_, TRX, TRY, TRZ);
+}
+
+
+
+11100,3.RX,3.RY,3.RZ,11:RRR:16::SUBU
+"subu r<TRZ>, r<TRX>, r<TRY>"
+*brownie3216:
+*vr4100:
+{
+  do_subu (SD_, TRX, TRY, TRZ);
+}
+
+11100,3.RX,3.RY,3.RZ,00:RRR:16::DADDU
+"daddu r<TRZ>, r<TRX>, r<TRY>"
+*brownie3216:
+*vr4100:
+{
+  do_daddu (SD_, TRX, TRY, TRZ);
+}
+
+
+
+11100,3.RX,3.RY,3.RZ,10:RRR:16::DSUBU
+"dsubu r<TRZ>, r<TRX>, r<TRY>"
+*brownie3216:
+*vr4100:
+{
+  do_dsubu (SD_, TRX, TRY, TRZ);
+}
+
+
+
+11101,3.RX,3.RY,00010:RR:16::SLT
+"slt r<TRX>, r<TRY>"
+*brownie3216:
+*vr4100:
+{
+  do_slt (SD_, TRX, TRY, T8IDX);
+}
+
+
+
+11101,3.RX,3.RY,00011:RR:16::SLTU
+"sltu r<TRX>, r<TRY>"
+*brownie3216:
+*vr4100:
+{
+  do_sltu (SD_, TRX, TRY, T8IDX);
+}
+
+
+
+11101,3.RX,3.RY,01011:RR:16::NEG
+"neg r<TRX>, r<TRY>"
+*brownie3216:
+*vr4100:
+{
+  do_subu (SD_, 0, TRY, TRX);
+}
+
+
+
+11101,3.RX,3.RY,01100:RR:16::AND
+"and r<TRX>, r<TRY>"
+*brownie3216:
+*vr4100:
+{
+  do_and (SD_, TRX, TRY, TRX);
+}
+
+
+
+11101,3.RX,3.RY,01101:RR:16::OR
+"or r<TRX>, r<TRY>"
+*brownie3216:
+*vr4100:
+{
+  do_or (SD_, TRX, TRY, TRX);
+}
+
+
+
+11101,3.RX,3.RY,01110:RR:16::XOR
+"xor r<TRX>, r<TRY>"
+*brownie3216:
+*vr4100:
+{
+  do_xor (SD_, TRX, TRY, TRX);
+}
+
+
+
+11101,3.RX,3.RY,01111:RR:16::NOT
+"not r<TRX>, r<TRY>"
+*brownie3216:
+*vr4100:
+{
+  do_nor (SD_, 0, TRY, TRX);
+}
+
+
+
+01100,111,3.RY,5.R32:I8_MOVR32:16::MOVR32
+"move r<TRY>, r<R32>"
+*brownie3216:
+*vr4100:
+{
+  do_or (SD_, R32, 0, TRY);
+}
+
+
+
+01100,101,3.R32L,2.R32H,3.RZ:I8_MOV32R:16::MOV32R
+"move r<R32>, r<TRZ>"
+*brownie3216:
+*vr4100:
+{
+  do_or (SD_, TRZ, 0, R32);
+}
+
+
+
+00110,3.RX,3.RY,3.SHAMT,00:SHIFT:16::SLL
+"sll r<TRX>, r<TRY>, <SHIFT>"
+*brownie3216:
+*vr4100:
+{
+  do_sll (SD_, TRY, TRX, SHIFT);
+}
+
+11110,5.SHAMT,0,00000 + 00110,3.RX,3.RY,000,00:EXT-SHIFT:16::SLL
+"sll r<TRX>, r<TRY>, <SHIFT>"
+*brownie3216:
+*vr4100:
+{
+  do_sll (SD_, TRY, TRX, SHAMT);
+}
+
+
+
+00110,3.RX,3.RY,3.SHAMT,10:SHIFT:16::SRL
+"srl r<TRX>, r<TRY>, <SHIFT>"
+*brownie3216:
+*vr4100:
+{
+  do_srl (SD_, TRY, TRX, SHIFT);
+}
+
+11110,5.SHAMT,0,00000 + 00110,3.RX,3.RY,000,10:EXT-SHIFT:16::SRL
+"srl r<TRX>, r<TRY>, <SHIFT>"
+*brownie3216:
+*vr4100:
+{
+  do_srl (SD_, TRY, TRX, SHAMT);
+}
+
+
+
+00110,3.RX,3.RY,3.SHAMT,11:SHIFT:16::SRA
+"sra r<TRX>, r<TRY>, <SHIFT>"
+*brownie3216:
+*vr4100:
+{
+  do_sra (SD_, TRY, TRX, SHIFT);
+}
+
+11110,5.SHAMT,0,00000 + 00110,3.RX,3.RY,000,11:EXT-SHIFT:16::SRA
+"sra r<TRX>, r<TRY>, <SHIFT>"
+*brownie3216:
+*vr4100:
+{
+  do_sra (SD_, TRY, TRX, SHAMT);
+}
+
+
+
+11101,3.RX,3.RY,00100:RR:16::SLLV
+"sllv r<TRY>, r<TRX>"
+*brownie3216:
+*vr4100:
+{
+  do_sllv (SD_, TRX, TRY, TRY);
+}
+
+
+11101,3.RX,3.RY,00110:RR:16::SRLV
+"srlv r<TRY>, r<TRX>"
+*brownie3216:
+*vr4100:
+{
+  do_srlv (SD_, TRX, TRY, TRY);
+}
+
+
+11101,3.RX,3.RY,00111:RR:16::SRAV
+"srav r<TRY>, r<TRX>"
+*brownie3216:
+*vr4100:
+{
+  do_srav (SD_, TRX, TRY, TRY);
+}
+
+
+00110,3.RX,3.RY,3.SHAMT,01:SHIFT:16::DSLL
+"dsll r<TRY>, r<TRX>, <SHIFT>"
+*brownie3216:
+*vr4100:
+{
+  do_dsll (SD_, TRY, TRX, SHIFT);
+}
+  
+11110,5.SHAMT_4_0,1.S5,00000 + 00110,3.RX,3.RY,000,01:EXT-SHIFT:16::DSLL
+"dsll r<TRY>, r<TRX>, <SHAMT>"
+*brownie3216:
+*vr4100:
+{
+  do_dsll (SD_, TRY, TRX, SHAMT);
+}
+  
+  
+  
+11101,3.SHAMT,3.RY,01000:SHIFT64:16::DSRL
+"dsrl r<TRY>, <SHIFT>"
+*brownie3216:
+*vr4100:
+{
+  do_dsrl (SD_, TRY, TRY, SHIFT);
+}
+
+11110,5.SHAMT_4_0,1.S5,00000 + 11101,000,3.RY,01000:EXT-SHIFT64:16::DSRL
+"dsrl r<TRY>, <SHAMT>"
+*brownie3216:
+*vr4100:
+{
+  do_dsrl (SD_, TRY, TRY, SHAMT);
+}
+
+
+
+11101,3.SHAMT,3.RY,10011:SHIFT64:16::DSRA
+"dsra r<TRY>, <SHIFT>"
+*brownie3216:
+*vr4100:
+{
+  do_dsra (SD_, TRY, TRY, SHIFT);
+}
+
+11110,5.SHAMT_4_0,1.S5,00000 + 11101,000,3.RY,10011:EXT-SHIFT64:16::DSRA
+"dsra r<TRY>, <SHAMT>"
+*brownie3216:
+*vr4100:
+{
+  do_dsra (SD_, TRY, TRY, SHAMT);
+}
+
+
+
+11101,3.RX,3.RY,10100:RR:16::DSLLV
+"dsllv r<TRY>, r<TRX>"
+*brownie3216:
+*vr4100:
+{
+  do_dsllv (SD_, TRX, TRY, TRY);
+}
+
+
+11101,3.RX,3.RY,10110:RR:16::DSRLV
+"dsrlv r<TRY>, r<TRX>"
+*brownie3216:
+*vr4100:
+{
+  do_dsrlv (SD_, TRX, TRY, TRY);
+}
+
+
+11101,3.RX,3.RY,10111:RR:16::DSRAV
+"dsrav r<TRY>, r<TRX>"
+*brownie3216:
+*vr4100:
+{
+  do_dsrav (SD_, TRX, TRY, TRY);
+}
+
+
+// Multiply /Divide Instructions
+
+
+11101,3.RX,3.RY,11000:RR:16::MULT
+"mult r<TRX>, r<TRY>"
+*brownie3216:
+*vr4100:
+{
+  do_mult (SD_, TRX, TRY, 0);
+}
+
+
+11101,3.RX,3.RY,11001:RR:16::MULTU
+"multu r<TRX>, r<TRY>"
+*brownie3216:
+*vr4100:
+{
+  do_multu (SD_, TRX, TRY, 0);
+}
+
+
+11101,3.RX,3.RY,11010:RR:16::DIV
+"div r<TRX>, r<TRY>"
+*brownie3216:
+*vr4100:
+{
+  do_div (SD_, TRX, TRY);
+}
+
+
+11101,3.RX,3.RY,11011:RR:16::DIVU
+"divu r<TRX>, r<TRY>"
+*brownie3216:
+*vr4100:
+{
+  do_divu (SD_, TRX, TRY);
+}
+
+
+11101,3.RX,000,10000:RR:16::MFHI
+"mfhi r<TRX>"
+*brownie3216:
+*vr4100:
+{
+  do_mfhi (SD_, TRX);
+}
+
+
+11101,3.RX,000,10010:RR:16::MFLO
+"mflo r<TRX>"
+*brownie3216:
+*vr4100:
+{
+  do_mflo (SD_, TRX);
+}
+
+
+11101,3.RX,3.RY,11100:RR:16::DMULT
+"dmult r<TRX>, r<TRY>"
+*brownie3216:
+*vr4100:
+{
+  do_dmult (SD_, TRX, TRY, 0);
+}
+
+
+11101,3.RX,3.RY,11101:RR:16::DMULTU
+"dmultu r<TRX>, r<TRY>"
+*brownie3216:
+*vr4100:
+{
+  do_dmultu (SD_, TRX, TRY, 0);
+}
+
+
+11101,3.RX,3.RY,11110:RR:16::DDIV
+"ddiv r<TRX>, r<TRY>"
+*brownie3216:
+*vr4100:
+{
+  do_ddiv (SD_, TRX, TRY);
+}
+
+
+11101,3.RX,3.RY,11111:RR:16::DDIVU
+"ddivu r<TRX>, r<TRY>"
+*brownie3216:
+*vr4100:
+{
+  do_ddivu (SD_, TRX, TRY);
+}
+
+
+// Jump and Branch Instructions
+
+
+
+// Issue instruction in delay slot of branch
+:function:::address_word:delayslot16:address_word nia, address_word target
+{
+  instruction_word delay_insn;
+  sim_events_slip (SD, 1);
+  DSPC = CIA; /* save current PC somewhere */
+  STATE |= simDELAYSLOT;
+  delay_insn = IMEM16 (nia); /* NOTE: brownie3216 */
+  idecode_issue (CPU_, delay_insn, (nia));
+  STATE &= ~simDELAYSLOT;
+  return target;
+}
+  
+// compute basepc dependant on us being in a delay slot
+:function:::address_word:basepc:
+{
+  if (STATE & simDELAYSLOT)
+    {
+      return DSPC; /* return saved address of preceeding jmp */
+    }
+  else
+    {
+      return CIA;
+    }
+}
+
+
+// JAL
+00011,0,5.IMM_20_16,5.IMM_25_21 + 16.IMMED_15_0:JAL:16::JAL
+"jal <IMMEDIATE>"
+*brownie3216:
+*vr4100:
+{
+  address_word region = (NIA & MASK (63, 28));
+  RA = NIA + 2; /* skip 16 bit delayslot insn */
+  NIA = delayslot16 (SD_, NIA, (region | (IMMEDIATE << 2))) | 1;
+}
+
+
+
+// JALX - 32 and 16 bit versions.
+
+011101,26.IMMED:JALX:32::JALX32
+"jalx <IMMED>"
+*brownie3216:
+*vr4100:
+{
+  address_word region = (NIA & MASK (63, 28));
+  RA = NIA + 4; /* skip 32 bit delayslot insn */
+  NIA = delayslot32 (SD_, (region | (IMMED << 2)) | 1);
+}
+
+00011,1,5.IMM_20_16,5.IMM_25_21 + 16.IMMED_15_0:JALX:16::JALX16
+"jalx <IMMEDIATE>"
+*brownie3216:
+*vr4100:
+{
+  address_word region = (NIA & MASK (63, 28));
+  RA = NIA + 2; /* 16 bit INSN */
+  NIA = delayslot16 (SD_, NIA, (region | (IMMEDIATE << 2)) & ~1);
+}
+
+
+
+11101,3.RX,000,00000:RR:16::JR
+"jr r<TRX>"
+*brownie3216:
+*vr4100:
+{
+  NIA = delayslot16 (SD_, NIA, GPR[TRX]);
+}
+
+
+11101,000,001,00000:RR:16::JRRA
+"jrra"
+*brownie3216:
+*vr4100:
+{
+  NIA = delayslot16 (SD_, NIA, RA);
+}
+
+
+
+11101,3.RX,010,00000:RR:16::JALR
+"jalr r<TRX>"
+*brownie3216:
+*vr4100:
+{
+  RA = NIA + 2;
+  NIA = delayslot16 (SD_, NIA, GPR[TRX]);
+}
+
+
+
+00100,3.RX,8.IMMED:RI:16::BEQZ
+"beqz r<TRX>, <IMMED>"
+*brownie3216:
+*vr4100:
+{
+  if (GPR[TRX] == 0)
+    NIA = (NIA + (EXTEND8 (IMMED) << 1));
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 00100,3.RX,000,5.IMM_4_0:EXT-RI:16::BEQZ
+"beqz r<TRX>, <IMMEDIATE>"
+*brownie3216:
+*vr4100:
+{
+  if (GPR[TRX] == 0)
+    NIA = (NIA + (EXTEND16 (IMMEDIATE) << 1));
+}
+
+
+
+00101,3.RX,8.IMMED:RI:16::BNEZ
+"bnez r<TRX>, <IMMED>"
+*brownie3216:
+*vr4100:
+{
+  if (GPR[TRX] != 0)
+    NIA = (NIA + (EXTEND8 (IMMED) << 1));
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 00101,3.RX,000,5.IMM_4_0:EXT-RI:16::BNEZ
+"bnez r<TRX>, <IMMEDIATE>"
+*brownie3216:
+*vr4100:
+{
+  if (GPR[TRX] != 0)
+    NIA = (NIA + (EXTEND16 (IMMEDIATE) << 1));
+}
+
+
+
+01100,000,8.IMMED:I8:16::BTEQZ
+"bteqz <IMMED>"
+*brownie3216:
+*vr4100:
+{
+  if (T8 == 0)
+    NIA = (NIA + (EXTEND8 (IMMED) << 1));
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 01100,000,000,5.IMM_4_0:EXT-I8:16::BTEQZ
+"bteqz <IMMEDIATE>"
+*brownie3216:
+*vr4100:
+{
+  if (T8 == 0)
+    NIA = (NIA + (EXTEND16 (IMMEDIATE) << 1));
+}
+
+
+
+01100,001,8.IMMED:I8:16::BTNEZ
+"btnez <IMMED>"
+*brownie3216:
+*vr4100:
+{
+  if (T8 != 0)
+    NIA = (NIA + (EXTEND8 (IMMED) << 1));
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 01100,001,000,5.IMM_4_0:EXT-I8:16::BTNEZ
+"btnez <IMMEDIATE>"
+*brownie3216:
+*vr4100:
+{
+  if (T8 != 0)
+    NIA = (NIA + (EXTEND16 (IMMEDIATE) << 1));
+}
+
+
+
+00010,11.IMMED:I:16::B
+"b <IMMED>"
+*brownie3216:
+*vr4100:
+{
+  NIA = (NIA + (EXTEND11 (IMMED) << 1));
+}
+
+11110,6.IMM_10_5,5.IMM_15_11 + 00010,6.0,5.IMM_4_0:EXT-I:16::B
+"b <IMMEDIATE>"
+*brownie3216:
+*vr4100:
+{
+  NIA = (NIA + (EXTEND16 (IMMEDIATE) << 1));
+}
+
+
+
+11101,3.RX,3.RY,00101:RR:16::BREAK
+"break"
+*brownie3216:
+*vr4100:
+{
+  if (STATE & simDELAYSLOT)
+    PC = cia - 2; /* reference the branch instruction */
+  else
+    PC = cia;
+  SignalException (BreakPoint, instruction_0);
+}
Index: sim/brownie32/m16e.igen
===================================================================
RCS file: sim/brownie32/m16e.igen
diff -N sim/brownie32/m16e.igen
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/m16e.igen	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,105 @@
+// -*- C -*-
+
+// Simulator definition for the MIPS16e instructions.
+// Copyright (C) 2005 Free Software Foundation, Inc.
+// Contributed by Nigel Stephens (nigel@brownie32.com) and 
+//                David Ung (davidu@brownie32.com) of MIPS Technologies.
+//
+// This file is part of GDB, the GNU debugger.
+// 
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License along
+// with this program; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+
+11101,3.RX,100,10001:RR:16::SEB
+"seb r<TRX>"
+*brownie3216e:
+{
+  TRACE_ALU_INPUT1 (GPR[TRX]);
+  GPR[TRX] = EXTEND8 (GPR[TRX]);
+  TRACE_ALU_RESULT (GPR[TRX]);
+}
+
+
+11101,3.RX,101,10001:RR:16::SEH
+"seh r<TRX>"
+*brownie3216e:
+{
+  TRACE_ALU_INPUT1 (GPR[TRX]);
+  GPR[TRX] = EXTEND16 (GPR[TRX]);
+  TRACE_ALU_RESULT (GPR[TRX]);
+}
+
+11101,3.RX,110,10001:RR:16::SEW
+"sew r<TRX>"
+*brownie3216e:
+{
+  check_u64 (SD_, instruction_0);
+  TRACE_ALU_INPUT1 (GPR[TRX]);
+  GPR[TRX] = EXTEND32 (GPR[TRX]);
+  TRACE_ALU_RESULT (GPR[TRX]);
+}
+
+11101,3.RX,000,10001:RR:16::ZEB
+"zeb r<TRX>"
+*brownie3216e:
+{
+  TRACE_ALU_INPUT1 (GPR[TRX]);
+  GPR[TRX] =  (unsigned_word)(unsigned8)(GPR[TRX]);
+  TRACE_ALU_RESULT (GPR[TRX]);
+}
+
+11101,3.RX,001,10001:RR:16::ZEH
+"zeh r<TRX>"
+*brownie3216e:
+{
+  TRACE_ALU_INPUT1 (GPR[TRX]);
+  GPR[TRX] = (unsigned_word)(unsigned16)(GPR[TRX]);
+  TRACE_ALU_RESULT (GPR[TRX]);
+}
+
+11101,3.RX,010,10001:RR:16::ZEW
+"zew r<TRX>"
+*brownie3216e:
+{
+  check_u64 (SD_, instruction_0);
+  TRACE_ALU_INPUT1 (GPR[TRX]);
+  GPR[TRX] = (unsigned_word)(unsigned32)(GPR[TRX]);
+  TRACE_ALU_RESULT (GPR[TRX]);
+}
+
+
+11101,3.RX,100,00000:RR:16::JRC
+"jrc r<TRX>"
+*brownie3216e:
+{
+  NIA = GPR[TRX];
+}
+
+
+11101,000,101,00000:RR:16::JRCRA
+"jrc ra"
+*brownie3216e:
+{
+  NIA = RA;
+}
+
+
+11101,3.RX,110,00000:RR:16::JALRC
+"jalrc r<TRX>"
+*brownie3216e:
+{
+  RA = NIA;
+  NIA = GPR[TRX];
+}
Index: sim/brownie32/m16run.c
===================================================================
RCS file: sim/brownie32/m16run.c
diff -N sim/brownie32/m16run.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/m16run.c	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,74 @@
+/*  This file is part of the program psim.
+
+    Copyright (C) 1998, Andrew Cagney <cagney@highland.com.au>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+ 
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ 
+    */
+
+#include "sim-main.h"
+#include "m16_idecode.h"
+#include "m32_idecode.h"
+#include "bfd.h"
+
+
+#define SD sd
+#define CPU cpu
+
+void
+sim_engine_run (SIM_DESC sd,
+		int next_cpu_nr,
+		int nr_cpus, /* ignore */
+		int siggnal) /* ignore */
+{
+  sim_cpu *cpu = STATE_CPU (sd, next_cpu_nr);
+  address_word cia = CIA_GET (cpu);
+
+  while (1)
+    {
+      address_word nia;
+
+#if defined (ENGINE_ISSUE_PREFIX_HOOK)
+      ENGINE_ISSUE_PREFIX_HOOK ();
+#endif
+
+      if ((cia & 1))
+	{
+	  m16_instruction_word instruction_0 = IMEM16 (cia);
+	  nia = m16_idecode_issue (sd, instruction_0, cia);
+	}
+      else
+	{
+	  m32_instruction_word instruction_0 = IMEM32 (cia);
+	  nia = m32_idecode_issue (sd, instruction_0, cia);
+	}
+
+#if defined (ENGINE_ISSUE_POSTFIX_HOOK)
+      ENGINE_ISSUE_POSTFIX_HOOK ();
+#endif
+
+      /* Update the instruction address */
+      cia = nia;
+
+      /* process any events */
+      if (sim_events_tick (sd))
+        {
+          CIA_SET (CPU, cia);
+          sim_events_process (sd);
+	  cia = CIA_GET (CPU);
+        }
+
+    }
+}
Index: sim/brownie32/mdmx.c
===================================================================
RCS file: sim/brownie32/mdmx.c
diff -N sim/brownie32/mdmx.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/mdmx.c	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,1478 @@
+/* Simulation code for the MIPS MDMX ASE.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   Contributed by Ed Satterthwaite and Chris Demetriou, of Broadcom
+   Corporation (SiByte).
+
+This file is part of GDB, the GNU debugger.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+#if 0
+#include <stdio.h>
+
+#include "sim-main.h"
+
+/* Within mdmx.c we refer to the sim_cpu directly. */
+#define CPU cpu
+#define SD  (CPU_STATE(CPU))
+
+/* XXX FIXME: temporary hack while the impact of making unpredictable()
+   a "normal" (non-igen) function is evaluated.  */
+#undef Unpredictable
+#define Unpredictable() unpredictable_action (cpu, cia)
+
+/* MDMX Representations
+
+   An 8-bit packed byte element (OB) is always unsigned.
+   The 24-bit accumulators are signed and are represented as 32-bit
+   signed values, which are reduced to 24-bit signed values prior to
+   Round and Clamp operations.
+  
+   A 16-bit packed halfword element (QH) is always signed.
+   The 48-bit accumulators are signed and are represented as 64-bit
+   signed values, which are reduced to 48-bit signed values prior to
+   Round and Clamp operations.
+  
+   The code below assumes a 2's-complement representation of signed
+   quantities.  Care is required to clear extended sign bits when
+   repacking fields.
+  
+   The code (and the code for arithmetic shifts in mips.igen) also makes
+   the (not guaranteed portable) assumption that right shifts of signed
+   quantities in C do sign extension.  */
+
+typedef unsigned64 unsigned48;
+#define MASK48 (UNSIGNED64 (0xffffffffffff))
+
+typedef unsigned32 unsigned24;
+#define MASK24 (UNSIGNED32 (0xffffff))
+
+typedef enum {
+  mdmx_ob,          /* OB (octal byte) */
+  mdmx_qh           /* QH (quad half-word) */
+} MX_fmt;
+
+typedef enum {
+  sel_elem,         /* element select */
+  sel_vect,         /* vector select */
+  sel_imm           /* immediate select */
+} VT_select;
+
+#define OB_MAX  ((unsigned8)0xFF)
+#define QH_MIN  ((signed16)0x8000)
+#define QH_MAX  ((signed16)0x7FFF)
+
+#define OB_CLAMP(x)  ((unsigned8)((x) > OB_MAX ? OB_MAX : (x)))
+#define QH_CLAMP(x)  ((signed16)((x) < QH_MIN ? QH_MIN : \
+                                ((x) > QH_MAX ? QH_MAX : (x))))
+
+#define MX_FMT(fmtsel) (((fmtsel) & 0x1) == 0 ? mdmx_ob : mdmx_qh)
+#define MX_VT(fmtsel)  (((fmtsel) & 0x10) == 0 ?    sel_elem : \
+                       (((fmtsel) & 0x18) == 0x10 ? sel_vect : sel_imm))
+
+#define QH_ELEM(v,fmtsel) \
+        ((signed16)(((v) >> (((fmtsel) & 0xC) << 2)) & 0xFFFF))
+#define OB_ELEM(v,fmtsel) \
+        ((unsigned8)(((v) >> (((fmtsel) & 0xE) << 2)) & 0xFF))
+
+
+typedef signed16 (*QH_FUNC)(signed16, signed16);
+typedef unsigned8 (*OB_FUNC)(unsigned8, unsigned8);
+
+/* vectorized logical operators */
+
+static signed16
+AndQH(signed16 ts, signed16 tt)
+{
+  return (signed16)((unsigned16)ts & (unsigned16)tt);
+}
+
+static unsigned8
+AndOB(unsigned8 ts, unsigned8 tt)
+{
+  return ts & tt;
+}
+
+static signed16
+NorQH(signed16 ts, signed16 tt)
+{
+  return (signed16)(((unsigned16)ts | (unsigned16)tt) ^ 0xFFFF);
+}
+
+static unsigned8
+NorOB(unsigned8 ts, unsigned8 tt)
+{
+  return (ts | tt) ^ 0xFF;
+}
+
+static signed16
+OrQH(signed16 ts, signed16 tt)
+{
+  return (signed16)((unsigned16)ts | (unsigned16)tt);
+}
+
+static unsigned8
+OrOB(unsigned8 ts, unsigned8 tt)
+{
+  return ts | tt;
+}
+
+static signed16
+XorQH(signed16 ts, signed16 tt)
+{
+  return (signed16)((unsigned16)ts ^ (unsigned16)tt);
+}
+
+static unsigned8
+XorOB(unsigned8 ts, unsigned8 tt)
+{
+  return ts ^ tt;
+}
+
+static signed16
+SLLQH(signed16 ts, signed16 tt)
+{
+  unsigned32 s = (unsigned32)tt & 0xF;
+  return (signed16)(((unsigned32)ts << s) & 0xFFFF);
+}
+
+static unsigned8
+SLLOB(unsigned8 ts, unsigned8 tt)
+{
+  unsigned32 s = tt & 0x7;
+  return (ts << s) & 0xFF;
+}
+
+static signed16
+SRLQH(signed16 ts, signed16 tt)
+{
+  unsigned32 s = (unsigned32)tt & 0xF;
+  return (signed16)((unsigned16)ts >> s);
+}
+
+static unsigned8
+SRLOB(unsigned8 ts, unsigned8 tt)
+{
+  unsigned32 s = tt & 0x7;
+  return ts >> s;
+}
+
+
+/* Vectorized arithmetic operators.  */
+
+static signed16
+AddQH(signed16 ts, signed16 tt)
+{
+  signed32 t = (signed32)ts + (signed32)tt;
+  return QH_CLAMP(t);
+}
+
+static unsigned8
+AddOB(unsigned8 ts, unsigned8 tt)
+{
+  unsigned32 t = (unsigned32)ts + (unsigned32)tt;
+  return OB_CLAMP(t);
+}
+
+static signed16
+SubQH(signed16 ts, signed16 tt)
+{
+  signed32 t = (signed32)ts - (signed32)tt;
+  return QH_CLAMP(t);
+}
+
+static unsigned8
+SubOB(unsigned8 ts, unsigned8 tt)
+{
+  signed32 t;
+  t = (signed32)ts - (signed32)tt;
+  if (t < 0)
+    t = 0;
+  return (unsigned8)t;
+}
+
+static signed16
+MinQH(signed16 ts, signed16 tt)
+{
+  return (ts < tt ? ts : tt);
+}
+
+static unsigned8
+MinOB(unsigned8 ts, unsigned8 tt)
+{
+  return (ts < tt ? ts : tt);
+}
+
+static signed16
+MaxQH(signed16 ts, signed16 tt)
+{
+  return (ts > tt ? ts : tt);
+}
+
+static unsigned8
+MaxOB(unsigned8 ts, unsigned8 tt)
+{
+  return (ts > tt ? ts : tt);
+}
+
+static signed16
+MulQH(signed16 ts, signed16 tt)
+{
+  signed32 t = (signed32)ts * (signed32)tt;
+  return QH_CLAMP(t);
+}
+
+static unsigned8
+MulOB(unsigned8 ts, unsigned8 tt)
+{
+  unsigned32 t = (unsigned32)ts * (unsigned32)tt;
+  return OB_CLAMP(t);
+}
+
+/* "msgn" and "sra" are defined only for QH format.  */
+
+static signed16
+MsgnQH(signed16 ts, signed16 tt)
+{
+  signed16 t;
+  if (ts < 0)
+    t = (tt == QH_MIN ? QH_MAX : -tt);
+  else if (ts == 0)
+    t = 0;
+  else
+    t = tt;
+  return t;
+}
+
+static signed16
+SRAQH(signed16 ts, signed16 tt)
+{
+  unsigned32 s = (unsigned32)tt & 0xF;
+  return (signed16)((signed32)ts >> s);
+}
+
+
+/* "pabsdiff" and "pavg" are defined only for OB format.  */
+
+static unsigned8
+AbsDiffOB(unsigned8 ts, unsigned8 tt)
+{
+  return (ts >= tt ? ts - tt : tt - ts);
+}
+
+static unsigned8
+AvgOB(unsigned8 ts, unsigned8 tt)
+{
+  return ((unsigned32)ts + (unsigned32)tt + 1) >> 1;
+}
+
+
+/* Dispatch tables for operations that update a CPR.  */
+
+static const QH_FUNC qh_func[] = {
+  AndQH,  NorQH,  OrQH,   XorQH, SLLQH, SRLQH,
+  AddQH,  SubQH,  MinQH,  MaxQH,
+  MulQH,  MsgnQH, SRAQH,  NULL,  NULL
+};
+
+static const OB_FUNC ob_func[] = {
+  AndOB,  NorOB,  OrOB,   XorOB, SLLOB, SRLOB,
+  AddOB,  SubOB,  MinOB,  MaxOB,
+  MulOB,  NULL,   NULL,   AbsDiffOB, AvgOB
+};
+
+/* Auxiliary functions for CPR updates.  */
+
+/* Vector mapping for QH format.  */
+static unsigned64
+qh_vector_op(unsigned64 v1, unsigned64 v2, QH_FUNC func)
+{
+  unsigned64 result = 0;
+  int  i;
+  signed16 h, h1, h2;
+
+  for (i = 0; i < 64; i += 16)
+    {
+      h1 = (signed16)(v1 & 0xFFFF);  v1 >>= 16;
+      h2 = (signed16)(v2 & 0xFFFF);  v2 >>= 16;
+      h = (*func)(h1, h2);
+      result |= ((unsigned64)((unsigned16)h) << i);
+    }
+  return result;
+}
+
+static unsigned64
+qh_map_op(unsigned64 v1, signed16 h2, QH_FUNC func)
+{
+  unsigned64 result = 0;
+  int  i;
+  signed16 h, h1;
+
+  for (i = 0; i < 64; i += 16)
+    {
+      h1 = (signed16)(v1 & 0xFFFF);  v1 >>= 16;
+      h = (*func)(h1, h2);
+      result |= ((unsigned64)((unsigned16)h) << i);
+    }
+  return result;
+}
+
+
+/* Vector operations for OB format.  */
+
+static unsigned64
+ob_vector_op(unsigned64 v1, unsigned64 v2, OB_FUNC func)
+{
+  unsigned64 result = 0;
+  int  i;
+  unsigned8 b, b1, b2;
+
+  for (i = 0; i < 64; i += 8)
+    {
+      b1 = v1 & 0xFF;  v1 >>= 8;
+      b2 = v2 & 0xFF;  v2 >>= 8;
+      b = (*func)(b1, b2);
+      result |= ((unsigned64)b << i);
+    }
+  return result;
+}
+
+static unsigned64
+ob_map_op(unsigned64 v1, unsigned8 b2, OB_FUNC func)
+{
+  unsigned64 result = 0;
+  int  i;
+  unsigned8 b, b1;
+
+  for (i = 0; i < 64; i += 8)
+    {
+      b1 = v1 & 0xFF;  v1 >>= 8;
+      b = (*func)(b1, b2);
+      result |= ((unsigned64)b << i);
+    }
+  return result;
+}
+
+
+/* Primary entry for operations that update CPRs.  */
+unsigned64
+mdmx_cpr_op(sim_cpu *cpu,
+	    address_word cia,
+	    int op,
+	    unsigned64 op1,
+	    int vt,
+	    MX_fmtsel fmtsel) 
+{
+  unsigned64 op2;
+  unsigned64 result = 0;
+
+  switch (MX_FMT (fmtsel))
+    {
+    case mdmx_qh:
+      switch (MX_VT (fmtsel))
+	{
+	case sel_elem:
+	  op2 = ValueFPR(vt, fmt_mdmx);
+	  result = qh_map_op(op1, QH_ELEM(op2, fmtsel), qh_func[op]);
+	  break;
+	case sel_vect:
+	  result = qh_vector_op(op1, ValueFPR(vt, fmt_mdmx), qh_func[op]);
+	  break;
+	case sel_imm:
+	  result = qh_map_op(op1, vt, qh_func[op]);
+	  break;
+	}
+      break;
+    case mdmx_ob:
+      switch (MX_VT (fmtsel))
+	{
+	case sel_elem:
+	  op2 = ValueFPR(vt, fmt_mdmx);
+	  result = ob_map_op(op1, OB_ELEM(op2, fmtsel), ob_func[op]);
+	  break;
+	case sel_vect:
+	  result = ob_vector_op(op1, ValueFPR(vt, fmt_mdmx), ob_func[op]);
+	  break;
+	case sel_imm:
+	  result = ob_map_op(op1, vt, ob_func[op]);
+	  break;
+	}
+      break;
+    default:
+      Unpredictable ();
+    }
+
+  return result;
+}
+
+
+/* Operations that update CCs */
+
+static void
+qh_vector_test(sim_cpu *cpu, unsigned64 v1, unsigned64 v2, int cond)
+{
+  int  i;
+  signed16 h1, h2;
+  int  boolean;
+
+  for (i = 0; i < 4; i++)
+    {
+      h1 = (signed16)(v1 & 0xFFFF);  v1 >>= 16;
+      h2 = (signed16)(v2 & 0xFFFF);  v2 >>= 16;
+      boolean = ((cond & MX_C_EQ) && (h1 == h2)) ||
+	((cond & MX_C_LT) && (h1 < h2));
+      SETFCC(i, boolean);
+    }
+}
+
+static void
+qh_map_test(sim_cpu *cpu, unsigned64 v1, signed16 h2, int cond)
+{
+  int  i;
+  signed16 h1;
+  int  boolean;
+
+  for (i = 0; i < 4; i++)
+    {
+      h1 = (signed16)(v1 & 0xFFFF);  v1 >>= 16;
+      boolean = ((cond & MX_C_EQ) && (h1 == h2)) ||
+	((cond & MX_C_LT) && (h1 < h2));
+      SETFCC(i, boolean);
+    }
+}
+
+static void
+ob_vector_test(sim_cpu *cpu, unsigned64 v1, unsigned64 v2, int cond)
+{
+  int  i;
+  unsigned8 b1, b2;
+  int  boolean;
+
+  for (i = 0; i < 8; i++)
+    {
+      b1 = v1 & 0xFF;  v1 >>= 8;
+      b2 = v2 & 0xFF;  v2 >>= 8;
+      boolean = ((cond & MX_C_EQ) && (b1 == b2)) ||
+	((cond & MX_C_LT) && (b1 < b2));
+      SETFCC(i, boolean);
+    }
+}
+
+static void
+ob_map_test(sim_cpu *cpu, unsigned64 v1, unsigned8 b2, int cond)
+{
+  int  i;
+  unsigned8 b1;
+  int  boolean;
+
+  for (i = 0; i < 8; i++)
+    {
+      b1 = (unsigned8)(v1 & 0xFF);  v1 >>= 8;
+      boolean = ((cond & MX_C_EQ) && (b1 == b2)) ||
+	((cond & MX_C_LT) && (b1 < b2));
+      SETFCC(i, boolean);
+    }
+}
+
+
+void
+mdmx_cc_op(sim_cpu *cpu,
+	   address_word cia,
+	   int cond,
+	   unsigned64 v1,
+	   int vt,
+	   MX_fmtsel fmtsel)
+{
+  unsigned64 op2;
+
+  switch (MX_FMT (fmtsel))
+    {
+    case mdmx_qh:
+      switch (MX_VT (fmtsel))
+	{
+	case sel_elem:
+	  op2 = ValueFPR(vt, fmt_mdmx);
+	  qh_map_test(cpu, v1, QH_ELEM(op2, fmtsel), cond);
+	  break;
+	case sel_vect:
+	  qh_vector_test(cpu, v1, ValueFPR(vt, fmt_mdmx), cond);
+	  break;
+	case sel_imm:
+	  qh_map_test(cpu, v1, vt, cond);
+	  break;
+	}
+      break;
+    case mdmx_ob:
+      switch (MX_VT (fmtsel))
+	{
+	case sel_elem:
+	  op2 = ValueFPR(vt, fmt_mdmx);
+	  ob_map_test(cpu, v1, OB_ELEM(op2, fmtsel), cond);
+	  break;
+	case sel_vect:
+	  ob_vector_test(cpu, v1, ValueFPR(vt, fmt_mdmx), cond);
+	  break;
+	case sel_imm:
+	  ob_map_test(cpu, v1, vt, cond);
+	  break;
+	}
+      break;
+    default:
+      Unpredictable ();
+    }
+}
+
+
+/* Pick operations.  */
+
+static unsigned64
+qh_vector_pick(sim_cpu *cpu, unsigned64 v1, unsigned64 v2, int tf)
+{
+  unsigned64 result = 0;
+  int  i, s;
+  unsigned16 h;
+
+  s = 0;
+  for (i = 0; i < 4; i++)
+    {
+      h = ((GETFCC(i) == tf) ? (v1 & 0xFFFF) : (v2 & 0xFFFF));
+      v1 >>= 16;  v2 >>= 16;
+      result |= ((unsigned64)h << s);
+      s += 16;
+    }
+  return result;
+}
+
+static unsigned64
+qh_map_pick(sim_cpu *cpu, unsigned64 v1, signed16 h2, int tf)
+{
+  unsigned64 result = 0;
+  int  i, s;
+  unsigned16 h;
+
+  s = 0;
+  for (i = 0; i < 4; i++)
+    {
+      h = (GETFCC(i) == tf) ? (v1 & 0xFFFF) : (unsigned16)h2;
+      v1 >>= 16;
+      result |= ((unsigned64)h << s);
+      s += 16;
+    }
+  return result;
+}
+
+static unsigned64
+ob_vector_pick(sim_cpu *cpu, unsigned64 v1, unsigned64 v2, int tf)
+{
+  unsigned64 result = 0;
+  int  i, s;
+  unsigned8 b;
+
+  s = 0;
+  for (i = 0; i < 8; i++)
+    {
+      b = (GETFCC(i) == tf) ? (v1 & 0xFF) : (v2 & 0xFF);
+      v1 >>= 8;  v2 >>= 8;
+      result |= ((unsigned64)b << s);
+      s += 8;
+    }
+  return result;
+}
+
+static unsigned64
+ob_map_pick(sim_cpu *cpu, unsigned64 v1, unsigned8 b2, int tf)
+{
+  unsigned64 result = 0;
+  int  i, s;
+  unsigned8 b;
+
+  s = 0;
+  for (i = 0; i < 8; i++)
+    {
+      b = (GETFCC(i) == tf) ? (v1 & 0xFF) : b2;
+      v1 >>= 8;
+      result |= ((unsigned64)b << s);
+      s += 8;
+    }
+  return result;
+}
+
+
+unsigned64
+mdmx_pick_op(sim_cpu *cpu,
+	     address_word cia,
+	     int tf,
+	     unsigned64 v1,
+	     int vt,
+	     MX_fmtsel fmtsel)
+{
+  unsigned64 result = 0;
+  unsigned64 op2;
+
+  switch (MX_FMT (fmtsel))
+    {
+    case mdmx_qh:
+      switch (MX_VT (fmtsel))
+	{
+	case sel_elem:
+	  op2 = ValueFPR(vt, fmt_mdmx);
+	  result = qh_map_pick(cpu, v1, QH_ELEM(op2, fmtsel), tf);
+	  break;
+	case sel_vect:
+	  result = qh_vector_pick(cpu, v1, ValueFPR(vt, fmt_mdmx), tf);
+	  break;
+	case sel_imm:
+	  result = qh_map_pick(cpu, v1, vt, tf);
+	  break;
+	}
+      break;
+    case mdmx_ob:
+      switch (MX_VT (fmtsel))
+	{
+	case sel_elem:
+	  op2 = ValueFPR(vt, fmt_mdmx);
+	  result = ob_map_pick(cpu, v1, OB_ELEM(op2, fmtsel), tf);
+	  break;
+	case sel_vect:
+	  result = ob_vector_pick(cpu, v1, ValueFPR(vt, fmt_mdmx), tf);
+	  break;
+	case sel_imm:
+	  result = ob_map_pick(cpu, v1, vt, tf);
+	  break;
+	}
+      break;
+    default:
+      Unpredictable ();
+    }
+  return result;
+}
+
+
+/* Accumulators.  */
+
+typedef void (*QH_ACC)(signed48 *a, signed16 ts, signed16 tt);
+
+static void
+AccAddAQH(signed48 *a, signed16 ts, signed16 tt)
+{
+  *a += (signed48)ts + (signed48)tt;
+}
+
+static void
+AccAddLQH(signed48 *a, signed16 ts, signed16 tt)
+{
+  *a = (signed48)ts + (signed48)tt;
+}
+
+static void
+AccMulAQH(signed48 *a, signed16 ts, signed16 tt)
+{
+  *a += (signed48)ts * (signed48)tt;
+}
+
+static void
+AccMulLQH(signed48 *a, signed16 ts, signed16 tt)
+{
+  *a = (signed48)ts * (signed48)tt;
+}
+
+static void
+SubMulAQH(signed48 *a, signed16 ts, signed16 tt)
+{
+  *a -= (signed48)ts * (signed48)tt;
+}
+
+static void
+SubMulLQH(signed48 *a, signed16 ts, signed16 tt)
+{
+  *a = -((signed48)ts * (signed48)tt);
+}
+
+static void
+AccSubAQH(signed48 *a, signed16 ts, signed16 tt)
+{
+  *a += (signed48)ts - (signed48)tt;
+}
+
+static void
+AccSubLQH(signed48 *a, signed16 ts, signed16 tt)
+{
+  *a =  (signed48)ts - (signed48)tt;
+}
+
+
+typedef void (*OB_ACC)(signed24 *acc, unsigned8 ts, unsigned8 tt);
+
+static void
+AccAddAOB(signed24 *a, unsigned8 ts, unsigned8 tt)
+{
+  *a += (signed24)ts + (signed24)tt;
+}
+
+static void
+AccAddLOB(signed24 *a, unsigned8 ts, unsigned8 tt)
+{
+  *a = (signed24)ts + (signed24)tt;
+}
+
+static void
+AccMulAOB(signed24 *a, unsigned8 ts, unsigned8 tt)
+{
+  *a += (signed24)ts * (signed24)tt;
+}
+
+static void
+AccMulLOB(signed24 *a, unsigned8 ts, unsigned8 tt)
+{
+  *a = (signed24)ts * (signed24)tt;
+}
+
+static void
+SubMulAOB(signed24 *a, unsigned8 ts, unsigned8 tt)
+{
+  *a -= (signed24)ts * (signed24)tt;
+}
+
+static void
+SubMulLOB(signed24 *a, unsigned8 ts, unsigned8 tt)
+{
+  *a = -((signed24)ts * (signed24)tt);
+}
+
+static void
+AccSubAOB(signed24 *a, unsigned8 ts, unsigned8 tt)
+{
+  *a += (signed24)ts - (signed24)tt;
+}
+
+static void
+AccSubLOB(signed24 *a, unsigned8 ts, unsigned8 tt)
+{
+  *a = (signed24)ts - (signed24)tt;
+}
+
+static void
+AccAbsDiffOB(signed24 *a, unsigned8 ts, unsigned8 tt)
+{
+  unsigned8 t = (ts >= tt ? ts - tt : tt - ts);
+  *a += (signed24)t;
+}
+
+
+/* Dispatch tables for operations that update a CPR.  */
+
+static const QH_ACC qh_acc[] = {
+  AccAddAQH, AccAddAQH, AccMulAQH, AccMulLQH,
+  SubMulAQH, SubMulLQH, AccSubAQH, AccSubLQH,
+  NULL
+};
+
+static const OB_ACC ob_acc[] = {
+  AccAddAOB, AccAddLOB, AccMulAOB, AccMulLOB,
+  SubMulAOB, SubMulLOB, AccSubAOB, AccSubLOB,
+  AccAbsDiffOB
+};
+
+
+static void
+qh_vector_acc(signed48 a[], unsigned64 v1, unsigned64 v2, QH_ACC acc)
+{
+  int  i;
+  signed16 h1, h2;
+
+  for (i = 0; i < 4; i++)
+    {
+      h1 = (signed16)(v1 & 0xFFFF);  v1 >>= 16;
+      h2 = (signed16)(v2 & 0xFFFF);  v2 >>= 16;
+      (*acc)(&a[i], h1, h2);
+    }
+}
+
+static void
+qh_map_acc(signed48 a[], unsigned64 v1, signed16 h2, QH_ACC acc)
+{
+  int  i;
+  signed16 h1;
+
+  for (i = 0; i < 4; i++)
+    {
+      h1 = (signed16)(v1 & 0xFFFF);  v1 >>= 16;
+      (*acc)(&a[i], h1, h2);
+    }
+}
+
+static void
+ob_vector_acc(signed24 a[], unsigned64 v1, unsigned64 v2, OB_ACC acc)
+{
+  int  i;
+  unsigned8  b1, b2;
+
+  for (i = 0; i < 8; i++)
+    {
+      b1 = v1 & 0xFF;  v1 >>= 8;
+      b2 = v2 & 0xFF;  v2 >>= 8;
+      (*acc)(&a[i], b1, b2);
+    }
+}
+
+static void
+ob_map_acc(signed24 a[], unsigned64 v1, unsigned8 b2, OB_ACC acc)
+{
+  int  i;
+  unsigned8 b1;
+
+  for (i = 0; i < 8; i++)
+    {
+      b1 = v1 & 0xFF;  v1 >>= 8;
+      (*acc)(&a[i], b1, b2);
+    }
+}
+
+
+/* Primary entry for operations that accumulate */
+void
+mdmx_acc_op(sim_cpu *cpu,
+	    address_word cia,
+	    int op,
+	    unsigned64 op1,
+	    int vt,
+	    MX_fmtsel fmtsel) 
+{
+  unsigned64 op2;
+
+  switch (MX_FMT (fmtsel))
+    {
+    case mdmx_qh:
+      switch (MX_VT (fmtsel))
+	{
+	case sel_elem:
+	  op2 = ValueFPR(vt, fmt_mdmx);
+	  qh_map_acc(ACC.qh, op1, QH_ELEM(op2, fmtsel), qh_acc[op]);
+	  break;
+	case sel_vect:
+	  qh_vector_acc(ACC.qh, op1, ValueFPR(vt, fmt_mdmx), qh_acc[op]);
+	  break;
+	case sel_imm:
+	  qh_map_acc(ACC.qh, op1, vt, qh_acc[op]);
+	  break;
+	}
+      break;
+    case mdmx_ob:
+      switch (MX_VT (fmtsel))
+	{
+	case sel_elem:
+	  op2 = ValueFPR(vt, fmt_mdmx);
+	  ob_map_acc(ACC.ob, op1, OB_ELEM(op2, fmtsel), ob_acc[op]);
+	  break;
+	case sel_vect:
+	  ob_vector_acc(ACC.ob, op1, ValueFPR(vt, fmt_mdmx), ob_acc[op]);
+	  break;
+	case sel_imm:
+	  ob_map_acc(ACC.ob, op1, vt, ob_acc[op]);
+	  break;
+	}
+      break;
+    default:
+      Unpredictable ();
+    }
+}
+
+
+/* Reading and writing accumulator (no conversion).  */
+
+unsigned64
+mdmx_rac_op(sim_cpu *cpu,
+	    address_word cia,
+	    int op,
+	    int fmt) 
+{
+  unsigned64    result;
+  unsigned int  shift;
+  int           i;
+
+  shift = op;          /* L = 00, M = 01, H = 10.  */
+  result = 0;
+
+  switch (fmt)
+    {
+    case MX_FMT_QH:
+      shift <<= 4;              /* 16 bits per element.  */
+      for (i = 3; i >= 0; --i)
+	{
+	  result <<= 16;
+	  result |= ((ACC.qh[i] >> shift) & 0xFFFF);
+	}
+      break;
+    case MX_FMT_OB:
+      shift <<= 3;              /*  8 bits per element.  */
+      for (i = 7; i >= 0; --i)
+	{
+	  result <<= 8;
+	  result |= ((ACC.ob[i] >> shift) & 0xFF);
+	}
+      break;
+    default:
+      Unpredictable ();
+    }
+  return result;
+}
+
+void
+mdmx_wacl(sim_cpu *cpu,
+	  address_word cia,
+	  int fmt,
+	  unsigned64 vs,
+	  unsigned64 vt) 
+{
+  int           i;
+
+  switch (fmt)
+    {
+    case MX_FMT_QH:
+      for (i = 0; i < 4; i++)
+	{
+	  signed32  s = (signed16)(vs & 0xFFFF);
+	  ACC.qh[i] = ((signed48)s << 16) | (vt & 0xFFFF);
+	  vs >>= 16;  vt >>= 16;
+	}
+      break;
+    case MX_FMT_OB:
+      for (i = 0; i < 8; i++)
+	{
+	  signed16  s = (signed8)(vs & 0xFF);
+	  ACC.ob[i] = ((signed24)s << 8) | (vt & 0xFF);
+	  vs >>= 8;   vt >>= 8;
+	}
+      break;
+    default:
+      Unpredictable ();
+    }
+}
+
+void
+mdmx_wach(sim_cpu *cpu,
+	  address_word cia,
+	  int fmt,
+	  unsigned64 vs)
+{
+  int           i;
+
+  switch (fmt)
+    {
+    case MX_FMT_QH:
+      for (i = 0; i < 4; i++)
+	{
+	  signed32  s = (signed16)(vs & 0xFFFF);
+	  ACC.qh[i] &= ~((signed48)0xFFFF << 32);
+	  ACC.qh[i] |=  ((signed48)s << 32);
+	  vs >>= 16;
+	}
+      break;
+    case MX_FMT_OB:
+      for (i = 0; i < 8; i++)
+	{
+	  ACC.ob[i] &= ~((signed24)0xFF << 16);
+	  ACC.ob[i] |=  ((signed24)(vs & 0xFF) << 16);
+	  vs >>= 8;
+	}
+      break;
+    default:
+      Unpredictable ();
+    }
+}
+
+
+/* Reading and writing accumulator (rounding conversions).
+   Enumerating function guarantees s >= 0 for QH ops.  */
+
+typedef signed16 (*QH_ROUND)(signed48 a, signed16 s);
+
+#define QH_BIT(n)  ((unsigned48)1 << (n))
+#define QH_ONES(n) (((unsigned48)1 << (n))-1)
+
+static signed16
+RNASQH(signed48 a, signed16 s)
+{
+  signed48 t;
+  signed16 result = 0;
+
+  if (s > 48)
+    result = 0;
+  else
+    {
+      t = (a >> s);
+      if ((a & QH_BIT(47)) == 0)
+	{
+	  if (s > 0 && ((a >> (s-1)) & 1) == 1)
+	    t++;
+	  if (t > QH_MAX)
+	    t = QH_MAX;
+	}
+      else
+	{
+	  if (s > 0 && ((a >> (s-1)) & 1) == 1)
+	    {
+	      if (s > 1 && ((unsigned48)a & QH_ONES(s-1)) != 0)
+		t++;
+	    }
+	  if (t < QH_MIN)
+	    t = QH_MIN;
+	}
+      result = (signed16)t;
+    }
+  return result;
+}
+
+static signed16
+RNAUQH(signed48 a, signed16 s)
+{
+  unsigned48 t;
+  signed16 result;
+
+  if (s > 48)
+    result = 0;
+  else if (s == 48)
+    result = ((unsigned48)a & MASK48) >> 47;
+  else
+    {
+      t = ((unsigned48)a & MASK48) >> s;
+      if (s > 0 && ((a >> (s-1)) & 1) == 1)
+	t++;
+      if (t > 0xFFFF)
+	t = 0xFFFF;
+      result = (signed16)t;
+    }
+  return result;
+}
+
+static signed16
+RNESQH(signed48 a, signed16 s)
+{
+  signed48 t;
+  signed16 result = 0;
+
+  if (s > 47)
+    result = 0;
+  else
+    {
+      t = (a >> s);
+      if (s > 0 && ((a >> (s-1)) & 1) == 1)
+	{
+	  if (s == 1 || (a & QH_ONES(s-1)) == 0)
+	    t += t & 1;
+	  else
+	    t += 1;
+	}
+      if ((a & QH_BIT(47)) == 0)
+	{
+	  if (t > QH_MAX)
+	    t = QH_MAX;
+	}
+      else
+	{
+	  if (t < QH_MIN)
+	    t = QH_MIN;
+	}
+      result = (signed16)t;
+    }
+  return result;
+}
+
+static signed16
+RNEUQH(signed48 a, signed16 s)
+{
+  unsigned48 t;
+  signed16 result;
+
+  if (s > 48)
+    result = 0;
+  else if (s == 48)
+    result = ((unsigned48)a > QH_BIT(47) ? 1 : 0);
+  else
+    {
+      t = ((unsigned48)a & MASK48) >> s;
+      if (s > 0 && ((a >> (s-1)) & 1) == 1)
+	{
+	  if (s > 1 && (a & QH_ONES(s-1)) != 0)
+	    t++;
+	  else
+	    t += t & 1;
+	}
+      if (t > 0xFFFF)
+	t = 0xFFFF;
+      result = (signed16)t;
+    }
+  return result;
+}
+
+static signed16
+RZSQH(signed48 a, signed16 s)
+{
+  signed48 t;
+  signed16 result = 0;
+
+  if (s > 47)
+    result = 0;
+  else
+    {
+      t = (a >> s);
+      if ((a & QH_BIT(47)) == 0)
+	{
+	  if (t > QH_MAX)
+	    t = QH_MAX;
+	}
+      else
+	{
+	  if (t < QH_MIN)
+	    t = QH_MIN;
+	}
+      result = (signed16)t;
+    }
+  return result;
+}
+
+static signed16
+RZUQH(signed48 a, signed16 s)
+{
+  unsigned48 t;
+  signed16 result = 0;
+
+  if (s > 48)
+    result = 0;
+  else if (s == 48)
+    result = ((unsigned48)a > QH_BIT(47) ? 1 : 0);
+  else
+    {
+      t = ((unsigned48)a & MASK48) >> s;
+      if (t > 0xFFFF)
+	t = 0xFFFF;
+      result = (signed16)t;
+    }
+  return result;
+}
+
+
+typedef unsigned8 (*OB_ROUND)(signed24 a, unsigned8 s);
+
+#define OB_BIT(n)  ((unsigned24)1 << (n))
+#define OB_ONES(n) (((unsigned24)1 << (n))-1)
+
+static unsigned8
+RNAUOB(signed24 a, unsigned8 s)
+{
+  unsigned8 result;
+  unsigned24 t;
+
+  if (s > 24)
+    result = 0;
+  else if (s == 24)
+    result = ((unsigned24)a & MASK24) >> 23;
+  else
+    {
+      t = ((unsigned24)a & MASK24) >> s;
+      if (s > 0 && ((a >> (s-1)) & 1) == 1)
+	t ++;
+      result = OB_CLAMP(t);
+    }
+  return result;
+}
+
+static unsigned8
+RNEUOB(signed24 a, unsigned8 s)
+{
+  unsigned8 result;
+  unsigned24 t;
+
+  if (s > 24)
+    result = 0;
+  else if (s == 24)
+    result = (((unsigned24)a & MASK24) > OB_BIT(23) ? 1 : 0);
+  else
+    {
+      t = ((unsigned24)a & MASK24) >> s;
+      if (s > 0 && ((a >> (s-1)) & 1) == 1)
+	{
+	  if (s > 1 && (a & OB_ONES(s-1)) != 0)
+	    t++;
+	  else
+	    t += t & 1;
+	}
+      result = OB_CLAMP(t);
+    }
+  return result;
+}
+
+static unsigned8
+RZUOB(signed24 a, unsigned8 s)
+{
+  unsigned8 result;
+  unsigned24 t;
+
+  if (s >= 24)
+    result = 0;
+  else
+    {
+      t = ((unsigned24)a & MASK24) >> s;
+      result = OB_CLAMP(t);
+    }
+  return result;
+}
+
+
+static const QH_ROUND qh_round[] = {
+  RNASQH, RNAUQH, RNESQH, RNEUQH, RZSQH,  RZUQH
+};
+
+static const OB_ROUND ob_round[] = {
+  NULL,   RNAUOB, NULL,   RNEUOB, NULL,   RZUOB
+};
+
+
+static unsigned64
+qh_vector_round(sim_cpu *cpu, address_word cia, unsigned64 v2, QH_ROUND round)
+{
+  unsigned64 result = 0;
+  int  i, s;
+  signed16 h, h2;
+
+  s = 0;
+  for (i = 0; i < 4; i++)
+    {
+      h2 = (signed16)(v2 & 0xFFFF);
+      if (h2 >= 0)
+	h = (*round)(ACC.qh[i], h2);
+      else
+	{
+	  UnpredictableResult ();
+	  h = 0xdead;
+	}
+      v2 >>= 16;
+      result |= ((unsigned64)((unsigned16)h) << s);
+      s += 16;
+    }
+  return result;
+}
+
+static unsigned64
+qh_map_round(sim_cpu *cpu, address_word cia, signed16 h2, QH_ROUND round)
+{
+  unsigned64 result = 0;
+  int  i, s;
+  signed16  h;
+
+  s = 0;
+  for (i = 0; i < 4; i++)
+    {
+      if (h2 >= 0)
+	h = (*round)(ACC.qh[i], h2);
+      else
+	{
+	  UnpredictableResult ();
+	  h = 0xdead;
+	}
+      result |= ((unsigned64)((unsigned16)h) << s);
+      s += 16;
+    }
+  return result;
+}
+
+static unsigned64
+ob_vector_round(sim_cpu *cpu, address_word cia, unsigned64 v2, OB_ROUND round)
+{
+  unsigned64 result = 0;
+  int  i, s;
+  unsigned8 b, b2;
+
+  s = 0;
+  for (i = 0; i < 8; i++)
+    {
+      b2 = v2 & 0xFF;  v2 >>= 8;
+      b = (*round)(ACC.ob[i], b2);
+      result |= ((unsigned64)b << s);
+      s += 8;
+    }
+  return result;
+}
+
+static unsigned64
+ob_map_round(sim_cpu *cpu, address_word cia, unsigned8 b2, OB_ROUND round)
+{
+  unsigned64 result = 0;
+  int  i, s;
+  unsigned8 b;
+
+  s = 0;
+  for (i = 0; i < 8; i++)
+    {
+      b = (*round)(ACC.ob[i], b2);
+      result |= ((unsigned64)b << s);
+      s += 8;
+    }
+  return result;
+}
+
+
+unsigned64
+mdmx_round_op(sim_cpu *cpu,
+	      address_word cia,
+	      int rm,
+	      int vt,
+	      MX_fmtsel fmtsel) 
+{
+  unsigned64 op2;
+  unsigned64 result = 0;
+
+  switch (MX_FMT (fmtsel))
+    {
+    case mdmx_qh:
+      switch (MX_VT (fmtsel))
+	{
+	case sel_elem:
+	  op2 = ValueFPR(vt, fmt_mdmx);
+	  result = qh_map_round(cpu, cia, QH_ELEM(op2, fmtsel), qh_round[rm]);
+	  break;
+	case sel_vect:
+	  op2 = ValueFPR(vt, fmt_mdmx);
+	  result = qh_vector_round(cpu, cia, op2, qh_round[rm]);
+	  break;
+	case sel_imm:
+	  result = qh_map_round(cpu, cia, vt, qh_round[rm]);
+	  break;
+	}
+      break;
+    case mdmx_ob:
+      switch (MX_VT (fmtsel))
+	{
+	case sel_elem:
+	  op2 = ValueFPR(vt, fmt_mdmx);
+	  result = ob_map_round(cpu, cia, OB_ELEM(op2, fmtsel), ob_round[rm]);
+	  break;
+	case sel_vect:
+	  op2 = ValueFPR(vt, fmt_mdmx);
+	  result = ob_vector_round(cpu, cia, op2, ob_round[rm]);
+	  break;
+	case sel_imm:
+	  result = ob_map_round(cpu, cia, vt, ob_round[rm]);
+	  break;
+	}
+      break;
+    default:
+      Unpredictable ();
+    }
+
+  return result;
+}
+
+
+/* Shuffle operation.  */
+
+typedef struct {
+  enum {vs, ss, vt} source;
+  unsigned int      index;
+} sh_map;
+
+static const sh_map ob_shuffle[][8] = {
+  /* MDMX 2.0 encodings (3-4, 6-7).  */
+  /* vr5400   encoding  (5), otherwise.  */
+  {                                                              }, /* RSVD */
+  {{vt,4}, {vs,4}, {vt,5}, {vs,5}, {vt,6}, {vs,6}, {vt,7}, {vs,7}}, /* RSVD */
+  {{vt,0}, {vs,0}, {vt,1}, {vs,1}, {vt,2}, {vs,2}, {vt,3}, {vs,3}}, /* RSVD */
+  {{vs,0}, {ss,0}, {vs,1}, {ss,1}, {vs,2}, {ss,2}, {vs,3}, {ss,3}}, /* upsl */
+  {{vt,1}, {vt,3}, {vt,5}, {vt,7}, {vs,1}, {vs,3}, {vs,5}, {vs,7}}, /* pach */
+  {{vt,0}, {vt,2}, {vt,4}, {vt,6}, {vs,0}, {vs,2}, {vs,4}, {vs,6}}, /* pacl */
+  {{vt,4}, {vs,4}, {vt,5}, {vs,5}, {vt,6}, {vs,6}, {vt,7}, {vs,7}}, /* mixh */
+  {{vt,0}, {vs,0}, {vt,1}, {vs,1}, {vt,2}, {vs,2}, {vt,3}, {vs,3}}  /* mixl */
+};
+
+static const sh_map qh_shuffle[][4] = {
+  {{vt,2}, {vs,2}, {vt,3}, {vs,3}},  /* mixh */
+  {{vt,0}, {vs,0}, {vt,1}, {vs,1}},  /* mixl */
+  {{vt,1}, {vt,3}, {vs,1}, {vs,3}},  /* pach */
+  {                              },  /* RSVD */
+  {{vt,1}, {vs,0}, {vt,3}, {vs,2}},  /* bfla */
+  {                              },  /* RSVD */
+  {{vt,2}, {vt,3}, {vs,2}, {vs,3}},  /* repa */
+  {{vt,0}, {vt,1}, {vs,0}, {vs,1}}   /* repb */
+};
+
+
+unsigned64
+mdmx_shuffle(sim_cpu *cpu,
+	     address_word cia,
+	     int shop,
+	     unsigned64 op1,
+	     unsigned64 op2)
+{
+  unsigned64 result = 0;
+  int  i, s;
+  int  op;
+
+  if ((shop & 0x3) == 0x1)       /* QH format.  */
+    {
+      op = shop >> 2;
+      s = 0;
+      for (i = 0; i < 4; i++)
+	{
+	  unsigned64 v;
+
+	  switch (qh_shuffle[op][i].source)
+	    {
+	    case vs:
+	      v = op1;
+	      break;
+	    case vt:
+	      v = op2;
+	      break;
+	    default:
+	      Unpredictable ();
+	      v = 0;
+	    }
+	  result |= (((v >> 16*qh_shuffle[op][i].index) & 0xFFFF) << s);
+	  s += 16;
+	}
+    }
+  else if ((shop & 0x1) == 0x0)  /* OB format.  */
+    {
+      op = shop >> 1;
+      s = 0;
+      for (i = 0; i < 8; i++)
+	{
+	  unsigned8 b;
+	  unsigned int ishift = 8*ob_shuffle[op][i].index;
+
+	  switch (ob_shuffle[op][i].source)
+	    {
+	    case vs:
+	      b = (op1 >> ishift) & 0xFF;
+	      break;
+	    case ss:
+	      b = ((op1 >> ishift) & 0x80) ? 0xFF : 0;
+	      break;
+	    case vt:
+	      b = (op2 >> ishift) & 0xFF;
+	      break;
+	    default:
+	      Unpredictable ();
+	      b = 0;
+	    }
+	  result |= ((unsigned64)b << s);
+	  s += 8;
+	}
+    }
+  else
+    Unpredictable ();
+
+  return result;
+}
+#endif
Index: sim/brownie32/mdmx.igen
===================================================================
RCS file: sim/brownie32/mdmx.igen
diff -N sim/brownie32/mdmx.igen
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/mdmx.igen	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,593 @@
+// -*- C -*-
+
+// Simulator definition for the MIPS MDMX ASE.
+// Copyright (C) 2002 Free Software Foundation, Inc.
+// Contributed by Ed Satterthwaite and Chris Demetriou, of Broadcom
+// Corporation (SiByte).
+//
+// This file is part of GDB, the GNU debugger.
+// 
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License along
+// with this program; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+//  Reference: MIPS64 Architecture Volume IV-b:
+//             The MDMX Application-Specific Extension
+
+//  Notes on "format selectors" (FMTSEL):
+//
+//   A selector with final bit 0 indicates OB format.
+//   A selector with final bits 01 indicates QH format.
+//   A selector with final bits 11 has UNPREDICTABLE result per the spec.
+//
+//  Similarly, for the single-bit fields which differentiate between
+//  formats (FMTOP), 0 is OB format and 1 is QH format.
+
+//  If you change this file to add instructions, please make sure that model
+//  "sb1" configurations still build, and that you've added no new
+//  instructions to the "sb1" model.
+
+
+// Helper:
+//
+// Check whether MDMX is usable, and if not signal an appropriate exception.
+//
+
+:function:::void:check_mdmx:instruction_word insn
+*mdmx:
+{
+  if (! COP_Usable (1))
+    SignalExceptionCoProcessorUnusable (1);
+  if ((SR & (status_MX|status_FR)) != (status_MX|status_FR))
+    SignalExceptionMDMX ();
+  check_u64 (SD_, insn);
+}
+
+
+// Helper:
+//
+// Check whether a given MDMX format selector indicates a valid and usable
+// format, and if not signal an appropriate exception.
+//
+
+:function:::int:check_mdmx_fmtsel:instruction_word insn, int fmtsel
+*mdmx:
+{
+  switch (fmtsel & 0x03)
+    {
+    case 0x00:     /* ob */
+    case 0x02:
+    case 0x01:     /* qh */
+      return 1;
+    case 0x03:     /* UNPREDICTABLE */
+      SignalException (ReservedInstruction, insn);
+      return 0;
+    }
+  return 0;
+}
+
+
+// Helper:
+//
+// Check whether a given MDMX format bit indicates a valid and usable
+// format, and if not signal an appropriate exception.
+//
+
+:function:::int:check_mdmx_fmtop:instruction_word insn, int fmtop
+*mdmx:
+{
+  switch (fmtop & 0x01)
+    {
+    case 0x00:     /* ob */
+    case 0x01:     /* qh */
+      return 1;
+    }
+  return 0;
+}
+
+
+:%s::::FMTSEL:int fmtsel
+*mdmx:
+*sb1:
+{
+  if ((fmtsel & 0x1) == 0)
+    return "ob";
+  else if ((fmtsel & 0x3) == 1)
+    return "qh";
+  else
+    return "?";
+}
+
+
+:%s::::FMTOP:int fmtop
+*mdmx:
+*sb1:
+{
+  switch (fmtop)
+    {
+    case 0: return "ob";
+    case 1: return "qh";
+    default: return "?";
+    }
+}
+
+
+:%s::::SHOP:int shop
+*mdmx:
+*sb1:
+{
+  if ((shop & 0x11) == 0x00)
+    switch ((shop >> 1) & 0x07)
+      {
+      case 3:  return "upsl.ob";
+      case 4:  return "pach.ob";
+      case 6:  return "mixh.ob";
+      case 7:  return "mixl.ob";
+      default: return "?";
+      }
+  else if ((shop & 0x03) == 0x01)
+    switch ((shop >> 2) & 0x07)
+      {
+      case 0:  return "mixh.qh";
+      case 1:  return "mixl.qh";
+      case 2:  return "pach.qh";
+      case 4:  return "bfla.qh";
+      case 6:  return "repa.qh";
+      case 7:  return "repb.qh";
+      default: return "?";
+      }
+  else
+    return "?";
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,5.VD,001011:MDMX:64::ADD.fmt
+"add.%s<FMTSEL> v<VD>, v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    StoreFPR(VD,fmt_mdmx,MX_Add(ValueFPR(VS,fmt_mdmx),VT,FMTSEL));
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,0,0000,110111:MDMX:64::ADDA.fmt
+"adda.%s<FMTSEL> v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    MX_AddA(ValueFPR(VS,fmt_mdmx),VT,FMTSEL);
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,1,0000,110111:MDMX:64::ADDL.fmt
+"addl.%s<FMTSEL> v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    MX_AddL(ValueFPR(VS,fmt_mdmx),VT,FMTSEL);
+}
+
+
+011110,00,3.IMM,5.VT,5.VS,5.VD,0110,1.FMTOP,0:MDMX:64::ALNI.fmt
+"alni.%s<FMTOP> v<VD>, v<VS>, v<VT>, <IMM>"
+*mdmx:
+*sb1:
+{
+  unsigned64 result;
+  int s;
+  check_mdmx (SD_, instruction_0);
+  check_mdmx_fmtop (SD_, instruction_0, FMTOP);
+  s = (IMM << 3);
+  result = ValueFPR(VS,fmt_mdmx) << s;
+  if (s != 0)  // x86 gcc treats >> 64 as >> 0
+    result |= ValueFPR(VT,fmt_mdmx) >> (64 - s);
+  StoreFPR(VD,fmt_mdmx,result);
+}
+
+
+011110,5.RS,5.VT,5.VS,5.VD,0110,1.FMTOP,1:MDMX:64::ALNV.fmt
+"alnv.%s<FMTOP> v<VD>, v<VS>, v<VT>, r<RS>"
+*mdmx:
+*sb1:
+{
+  unsigned64 result;
+  int s;
+  check_mdmx (SD_, instruction_0);
+  check_mdmx_fmtop (SD_, instruction_0, FMTOP);
+  s = ((GPR[RS] & 0x7) << 3);
+  result = ValueFPR(VS,fmt_mdmx) << s;
+  if (s != 0)  // x86 gcc treats >> 64 as >> 0
+    result |= ValueFPR(VT,fmt_mdmx) >> (64 - s);
+  StoreFPR(VD,fmt_mdmx,result);
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,5.VD,001100:MDMX:64::AND.fmt
+"and.%s<FMTSEL> v<VD>, v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    StoreFPR(VD,fmt_mdmx,MX_And(ValueFPR(VS,fmt_mdmx),VT,FMTSEL));
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,00000,000001:MDMX:64::C.EQ.fmt
+"c.eq.%s<FMTSEL> v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    MX_Comp(ValueFPR(VS,fmt_mdmx),MX_C_EQ,VT,FMTSEL);
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,00000,000101:MDMX:64::C.LE.fmt
+"c.le.%s<FMTSEL> v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    MX_Comp(ValueFPR(VS,fmt_mdmx),MX_C_LT|MX_C_EQ,VT,FMTSEL);
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,00000,000100:MDMX:64::C.LT.fmt
+"c.lt.%s<FMTSEL> v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    MX_Comp(ValueFPR(VS,fmt_mdmx),MX_C_LT,VT,FMTSEL);
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,5.VD,000111:MDMX:64::MAX.fmt
+"max.%s<FMTSEL> v<VD>, v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    StoreFPR(VD,fmt_mdmx,MX_Max(ValueFPR(VS,fmt_mdmx),VT,FMTSEL));
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,5.VD,000110:MDMX:64::MIN.fmt
+"min.%s<FMTSEL> v<VD>, v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    StoreFPR(VD,fmt_mdmx,MX_Min(ValueFPR(VS,fmt_mdmx),VT,FMTSEL));
+}
+
+
+011110,3.SEL,01,5.VT,5.VS,5.VD,000000:MDMX:64::MSGN.QH
+"msgn.qh v<VD>, v<VS>, v<VT>"
+*mdmx:
+{
+  check_mdmx (SD_, instruction_0);
+  StoreFPR(VD,fmt_mdmx,MX_Msgn(ValueFPR(VS,fmt_mdmx),VT,qh_fmtsel(SEL)));
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,5.VD,110000:MDMX:64::MUL.fmt
+"mul.%s<FMTSEL> v<VD>, v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    StoreFPR(VD,fmt_mdmx,MX_Mul(ValueFPR(VS,fmt_mdmx),VT,FMTSEL));
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,0,0000,110011:MDMX:64::MULA.fmt
+"mula.%s<FMTSEL> v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    MX_MulA(ValueFPR(VS,fmt_mdmx),VT,FMTSEL);
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,1,0000,110011:MDMX:64::MULL.fmt
+"mull.%s<FMTSEL> v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    MX_MulL(ValueFPR(VS,fmt_mdmx),VT,FMTSEL);
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,0,0000,110010:MDMX:64::MULS.fmt
+"muls.%s<FMTSEL> v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    MX_MulS(ValueFPR(VS,fmt_mdmx),VT,FMTSEL);
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,1,0000,110010:MDMX:64::MULSL.fmt
+"mulsl.%s<FMTSEL> v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    MX_MulSL(ValueFPR(VS,fmt_mdmx),VT,FMTSEL);
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,5.VD,001111:MDMX:64::NOR.fmt
+"nor.%s<FMTSEL> v<VD>, v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    StoreFPR(VD,fmt_mdmx,MX_Nor(ValueFPR(VS,fmt_mdmx),VT,FMTSEL));
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,5.VD,001110:MDMX:64::OR.fmt
+"or.%s<FMTSEL> v<VD>, v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    StoreFPR(VD,fmt_mdmx,MX_Or(ValueFPR(VS,fmt_mdmx),VT,FMTSEL));
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,5.VD,000010:MDMX:64::PICKF.fmt
+"pickf.%s<FMTSEL> v<VD>, v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    StoreFPR(VD,fmt_mdmx,MX_Pick(0,ValueFPR(VS,fmt_mdmx),VT,FMTSEL));
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,5.VD,000011:MDMX:64::PICKT.fmt
+"pickt.%s<FMTSEL> v<VD>, v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    StoreFPR(VD,fmt_mdmx,MX_Pick(1,ValueFPR(VS,fmt_mdmx),VT,FMTSEL));
+}
+
+
+011110,1000,1.FMTOP,00000,00000,5.VD,111111:MDMX:64::RACH.fmt
+"rach.%s<FMTOP> v<VD>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  check_mdmx_fmtop (SD_, instruction_0, FMTOP);
+  StoreFPR(VD,fmt_mdmx,MX_RAC(MX_RAC_H,FMTOP));
+}
+
+
+011110,0000,1.FMTOP,00000,00000,5.VD,111111:MDMX:64::RACL.fmt
+"racl.%s<FMTOP> v<VD>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  check_mdmx_fmtop (SD_, instruction_0, FMTOP);
+  StoreFPR(VD,fmt_mdmx,MX_RAC(MX_RAC_L,FMTOP));
+}
+
+
+011110,0100,1.FMTOP,00000,00000,5.VD,111111:MDMX:64::RACM.fmt
+"racm.%s<FMTOP> v<VD>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  check_mdmx_fmtop (SD_, instruction_0, FMTOP);
+  StoreFPR(VD,fmt_mdmx,MX_RAC(MX_RAC_M,FMTOP));
+}
+
+
+011110,3.SEL,01,5.VT,00000,5.VD,100101:MDMX:64::RNAS.QH
+"rnas.qh v<VD>, v<VT>"
+*mdmx:
+{
+  check_mdmx (SD_, instruction_0);
+  StoreFPR(VD,fmt_mdmx,MX_RNAS(VT,qh_fmtsel(SEL)));
+}
+
+
+011110,5.FMTSEL,5.VT,00000,5.VD,100001:MDMX:64::RNAU.fmt
+"rnau.%s<FMTSEL> v<VD>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    StoreFPR(VD,fmt_mdmx,MX_RNAU(VT,FMTSEL));
+}
+
+
+011110,3.SEL,01,5.VT,00000,5.VD,100110:MDMX:64::RNES.QH
+"rnes.qh v<VD>, v<VT>"
+*mdmx:
+{
+  check_mdmx (SD_, instruction_0);
+  StoreFPR(VD,fmt_mdmx,MX_RNES(VT,qh_fmtsel(SEL)));
+}
+
+
+011110,5.FMTSEL,5.VT,00000,5.VD,100010:MDMX:64::RNEU.fmt
+"rneu.%s<FMTSEL> v<VD>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    StoreFPR(VD,fmt_mdmx,MX_RNEU(VT,FMTSEL));
+}
+
+
+011110,3.SEL,01,5.VT,00000,5.VD,100100:MDMX:64::RZS.QH
+"rzs.qh v<VD>, v<VT>"
+*mdmx:
+{
+  check_mdmx (SD_, instruction_0);
+  StoreFPR(VD,fmt_mdmx,MX_RZS(VT,qh_fmtsel(SEL)));
+}
+
+
+011110,5.FMTSEL,5.VT,00000,5.VD,100000:MDMX:64::RZU.fmt
+"rzu.%s<FMTSEL> v<VD>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    StoreFPR(VD,fmt_mdmx,MX_RZU(VT,FMTSEL));
+}
+
+
+011110,5.SHOP,5.VT,5.VS,5.VD,011111:MDMX:64::SHFL.op.fmt
+"shfl.%s<SHOP> v<VD>, v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, SHOP))
+    StoreFPR(VD,fmt_mdmx,MX_SHFL(SHOP,ValueFPR(VS,fmt_mdmx),ValueFPR(VT,fmt_mdmx)));
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,5.VD,010000:MDMX:64::SLL.fmt
+"sll.%s<FMTSEL> v<VD>, v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    StoreFPR(VD,fmt_mdmx,MX_ShiftLeftLogical(ValueFPR(VS,fmt_mdmx),VT,FMTSEL));
+}
+
+
+011110,3.SEL,01,5.VT,5.VS,5.VD,010011:MDMX:64::SRA.QH
+"sra.qh v<VD>, v<VS>, v<VT>"
+*mdmx:
+{
+  check_mdmx (SD_, instruction_0);
+  StoreFPR(VD,fmt_mdmx,MX_ShiftRightArith(ValueFPR(VS,fmt_mdmx),VT,qh_fmtsel(SEL)));
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,5.VD,010010:MDMX:64::SRL.fmt
+"srl.%s<FMTSEL> v<VD>, v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    StoreFPR(VD,fmt_mdmx,MX_ShiftRightLogical(ValueFPR(VS,fmt_mdmx),VT,FMTSEL));
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,5.VD,001010:MDMX:64::SUB.fmt
+"sub.%s<FMTSEL> v<VD>, v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    StoreFPR(VD,fmt_mdmx,MX_Sub(ValueFPR(VS,fmt_mdmx),VT,FMTSEL));
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,0,0000,110110:MDMX:64::SUBA.fmt
+"suba.%s<FMTSEL> v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    MX_SubA(ValueFPR(VS,fmt_mdmx),VT,FMTSEL);
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,1,0000,110110:MDMX:64::SUBL.fmt
+"subl.%s<FMTSEL> v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    MX_SubL(ValueFPR(VS,fmt_mdmx),VT,FMTSEL);
+}
+
+
+011110,1000,1.FMTOP,00000,5.VS,00000,111110:MDMX:64::WACH.fmt
+"wach.%s<FMTOP> v<VS>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  check_mdmx_fmtop (SD_, instruction_0, FMTOP);
+  MX_WACH(FMTOP,ValueFPR(VS,fmt_mdmx));
+}
+
+
+011110,0000,1.FMTOP,5.VT,5.VS,00000,111110:MDMX:64::WACL.fmt
+"wacl.%s<FMTOP> v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  check_mdmx_fmtop (SD_, instruction_0, FMTOP);
+  MX_WACL(FMTOP,ValueFPR(VS,fmt_mdmx),ValueFPR(VT,fmt_mdmx));
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,5.VD,001101:MDMX:64::XOR.fmt
+"xor.%s<FMTSEL> v<VD>, v<VS>, v<VT>"
+*mdmx:
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  if (check_mdmx_fmtsel (SD_, instruction_0, FMTSEL))
+    StoreFPR(VD,fmt_mdmx,MX_Xor(ValueFPR(VS,fmt_mdmx),VT,FMTSEL));
+}
Index: sim/brownie32/sb1.igen
===================================================================
RCS file: sim/brownie32/sb1.igen
diff -N sim/brownie32/sb1.igen
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/sb1.igen	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,244 @@
+// -*- C -*-
+
+// Simulator definition for the Broadcom SiByte SB-1 CPU extensions.
+// Copyright (C) 2002 Free Software Foundation, Inc.
+// Contributed by Ed Satterthwaite and Chris Demetriou, of Broadcom
+// Corporation (SiByte).
+//
+// This file is part of GDB, the GNU debugger.
+// 
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License along
+// with this program; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+
+// Helper:
+//
+// Check that the SB-1 extension instruction can currently be used, and
+// signal a ReservedInstruction exception if not.
+//
+
+:function:::void:check_sbx:instruction_word insn
+*sb1:
+{
+  if ((SR & status_SBX) == 0)
+    SignalException(ReservedInstruction, insn);
+}
+
+
+//  MDMX ASE Instructions
+//  ---------------------
+//
+//  The SB-1 implements the format OB subset of MDMX
+//  and has three additions (pavg, pabsdiff, pabsdifc).
+//  In addition, there are a couple of partial-decoding
+//  issues for the read/write accumulator instructions.
+//
+//  This code is structured so that mdmx.igen can be used by
+//  selecting the allowed instructions either via model, or by
+//  using check_mdmx_fmtsel and check_mdmx_fmtop to cause an
+//  exception if the instruction is not allowed.
+
+
+:function:::void:check_mdmx:instruction_word insn
+*sb1:
+{
+  if (!COP_Usable(1))
+    SignalExceptionCoProcessorUnusable(1);
+  if ((SR & status_MX) == 0)
+    SignalExceptionMDMX();
+  check_u64 (SD_, insn);
+}
+
+:function:::int:check_mdmx_fmtsel:instruction_word insn, int fmtsel
+*sb1:
+{
+  switch (fmtsel & 0x03)
+    {
+    case 0x00:     /* ob */
+    case 0x02:
+      return 1;
+    case 0x01:     /* qh */
+    case 0x03:     /* UNPREDICTABLE */
+      SignalException (ReservedInstruction, insn);
+      return 0;
+    }
+  return 0;
+}
+
+:function:::int:check_mdmx_fmtop:instruction_word insn, int fmtop
+*sb1:
+{
+  switch (fmtop & 0x01)
+    {
+    case 0x00:     /* ob */
+      return 1;
+    case 0x01:     /* qh */
+      SignalException (ReservedInstruction, insn);
+      return 0;
+    }
+  return 0;
+}
+
+
+011110,10,2.X!0,1.FMTOP,00000,00000,5.VD,111111:MDMX:64::RACH.sb1.fmt
+"rach.?<X>.%s<FMTOP> v<VD>"
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  check_mdmx_fmtop (SD_, instruction_0, FMTOP);
+  /* No op.  */
+}
+
+
+011110,00,2.X!0,1.FMTOP,00000,00000,5.VD,111111:MDMX:64::RACL.sb1.fmt
+"racl.?<X>.%s<FMTOP> v<VD>"
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  check_mdmx_fmtop (SD_, instruction_0, FMTOP);
+  /* No op.  */
+}
+
+
+011110,01,2.X!0,1.FMTOP,00000,00000,5.VD,111111:MDMX:64::RACM.sb1.fmt
+"racm.?<X>.%s<FMTOP> v<VD>"
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  check_mdmx_fmtop (SD_, instruction_0, FMTOP);
+  /* No op.  */
+}
+
+
+011110,2.X1!0!1!2,2.X2,1.FMTOP,00000,00000,5.VD,111111:MDMX:64::RAC.sb1.fmt
+"rac?<X1>.?<X2> v<VD>"
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  check_mdmx_fmtop (SD_, instruction_0, FMTOP);
+  /* No op.  */
+}
+
+
+011110,10,2.X!0,1.FMTOP,00000,5.VS,00000,111110:MDMX:64::WACH.sb1.fmt
+"wach.?<X>.%s<FMTOP> v<VS>"
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  check_mdmx_fmtop (SD_, instruction_0, FMTOP);
+  /* No op.  */
+}
+
+
+011110,00,2.X!0,1.FMTOP,5.VT,5.VS,00000,111110:MDMX:64::WACL.sb1.fmt
+"wacl.?<X>.%s<FMTOP> v<VS>,v<VT>"
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  check_mdmx_fmtop (SD_, instruction_0, FMTOP);
+  /* No op.  */
+}
+
+
+011110,2.X1!0!2,2.X2,1.FMTOP,5.VT,5.VS,00000,111110:MDMX:64::WAC.sb1.fmt
+"wacl?<X1>.?<X2>.%s<FMTOP> v<VS>,v<VT>"
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  check_mdmx_fmtop (SD_, instruction_0, FMTOP);
+  /* No op.  */
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,5.VD,001001:MDMX:64::PABSDIFF.fmt
+"pabsdiff.%s<FMTSEL> v<VD>,v<VS>,v<VT>"
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  check_sbx (SD_, instruction_0);
+  check_mdmx_fmtsel (SD_, instruction_0, FMTSEL);
+  StoreFPR(VD,fmt_mdmx,MX_AbsDiff(ValueFPR(VS,fmt_mdmx),VT,FMTSEL));
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,00000,110101:MDMX:64::PABSDIFC.fmt
+"pabsdifc.%<FMTSEL> v<VS>,v<VT>"
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  check_sbx (SD_, instruction_0);
+  check_mdmx_fmtsel (SD_, instruction_0, FMTSEL);
+  MX_AbsDiffC(ValueFPR(VS,fmt_mdmx),VT,FMTSEL);
+}
+
+
+011110,5.FMTSEL,5.VT,5.VS,5.VD,001000:MDMX:64::PAVG.fmt
+"pavg.%s<FMTSEL> v<VD>,v<VS>,v<VT>"
+*sb1:
+{
+  check_mdmx (SD_, instruction_0);
+  check_sbx (SD_, instruction_0);
+  check_mdmx_fmtsel (SD_, instruction_0, FMTSEL);
+  StoreFPR(VD,fmt_mdmx,MX_Avg(ValueFPR(VS,fmt_mdmx),VT,FMTSEL));
+}
+
+
+//  Paired-Single Extension Instructions
+//  ------------------------------------
+//
+//  The SB-1 implements several .PS format instructions that are
+//  extensions to the MIPS64 architecture.
+
+010001,10,3.FMT=6,5.FT,5.FS,5.FD,000011:COP1:32,f::DIV.PS
+"div.%s<FMT> f<FD>, f<FS>, f<FT>"
+*sb1:
+{
+  int fmt = FMT;
+  check_fpu (SD_);
+  check_sbx (SD_, instruction_0);
+  StoreFPR (FD, fmt, Divide (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
+}
+
+
+010001,10,3.FMT=6,00000,5.FS,5.FD,010101:COP1:32,f::RECIP.PS
+"recip.%s<FMT> f<FD>, f<FS>"
+*sb1:
+{
+  int fmt = FMT;
+  check_fpu (SD_);
+  check_sbx (SD_, instruction_0);
+  StoreFPR (FD, fmt, Recip (ValueFPR (FS, fmt), fmt));
+}
+
+
+010001,10,3.FMT=6,00000,5.FS,5.FD,010110:COP1:32,f::RSQRT.PS
+"rsqrt.%s<FMT> f<FD>, f<FS>"
+*sb1:
+{
+  int fmt = FMT;
+  check_fpu (SD_);
+  check_sbx (SD_, instruction_0);
+  StoreFPR (FD, fmt, RSquareRoot (ValueFPR (FS, fmt), fmt));
+}
+
+
+010001,10,3.FMT=6,00000,5.FS,5.FD,000100:COP1:32,f::SQRT.PS
+"sqrt.%s<FMT> f<FD>, f<FS>"
+*sb1:
+{
+  int fmt = FMT;
+  check_fpu (SD_);
+  check_sbx (SD_, instruction_0);
+  StoreFPR (FD, fmt,  (SquareRoot (ValueFPR (FS, fmt), fmt)));
+}
Index: sim/brownie32/sim-main.c
===================================================================
RCS file: sim/brownie32/sim-main.c
diff -N sim/brownie32/sim-main.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/sim-main.c	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,647 @@
+/*  Copyright (C) 1998, Cygnus Solutions
+    Copyright (C) 2005,2006  Upwind technology, Inc.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+    */
+
+
+#ifndef SIM_MAIN_C
+#define SIM_MAIN_C
+
+
+#include "sim-main.h"
+#include "sim-assert.h"
+
+
+/*---------------------------------------------------------------------------*/
+/*-- simulator engine -------------------------------------------------------*/
+/*---------------------------------------------------------------------------*/
+
+
+/* Description from page A-22 of the "MIPS IV Instruction Set" manual
+   (revision 3.1) */
+/* Translate a virtual address to a physical address and cache
+   coherence algorithm describing the mechanism used to resolve the
+   memory reference. Given the virtual address vAddr, and whether the
+   reference is to Instructions ot Data (IorD), find the corresponding
+   physical address (pAddr) and the cache coherence algorithm (CCA)
+   used to resolve the reference. If the virtual address is in one of
+   the unmapped address spaces the physical address and the CCA are
+   determined directly by the virtual address. If the virtual address
+   is in one of the mapped address spaces then the TLB is used to
+   determine the physical address and access type; if the required
+   translation is not present in the TLB or the desired access is not
+   permitted the function fails and an exception is taken.
+
+   NOTE: Normally (RAW == 0), when address translation fails, this
+   function raises an exception and does not return. */
+
+INLINE_SIM_MAIN
+(int)
+address_translation (SIM_DESC sd,
+		     sim_cpu * cpu,
+		     address_word cia,
+		     address_word vAddr,
+		     int IorD,
+		     int LorS,
+		     address_word * pAddr,
+		     int *CCA,
+		     int raw)
+{
+  int res = -1;			/* TRUE : Assume good return */
+
+#ifdef DEBUG
+  sim_io_printf (sd, "AddressTranslation(0x%s,%s,%s,...);\n", pr_addr (vAddr), (IorD ? "isDATA" : "isINSTRUCTION"), (LorS ? "iSTORE" : "isLOAD"));
+#endif
+
+  /* Check that the address is valid for this memory model */
+
+  /* For a simple (flat) memory model, we simply pass virtual
+     addressess through (mostly) unchanged. */
+  vAddr &= 0xFFFFFFFF;
+
+  *pAddr = vAddr;		/* default for isTARGET */
+  *CCA = Uncached;		/* not used for isHOST */
+
+  return (res);
+}
+
+
+
+/* Description from page A-23 of the "MIPS IV Instruction Set" manual
+   (revision 3.1) */
+/* Prefetch data from memory. Prefetch is an advisory instruction for
+   which an implementation specific action is taken. The action taken
+   may increase performance, but must not change the meaning of the
+   program, or alter architecturally-visible state. */
+
+INLINE_SIM_MAIN (void)
+prefetch (SIM_DESC sd,
+	  sim_cpu *cpu,
+	  address_word cia,
+	  int CCA,
+	  address_word pAddr,
+	  address_word vAddr,
+	  int DATA,
+	  int hint)
+{
+#ifdef DEBUG
+  sim_io_printf(sd,"Prefetch(%d,0x%s,0x%s,%d,%d);\n",CCA,pr_addr(pAddr),pr_addr(vAddr),DATA,hint);
+#endif /* DEBUG */
+
+  /* For our simple memory model we do nothing */
+  return;
+}
+
+/* Description from page A-22 of the "MIPS IV Instruction Set" manual
+   (revision 3.1) */
+/* Load a value from memory. Use the cache and main memory as
+   specified in the Cache Coherence Algorithm (CCA) and the sort of
+   access (IorD) to find the contents of AccessLength memory bytes
+   starting at physical location pAddr. The data is returned in the
+   fixed width naturally-aligned memory element (MemElem). The
+   low-order two (or three) bits of the address and the AccessLength
+   indicate which of the bytes within MemElem needs to be given to the
+   processor. If the memory access type of the reference is uncached
+   then only the referenced bytes are read from memory and valid
+   within the memory element. If the access type is cached, and the
+   data is not present in cache, an implementation specific size and
+   alignment block of memory is read and loaded into the cache to
+   satisfy a load reference. At a minimum, the block is the entire
+   memory element. */
+
+struct {
+	unsigned int cnt;
+	struct {
+     unsigned int regno;     // [hWX^
+     unsigned int byte;      // TCY
+ 	 unsigned int eff;
+	 unsigned64   memval;    // f[^
+//	 unsigned int memval;    // f[^
+    }inf[2];
+} DelayLoad;
+INLINE_SIM_MAIN (void)
+delay_load_p (SIM_DESC SD, sim_cpu *CPU, unsigned int regno, unsigned64 memval,unsigned int byte, unsigned access )
+//delay_load_p (SIM_DESC SD, sim_cpu *CPU, unsigned int regno, unsigned int memval,unsigned int byte, unsigned access )
+{
+    if( access == AccessLength_BYTE )
+	    DelayLoad.inf[DelayLoad.cnt&0x01].memval = EXTEND8(memval);
+	else if( access == AccessLength_HALFWORD )
+	    DelayLoad.inf[DelayLoad.cnt&0x01].memval = EXTEND16(memval);
+	else if(access == AccessLength_WORD)
+	    DelayLoad.inf[DelayLoad.cnt&0x01].memval = EXTEND32(memval);
+	
+	DelayLoad.inf[DelayLoad.cnt&0x01].regno  = regno;
+	DelayLoad.inf[DelayLoad.cnt&0x01].byte   = byte;
+    DelayLoad.inf[DelayLoad.cnt&0x01].eff    = 1;
+//printf("## delay_load_p(DelayLoad.cnt=0x%x(%x) memval=0x%x regno=%d byte=%d access=%d\n",DelayLoad.cnt,DelayLoad.cnt&0x01,memval,regno,byte,access);
+//printf("#- load memval=0x%x\n",DelayLoad.inf[DelayLoad.cnt&0x01].memval);
+}
+
+INLINE_SIM_MAIN (unsigned int)
+delay_load_e (SIM_DESC SD, sim_cpu *CPU, unsigned int* regnop, unsigned64* memvalp,unsigned int* bytep )
+//delay_load_e (SIM_DESC SD, sim_cpu *CPU, unsigned int* regnop, unsigned int* memvalp,unsigned int* bytep )
+{
+    DelayLoad.cnt++;
+//printf("X- delay_load_e *regnop=%d *memvalp=0x%x *bytep=%d\n",*regnop,*memvalp,*bytep);
+//printf("## delay_load_e(DelayLoad.cnt=0x%x(%x) eff=%d\n",DelayLoad.cnt,DelayLoad.cnt&0x01,DelayLoad.inf[(DelayLoad.cnt&0x01)].eff);
+
+    if(DelayLoad.inf[(DelayLoad.cnt&0x01)].eff == 1)
+	{
+		*memvalp = DelayLoad.inf[(DelayLoad.cnt&0x01)].memval;
+	    *regnop  = DelayLoad.inf[(DelayLoad.cnt&0x01)].regno;
+	    *bytep   = DelayLoad.inf[(DelayLoad.cnt&0x01)].byte;
+        DelayLoad.inf[(DelayLoad.cnt&0x01)].eff = 0;
+//printf("## delay_load_e *regnop=%d *memvalp=0x%x *bytep=%d\n",*regnop,*memvalp,*bytep);
+        return 1;
+    }
+    else
+        return 0;
+}
+
+
+INLINE_SIM_MAIN (void)
+load_memory (SIM_DESC SD,
+	     sim_cpu *CPU,
+	     address_word cia,
+	     uword64* memvalp,
+	     uword64* memval1p,
+	     int CCA,
+	     unsigned int AccessLength,
+	     address_word pAddr,
+	     address_word vAddr,
+	     int IorD)
+{
+  uword64 value = 0;
+  uword64 value1 = 0;
+#ifdef DEBUG
+  sim_io_printf(SD,"DBG: LoadMemory(%p,%p,%d,%d,0x%s,0x%s,%s)\n",memvalp,memval1p,CCA,AccessLength,pr_addr(pAddr),pr_addr(vAddr),(IorD ? "isDATA" : "isINSTRUCTION"));
+#endif /* DEBUG */
+
+#if defined(WARN_MEM)
+  if (CCA != uncached)
+    sim_io_eprintf(SD,"LoadMemory CCA (%d) is not uncached (currently all accesses treated as cached)\n",CCA);
+#endif /* WARN_MEM */
+//                (n+3)+3                              3
+//#if 0 //Katano
+//  if (((pAddr & LOADDRMASK) + AccessLength) > LOADDRMASK)
+//    {
+//      /* In reality this should be a Bus Error */
+//      sim_io_error (SD, "#### LOAD AccessLength of %d would extend over %d bit aligned boundary for physical address 0x%s\n",
+//		    AccessLength,
+//		    (LOADDRMASK + 1) << 3,
+//		    pr_addr (pAddr));
+//    }
+//#endif
+#if defined(TRACE)
+  dotrace (SD, CPU, tracefh,((IorD == isDATA) ? 0 : 2),(unsigned int)(pAddr&0xFFFFFFFF),(AccessLength + 1),"load%s",((IorD == isDATA) ? "" : " instruction"));
+#endif /* TRACE */
+  
+  /* Read the specified number of bytes from memory.  Adjust for
+     host/target byte ordering/ Align the least significant byte
+     read. */
+
+  switch (AccessLength)
+    {
+    case AccessLength_QUADWORD:
+      {
+	unsigned_16 val = sim_core_read_aligned_16 (CPU, cia, read_map, pAddr);
+	value1 = VH8_16 (val);
+	value = VL8_16 (val);
+	break;
+      }
+    case AccessLength_DOUBLEWORD:
+      value = sim_core_read_aligned_8 (CPU, cia, read_map, pAddr);
+      break;
+    case AccessLength_SEPTIBYTE:
+      value = sim_core_read_misaligned_7 (CPU, cia, read_map, pAddr);
+      break;
+    case AccessLength_SEXTIBYTE:
+      value = sim_core_read_misaligned_6 (CPU, cia, read_map, pAddr);
+      break;
+    case AccessLength_QUINTIBYTE:
+      value = sim_core_read_misaligned_5 (CPU, cia, read_map, pAddr);
+      break;
+    case AccessLength_WORD:
+      value = sim_core_read_aligned_4 (CPU, cia, read_map, pAddr);
+
+      break;
+    case AccessLength_TRIPLEBYTE:
+      value = sim_core_read_misaligned_3 (CPU, cia, read_map, pAddr);
+      break;
+    case AccessLength_HALFWORD:
+      value = sim_core_read_aligned_2 (CPU, cia, read_map, pAddr);
+      break;
+    case AccessLength_BYTE:
+      value = sim_core_read_aligned_1 (CPU, cia, read_map, pAddr);
+      break;
+    default:
+      abort ();
+    }
+  
+#ifdef DEBUG
+  printf("DBG: LoadMemory() : (offset %d) : value = 0x%s%s\n",
+	 (int)(pAddr & LOADDRMASK),pr_uword64(value1),pr_uword64(value));
+#endif /* DEBUG */
+  
+  /* See also store_memory. Position data in correct byte lanes. */
+  if (AccessLength <= LOADDRMASK)
+    {
+      if (BigEndianMem)
+	/* for big endian target, byte (pAddr&LOADDRMASK == 0) is
+	   shifted to the most significant byte position.  */
+	value <<= (((LOADDRMASK - (pAddr & LOADDRMASK)) - AccessLength) * 8);
+      else
+	/* For little endian target, byte (pAddr&LOADDRMASK == 0)
+	   is already in the correct postition. */
+	value <<= ((pAddr & LOADDRMASK) * 8);
+    }
+  
+#ifdef DEBUG
+  printf("DBG: LoadMemory() : shifted value = 0x%s%s\n",
+	 pr_uword64(value1),pr_uword64(value));
+#endif /* DEBUG */
+  
+  *memvalp = value;
+  
+  if (memval1p) *memval1p = value1;
+
+#ifdef DEBUG
+  printf("DBG: LoadMemory() :memval=0x%x value=0x%x memval1p=0x%x value1=0x%x\n",memvalp,value,memval1p,value1);
+#endif
+}
+
+/* Description from page A-23 of the "MIPS IV Instruction Set" manual
+   (revision 3.1) */
+/* Store a value to memory. The specified data is stored into the
+   physical location pAddr using the memory hierarchy (data caches and
+   main memory) as specified by the Cache Coherence Algorithm
+   (CCA). The MemElem contains the data for an aligned, fixed-width
+   memory element (word for 32-bit processors, doubleword for 64-bit
+   processors), though only the bytes that will actually be stored to
+   memory need to be valid. The low-order two (or three) bits of pAddr
+   and the AccessLength field indicates which of the bytes within the
+   MemElem data should actually be stored; only these bytes in memory
+   will be changed. */
+
+INLINE_SIM_MAIN (void)
+store_memory (SIM_DESC SD,
+	      sim_cpu *CPU,
+	      address_word cia,
+	      int CCA,
+	      unsigned int AccessLength,
+	      uword64 MemElem,
+	      uword64 MemElem1,   /* High order 64 bits */
+	      address_word pAddr,
+	      address_word vAddr)
+{
+#ifdef DEBUG
+  sim_io_printf(sd,"DBG: StoreMemory(%d,%d,0x%s,0x%s,0x%s,0x%s)\n",CCA,AccessLength,pr_uword64(MemElem),pr_uword64(MemElem1),pr_addr(pAddr),pr_addr(vAddr));
+#endif /* DEBUG */
+  
+#if defined(WARN_MEM)
+  if (CCA != uncached)
+    sim_io_eprintf(sd,"StoreMemory CCA (%d) is not uncached (currently all accesses treated as cached)\n",CCA);
+#endif /* WARN_MEM */
+  
+  if (((pAddr & LOADDRMASK) + AccessLength) > LOADDRMASK)
+    sim_io_error (SD, "STORE AccessLength of %d would extend over %d bit aligned boundary for physical address 0x%s\n",
+		  AccessLength,
+		  (LOADDRMASK + 1) << 3,
+		  pr_addr(pAddr));
+  
+#if defined(TRACE)
+  dotrace (SD, CPU, tracefh,1,(unsigned int)(pAddr&0xFFFFFFFF),(AccessLength + 1),"store");
+#endif /* TRACE */
+  
+#ifdef DEBUG
+  printf("DBG: StoreMemory: offset = %d MemElem = 0x%s%s\n",(unsigned int)(pAddr & LOADDRMASK),pr_uword64(MemElem1),pr_uword64(MemElem));
+#endif /* DEBUG */
+  
+  /* See also load_memory. Position data in correct byte lanes. */
+  if (AccessLength <= LOADDRMASK)
+    {
+      if (BigEndianMem)
+	/* for big endian target, byte (pAddr&LOADDRMASK == 0) is
+	   shifted to the most significant byte position.  */
+	MemElem >>= (((LOADDRMASK - (pAddr & LOADDRMASK)) - AccessLength) * 8);
+      else
+	/* For little endian target, byte (pAddr&LOADDRMASK == 0)
+	   is already in the correct postition. */
+	MemElem >>= ((pAddr & LOADDRMASK) * 8);
+    }
+  
+#ifdef DEBUG
+  printf("DBG: StoreMemory: shift = %d MemElem = 0x%s%s\n",shift,pr_uword64(MemElem1),pr_uword64(MemElem));
+#endif /* DEBUG */
+  
+  switch (AccessLength)
+    {
+    case AccessLength_QUADWORD:
+      {
+	unsigned_16 val = U16_8 (MemElem1, MemElem);
+	sim_core_write_aligned_16 (CPU, cia, write_map, pAddr, val);
+	break;
+      }
+    case AccessLength_DOUBLEWORD:
+      sim_core_write_aligned_8 (CPU, cia, write_map, pAddr, MemElem);
+      break;
+    case AccessLength_SEPTIBYTE:
+      sim_core_write_misaligned_7 (CPU, cia, write_map, pAddr, MemElem);
+      break;
+    case AccessLength_SEXTIBYTE:
+      sim_core_write_misaligned_6 (CPU, cia, write_map, pAddr, MemElem);
+      break;
+    case AccessLength_QUINTIBYTE:
+      sim_core_write_misaligned_5 (CPU, cia, write_map, pAddr, MemElem);
+      break;
+    case AccessLength_WORD:
+      sim_core_write_aligned_4 (CPU, cia, write_map, pAddr, MemElem);
+      break;
+    case AccessLength_TRIPLEBYTE:
+      sim_core_write_misaligned_3 (CPU, cia, write_map, pAddr, MemElem);
+      break;
+    case AccessLength_HALFWORD:
+      sim_core_write_aligned_2 (CPU, cia, write_map, pAddr, MemElem);
+      break;
+    case AccessLength_BYTE:
+      sim_core_write_aligned_1 (CPU, cia, write_map, pAddr, MemElem);
+      break;
+    default:
+      abort ();
+    }	
+  
+  return;
+}
+
+
+INLINE_SIM_MAIN (unsigned32)
+ifetch32 (SIM_DESC SD,
+	  sim_cpu *CPU,
+	  address_word cia,
+	  address_word vaddr)
+{
+  /* Copy the action of the LW instruction */
+  address_word mask = LOADDRMASK;
+  address_word access = AccessLength_WORD;
+//#if 0 // C.Katano
+//  address_word reverseendian = (ReverseEndian ? (mask ^ access) : 0);
+  address_word bigendiancpu = (1 ? (mask ^ access) : 0);
+//#else
+  address_word reverseendian = 0;
+//  address_word bigendiancpu = 1;
+//#endif
+  unsigned int byte;
+  address_word paddr;
+  int uncached;
+  unsigned64 memval;
+
+#if 1
+   if(cia > (0x20000000-1))
+   {
+         sim_engine_halt (SD, CPU, NULL, NULL_CIA, sim_exited,
+                  (unsigned int)(0xFFFFFFFF));
+   }
+#endif
+     if ((vaddr & access) != 0)
+  {
+#if 0
+//    SignalExceptionInstructionFetch ();
+#endif
+  }
+  AddressTranslation (vaddr, isINSTRUCTION, isLOAD, &paddr, &uncached, isTARGET, isREAL);
+  paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
+  LoadMemory (&memval, NULL, uncached, access, paddr, vaddr, isINSTRUCTION, isREAL);
+  byte = ((vaddr & mask) ^ bigendiancpu);
+//  return (memval >> (8 * byte));
+  return (memval);
+}
+
+#if 0  // Delete C.Katano
+INLINE_SIM_MAIN (unsigned16)
+ifetch16 (SIM_DESC SD,
+	  sim_cpu *CPU,
+	  address_word cia,
+	  address_word vaddr)
+{
+  /* Copy the action of the LH instruction */
+  address_word mask = LOADDRMASK;
+  address_word access = AccessLength_HALFWORD;
+  address_word reverseendian = (ReverseEndian ? (mask ^ access) : 0);
+  address_word bigendiancpu = (BigEndianCPU ? (mask ^ access) : 0);
+  unsigned int byte;
+  address_word paddr;
+  int uncached;
+  unsigned64 memval;
+
+  if ((vaddr & access) != 0)
+  {
+    SignalExceptionInstructionFetch ();
+  }
+  AddressTranslation (vaddr, isINSTRUCTION, isLOAD, &paddr, &uncached, isTARGET, isREAL);
+  paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
+  LoadMemory (&memval, NULL, uncached, access, paddr, vaddr, isINSTRUCTION, isREAL);
+  byte = ((vaddr & mask) ^ bigendiancpu);
+  return (memval >> (8 * byte));
+}
+#endif
+
+
+/* Description from page A-26 of the "MIPS IV Instruction Set" manual (revision 3.1) */
+/* Order loads and stores to synchronise shared memory. Perform the
+   action necessary to make the effects of groups of synchronizable
+   loads and stores indicated by stype occur in the same order for all
+   processors. */
+INLINE_SIM_MAIN (void)
+sync_operation (SIM_DESC sd,
+		sim_cpu *cpu,
+		address_word cia,
+		int stype)
+{
+#ifdef DEBUG
+  sim_io_printf(sd,"SyncOperation(%d) : TODO\n",stype);
+#endif /* DEBUG */
+  return;
+}
+
+INLINE_SIM_MAIN (void)
+cache_op (SIM_DESC SD,
+	  sim_cpu *CPU,
+	  address_word cia,
+	  int op,
+	  address_word pAddr,
+	  address_word vAddr,
+	  unsigned int instruction)
+{
+#if 0
+//#if 1 /* stop warning message being displayed (we should really just remove the code) */
+//  static int icache_warning = 1;
+//  static int dcache_warning = 1;
+//#else
+//  static int icache_warning = 0;
+//  static int dcache_warning = 0;
+//#endif
+//
+//  /* If CP0 is not useable (User or Supervisor mode) and the CP0
+//     enable bit in the Status Register is clear - a coprocessor
+//     unusable exception is taken. */
+//#if 0
+//  sim_io_printf(SD,"TODO: Cache availability checking (PC = 0x%s)\n",pr_addr(cia));
+//#endif
+//
+//  switch (op & 0x3) {
+//    case 0: /* instruction cache */
+//      switch (op >> 2) {
+//        case 0: /* Index Invalidate */
+//        case 1: /* Index Load Tag */
+//        case 2: /* Index Store Tag */
+//        case 4: /* Hit Invalidate */
+//        case 5: /* Fill */
+//        case 6: /* Hit Writeback */
+//          if (!icache_warning)
+//            {
+//              sim_io_eprintf(SD,"Instruction CACHE operation %d to be coded\n",(op >> 2));
+//              icache_warning = 1;
+//            }
+//          break;
+//
+//        default:
+//printf("[[[[[[[[[[[[[[[[[[[singlestep %s(%d)\n",__FILE__,__LINE__);
+//          SignalException(ReservedInstruction,instruction);
+//          break;
+//      }
+//      break;
+//
+//    case 1: /* data cache */
+//    case 3: /* secondary data cache */
+//      switch (op >> 2) {
+//        case 0: /* Index Writeback Invalidate */
+//        case 1: /* Index Load Tag */
+//        case 2: /* Index Store Tag */
+//        case 3: /* Create Dirty */
+//        case 4: /* Hit Invalidate */
+//        case 5: /* Hit Writeback Invalidate */
+//        case 6: /* Hit Writeback */ 
+//          if (!dcache_warning)
+//            {
+//              sim_io_eprintf(SD,"Data CACHE operation %d to be coded\n",(op >> 2));
+//              dcache_warning = 1;
+//            }
+//          break;
+//
+//        default:
+//printf("[[[[[[[[[[[[[[[[[[[singlestep %s(%d)\n",__FILE__,__LINE__);
+//          SignalException(ReservedInstruction,instruction);
+//          break;
+//      }
+//      break;
+//
+//    default: /* unrecognised cache ID */
+//printf("[[[[[[[[[[[[[[[[[[[singlestep %s(%d)\n",__FILE__,__LINE__);
+//      SignalException(ReservedInstruction,instruction);
+//      break;
+//  }
+#endif
+  return;
+}
+
+
+INLINE_SIM_MAIN (void)
+pending_tick (SIM_DESC SD,
+	      sim_cpu *CPU,
+	      address_word cia)
+{
+  if (PENDING_TRACE)							
+    sim_io_eprintf (SD, "PENDING_DRAIN - 0x%lx - pending_in = %d, pending_out = %d, pending_total = %d\n", (unsigned long) cia, PENDING_IN, PENDING_OUT, PENDING_TOTAL); 
+  if (PENDING_OUT != PENDING_IN)					
+    {									
+      int loop;							
+      int index = PENDING_OUT;					
+      int total = PENDING_TOTAL;					
+      if (PENDING_TOTAL == 0)						
+      {
+	sim_engine_abort (SD, CPU, cia, "PENDING_DRAIN - Mis-match on pending update pointers\n"); 
+      }
+      for (loop = 0, index = PENDING_OUT;
+	   (loop < total);
+	   loop++, index = (index + 1) % PSLOTS)
+	{								
+	  if (PENDING_SLOT_DEST[index] != NULL)			
+	    {								
+	      PENDING_SLOT_DELAY[index] -= 1;				
+	      if (PENDING_SLOT_DELAY[index] == 0)			
+		{							
+		  if (PENDING_TRACE)
+		    sim_io_eprintf (SD, "PENDING_DRAIN - drained - index %d, dest 0x%lx, bit %d, val 0x%lx, size %d\n",
+				    index,
+				    (unsigned long) PENDING_SLOT_DEST[index],
+				    PENDING_SLOT_BIT[index],
+				    (unsigned long) PENDING_SLOT_VALUE[index],
+				    PENDING_SLOT_SIZE[index]);
+		  if (PENDING_SLOT_BIT[index] >= 0)			
+		    switch (PENDING_SLOT_SIZE[index])                 
+		      {						
+		      case 4:
+			if (PENDING_SLOT_VALUE[index])		
+			  *(unsigned32*)PENDING_SLOT_DEST[index] |= 	
+			    BIT32 (PENDING_SLOT_BIT[index]);		
+			else						
+			  *(unsigned32*)PENDING_SLOT_DEST[index] &= 	
+			    BIT32 (PENDING_SLOT_BIT[index]);		
+			break;					
+		      case 8:					
+			if (PENDING_SLOT_VALUE[index])		
+			  *(unsigned64*)PENDING_SLOT_DEST[index] |= 	
+			    BIT64 (PENDING_SLOT_BIT[index]);		
+			else						
+			  *(unsigned64*)PENDING_SLOT_DEST[index] &= 	
+			    BIT64 (PENDING_SLOT_BIT[index]);		
+			break;					
+		      }
+		  else
+		    switch (PENDING_SLOT_SIZE[index])                 
+		      {						
+		      case 4:					
+			*(unsigned32*)PENDING_SLOT_DEST[index] = 	
+			  PENDING_SLOT_VALUE[index];			
+			break;					
+		      case 8:					
+			*(unsigned64*)PENDING_SLOT_DEST[index] = 	
+			  PENDING_SLOT_VALUE[index];			
+			break;					
+		      }							
+		  if (PENDING_OUT == index)
+		    {
+		      PENDING_SLOT_DEST[index] = NULL;
+		      PENDING_OUT = (PENDING_OUT + 1) % PSLOTS;
+		      PENDING_TOTAL--;
+		    }
+		}							
+	      else if (PENDING_TRACE && PENDING_SLOT_DELAY[index] > 0)
+		sim_io_eprintf (SD, "PENDING_DRAIN - queued - index %d, delay %d, dest 0x%lx, bit %d, val 0x%lx, size %d\n",
+				index, PENDING_SLOT_DELAY[index],
+				(unsigned long) PENDING_SLOT_DEST[index],
+				PENDING_SLOT_BIT[index],
+				(unsigned long) PENDING_SLOT_VALUE[index],
+				PENDING_SLOT_SIZE[index]);
+
+	    }								
+	}								
+    }									
+}
+
+
+#endif
Index: sim/brownie32/sim-main.h
===================================================================
RCS file: sim/brownie32/sim-main.h
diff -N sim/brownie32/sim-main.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/sim-main.h	11 Feb 2008 15:48:10 -0000	1.4
@@ -0,0 +1,1033 @@
+/* Brownie32 Simulator definition.
+   Copyright (C) 1997, 1998, 2003 Free Software Foundation, Inc.
+   Contributed by Cygnus Support.
+
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
+This file is part of GDB, the GNU debugger.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#ifndef SIM_MAIN_H
+#define SIM_MAIN_H
+
+
+/* This simulator doesn't cache the Current Instruction Address */
+/* #define SIM_ENGINE_HALT_HOOK(SD, LAST_CPU, CIA) */
+/* #define SIM_ENGINE_RESUME_HOOK(SD, LAST_CPU, CIA) */
+
+#define SIM_HAVE_BIENDIAN
+
+
+/* hobble some common features for moment */
+#define WITH_WATCHPOINTS 1
+#define WITH_MODULO_MEMORY 1
+
+
+#define SIM_CORE_SIGNAL(SD,CPU,CIA,MAP,NR_BYTES,ADDR,TRANSFER,ERROR) \
+brownie32_core_signal ((SD), (CPU), (CIA), (MAP), (NR_BYTES), (ADDR), (TRANSFER), (ERROR))
+
+#include "sim-basics.h"
+
+typedef address_word sim_cia;
+
+#include "sim-base.h"
+#include "bfd.h"
+
+/* Deprecated macros and types for manipulating 64bit values.  Use
+   ../common/sim-bits.h and ../common/sim-endian.h macros instead. */
+
+typedef signed64 word64;
+typedef unsigned64 uword64;
+
+#define WORD64LO(t)     (unsigned int)((t)&0xFFFFFFFF)
+#define WORD64HI(t)     (unsigned int)(((uword64)(t))>>32)
+#define SET64LO(t)      (((uword64)(t))&0xFFFFFFFF)
+#define SET64HI(t)	(((uword64)(t))<<32)
+#define WORD64(h,l)     ((word64)((SET64HI(h)|SET64LO(l))))
+#define UWORD64(h,l)     (SET64HI(h)|SET64LO(l))
+
+/* Check if a value will fit within a halfword: */
+#define NOTHALFWORDVALUE(v) ((((((uword64)(v)>>16) == 0) && !((v) & ((unsigned)1 << 15))) || (((((uword64)(v)>>32) == 0xFFFFFFFF) && ((((uword64)(v)>>16) & 0xFFFF) == 0xFFFF)) && ((v) & ((unsigned)1 << 15)))) ? (1 == 0) : (1 == 1))
+
+
+//#if 0 // C.Katano
+/* Floating-point operations: */
+//
+//#include "sim-fpu.h"
+//#include "cp1.h"
+//
+///* FPU registers must be one of the following types. All other values
+//   are reserved (and undefined). */
+//typedef enum {
+// fmt_single  = 0,
+// fmt_double  = 1,
+// fmt_word    = 4,
+// fmt_long    = 5,
+// fmt_ps      = 6,
+// /* The following are well outside the normal acceptable format
+//    range, and are used in the register status vector. */
+// fmt_unknown       = 0x10000000,
+// fmt_uninterpreted = 0x20000000,
+// fmt_uninterpreted_32 = 0x40000000,
+// fmt_uninterpreted_64 = 0x80000000U,
+//} FP_formats;
+//
+///* For paired word (pw) operations, the opcode representation is fmt_word,
+//   but register transfers (StoreFPR, ValueFPR, etc.) are done as fmt_long.  */
+//#define fmt_pw fmt_long
+//#endif
+/* This should be the COC1 value at the start of the preceding
+   instruction: */
+#define PREVCOC1() ((STATE & simPCOC1) ? 1 : 0)
+
+#ifdef TARGET_ENABLE_FR
+/* FIXME: this should be enabled for all targets, but needs testing first. */
+#define SizeFGR() (((WITH_TARGET_FLOATING_POINT_BITSIZE) == 64) \
+   ? ((SR & status_FR) ? 64 : 32) \
+   : (WITH_TARGET_FLOATING_POINT_BITSIZE))
+#else
+#define SizeFGR() (WITH_TARGET_FLOATING_POINT_BITSIZE)
+#endif
+
+
+
+
+
+/* HI/LO register accesses */
+
+/* For some MIPS targets, the HI/LO registers have certain timing
+   restrictions in that, for instance, a read of a HI register must be
+   separated by at least three instructions from a preceeding read.
+
+   The struct below is used to record the last access by each of A MT,
+   MF or other OP instruction to a HI/LO register.  See mips.igen for
+   more details. */
+//#if 0
+//typedef struct _hilo_access {
+//  signed64 timestamp;
+//  address_word cia;
+//} hilo_access;
+//
+//typedef struct _hilo_history {
+//  hilo_access mt;
+//  hilo_access mf;
+//  hilo_access op;
+//} hilo_history;
+//#endif
+
+
+
+/* Integer ALU operations: */
+
+#include "sim-alu.h"
+#if 0
+//#define ALU32_END(ANS) 
+//  if (ALU32_HAD_OVERFLOW) 
+//    SignalExceptionIntegerOverflow (); 
+//  (ANS) = (signed32) ALU32_OVERFLOW_RESULT
+#else
+#define ALU32_END(ANS) \
+    SR=0; \
+    if(ALU32_HAD_OVERFLOW) \
+        SR |= status_OVF; \
+    if(ALU32_HAD_CARRY_BORROW) \
+        SR |= status_CARY; \
+    if( ALU32_OVERFLOW_RESULT == 0 ) \
+        SR |= status_ZERO; \
+    if( ALU32_OVERFLOW_RESULT & 0x80000000 ) \
+        SR |= status_MSB; \
+  (ANS) = (signed32) ALU32_OVERFLOW_RESULT
+#endif
+
+#define ALU64_END(ANS) \
+  if (ALU64_HAD_OVERFLOW) \
+    SignalExceptionIntegerOverflow (); \
+  (ANS) = ALU64_OVERFLOW_RESULT;
+
+
+
+
+
+/* The following is probably not used for MIPS IV onwards: */
+/* Slots for delayed register updates. For the moment we just have a
+   fixed number of slots (rather than a more generic, dynamic
+   system). This keeps the simulator fast. However, we only allow
+   for the register update to be delayed for a single instruction
+   cycle. */
+#define PSLOTS (8) /* Maximum number of instruction cycles */
+
+typedef struct _pending_write_queue {
+  int in;
+  int out;
+  int total;
+  int slot_delay[PSLOTS];
+  int slot_size[PSLOTS];
+  int slot_bit[PSLOTS];
+  void *slot_dest[PSLOTS];
+  unsigned64 slot_value[PSLOTS];
+} pending_write_queue;
+
+#ifndef PENDING_TRACE
+#define PENDING_TRACE 0
+#endif
+#define PENDING_IN ((CPU)->pending.in)
+#define PENDING_OUT ((CPU)->pending.out)
+#define PENDING_TOTAL ((CPU)->pending.total)
+#define PENDING_SLOT_SIZE ((CPU)->pending.slot_size)
+#define PENDING_SLOT_BIT ((CPU)->pending.slot_bit)
+#define PENDING_SLOT_DELAY ((CPU)->pending.slot_delay)
+#define PENDING_SLOT_DEST ((CPU)->pending.slot_dest)
+#define PENDING_SLOT_VALUE ((CPU)->pending.slot_value)
+
+/* Invalidate the pending write queue, all pending writes are
+   discarded. */
+
+#define PENDING_INVALIDATE() \
+memset (&(CPU)->pending, 0, sizeof ((CPU)->pending))
+
+/* Schedule a write to DEST for N cycles time.  For 64 bit
+   destinations, schedule two writes.  For floating point registers,
+   the caller should schedule a write to both the dest register and
+   the FPR_STATE register.  When BIT is non-negative, only BIT of DEST
+   is updated. */
+
+#define PENDING_SCHED(DEST,VAL,DELAY,BIT)				\
+  do {									\
+    if (PENDING_SLOT_DEST[PENDING_IN] != NULL)				\
+    {                                                                   \
+      sim_engine_abort (SD, CPU, cia,					\
+		        "PENDING_SCHED - buffer overflow\n");		\
+    }									\
+    if (PENDING_TRACE)							\
+      sim_io_eprintf (SD, "PENDING_SCHED - 0x%lx - dest 0x%lx, val 0x%lx, bit %d, size %d, pending_in %d, pending_out %d, pending_total %d\n",			\
+		      (unsigned long) cia, (unsigned long) &(DEST),	\
+		      (unsigned long) (VAL), (BIT), (int) sizeof (DEST),\
+		      PENDING_IN, PENDING_OUT, PENDING_TOTAL);		\
+    PENDING_SLOT_DELAY[PENDING_IN] = (DELAY) + 1;			\
+    PENDING_SLOT_DEST[PENDING_IN] = &(DEST);				\
+    PENDING_SLOT_VALUE[PENDING_IN] = (VAL);				\
+    PENDING_SLOT_SIZE[PENDING_IN] = sizeof (DEST);			\
+    PENDING_SLOT_BIT[PENDING_IN] = (BIT);				\
+    PENDING_IN = (PENDING_IN + 1) % PSLOTS;                             \
+    PENDING_TOTAL += 1;			                                \
+  } while (0)
+
+#define PENDING_WRITE(DEST,VAL,DELAY) PENDING_SCHED(DEST,VAL,DELAY,-1)
+#define PENDING_BIT(DEST,VAL,DELAY,BIT) PENDING_SCHED(DEST,VAL,DELAY,BIT)
+
+#define PENDING_TICK() pending_tick (SD, CPU, cia)
+
+#define PENDING_FLUSH() abort () /* think about this one */
+#define PENDING_FP() abort () /* think about this one */
+
+/* For backward compatibility */
+#define PENDING_FILL(R,VAL) 						\
+do {									\
+  if ((R) >= FGR_BASE && (R) < FGR_BASE + NR_FGR)			\
+    {									\
+      PENDING_SCHED(FGR[(R) - FGR_BASE], VAL, 1, -1);			\
+      PENDING_SCHED(FPR_STATE[(R) - FGR_BASE], fmt_uninterpreted, 1, -1); \
+    }									\
+  else									\
+    PENDING_SCHED(GPR[(R)], VAL, 1, -1);				\
+} while (0)
+
+
+enum float_operation
+  {
+    FLOP_ADD,    FLOP_SUB,    FLOP_MUL,    FLOP_MADD,
+    FLOP_MSUB,   FLOP_MAX=10, FLOP_MIN,    FLOP_ABS,
+    FLOP_ITOF0=14, FLOP_FTOI0=18, FLOP_NEG=23
+  };
+
+
+/* The internal representation of an MDMX accumulator. 
+   Note that 24 and 48 bit accumulator elements are represented in
+   32 or 64 bits.  Since the accumulators are 2's complement with
+   overflow suppressed, high-order bits can be ignored in most contexts.  */
+
+typedef signed32 signed24;
+typedef signed64 signed48;
+//#if 0
+//typedef union { 
+//  signed24  ob[8];
+//  signed48  qh[4]; 
+//} MDMX_accumulator;
+//#endif
+
+/* Conventional system arguments.  */ 
+#define SIM_STATE  sim_cpu *cpu, address_word cia
+#define SIM_ARGS   CPU, cia
+
+struct _sim_cpu {
+
+
+  /* The following are internal simulator state variables: */
+#define CIA_GET(CPU) ((CPU)->registers[PCIDX] + 0)
+#define CIA_SET(CPU,CIA) ((CPU)->registers[PCIDX] = (CIA))
+  address_word dspc;  /* delay-slot PC */
+#define DSPC ((CPU)->dspc)
+
+#define DELAY_SLOT(TARGET) NIA = delayslot32 (SD_, (TARGET))
+#define NULLIFY_NEXT_INSTRUCTION() NIA = nullify_next_insn32 (SD_)
+
+
+  /* State of the simulator */
+  unsigned int state;
+  unsigned int dsstate;
+#define STATE ((CPU)->state)
+#define DSSTATE ((CPU)->dsstate)
+
+/* Flags in the "state" variable: */
+#define simHALTEX       (1 << 2)  /* 0 = run; 1 = halt on exception */
+#define simHALTIN       (1 << 3)  /* 0 = run; 1 = halt on interrupt */
+#define simTRACE        (1 << 8)  /* 0 = do nothing; 1 = trace address activity */
+#define simPCOC0        (1 << 17) /* COC[1] from current */
+#define simPCOC1        (1 << 18) /* COC[1] from previous */
+#define simDELAYSLOT    (1 << 24) /* 0 = do nothing; 1 = delay slot entry exists */
+#define simSKIPNEXT     (1 << 25) /* 0 = do nothing; 1 = skip instruction */
+#define simSIGINT	(1 << 28)  /* 0 = do nothing; 1 = SIGINT has occured */
+#define simJALDELAYSLOT	(1 << 29) /* 1 = in jal delay slot */
+
+#ifndef ENGINE_ISSUE_PREFIX_HOOK
+#define ENGINE_ISSUE_PREFIX_HOOK() \
+  { \
+    /* Perform any pending writes */ \
+    PENDING_TICK(); \
+    /* Set previous flag, depending on current: */ \
+    if (STATE & simPCOC0) \
+     STATE |= simPCOC1; \
+    else \
+     STATE &= ~simPCOC1; \
+    /* and update the current value: */ \
+  }
+#endif /* ENGINE_ISSUE_PREFIX_HOOK */
+
+/* This is nasty, since we have to rely on matching the register
+   numbers used by GDB. Unfortunately, depending on the MIPS target
+   GDB uses different register numbers. We cannot just include the
+   relevant "gdb/tm.h" link, since GDB may not be configured before
+   the sim world, and also the GDB header file requires too much other
+   state. */
+
+#ifndef TM_BROWNIE32_H
+#define LAST_EMBED_REGNUM (39) //(32)
+#define NUM_REGS (LAST_EMBED_REGNUM + 1)
+
+//#if 0   //C.Katano
+//#define FP0_REGNUM 38           /* Floating point register 0 (single float) */
+//#define FCRCS_REGNUM 70         /* FP control/status */
+//#define FCRIR_REGNUM 71         /* FP implementation/revision */
+//#endif
+#endif
+
+
+/* To keep this default simulator simple, and fast, we use a direct
+   vector of registers. The internal simulator engine then uses
+   manifests to access the correct slot. */
+
+  unsigned_word registers[LAST_EMBED_REGNUM + 1];
+
+  int register_widths[NUM_REGS];
+#define REGISTERS       ((CPU)->registers)
+
+#define GPR     (&REGISTERS[0])
+#define GPR_SET(N,VAL) (REGISTERS[(N)] = (VAL))
+//#if 0  // Katano
+//#define LO      (REGISTERS[33])
+//#define HI      (REGISTERS[34])
+//#define PCIDX	33
+//#define PC      (REGISTERS[PCIDX])
+//#define CAUSE   (REGISTERS[36])
+//#endif
+#define SRIDX   (1)
+#define SR      (REGISTERS[SRIDX])      /* CPU status register */
+#define PCIDX	32
+#define PC      (REGISTERS[PCIDX])
+
+#if 0 //Katano
+//#define FCR0IDX  (71)
+//#define FCR0    (REGISTERS[FCR0IDX])    /* really a 32bit register */
+//#define FCR31IDX (70)
+//#define FCR31   (REGISTERS[FCR31IDX])   /* really a 32bit register */
+//#define FCSR    (FCR31)
+
+//#define Debug	(REGISTERS[36])
+//#define DEPC	(REGISTERS[37])
+//#define EPC	(REGISTERS[38])
+#endif
+#define EPC	(REGISTERS[2])
+  /* All internal state modified by signal_exception() that may need to be
+     rolled back for passing moment-of-exception image back to gdb. */
+  unsigned_word exc_trigger_registers[LAST_EMBED_REGNUM + 1];
+  unsigned_word exc_suspend_registers[LAST_EMBED_REGNUM + 1];
+  int exc_suspended;
+
+#define SIM_CPU_EXCEPTION_TRIGGER(SD,CPU,CIA) brownie32_cpu_exception_trigger(SD,CPU,CIA)
+#define SIM_CPU_EXCEPTION_SUSPEND(SD,CPU,EXC) brownie32_cpu_exception_suspend(SD,CPU,EXC)
+#define SIM_CPU_EXCEPTION_RESUME(SD,CPU,EXC) brownie32_cpu_exception_resume(SD,CPU,EXC)
+
+  unsigned_word c0_config_reg;
+#define C0_CONFIG ((CPU)->c0_config_reg)
+
+/* The following are pseudonyms for standard registers */
+//#if 0
+//#define ZERO    (REGISTERS[0])
+//#define V0      (REGISTERS[2])
+//#define A0      (REGISTERS[4])
+//#define A1      (REGISTERS[5])
+//#define A2      (REGISTERS[6])
+//#define A3      (REGISTERS[7])
+//#define T8IDX   24
+//#define T8	(REGISTERS[T8IDX])
+//#define SPIDX   29
+//#define SP      (REGISTERS[SPIDX])
+//#define RAIDX   31
+//#define RA      (REGISTERS[RAIDX])
+//#else
+#define ZERO    (REGISTERS[0])
+#define IRR     (REGISTERS[2])
+#define LNK     (REGISTERS[3])
+//#define RET     (REGISTERS[4])
+//#define FRM     (REGISTERS[5])
+//#define SPIDX   6
+//#define SP      (REGISTERS[SPIDX])
+//#define FIRST_ARG_IDX 7
+#define FRM     (REGISTERS[4])
+#define SPIDX   5
+#define SP      (REGISTERS[SPIDX])
+#define RET     (REGISTERS[6])
+#define FIRST_ARG_IDX 8
+//#endif
+  /* While space is allocated in the main registers arrray for some of
+     the COP0 registers, that space isn't sufficient.  Unknown COP0
+     registers overflow into the array below */
+//#if 0
+//#define NR_COP0_GPR	32
+//  unsigned_word cop0_gpr[NR_COP0_GPR];
+//#define COP0_GPR	((CPU)->cop0_gpr)
+//#define COP0_BADVADDR	(COP0_GPR[8])
+//#endif
+  /* While space is allocated for the floating point registers in the
+     main registers array, they are stored separatly.  This is because
+     their size may not necessarily match the size of either the
+     general-purpose or system specific registers.  */
+//#if 0
+//#define NR_FGR    (32)
+//#define FGR_BASE  FP0_REGNUM
+//  fp_word fgr[NR_FGR];
+//#define FGR       ((CPU)->fgr)
+//#endif
+  /* Keep the current format state for each register: */
+//#if 0
+//  FP_formats fpr_state[32];
+//#define FPR_STATE ((CPU)->fpr_state)
+//#endif
+
+  pending_write_queue pending;
+  /* The MDMX accumulator (used only for MDMX ASE).  */
+//#if 0
+//  MDMX_accumulator acc; 
+//#define ACC             ((CPU)->acc)
+//#endif
+  /* LLBIT = Load-Linked bit. A bit of "virtual" state used by atomic
+     read-write instructions. It is set when a linked load occurs. It
+     is tested and cleared by the conditional store. It is cleared
+     (during other CPU operations) when a store to the location would
+     no longer be atomic. In particular, it is cleared by exception
+     return instructions. */
+//#if 0
+//  int llbit;
+//#define LLBIT ((CPU)->llbit)
+//#endif
+
+/* The HIHISTORY and LOHISTORY timestamps are used to ensure that
+   corruptions caused by using the HI or LO register too close to a
+   following operation is spotted. See mips.igen for more details. */
+//#if 0
+//  hilo_history hi_history;
+//#define HIHISTORY (&(CPU)->hi_history)
+//  hilo_history lo_history;
+//#define LOHISTORY (&(CPU)->lo_history)
+//#endif
+
+  sim_cpu_base base;
+};
+
+
+/* MIPS specific simulator watch config */
+
+void watch_options_install PARAMS ((SIM_DESC sd));
+
+struct swatch {
+  sim_event *pc;
+  sim_event *clock;
+  sim_event *cycles;
+};
+
+
+/* FIXME: At present much of the simulator is still static */
+struct sim_state {
+
+  struct swatch watch;
+
+  sim_cpu cpu[MAX_NR_PROCESSORS];
+#if (WITH_SMP)
+#define STATE_CPU(sd,n) (&(sd)->cpu[n])
+#else
+#define STATE_CPU(sd,n) (&(sd)->cpu[0])
+#endif
+
+
+  sim_state_base base;
+};
+
+
+
+/* Status information: */
+
+/* TODO : these should be the bitmasks for these bits within the
+   status register. At the moment the following are VR4300
+   bit-positions: */
+//#if 1 // Modified C.Katano
+#define status_KSU_mask  (0x40)         /* mask for KSU bits */
+#define status_KSU_shift (5)            /* shift for field */
+#define ksu_kernel       (0x0)
+#define ksu_supervisor   (0x1)
+#define ksu_user         (0x2)
+#define ksu_unknown      (0x3)
+//#else
+//#define status_KSU_mask  (0x18)         /* mask for KSU bits */
+//#define status_KSU_shift (3)            /* shift for field */
+//#define ksu_kernel       (0x0)
+//#define ksu_supervisor   (0x1)
+//#define ksu_user         (0x2)
+//#define ksu_unknown      (0x3)
+//#endif
+#define SR_KSU		 ((SR & status_KSU_mask) >> status_KSU_shift)
+
+//#if 1   // C.Katano
+#define status_IEN	 (1 <<  5)      /* Internal Interrupt enable */
+#define status_EIEN	 (1 <<  4)      /* External Interrupt enable */
+#define status_CARY	 (1 <<  3)	/* Carry */
+#define status_ZERO	 (1 <<  2)	/* Zero  */
+#define status_MSB	 (1 <<  1)	/* MSB   */
+#define status_OVF	 (1 <<  0)	/* Overflow */
+//#define status_KENL      (1 <<  6)      /* Kernel/User mode */
+//#else
+//#define status_IE	 (1 <<  0)      /* Interrupt enable */
+//#define status_EIE	 (1 << 16)      /* Enable Interrupt Enable */
+//#define status_EXL	 (1 <<  1)	/* Exception level */
+//#define status_RE        (1 << 25)      /* Reverse Endian in user mode */
+//#define status_FR        (1 << 26)      /* enables MIPS III additional FP registers */
+//#define status_SR        (1 << 20)      /* soft reset or NMI */
+//#define status_BEV       (1 << 22)      /* Location of general exception vectors */
+//#define status_TS        (1 << 21)      /* TLB shutdown has occurred */
+//#define status_ERL       (1 <<  2)      /* Error level */
+//#define status_IM7       (1 << 15)      /* Timer Interrupt Mask */
+//#define status_RP        (1 << 27)      /* Reduced Power mode */
+
+
+/* Specializations for TX39 family */
+//#define status_IEc       (1 << 0)       /* Interrupt enable (current) */
+//#define status_KUc       (1 << 1)       /* Kernel/User mode */
+//#define status_IEp       (1 << 2)       /* Interrupt enable (previous) */
+//#define status_KUp       (1 << 3)       /* Kernel/User mode */
+//#define status_IEo       (1 << 4)       /* Interrupt enable (old) */
+//#define status_KUo       (1 << 5)       /* Kernel/User mode */
+//#define status_IM_mask   (0xff)         /* Interrupt mask */
+//#define status_IM_shift  (8)
+//#define status_NMI       (1 << 20)      /* NMI */
+//#define status_NMI       (1 << 20)      /* NMI */
+
+/* Status bits used by MIPS32/MIPS64.  */
+//#define status_UX        (1 <<  5)      /* 64-bit user addrs */
+//#define status_SX        (1 <<  6)      /* 64-bit supervisor addrs */
+//#define status_KX        (1 <<  7)      /* 64-bit kernel addrs */
+//#define status_TS        (1 << 21)      /* TLB shutdown has occurred */
+//#define status_PX        (1 << 23)      /* Enable 64 bit operations */
+//#define status_MX        (1 << 24)      /* Enable MDMX resources */
+//#define status_CU0       (1 << 28)      /* Coprocessor 0 usable */
+//#define status_CU1       (1 << 29)      /* Coprocessor 1 usable */
+//#define status_CU2       (1 << 30)      /* Coprocessor 2 usable */
+//#define status_CU3       (1 << 31)      /* Coprocessor 3 usable */
+/* Bits reserved for implementations:  */
+//#define status_SBX       (1 << 16)      /* Enable SiByte SB-1 extensions.  */
+//#endif
+
+//#define cause_BD ((unsigned)1 << 31)    /* L1 Exception in branch delay slot */
+//#define cause_BD2         (1 << 30)     /* L2 Exception in branch delay slot */
+//#define cause_CE_mask     0x30000000	/* Coprocessor exception */
+//#define cause_CE_shift    28
+//#define cause_EXC2_mask   0x00070000
+//#define cause_EXC2_shift  16
+//#define cause_IP7 	  (1 << 15)	/* Interrupt pending */
+//#define cause_SIOP        (1 << 12)     /* SIO pending */
+//#define cause_IP3 	  (1 << 11)	/* Int 0 pending */
+//#define cause_IP2 	  (1 << 10)	/* Int 1 pending */
+//
+//#define cause_EXC_mask  (0x1c)          /* Exception code */
+//#define cause_EXC_shift (2)
+//
+//#define cause_SW0       (1 << 8)        /* Software interrupt 0 */
+//#define cause_SW1       (1 << 9)        /* Software interrupt 1 */
+//#define cause_IP_mask   (0x3f)          /* Interrupt pending field */
+//#define cause_IP_shift  (10)
+//
+//#define cause_set_EXC(x)  CAUSE = (CAUSE & ~cause_EXC_mask)  | ((x << cause_EXC_shift)  & cause_EXC_mask)
+//#define cause_set_EXC2(x) CAUSE = (CAUSE & ~cause_EXC2_mask) | ((x << cause_EXC2_shift) & cause_EXC2_mask)
+
+
+/* NOTE: We keep the following status flags as bit values (1 for true,
+   0 for false). This allows them to be used in binary boolean
+   operations without worrying about what exactly the non-zero true
+   value is. */
+
+/* UserMode */
+//#ifdef SUBTARGET_R3900
+//#define UserMode        ((SR & status_KUc) ? 1 : 0)
+//#else
+#define UserMode	((((SR & status_KSU_mask) >> status_KSU_shift) == ksu_user) ? 1 : 0)
+//#endif /* SUBTARGET_R3900 */
+
+/* BigEndianMem */
+/* Hardware configuration. Affects endianness of LoadMemory and
+   StoreMemory and the endianness of Kernel and Supervisor mode
+   execution. The value is 0 for little-endian; 1 for big-endian. */
+#define BigEndianMem    (CURRENT_TARGET_BYTE_ORDER == BIG_ENDIAN)
+/*(state & simBE) ? 1 : 0)*/
+
+/* ReverseEndian */
+/* This mode is selected if in User mode with the RE bit being set in
+   SR (Status Register). It reverses the endianness of load and store
+   instructions. */
+//#define ReverseEndian   (((SR & status_RE) && UserMode) ? 1 : 0)
+
+/* BigEndianCPU */
+/* The endianness for load and store instructions (0=little;1=big). In
+   User mode this endianness may be switched by setting the state_RE
+   bit in the SR register. Thus, BigEndianCPU may be computed as
+   (BigEndianMem EOR ReverseEndian). */
+//#define BigEndianCPU    (BigEndianMem ^ ReverseEndian) /* Already bits */
+#define BigEndianCPU    (BigEndianMem) /* Already bits */
+
+
+
+/* Exceptions: */
+
+/* NOTE: These numbers depend on the processor architecture being
+   simulated: */
+enum ExceptionCause {
+  Interrupt               = 0,
+//  TLBModification         = 1,
+//  TLBLoad                 = 2,
+//  TLBStore                = 3,
+//  AddressLoad             = 4,
+//  AddressStore            = 5,
+//  InstructionFetch        = 6,
+//  DataReference           = 7,
+//  SystemCall              = 8,
+  BreakPoint              = 9,
+//  ReservedInstruction     = 10,
+//  CoProcessorUnusable     = 11,
+//  IntegerOverflow         = 12,    /* Arithmetic overflow (IDT monitor raises SIGFPE) */
+  Trap                    = 13,
+//  FPE                     = 15,
+  DebugBreakPoint         = 16,    /* Impl. dep. in MIPS32/MIPS64.  */
+//  MDMX                    = 22,
+//  Watch                   = 23,
+//  MCheck                  = 24,
+//  CacheErr                = 30,
+  NMIReset                = 31,    /* Reserved in MIPS32/MIPS64.  */
+
+
+/* The following exception code is actually private to the simulator
+   world. It is *NOT* a processor feature, and is used to signal
+   run-time errors in the simulator. */
+  SimulatorFault      	  = 0xFFFFFFFF
+};
+
+#define TLB_REFILL  (0)
+#define TLB_INVALID (1)
+
+
+/* The following break instructions are reserved for use by the
+   simulator.  The first is used to halt the simulation.  The second
+   is used by gdb for break-points.  NOTE: Care must be taken, since 
+   this value may be used in later revisions of the MIPS ISA. */
+#define HALT_INSTRUCTION_MASK   (0x03FFFFC0)
+
+#define HALT_INSTRUCTION        (0x03ff000d)
+#define HALT_INSTRUCTION2       (0x0000ffcd)
+
+
+#define BREAKPOINT_INSTRUCTION  (0x0000000d)
+#define BREAKPOINT_INSTRUCTION2 (0x0000014d)
+
+
+
+void interrupt_event (SIM_DESC sd, void *data);
+
+void signal_exception (SIM_DESC sd, sim_cpu *cpu, address_word cia, int exception, ...);
+#define SignalException(exc,instruction)     signal_exception (SD, CPU, cia, (exc), (instruction))
+#define SignalExceptionInterrupt(level)      signal_exception (SD, CPU, cia, Interrupt, level)
+#define SignalExceptionTrap(trpno)           signal_exception (SD, CPU, cia, Trap, (trapno))
+//#define SignalExceptionInstructionFetch()    signal_exception (SD, CPU, cia, InstructionFetch)
+//#define SignalExceptionAddressStore()        signal_exception (SD, CPU, cia, AddressStore)
+//#define SignalExceptionAddressLoad()         signal_exception (SD, CPU, cia, AddressLoad)
+//#define SignalExceptionDataReference()       signal_exception (SD, CPU, cia, DataReference)
+//#define SignalExceptionSimulatorFault(buf)   signal_exception (SD, CPU, cia, SimulatorFault, buf)
+//#define SignalExceptionFPE()                 signal_exception (SD, CPU, cia, FPE)
+//#define SignalExceptionIntegerOverflow()     signal_exception (SD, CPU, cia, IntegerOverflow)
+//#define SignalExceptionCoProcessorUnusable(cop) signal_exception (SD, CPU, cia, CoProcessorUnusable)
+#define SignalExceptionNMIReset()            signal_exception (SD, CPU, cia, NMIReset)
+//#define SignalExceptionTLBRefillStore()      signal_exception (SD, CPU, cia, TLBStore, TLB_REFILL)
+//#define SignalExceptionTLBRefillLoad()       signal_exception (SD, CPU, cia, TLBLoad, TLB_REFILL)
+//#define SignalExceptionTLBInvalidStore()     signal_exception (SD, CPU, cia, TLBStore, TLB_INVALID)
+//#define SignalExceptionTLBInvalidLoad()      signal_exception (SD, CPU, cia, TLBLoad, TLB_INVALID)
+//#define SignalExceptionTLBModification()     signal_exception (SD, CPU, cia, TLBModification)
+//#define SignalExceptionMDMX()                signal_exception (SD, CPU, cia, MDMX)
+//#define SignalExceptionWatch()               signal_exception (SD, CPU, cia, Watch)
+//#define SignalExceptionMCheck()              signal_exception (SD, CPU, cia, MCheck)
+//#define SignalExceptionCacheErr()            signal_exception (SD, CPU, cia, CacheErr)
+#define SignalExceptionSyscall(exc,ope,file,p,l)     signal_exception (SD, CPU, cia, (exc), (ope),(file),(p),(l))
+
+/* Co-processor accesses */
+
+/* XXX FIXME: For now, assume that FPU (cp1) is always usable.  */
+#define COP_Usable(coproc_num)		(coproc_num == 1)
+
+void cop_lw  PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, int coproc_num, int coproc_reg, unsigned int memword));
+void cop_ld  PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, int coproc_num, int coproc_reg, uword64 memword));
+unsigned int cop_sw PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, int coproc_num, int coproc_reg));
+uword64 cop_sd PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, int coproc_num, int coproc_reg));
+
+#define COP_LW(coproc_num,coproc_reg,memword) \
+cop_lw (SD, CPU, cia, coproc_num, coproc_reg, memword)
+#define COP_LD(coproc_num,coproc_reg,memword) \
+cop_ld (SD, CPU, cia, coproc_num, coproc_reg, memword)
+#define COP_SW(coproc_num,coproc_reg) \
+cop_sw (SD, CPU, cia, coproc_num, coproc_reg)
+#define COP_SD(coproc_num,coproc_reg) \
+cop_sd (SD, CPU, cia, coproc_num, coproc_reg)
+
+
+void decode_coproc PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, unsigned int instruction));
+#define DecodeCoproc(instruction) \
+decode_coproc (SD, CPU, cia, (instruction))
+
+int sim_monitor (SIM_DESC sd, sim_cpu *cpu, address_word cia, unsigned int arg);
+  
+
+/* FPR access.  */
+//#if 0
+//unsigned64 value_fpr (SIM_STATE, int fpr, FP_formats);
+//#define ValueFPR(FPR,FMT) value_fpr (SIM_ARGS, (FPR), (FMT))
+//void store_fpr (SIM_STATE, int fpr, FP_formats fmt, unsigned64 value);
+//#define StoreFPR(FPR,FMT,VALUE) store_fpr (SIM_ARGS, (FPR), (FMT), (VALUE))
+//unsigned64 ps_lower (SIM_STATE, unsigned64 op);
+//#define PSLower(op) ps_lower (SIM_ARGS, op)
+//unsigned64 ps_upper (SIM_STATE, unsigned64 op);
+//#define PSUpper(op) ps_upper (SIM_ARGS, op)
+//unsigned64 pack_ps (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats from);
+//#define PackPS(op1,op2) pack_ps (SIM_ARGS, op1, op2, fmt_single)
+//#endif
+
+///* FCR access.  */
+//unsigned_word value_fcr (SIM_STATE, int fcr);
+//#define ValueFCR(FCR) value_fcr (SIM_ARGS, (FCR))
+//void store_fcr (SIM_STATE, int fcr, unsigned_word value);
+//#define StoreFCR(FCR,VALUE) store_fcr (SIM_ARGS, (FCR), (VALUE))
+//void test_fcsr (SIM_STATE);
+//#define TestFCSR() test_fcsr (SIM_ARGS)
+
+//#if 0
+///* FPU operations.  */
+//void fp_cmp (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt, int abs, int cond, int cc);
+//#define Compare(op1,op2,fmt,cond,cc) fp_cmp(SIM_ARGS, op1, op2, fmt, 0, cond, cc)
+//unsigned64 fp_abs (SIM_STATE, unsigned64 op, FP_formats fmt);
+//#define AbsoluteValue(op,fmt) fp_abs(SIM_ARGS, op, fmt)
+//unsigned64 fp_neg (SIM_STATE, unsigned64 op, FP_formats fmt);
+//#define Negate(op,fmt) fp_neg(SIM_ARGS, op, fmt)
+//unsigned64 fp_add (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
+//#define Add(op1,op2,fmt) fp_add(SIM_ARGS, op1, op2, fmt)
+//unsigned64 fp_sub (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
+//#define Sub(op1,op2,fmt) fp_sub(SIM_ARGS, op1, op2, fmt)
+//unsigned64 fp_mul (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
+//#define Multiply(op1,op2,fmt) fp_mul(SIM_ARGS, op1, op2, fmt)
+//unsigned64 fp_div (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
+//#define Divide(op1,op2,fmt) fp_div(SIM_ARGS, op1, op2, fmt)
+//unsigned64 fp_recip (SIM_STATE, unsigned64 op, FP_formats fmt);
+//#define Recip(op,fmt) fp_recip(SIM_ARGS, op, fmt)
+//unsigned64 fp_sqrt (SIM_STATE, unsigned64 op, FP_formats fmt);
+//#define SquareRoot(op,fmt) fp_sqrt(SIM_ARGS, op, fmt)
+//unsigned64 fp_rsqrt (SIM_STATE, unsigned64 op, FP_formats fmt);
+//#define RSquareRoot(op,fmt) fp_rsqrt(SIM_ARGS, op, fmt)
+//unsigned64 fp_madd (SIM_STATE, unsigned64 op1, unsigned64 op2,
+//		    unsigned64 op3, FP_formats fmt);
+//#define MultiplyAdd(op1,op2,op3,fmt) fp_madd(SIM_ARGS, op1, op2, op3, fmt)
+//unsigned64 fp_msub (SIM_STATE, unsigned64 op1, unsigned64 op2,
+//		    unsigned64 op3, FP_formats fmt);
+//#define MultiplySub(op1,op2,op3,fmt) fp_msub(SIM_ARGS, op1, op2, op3, fmt)
+//unsigned64 fp_nmadd (SIM_STATE, unsigned64 op1, unsigned64 op2,
+//		     unsigned64 op3, FP_formats fmt);
+//#define NegMultiplyAdd(op1,op2,op3,fmt) fp_nmadd(SIM_ARGS, op1, op2, op3, fmt)
+//unsigned64 fp_nmsub (SIM_STATE, unsigned64 op1, unsigned64 op2,
+//		     unsigned64 op3, FP_formats fmt);
+//#define NegMultiplySub(op1,op2,op3,fmt) fp_nmsub(SIM_ARGS, op1, op2, op3, fmt)
+//unsigned64 convert (SIM_STATE, int rm, unsigned64 op, FP_formats from, FP_formats to);
+//#define Convert(rm,op,from,to) convert (SIM_ARGS, rm, op, from, to)
+//unsigned64 convert_ps (SIM_STATE, int rm, unsigned64 op, FP_formats from,
+//		       FP_formats to);
+//#define ConvertPS(rm,op,from,to) convert_ps (SIM_ARGS, rm, op, from, to)
+//
+//
+///* MIPS-3D ASE operations.  */
+//#define CompareAbs(op1,op2,fmt,cond,cc) fp_cmp(SIM_ARGS, op1, op2, fmt, 1, cond, cc)
+//unsigned64 fp_add_r (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
+//#define AddR(op1,op2,fmt) fp_add_r(SIM_ARGS, op1, op2, fmt)
+//unsigned64 fp_mul_r (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
+//#define MultiplyR(op1,op2,fmt) fp_mul_r(SIM_ARGS, op1, op2, fmt)
+//unsigned64 fp_recip1 (SIM_STATE, unsigned64 op, FP_formats fmt);
+//#define Recip1(op,fmt) fp_recip1(SIM_ARGS, op, fmt)
+//unsigned64 fp_recip2 (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
+//#define Recip2(op1,op2,fmt) fp_recip2(SIM_ARGS, op1, op2, fmt)
+//unsigned64 fp_rsqrt1 (SIM_STATE, unsigned64 op, FP_formats fmt);
+//#define RSquareRoot1(op,fmt) fp_rsqrt1(SIM_ARGS, op, fmt)
+//unsigned64 fp_rsqrt2 (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
+//#define RSquareRoot2(op1,op2,fmt) fp_rsqrt2(SIM_ARGS, op1, op2, fmt)
+//#endif
+
+/* MDMX access.  */
+//#if 0
+//typedef unsigned int MX_fmtsel;   /* MDMX format select field (5 bits).  */
+//#define ob_fmtsel(sel) (((sel)<<1)|0x0)
+//#define qh_fmtsel(sel) (((sel)<<2)|0x1)
+//
+//#define fmt_mdmx fmt_uninterpreted
+//
+//#define MX_VECT_AND  (0)
+//#define MX_VECT_NOR  (1)
+//#define MX_VECT_OR   (2)
+//#define MX_VECT_XOR  (3)
+//#define MX_VECT_SLL  (4)
+//#define MX_VECT_SRL  (5)
+//#define MX_VECT_ADD  (6)
+//#define MX_VECT_SUB  (7)
+//#define MX_VECT_MIN  (8)
+//#define MX_VECT_MAX  (9)
+//#define MX_VECT_MUL  (10)
+//#define MX_VECT_MSGN (11)
+//#define MX_VECT_SRA  (12)
+//#define MX_VECT_ABSD (13)		/* SB-1 only.  */
+//#define MX_VECT_AVG  (14)		/* SB-1 only.  */
+//
+//unsigned64 mdmx_cpr_op (SIM_STATE, int op, unsigned64 op1, int vt, MX_fmtsel fmtsel);
+//#define MX_Add(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_ADD, op1, vt, fmtsel)
+//#define MX_And(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_AND, op1, vt, fmtsel)
+//#define MX_Max(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_MAX, op1, vt, fmtsel)
+//#define MX_Min(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_MIN, op1, vt, fmtsel)
+//#define MX_Msgn(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_MSGN, op1, vt, fmtsel)
+//#define MX_Mul(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_MUL, op1, vt, fmtsel)
+//#define MX_Nor(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_NOR, op1, vt, fmtsel)
+//#define MX_Or(op1,vt,fmtsel)  mdmx_cpr_op(SIM_ARGS, MX_VECT_OR,  op1, vt, fmtsel)
+//#define MX_ShiftLeftLogical(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_SLL, op1, vt, fmtsel)
+//#define MX_ShiftRightArith(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_SRA, op1, vt, fmtsel)
+//#define MX_ShiftRightLogical(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_SRL, op1, vt, fmtsel)
+//#define MX_Sub(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_SUB, op1, vt, fmtsel)
+//#define MX_Xor(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_XOR, op1, vt, fmtsel)
+//#define MX_AbsDiff(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_ABSD, op1, vt, fmtsel)
+//#define MX_Avg(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_AVG, op1, vt, fmtsel)
+//
+//#define MX_C_EQ  0x1
+//#define MX_C_LT  0x4
+//
+//void mdmx_cc_op (SIM_STATE, int cond, unsigned64 op1, int vt, MX_fmtsel fmtsel);
+//#define MX_Comp(op1,cond,vt,fmtsel) mdmx_cc_op(SIM_ARGS, cond, op1, vt, fmtsel)
+//
+//unsigned64 mdmx_pick_op (SIM_STATE, int tf, unsigned64 op1, int vt, MX_fmtsel fmtsel);
+//#define MX_Pick(tf,op1,vt,fmtsel) mdmx_pick_op(SIM_ARGS, tf, op1, vt, fmtsel)
+//
+//#define MX_VECT_ADDA  (0)
+//#define MX_VECT_ADDL  (1)
+//#define MX_VECT_MULA  (2)
+//#define MX_VECT_MULL  (3)
+//#define MX_VECT_MULS  (4)
+//#define MX_VECT_MULSL (5)
+//#define MX_VECT_SUBA  (6)
+//#define MX_VECT_SUBL  (7)
+//#define MX_VECT_ABSDA (8)		/* SB-1 only.  */
+//
+//void mdmx_acc_op (SIM_STATE, int op, unsigned64 op1, int vt, MX_fmtsel fmtsel);
+//#define MX_AddA(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_ADDA, op1, vt, fmtsel)
+//#define MX_AddL(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_ADDL, op1, vt, fmtsel)
+//#define MX_MulA(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_MULA, op1, vt, fmtsel)
+//#define MX_MulL(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_MULL, op1, vt, fmtsel)
+//#define MX_MulS(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_MULS, op1, vt, fmtsel)
+//#define MX_MulSL(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_MULSL, op1, vt, fmtsel)
+//#define MX_SubA(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_SUBA, op1, vt, fmtsel)
+//#define MX_SubL(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_SUBL, op1, vt, fmtsel)
+//#define MX_AbsDiffC(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_ABSDA, op1, vt, fmtsel)
+//
+//#define MX_FMT_OB   (0)
+//#define MX_FMT_QH   (1)
+//
+///* The following codes chosen to indicate the units of shift.  */
+//#define MX_RAC_L    (0)
+//#define MX_RAC_M    (1)
+//#define MX_RAC_H    (2)
+//
+//unsigned64 mdmx_rac_op (SIM_STATE, int, int);
+//#define MX_RAC(op,fmt) mdmx_rac_op(SIM_ARGS, op, fmt)
+//
+//void mdmx_wacl (SIM_STATE, int, unsigned64, unsigned64);
+//#define MX_WACL(fmt,vs,vt) mdmx_wacl(SIM_ARGS, fmt, vs, vt)
+//void mdmx_wach (SIM_STATE, int, unsigned64);
+//#define MX_WACH(fmt,vs) mdmx_wach(SIM_ARGS, fmt, vs)
+//
+//#define MX_RND_AS   (0)
+//#define MX_RND_AU   (1)
+//#define MX_RND_ES   (2)
+//#define MX_RND_EU   (3)
+//#define MX_RND_ZS   (4)
+//#define MX_RND_ZU   (5)
+//
+//unsigned64 mdmx_round_op (SIM_STATE, int, int, MX_fmtsel);
+//#define MX_RNAS(vt,fmt) mdmx_round_op(SIM_ARGS, MX_RND_AS, vt, fmt)
+//#define MX_RNAU(vt,fmt) mdmx_round_op(SIM_ARGS, MX_RND_AU, vt, fmt)
+//#define MX_RNES(vt,fmt) mdmx_round_op(SIM_ARGS, MX_RND_ES, vt, fmt)
+//#define MX_RNEU(vt,fmt) mdmx_round_op(SIM_ARGS, MX_RND_EU, vt, fmt)
+//#define MX_RZS(vt,fmt)  mdmx_round_op(SIM_ARGS, MX_RND_ZS, vt, fmt)
+//#define MX_RZU(vt,fmt)  mdmx_round_op(SIM_ARGS, MX_RND_ZU, vt, fmt)
+//
+//unsigned64 mdmx_shuffle (SIM_STATE, int, unsigned64, unsigned64);
+//#define MX_SHFL(shop,op1,op2) mdmx_shuffle(SIM_ARGS, shop, op1, op2)
+//#endif
+
+
+/* Memory accesses */
+
+/* The following are generic to all versions of the MIPS architecture
+   to date: */
+
+/* Memory Access Types (for CCA): */
+#define Uncached                (0)
+#define CachedNoncoherent       (1)
+#define CachedCoherent          (2)
+#define Cached                  (3)
+
+#define isINSTRUCTION   (1 == 0) /* FALSE */
+#define isDATA          (1 == 1) /* TRUE */
+#define isLOAD          (1 == 0) /* FALSE */
+#define isSTORE         (1 == 1) /* TRUE */
+#define isREAL          (1 == 0) /* FALSE */
+#define isRAW           (1 == 1) /* TRUE */
+/* The parameter HOST (isTARGET / isHOST) is ignored */
+#define isTARGET        (1 == 0) /* FALSE */
+/* #define isHOST          (1 == 1) TRUE */
+
+/* The "AccessLength" specifications for Loads and Stores. NOTE: This
+   is the number of bytes minus 1. */
+#define AccessLength_BYTE       (0)
+#define AccessLength_HALFWORD   (1)
+#define AccessLength_TRIPLEBYTE (2)
+#define AccessLength_WORD       (3)
+#define AccessLength_QUINTIBYTE (4)
+#define AccessLength_SEXTIBYTE  (5)
+#define AccessLength_SEPTIBYTE  (6)
+#define AccessLength_DOUBLEWORD (7)
+#define AccessLength_QUADWORD   (15)
+
+#define LOADDRMASK (WITH_TARGET_WORD_BITSIZE == 64 \
+		    ? AccessLength_DOUBLEWORD /*7*/ \
+		    : AccessLength_WORD /*3*/)
+#define PSIZE (WITH_TARGET_ADDRESS_BITSIZE)
+
+
+INLINE_SIM_MAIN (int) address_translation PARAMS ((SIM_DESC sd, sim_cpu *, address_word cia, address_word vAddr, int IorD, int LorS, address_word *pAddr, int *CCA, int raw));
+#define AddressTranslation(vAddr,IorD,LorS,pAddr,CCA,host,raw) \
+address_translation (SD, CPU, cia, vAddr, IorD, LorS, pAddr, CCA, raw)
+
+INLINE_SIM_MAIN (void) load_memory PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, uword64* memvalp, uword64* memval1p, int CCA, unsigned int AccessLength, address_word pAddr, address_word vAddr, int IorD)); 
+#define LoadMemory(memvalp,memval1p,CCA,AccessLength,pAddr,vAddr,IorD,raw) \
+load_memory (SD, CPU, cia, memvalp, memval1p, CCA, AccessLength, pAddr, vAddr, IorD)
+
+INLINE_SIM_MAIN (void) delay_load_p PARAMS ((SIM_DESC sd, sim_cpu *cpu, unsigned int regno, uword64 memval, unsigned int byte, unsigned access));
+//INLINE_SIM_MAIN (void) delay_load_p PARAMS ((SIM_DESC sd, sim_cpu *cpu, unsigned int regno, unsigned int memval, unsigned int byte, unsigned access));
+#define DelayLoad_p(regno,memval,byte,access) \
+delay_load_p (SD, CPU, regno, memval, byte, access)
+
+INLINE_SIM_MAIN (unsigned int) delay_load_e PARAMS ((SIM_DESC sd, sim_cpu *cpu, unsigned int* regnop, uword64* memvalp, unsigned int* bytep));
+//INLINE_SIM_MAIN (unsigned int) delay_load_e PARAMS ((SIM_DESC sd, sim_cpu *cpu, unsigned int* regnop, unsigned int* memvalp, unsigned int* bytep));
+#define DelayLoad_e(regnop,memvalp,bytep) \
+delay_load_e (SD, CPU, regnop, memvalp, bytep)
+
+
+INLINE_SIM_MAIN (void) store_memory PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, int CCA, unsigned int AccessLength, uword64 MemElem, uword64 MemElem1, address_word pAddr, address_word vAddr));
+#define StoreMemory(CCA,AccessLength,MemElem,MemElem1,pAddr,vAddr,raw) \
+store_memory (SD, CPU, cia, CCA, AccessLength, MemElem, MemElem1, pAddr, vAddr)
+
+INLINE_SIM_MAIN (void) cache_op PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, int op, address_word pAddr, address_word vAddr, unsigned int instruction));
+#define CacheOp(op,pAddr,vAddr,instruction) \
+cache_op (SD, CPU, cia, op, pAddr, vAddr, instruction)
+
+INLINE_SIM_MAIN (void) sync_operation PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, int stype));
+#define SyncOperation(stype) \
+sync_operation (SD, CPU, cia, (stype))
+
+INLINE_SIM_MAIN (void) prefetch PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, int CCA, address_word pAddr, address_word vAddr, int DATA, int hint));
+#define Prefetch(CCA,pAddr,vAddr,DATA,hint) \
+prefetch (SD, CPU, cia, CCA, pAddr, vAddr, DATA, hint)
+
+void unpredictable_action (sim_cpu *cpu, address_word cia);
+#define NotWordValue(val)	not_word_value (SD_, (val))
+#define Unpredictable()		unpredictable (SD_)
+#define UnpredictableResult()	/* For now, do nothing.  */
+
+INLINE_SIM_MAIN (unsigned32) ifetch32 PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, address_word vaddr));
+#define IMEM32(CIA) ifetch32 (SD, CPU, (CIA), (CIA))
+INLINE_SIM_MAIN (unsigned16) ifetch16 PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, address_word vaddr));
+#define IMEM16(CIA) ifetch16 (SD, CPU, (CIA), ((CIA) & ~1))
+#define IMEM16_IMMED(CIA,NR) ifetch16 (SD, CPU, (CIA), ((CIA) & ~1) + 2 * (NR))
+
+void dotrace PARAMS ((SIM_DESC sd, sim_cpu *cpu, FILE *tracefh, int type, SIM_ADDR address, int width, char *comment, ...));
+extern FILE *tracefh;
+
+INLINE_SIM_MAIN (void) pending_tick PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia));
+extern SIM_CORE_SIGNAL_FN brownie32_core_signal;
+
+char* pr_addr PARAMS ((SIM_ADDR addr));
+char* pr_uword64 PARAMS ((uword64 addr));
+
+
+#define GPR_CLEAR(N) do { GPR_SET((N),0); } while (0)
+
+void brownie32_cpu_exception_trigger(SIM_DESC sd, sim_cpu* cpu, address_word pc);
+void brownie32_cpu_exception_suspend(SIM_DESC sd, sim_cpu* cpu, int exception);
+void brownie32_cpu_exception_resume(SIM_DESC sd, sim_cpu* cpu, int exception);
+
+#ifdef BROWNIE32_MACH_MULTI
+extern int brownie32_mach_multi(SIM_DESC sd);
+#define BROWNIE32_MACH(SD)	brownie32_mach_multi(SD)
+#else
+#define	BROWNIE32_MACH(SD)	BROWNIE32_MACH_DEFAULT
+#endif
+
+#if H_REVEALS_MODULE_P (SIM_MAIN_INLINE)
+#include "sim-main.c"
+#endif
+
+#endif
Index: sim/brownie32/tconfig.in
===================================================================
RCS file: sim/brownie32/tconfig.in
diff -N sim/brownie32/tconfig.in
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/tconfig.in	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,36 @@
+/* mips target configuration file.  */
+
+/* See sim-hload.c.  We properly handle LMA.  */
+#ifdef TARGET_TX3904
+#define SIM_HANDLES_LMA 1
+
+/* FIXME: This is unnecessarily necessary: */
+#include "ansidecl.h"
+#include "gdb/callback.h"
+#include "gdb/remote-sim.h"
+#include "sim-module.h"
+
+MODULE_INSTALL_FN dv_sockser_install;
+#define MODULE_LIST dv_sockser_install,
+#else
+#define SIM_HANDLES_LMA 0
+#endif
+
+/* Define this if the simulator supports profiling.
+   See the mips simulator for an example.
+   This enables the `-p foo' and `-s bar' options.
+   The target is required to provide sim_set_profile{,_size}.  */
+#define SIM_HAVE_PROFILE
+
+/* Define this if the simulator uses an instruction cache.
+   See the h8/300 simulator for an example.
+   This enables the `-c size' option to set the size of the cache.
+   The target is required to provide sim_set_simcache_size.  */
+/* #define SIM_HAVE_SIMCACHE */
+
+/* Define this if the target cpu is bi-endian
+   and the simulator supports it.  */
+#define SIM_HAVE_BIENDIAN
+
+/* MIPS uses an unusual format for floating point quiet NaNs.  */
+#define SIM_QUIET_NAN_NEGATED
Index: sim/brownie32/tx.igen
===================================================================
RCS file: sim/brownie32/tx.igen
diff -N sim/brownie32/tx.igen
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/tx.igen	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,46 @@
+// -*- C -*-
+//
+// toshiba specific instructions.
+//
+
+011100,5.RS,5.RT,5.RD,00000000000:MMINORM:::MADD
+"madd r<RS>, r<RT>":RD == 0
+"madd r<RD>, r<RS>, r<RT>"
+*r3900
+{
+  signed64 prod = (U8_4 (VL4_8 (HI), VL4_8 (LO))
+		   + ((signed64) EXTEND32 (GPR[RT])
+		      * (signed64) EXTEND32 (GPR[RS])));
+  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
+  TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
+  LO = EXTEND32 (prod);
+  HI = EXTEND32 (VH4_8 (prod));
+  TRACE_ALU_RESULT2 (HI, LO);
+  if(RD != 0 )
+    GPR[RD] = LO;
+}
+
+
+011100,5.RS,5.RT,5.RD,00000000001:MMINORM:::MADDU
+"maddu r<RS>, r<RT>":RD == 0
+"maddu r<RD>, r<RS>, r<RT>"
+*r3900
+{
+  unsigned64 prod = (U8_4 (VL4_8 (HI), VL4_8 (LO))
+		     + ((unsigned64) VL4_8 (GPR[RS])
+			* (unsigned64) VL4_8 (GPR[RT])));
+  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
+  TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
+  LO = EXTEND32 (prod);
+  HI = EXTEND32 (VH4_8 (prod));
+  TRACE_ALU_RESULT2 (HI, LO);
+  if(RD != 0)
+    GPR[RD] = LO;
+}
+
+000000,CODE.20,001110::CO1:::SDBBP
+"sdbbp"
+*r3900:
+{
+  SignalException (DebugBreakPoint, instruction);
+}
Index: sim/brownie32/vr.igen
===================================================================
RCS file: sim/brownie32/vr.igen
diff -N sim/brownie32/vr.igen
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/brownie32/vr.igen	8 Aug 2007 08:49:54 -0000	1.1
@@ -0,0 +1,257 @@
+// -*- C -*-
+//
+// NEC specific instructions
+//
+
+:%s::::MFHI:int hi
+{
+  return hi ? "hi" : "";
+}
+
+:%s::::SAT:int s
+{
+  return s ? "s" : "";
+}
+
+:%s::::UNS:int u
+{
+  return u ? "u" : "";
+}
+
+// Simulate the various kinds of multiply and multiply-accumulate instructions.
+// Perform an operation of the form:
+//
+//	LHS (+/-) GPR[RS] * GPR[RT]
+//
+// and store it in the 64-bit accumulator.  Optionally copy either LO or
+// HI into a general purpose register.
+//
+// - RD is the destination register of the LO or HI move
+// - RS are RT are the multiplication source registers
+// - ACCUMULATE_P is true if LHS should be the value of the 64-bit accumulator,
+//     false if it should be 0.
+// - STORE_HI_P is true if HI should be stored in RD, false if LO should be.
+// - UNSIGNED_P is true if the operation should be unsigned.
+// - SATURATE_P is true if the result should be saturated to a 32-bit value.
+// - SUBTRACT_P is true if the right hand side should be subtraced from LHS,
+//     false if it should be added.
+// - SHORT_P is true if RS and RT must be 16-bit numbers.
+// - DOUBLE_P is true if the 64-bit accumulator is in LO, false it is a
+//     concatenation of the low 32 bits of HI and LO.
+:function:::void:do_vr_mul_op:int rd, int rs, int rt, int accumulate_p, int store_hi_p, int unsigned_p, int saturate_p, int subtract_p, int short_p, int double_p
+{
+  unsigned64 lhs, x, y, xcut, ycut, product, result;
+
+  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
+
+  lhs = (!accumulate_p ? 0 : double_p ? LO : U8_4 (HI, LO));
+  x = GPR[rs];
+  y = GPR[rt];
+
+  /* Work out the canonical form of X and Y from their significant bits.  */
+  if (!short_p)
+    {
+      /* Normal sign-extension rule for 32-bit operands.  */
+      xcut = EXTEND32 (x);
+      ycut = EXTEND32 (y);
+    }
+  else if (unsigned_p)
+    {
+      /* Operands must be zero-extended 16-bit numbers.  */
+      xcut = x & 0xffff;
+      ycut = y & 0xffff;
+    }
+  else
+    {
+      /* Likewise but sign-extended.  */
+      xcut = EXTEND16 (x);
+      ycut = EXTEND16 (y);
+    }
+  if (x != xcut || y != ycut)
+    sim_engine_abort (SD, CPU, CIA,
+		      "invalid multiplication operand at 0x%08lx\n",
+		      (long) CIA);
+
+  TRACE_ALU_INPUT2 (x, y);
+  product = (unsigned_p
+	     ? V8_4 (x, 1) * V8_4 (y, 1)
+	     : EXTEND32 (x) * EXTEND32 (y));
+  result = (subtract_p ? lhs - product : lhs + product);
+  if (saturate_p)
+    {
+      /* Saturate the result to 32 bits.  An unsigned, unsaturated
+	 result is zero-extended to 64 bits, but unsigned overflow
+	 causes all 64 bits to be set.  */
+      if (!unsigned_p && (unsigned64) EXTEND32 (result) != result)
+	result = ((signed64) result < 0 ? -0x7fffffff - 1 : 0x7fffffff);
+      else if (unsigned_p && (result >> 32) != 0)
+	result = (unsigned64) 0 - 1;
+    }
+  TRACE_ALU_RESULT (result);
+
+  if (double_p)
+    LO = result;
+  else
+    {
+      LO = EXTEND32 (result);
+      HI = EXTEND32 (VH4_8 (result));
+    }
+  if (rd != 0)
+    GPR[rd] = store_hi_p ? HI : LO;
+}
+
+// VR4100 instructions.
+
+000000,5.RS,5.RT,00000,00000,101000::32::MADD16
+"madd16 r<RS>, r<RT>"
+*vr4100:
+{
+  do_vr_mul_op (SD_, 0, RS, RT,
+		1 /* accumulate */,
+		0 /* store in LO */,
+		0 /* signed arithmetic */,
+		0 /* don't saturate */,
+		0 /* don't subtract */,
+		1 /* short */,
+		0 /* single */);
+}
+
+000000,5.RS,5.RT,00000,00000,101001::64::DMADD16
+"dmadd16 r<RS>, r<RT>"
+*vr4100:
+{
+  do_vr_mul_op (SD_, 0, RS, RT,
+		1 /* accumulate */,
+		0 /* store in LO */,
+		0 /* signed arithmetic */,
+		0 /* don't saturate */,
+		0 /* don't subtract */,
+		1 /* short */,
+		1 /* double */);
+}
+
+
+
+// VR4120 and VR4130 instructions.
+
+000000,5.RS,5.RT,5.RD,1.SAT,1.MFHI,00,1.UNS,101001::64::DMACC
+"dmacc%s<MFHI>%s<UNS>%s<SAT> r<RD>, r<RS>, r<RT>"
+*vr4120:
+{
+  do_vr_mul_op (SD_, RD, RS, RT,
+		1 /* accumulate */,
+		MFHI, UNS, SAT,
+		0 /* don't subtract */,
+		SAT /* short */,
+		1 /* double */);
+}
+
+000000,5.RS,5.RT,5.RD,1.SAT,1.MFHI,00,1.UNS,101000::32::MACC_4120
+"macc%s<MFHI>%s<UNS>%s<SAT> r<RD>, r<RS>, r<RT>"
+*vr4120:
+{
+  do_vr_mul_op (SD_, RD, RS, RT,
+		1 /* accumulate */,
+		MFHI, UNS, SAT,
+		0 /* don't subtract */,
+		SAT /* short */,
+		0 /* single */);
+}
+
+
+// VR5400 and VR5500 instructions.
+
+000000,5.RS,5.RT,5.RD,0,1.MFHI,001,01100,1.UNS::32::MUL
+"mul%s<MFHI>%s<UNS> r<RD>, r<RS>, r<RT>"
+*vr5400:
+*vr5500:
+{
+  do_vr_mul_op (SD_, RD, RS, RT,
+		0 /* don't accumulate */,
+		MFHI, UNS,
+		0 /* don't saturate */,
+		0 /* don't subtract */,
+		0 /* not short */,
+		0 /* single */);
+}
+
+000000,5.RS,5.RT,5.RD,0,1.MFHI,011,01100,1.UNS::32::MULS
+"muls%s<MFHI>%s<UNS> r<RD>, r<RS>, r<RT>"
+*vr5400:
+*vr5500:
+{
+  do_vr_mul_op (SD_, RD, RS, RT,
+		0 /* don't accumulate */,
+		MFHI, UNS,
+		0 /* don't saturate */,
+		1 /* subtract */,
+		0 /* not short */,
+		0 /* single */);
+}
+
+000000,5.RS,5.RT,5.RD,0,1.MFHI,101,01100,1.UNS::32::MACC_5xxx
+"macc%s<MFHI>%s<UNS> r<RD>, r<RS>, r<RT>"
+*vr5400:
+*vr5500:
+{
+  do_vr_mul_op (SD_, RD, RS, RT,
+		1 /* accumulate */,
+		MFHI, UNS,
+		0 /* don't saturate */,
+		0 /* don't subtract */,
+		0 /* not short */,
+		0 /* single */);
+}
+
+000000,5.RS,5.RT,5.RD,0,1.MFHI,111,01100,1.UNS::32::MSAC
+"msac%s<MFHI>%s<UNS> r<RD>, r<RS>, r<RT>"
+*vr5400:
+*vr5500:
+{
+  do_vr_mul_op (SD_, RD, RS, RT,
+		1 /* accumulate */,
+		MFHI, UNS,
+		0 /* don't saturate */,
+		1 /* subtract */,
+		0 /* not short */,
+		0 /* single */);
+}
+
+
+010011,5.BASE,5.INDEX,5.0,5.FD,000101:COP1X:64::LUXC1
+"luxc1 f<FD>, r<INDEX>(r<BASE>)"
+*vr5500:
+{
+  check_fpu (SD_);
+  COP_LD (1, FD, do_load (SD_, AccessLength_DOUBLEWORD,
+			  (GPR[BASE] + GPR[INDEX]) & ~MASK64 (2, 0), 0));
+}
+
+010011,5.BASE,5.INDEX,5.FS,00000,001101:COP1X:64::SUXC1
+"suxc1 f<FS>, r<INDEX>(r<BASE>)"
+*vr5500:
+{
+  check_fpu (SD_);
+  do_store (SD_, AccessLength_DOUBLEWORD,
+	    (GPR[BASE] + GPR[INDEX]) & ~MASK64 (2, 0), 0,
+	    COP_SD (1, FS));
+}
+
+010000,1,19.*,100000:COP0:32::WAIT
+"wait"
+*vr5500:
+
+011100,00000,5.RT,5.DR,00000,111101:SPECIAL:64::MFDR
+"mfdr r<RT>, r<DR>"
+*vr5400:
+*vr5500:
+
+011100,00100,5.RT,5.DR,00000,111101:SPECIAL:64::MTDR
+"mtdr r<RT>, r<DR>"
+*vr5400:
+*vr5500:
+
+011100,00000,00000,00000,00000,111110:SPECIAL:64::DRET
+"dret"
+*vr5400:
+*vr5500:
Index: sim/common/configure
===================================================================
RCS file: /home/prj/asip/cvs/gdb/sim/common/configure,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- sim/common/configure	31 Jul 2007 11:40:27 -0000	1.1.1.1
+++ sim/common/configure	8 Aug 2007 08:49:55 -0000	1.2
@@ -964,7 +964,7 @@ esac
     else
       echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
     fi
-    cd "$ac_popdir"
+    cd $ac_popdir
   done
 fi
 
@@ -2023,7 +2023,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2081,7 +2082,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2197,7 +2199,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2251,7 +2254,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2296,7 +2300,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2340,7 +2345,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2621,7 +2627,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2675,7 +2682,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2990,7 +2998,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3197,7 +3206,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3257,7 +3267,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3336,7 +3347,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3401,7 +3413,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3466,7 +3479,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3530,7 +3544,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3611,7 +3626,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3752,7 +3768,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3890,7 +3907,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4074,7 +4092,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4325,7 +4344,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4519,7 +4539,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4622,7 +4643,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4693,7 +4715,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4790,7 +4813,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4926,7 +4950,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4990,7 +5015,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5045,7 +5071,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5185,7 +5212,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5318,7 +5346,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5595,7 +5624,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5789,7 +5819,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5939,7 +5970,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6089,7 +6121,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6240,7 +6273,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6427,7 +6461,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6500,7 +6535,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6573,7 +6609,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6795,7 +6832,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6915,7 +6953,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7103,7 +7142,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7173,7 +7213,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7222,7 +7263,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7293,7 +7335,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7342,7 +7385,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7413,7 +7457,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7462,7 +7507,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7533,7 +7579,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7582,7 +7629,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7653,7 +7701,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7702,7 +7751,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7773,7 +7823,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7822,7 +7873,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7893,7 +7945,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7942,7 +7995,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8013,7 +8067,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8062,7 +8117,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8133,7 +8189,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8182,7 +8239,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8253,7 +8311,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8302,7 +8361,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8373,7 +8433,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8422,7 +8483,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8493,7 +8555,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8542,7 +8605,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8613,7 +8677,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8662,7 +8727,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8779,9 +8845,10 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   # 1. Remove the extension, and $U if already installed.
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
-  # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
-  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
 
@@ -9562,6 +9629,11 @@ esac
   *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
   esac
 
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
   # Let's still pretend it is `configure' which instantiates (i.e., don't
   # use $as_me), people would be surprised to read:
   #    /* config.h.  Generated by config.status.  */
@@ -9600,12 +9672,6 @@ echo "$as_me: error: cannot find input f
 	 fi;;
       esac
     done` || { (exit 1); exit 1; }
-
-  if test x"$ac_file" != x-; then
-    { echo "$as_me:$LINENO: creating $ac_file" >&5
-echo "$as_me: creating $ac_file" >&6;}
-    rm -f "$ac_file"
-  fi
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF
   sed "$ac_vpsub
Index: sim/common/nrun.c
===================================================================
RCS file: /home/prj/asip/cvs/gdb/sim/common/nrun.c,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- sim/common/nrun.c	31 Jul 2007 11:40:27 -0000	1.1.1.1
+++ sim/common/nrun.c	8 Aug 2007 08:49:55 -0000	1.2
@@ -1,5 +1,6 @@
 /* New version of run front end support for simulators.
    Copyright (C) 1997, 2004 Free Software Foundation, Inc.
+   Copyright (C) 2005,2006  Upwind technology, Inc.
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
Index: sim/common/sim-bits.h
===================================================================
RCS file: /home/prj/asip/cvs/gdb/sim/common/sim-bits.h,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- sim/common/sim-bits.h	31 Jul 2007 11:40:27 -0000	1.1.1.1
+++ sim/common/sim-bits.h	8 Aug 2007 08:49:55 -0000	1.2
@@ -508,6 +508,7 @@ INLINE_SIM_BITS(unsigned_word) MSINSERTE
 #define EXTEND15(X)  (LSSEXT ((X), 14))
 #define EXTEND16(X) ((signed_word)(signed16)(X))
 #define EXTEND24(X)  (LSSEXT ((X), 23))
+#define EXTEND26(X)  (LSSEXT ((X), 25))
 #define EXTEND32(X) ((signed_word)(signed32)(X))
 #define EXTEND64(X) ((signed_word)(signed64)(X))
 
Index: sim/common/sim-hload.c
===================================================================
RCS file: /home/prj/asip/cvs/gdb/sim/common/sim-hload.c,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- sim/common/sim-hload.c	31 Jul 2007 11:40:27 -0000	1.1.1.1
+++ sim/common/sim-hload.c	8 Aug 2007 08:49:55 -0000	1.2
@@ -2,6 +2,8 @@
    Copyright (C) 1997 Free Software Foundation, Inc.
    Contributed by Cygnus Support.
 
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
 This file is part of GDB, the GNU debugger.
 
 This program is free software; you can redistribute it and/or modify
@@ -36,10 +38,10 @@ sim_load (sd, prog_name, prog_bfd, from_
 {
   bfd *result_bfd;
 
-  SIM_ASSERT (STATE_MAGIC (sd) == SIM_MAGIC_NUMBER);
+//  SIM_ASSERT (STATE_MAGIC (sd) == SIM_MAGIC_NUMBER);
   if (sim_analyze_program (sd, prog_name, prog_bfd) != SIM_RC_OK)
     return SIM_RC_FAIL;
-  SIM_ASSERT (STATE_PROG_BFD (sd) != NULL);
+//  SIM_ASSERT (STATE_PROG_BFD (sd) != NULL);
 
   /* NOTE: For historical reasons, older hardware simulators
      incorrectly write the program sections at LMA interpreted as a
Index: sim/common/sim-load.c
===================================================================
RCS file: /home/prj/asip/cvs/gdb/sim/common/sim-load.c,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- sim/common/sim-load.c	31 Jul 2007 11:40:27 -0000	1.1.1.1
+++ sim/common/sim-load.c	8 Aug 2007 08:49:55 -0000	1.2
@@ -1,6 +1,8 @@
 /* Utility to load a file into the simulator.
    Copyright (C) 1997, 1998, 2001, 2002, 2004 Free Software Foundation, Inc.
 
+   Copyright (C) 2005,2006  Upwind technology, Inc.
+
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
@@ -141,6 +143,11 @@ sim_load_file (sd, myname, callback, pro
 	      data_count += size;
 	      bfd_get_section_contents (result_bfd, s, buffer, 0, size);
 	      do_write (sd, lma, buffer, size);
+          if (strcmp (bfd_get_section_name (result_bfd, s), ".text") == 0)
+          {
+              unsigned char trapcode[4] = {0x00,0x00,0x00,0x0d};
+              sim_write(sd, lma+size,trapcode,4);
+          }
 	      found_loadable_section = 1;
 	      free (buffer);
 	    }
Index: sim/testsuite/configure
===================================================================
RCS file: /home/prj/asip/cvs/gdb/sim/testsuite/configure,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- sim/testsuite/configure	31 Jul 2007 11:40:27 -0000	1.1.1.1
+++ sim/testsuite/configure	8 Aug 2007 08:49:55 -0000	1.2
@@ -3,6 +3,7 @@
 # Generated by GNU Autoconf 2.59.
 #
 # Copyright (C) 2003 Free Software Foundation, Inc.
+# Copyright (C) 2005,2006  Upwind technology, Inc.
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
 ## --------------------- ##
@@ -275,6 +276,7 @@ ac_unique_file="common/bits-tst.c"
 ac_subdirs_all="$ac_subdirs_all frv-elf"
 ac_subdirs_all="$ac_subdirs_all m32r-elf"
 ac_subdirs_all="$ac_subdirs_all mips64el-elf"
+ac_subdirs_all="$ac_subdirs_all brownie3264el-elf"
 ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS CC build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os subdirs arch LIBOBJS LTLIBOBJS'
 ac_subst_files=''
 
@@ -1354,6 +1356,12 @@ subdirs="$subdirs m32r-elf"
 subdirs="$subdirs mips64el-elf"
 
 	;;
+    brownie3264el-*-elf )
+
+
+subdirs="$subdirs brownie3264el-elf"
+
+	;;
 esac
 
 # Compute the target architecture.
@@ -1478,9 +1486,10 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   # 1. Remove the extension, and $U if already installed.
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
-  # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
-  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
 
Index: sim/testsuite/configure.ac
===================================================================
RCS file: /home/prj/asip/cvs/gdb/sim/testsuite/configure.ac,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- sim/testsuite/configure.ac	31 Jul 2007 11:40:27 -0000	1.1.1.1
+++ sim/testsuite/configure.ac	8 Aug 2007 08:49:55 -0000	1.2
@@ -23,6 +23,9 @@ case ${target} in
     mips64el-*-elf )
         AC_CONFIG_SUBDIRS(mips64el-elf)
 	;;
+    brownie3264el-*-elf )
+        AC_CONFIG_SUBDIRS(brownie3264el-elf)
+	;;
 esac
 
 # Compute the target architecture.
Index: sim/testsuite/brownie3264el-elf/ChangeLog
===================================================================
RCS file: sim/testsuite/brownie3264el-elf/ChangeLog
diff -N sim/testsuite/brownie3264el-elf/ChangeLog
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/testsuite/brownie3264el-elf/ChangeLog	8 Aug 2007 08:49:55 -0000	1.1
@@ -0,0 +1,10 @@
+2005-01-07  Andrew Cagney  <cagney@gnu.org>
+
+	* configure.ac: Rename configure.in, require autoconf 2.59.
+	* configure: Re-generate.
+
+Thu Aug 13 22:37:29 EDT 1998  Jim Lemke  <jlemke@cygnus.com>
+
+	* Makefile.in, configure, configure.in:
+	Create a minimal testsuite.
+
Index: sim/testsuite/brownie3264el-elf/Makefile.in
===================================================================
RCS file: sim/testsuite/brownie3264el-elf/Makefile.in
diff -N sim/testsuite/brownie3264el-elf/Makefile.in
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/testsuite/brownie3264el-elf/Makefile.in	8 Aug 2007 08:49:55 -0000	1.1
@@ -0,0 +1,171 @@
+# Makefile for regression testing the GNU debugger.
+# Copyright (C) 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
+
+# This file is part of GDB.
+
+# GDB is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+
+# GDB is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+VPATH = @srcdir@
+srcdir = @srcdir@
+srcroot = $(srcdir)/..
+
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+
+host_alias = @host_alias@
+target_alias = @target_alias@
+program_transform_name = @program_transform_name@
+build_canonical = @build@
+host_canonical = @host@
+target_canonical = @target@
+target_cpu = @target_cpu@
+
+
+SHELL = /bin/sh
+SUBDIRS = @subdirs@
+RPATH_ENVVAR = @RPATH_ENVVAR@
+
+EXPECT = `if [ -f $${rootme}/../../expect/expect ] ; then \
+          echo $${rootme}/../../expect/expect ; \
+          else echo expect ; fi`
+
+RUNTEST = $(RUNTEST_FOR_TARGET)
+
+RUNTESTFLAGS =
+
+RUNTEST_FOR_TARGET = `\
+  if [ -f $${srcdir}/../../../dejagnu/runtest ]; then \
+    echo $${srcdir}/../../../dejagnu/runtest; \
+  else \
+    if [ "$(host_canonical)" = "$(target_canonical)" ]; then \
+      echo runtest; \
+    else \
+      t='$(program_transform_name)'; echo runtest | sed -e '' $$t; \
+    fi; \
+  fi`
+
+
+AS_FOR_TARGET = `\
+  if [ -x ../../../gas/as-new ]; then \
+    echo ../../../gas/as-new ; \
+  else \
+    echo $(target_alias)-as ; \
+  fi`
+
+LD_FOR_TARGET = `\
+  if [ -x ../../../ld/ld-new ]; then \
+    echo ../../../ld/ld-new ; \
+  else \
+    echo $(target_alias)-ld ; \
+  fi`
+
+RUN_FOR_TARGET = `\
+  if [ -x ../../../sim/mips/run ]; then \
+    echo ../../../sim/mips/run ; \
+  else \
+    echo $(target_alias)-run ; \
+  fi`
+
+TESTS = 
+
+check: sanity $(TESTS)
+sanity:
+	@eval echo AS_FOR_TARGET = $(AS_FOR_TARGET)
+	@eval echo LD_FOR_TARGET = $(LD_FOR_TARGET)
+	@eval echo RUN_FOR_TARGET = $(RUN_FOR_TARGET)
+
+
+
+# Rules for running all the tests, put into three types
+# exit success, exit fail, print "Hello World"
+
+.u.log:
+	uudecode $*.u
+	$(RUN_FOR_TARGET) $* > $*.log
+
+
+# Rules for running the tests
+
+.SUFFIXES: .u .uue .ok .ok .run .hi .ko .ko
+.run.ok:
+	rm -f tmp-$* $*.ok
+	ulimit -t 5 ; $(RUN_FOR_TARGET) $*.run > tmp-$*
+	mv tmp-$* $*.ok
+.run.hi:
+	rm -f tmp-$* $*.hi diff-$*
+	ulimit -t 5 ; $(RUN_FOR_TARGET) $*.run > tmp-$*
+	echo 'Hello World!' | diff - tmp-$* > diff-$*
+	cat tmp-$* diff-$* > $*.hi
+.run.ko:
+	rm -f tmp-$* $*.ko
+	set +e ; \
+	ulimit -t 5 ; $(RUN_FOR_TARGET) $*.run > tmp-$* ; \
+	if [ $$? -eq 47 ] ; then \
+	  exit 0 ; \
+	else \
+	  exit 1 ; \
+	fi
+	mv tmp-$* $*.ko
+
+
+# Rules for building all the tests and packing them into
+# uuencoded files.
+
+.run.u:
+	uuencode < $*.run $*.run > $*.u
+	@echo "Move $*.u $*.uue"
+.uue.run:
+	uudecode $(srcdir)/$*.uue
+.o.run:
+	$(LD_FOR_TARGET) -Ttext 0xa0020000 -o $*.run $*.o
+.s.o:
+	$(AS_FOR_TARGET) -I $(srcdir) $(srcdir)/$*.s -o $*.o
+
+
+#
+# Standard
+#
+clean mostlyclean:
+	-rm -f *~ core *.o a.out *.x *.grt *.run tmp-* diff-*
+	rm -f $(TESTS)
+#	if [ x"${SUBDIRS}" != x ] ; then \
+#	    for dir in ${SUBDIRS}; \
+#	    do \
+#		    echo "$$dir:"; \
+#		    if [ -d $$dir ]; then \
+#			    (cd $$dir; $(MAKE) clean); \
+#		    fi; \
+#	    done ; \
+#	else true; fi
+
+distclean maintainer-clean realclean: clean
+	-rm -f *~ core
+	-rm -f Makefile config.status *-init.exp
+	-rm -fr *.log summary detail *.plog *.sum *.psum site.*
+#	if [ x"${SUBDIRS}" != x ] ; then \
+#	    for dir in ${SUBDIRS}; \
+#	    do \
+#		    echo "$$dir:"; \
+#		    if [ -d $$dir ]; then \
+#			    (cd $$dir; $(MAKE) distclean); \
+#		    fi; \
+#	    done ; \
+#	else true; fi
+
+Makefile : Makefile.in config.status
+	$(SHELL) config.status
+
+config.status: configure
+	$(SHELL) config.status --recheck
Index: sim/testsuite/brownie3264el-elf/configure
===================================================================
RCS file: sim/testsuite/brownie3264el-elf/configure
diff -N sim/testsuite/brownie3264el-elf/configure
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/testsuite/brownie3264el-elf/configure	8 Aug 2007 08:49:55 -0000	1.1
@@ -0,0 +1,2250 @@
+#! /bin/sh
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.59.
+#
+# Copyright (C) 2003 Free Software Foundation, Inc.
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+
+# Name of the host.
+# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
+
+exec 6>&1
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_config_libobj_dir=.
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+# Maximum number of lines to put in a shell here document.
+# This variable seems obsolete.  It should probably be removed, and
+# only ac_max_sed_lines should be used.
+: ${ac_max_here_lines=38}
+
+# Identity of this package.
+PACKAGE_NAME=
+PACKAGE_TARNAME=
+PACKAGE_VERSION=
+PACKAGE_STRING=
+PACKAGE_BUGREPORT=
+
+ac_unique_file="Makefile.in"
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS CC build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os LIBOBJS LTLIBOBJS'
+ac_subst_files=''
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can "make install exec_prefix=/foo"
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datadir='${prefix}/share'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+libdir='${exec_prefix}/lib'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+infodir='${prefix}/info'
+mandir='${prefix}/man'
+
+ac_prev=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval "$ac_prev=\$ac_option"
+    ac_prev=
+    continue
+  fi
+
+  ac_optarg=`expr "x$ac_option" : 'x[^=]*=\(.*\)'`
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_option in
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
+  | --da=*)
+    datadir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    eval "enable_$ac_feature=no" ;;
+
+  -enable-* | --enable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "enable_$ac_feature='$ac_optarg'" ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst \
+  | --locals | --local | --loca | --loc | --lo)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* \
+  | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_package=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "with_$ac_package='$ac_optarg'" ;;
+
+  -without-* | --without-*)
+    ac_package=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package | sed 's/-/_/g'`
+    eval "with_$ac_package=no" ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) { echo "$as_me: error: unrecognized option: $ac_option
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; }
+    ;;
+
+  *=*)
+    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid variable name: $ac_envvar" >&2
+   { (exit 1); exit 1; }; }
+    ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`
+    eval "$ac_envvar='$ac_optarg'"
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  { echo "$as_me: error: missing argument to $ac_option" >&2
+   { (exit 1); exit 1; }; }
+fi
+
+# Be sure to have absolute paths.
+for ac_var in exec_prefix prefix
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* | NONE | '' ) ;;
+    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# Be sure to have absolute paths.
+for ac_var in bindir sbindir libexecdir datadir sysconfdir sharedstatedir \
+	      localstatedir libdir includedir oldincludedir infodir mandir
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* ) ;;
+    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test "x$host_alias" != x; then
+  if test "x$build_alias" = x; then
+    cross_compiling=maybe
+    echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used." >&2
+  elif test "x$build_alias" != "x$host_alias"; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+test "$silent" = yes && exec 6>/dev/null
+
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then its parent.
+  ac_confdir=`(dirname "$0") 2>/dev/null ||
+$as_expr X"$0" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$0" : 'X\(//\)[^/]' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$0" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r $srcdir/$ac_unique_file; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r $srcdir/$ac_unique_file; then
+  if test "$ac_srcdir_defaulted" = yes; then
+    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $ac_confdir or .." >&2
+   { (exit 1); exit 1; }; }
+  else
+    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $srcdir" >&2
+   { (exit 1); exit 1; }; }
+  fi
+fi
+(cd $srcdir && test -r ./$ac_unique_file) 2>/dev/null ||
+  { echo "$as_me: error: sources are in $srcdir, but \`cd $srcdir' does not work" >&2
+   { (exit 1); exit 1; }; }
+srcdir=`echo "$srcdir" | sed 's%\([^\\/]\)[\\/]*$%\1%'`
+ac_env_build_alias_set=${build_alias+set}
+ac_env_build_alias_value=$build_alias
+ac_cv_env_build_alias_set=${build_alias+set}
+ac_cv_env_build_alias_value=$build_alias
+ac_env_host_alias_set=${host_alias+set}
+ac_env_host_alias_value=$host_alias
+ac_cv_env_host_alias_set=${host_alias+set}
+ac_cv_env_host_alias_value=$host_alias
+ac_env_target_alias_set=${target_alias+set}
+ac_env_target_alias_value=$target_alias
+ac_cv_env_target_alias_set=${target_alias+set}
+ac_cv_env_target_alias_value=$target_alias
+
+#
+# Report the --help message.
+#
+if test "$ac_init_help" = "long"; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat <<_ACEOF
+\`configure' configures this package to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+_ACEOF
+
+  cat <<_ACEOF
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+			  [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+			  [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR           user executables [EPREFIX/bin]
+  --sbindir=DIR          system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR       program executables [EPREFIX/libexec]
+  --datadir=DIR          read-only architecture-independent data [PREFIX/share]
+  --sysconfdir=DIR       read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR   modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR    modifiable single-machine data [PREFIX/var]
+  --libdir=DIR           object code libraries [EPREFIX/lib]
+  --includedir=DIR       C header files [PREFIX/include]
+  --oldincludedir=DIR    C header files for non-gcc [/usr/include]
+  --infodir=DIR          info documentation [PREFIX/info]
+  --mandir=DIR           man documentation [PREFIX/man]
+_ACEOF
+
+  cat <<\_ACEOF
+
+System types:
+  --build=BUILD     configure for building on BUILD [guessed]
+  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
+  --target=TARGET   configure for building compilers for TARGET [HOST]
+_ACEOF
+fi
+
+if test -n "$ac_init_help"; then
+
+  cat <<\_ACEOF
+
+_ACEOF
+fi
+
+if test "$ac_init_help" = "recursive"; then
+  # If there are subdirs, report their specific --help.
+  ac_popdir=`pwd`
+  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
+    test -d $ac_dir || continue
+    ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+    cd $ac_dir
+    # Check for guested configure; otherwise get Cygnus style configure.
+    if test -f $ac_srcdir/configure.gnu; then
+      echo
+      $SHELL $ac_srcdir/configure.gnu  --help=recursive
+    elif test -f $ac_srcdir/configure; then
+      echo
+      $SHELL $ac_srcdir/configure  --help=recursive
+    elif test -f $ac_srcdir/configure.ac ||
+	   test -f $ac_srcdir/configure.in; then
+      echo
+      $ac_configure --help
+    else
+      echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+    fi
+    cd $ac_popdir
+  done
+fi
+
+test -n "$ac_init_help" && exit 0
+if $ac_init_version; then
+  cat <<\_ACEOF
+
+Copyright (C) 2003 Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit 0
+fi
+exec 5>config.log
+cat >&5 <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by $as_me, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+hostinfo               = `(hostinfo) 2>/dev/null               || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  echo "PATH: $as_dir"
+done
+
+} >&5
+
+cat >&5 <<_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_sep=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
+      ac_arg=`echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) ac_configure_args0="$ac_configure_args0 '$ac_arg'" ;;
+    2)
+      ac_configure_args1="$ac_configure_args1 '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case "$ac_configure_args0 " in
+	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      ac_configure_args="$ac_configure_args$ac_sep'$ac_arg'"
+      # Get rid of the leading space.
+      ac_sep=" "
+      ;;
+    esac
+  done
+done
+$as_unset ac_configure_args0 || test "${ac_configure_args0+set}" != set || { ac_configure_args0=; export ac_configure_args0; }
+$as_unset ac_configure_args1 || test "${ac_configure_args1+set}" != set || { ac_configure_args1=; export ac_configure_args1; }
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Be sure not to use single quotes in there, as some shells,
+# such as our DU 5.0 friend, will then `close' the trap.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    cat <<\_ASBOX
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+_ASBOX
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+{
+  (set) 2>&1 |
+    case `(ac_space='"'"' '"'"'; set | grep ac_space) 2>&1` in
+    *ac_space=\ *)
+      sed -n \
+	"s/'"'"'/'"'"'\\\\'"'"''"'"'/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='"'"'\\2'"'"'/p"
+      ;;
+    *)
+      sed -n \
+	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+      ;;
+    esac;
+}
+    echo
+
+    cat <<\_ASBOX
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+_ASBOX
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=$`echo $ac_var`
+      echo "$ac_var='"'"'$ac_val'"'"'"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      cat <<\_ASBOX
+## ------------- ##
+## Output files. ##
+## ------------- ##
+_ASBOX
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=$`echo $ac_var`
+	echo "$ac_var='"'"'$ac_val'"'"'"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      cat <<\_ASBOX
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+_ASBOX
+      echo
+      sed "/^$/d" confdefs.h | sort
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      echo "$as_me: caught signal $ac_signal"
+    echo "$as_me: exit $exit_status"
+  } >&5
+  rm -f core *.core &&
+  rm -rf conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+     ' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -rf conftest* confdefs.h
+# AIX cpp loses on an empty file, so make sure it contains at least a newline.
+echo >confdefs.h
+
+# Predefined preprocessor variables.
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_NAME "$PACKAGE_NAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_VERSION "$PACKAGE_VERSION"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_STRING "$PACKAGE_STRING"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer explicitly selected file to automatically selected ones.
+if test -z "$CONFIG_SITE"; then
+  if test "x$prefix" != xNONE; then
+    CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
+  else
+    CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
+  fi
+fi
+for ac_site_file in $CONFIG_SITE; do
+  if test -r "$ac_site_file"; then
+    { echo "$as_me:$LINENO: loading site script $ac_site_file" >&5
+echo "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file"
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special
+  # files actually), so we avoid doing that.
+  if test -f "$cache_file"; then
+    { echo "$as_me:$LINENO: loading cache $cache_file" >&5
+echo "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . $cache_file;;
+      *)                      . ./$cache_file;;
+    esac
+  fi
+else
+  { echo "$as_me:$LINENO: creating cache $cache_file" >&5
+echo "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in `(set) 2>&1 |
+	       sed -n 's/^ac_env_\([a-zA-Z_0-9]*\)_set=.*/\1/p'`; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val="\$ac_cv_env_${ac_var}_value"
+  eval ac_new_val="\$ac_env_${ac_var}_value"
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was not set in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+	{ echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
+echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+	{ echo "$as_me:$LINENO:   former value:  $ac_old_val" >&5
+echo "$as_me:   former value:  $ac_old_val" >&2;}
+	{ echo "$as_me:$LINENO:   current value: $ac_new_val" >&5
+echo "$as_me:   current value: $ac_new_val" >&2;}
+	ac_cache_corrupted=:
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
+      ac_arg=$ac_var=`echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) ac_configure_args="$ac_configure_args '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
+echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  { { echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
+echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+CC=${CC-cc}
+
+ac_aux_dir=
+for ac_dir in `cd $srcdir;pwd`/../../.. $srcdir/`cd $srcdir;pwd`/../../..; do
+  if test -f $ac_dir/install-sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f $ac_dir/install.sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  elif test -f $ac_dir/shtool; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/shtool install -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  { { echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in \`cd $srcdir;pwd\`/../../.. $srcdir/\`cd $srcdir;pwd\`/../../.." >&5
+echo "$as_me: error: cannot find install-sh or install.sh in \`cd $srcdir;pwd\`/../../.. $srcdir/\`cd $srcdir;pwd\`/../../.." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"
+ac_configure="$SHELL $ac_aux_dir/configure" # This should be Cygnus configure.
+
+# Make sure we can run config.sub.
+$ac_config_sub sun4 >/dev/null 2>&1 ||
+  { { echo "$as_me:$LINENO: error: cannot run $ac_config_sub" >&5
+echo "$as_me: error: cannot run $ac_config_sub" >&2;}
+   { (exit 1); exit 1; }; }
+
+echo "$as_me:$LINENO: checking build system type" >&5
+echo $ECHO_N "checking build system type... $ECHO_C" >&6
+if test "${ac_cv_build+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_build_alias=$build_alias
+test -z "$ac_cv_build_alias" &&
+  ac_cv_build_alias=`$ac_config_guess`
+test -z "$ac_cv_build_alias" &&
+  { { echo "$as_me:$LINENO: error: cannot guess build type; you must specify one" >&5
+echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
+   { (exit 1); exit 1; }; }
+ac_cv_build=`$ac_config_sub $ac_cv_build_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_build_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_build_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_build" >&5
+echo "${ECHO_T}$ac_cv_build" >&6
+build=$ac_cv_build
+build_cpu=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+build_vendor=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+build_os=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+echo "$as_me:$LINENO: checking host system type" >&5
+echo $ECHO_N "checking host system type... $ECHO_C" >&6
+if test "${ac_cv_host+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_host_alias=$host_alias
+test -z "$ac_cv_host_alias" &&
+  ac_cv_host_alias=$ac_cv_build_alias
+ac_cv_host=`$ac_config_sub $ac_cv_host_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_host_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_host_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_host" >&5
+echo "${ECHO_T}$ac_cv_host" >&6
+host=$ac_cv_host
+host_cpu=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+echo "$as_me:$LINENO: checking target system type" >&5
+echo $ECHO_N "checking target system type... $ECHO_C" >&6
+if test "${ac_cv_target+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_target_alias=$target_alias
+test "x$ac_cv_target_alias" = "x" &&
+  ac_cv_target_alias=$ac_cv_host_alias
+ac_cv_target=`$ac_config_sub $ac_cv_target_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_target_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_target_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_target" >&5
+echo "${ECHO_T}$ac_cv_target" >&6
+target=$ac_cv_target
+target_cpu=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+target_vendor=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+target_os=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+# The aliases save the names the user supplied, while $host etc.
+# will get canonicalized.
+test -n "$target_alias" &&
+  test "$program_prefix$program_suffix$program_transform_name" = \
+    NONENONEs,x,x, &&
+  program_prefix=${target_alias}-
+
+
+
+
+          ac_config_files="$ac_config_files Makefile"
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, don't put newlines in cache variables' values.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+{
+  (set) 2>&1 |
+    case `(ac_space=' '; set | grep ac_space) 2>&1` in
+    *ac_space=\ *)
+      # `set' does not quote correctly, so add quotes (double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \).
+      sed -n \
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;;
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n \
+	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+      ;;
+    esac;
+} |
+  sed '
+     t clear
+     : clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     /^ac_cv_env/!s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     : end' >>confcache
+if diff $cache_file confcache >/dev/null 2>&1; then :; else
+  if test -w $cache_file; then
+    test "x$cache_file" != "x/dev/null" && echo "updating cache $cache_file"
+    cat confcache >$cache_file
+  else
+    echo "not updating unwritable cache $cache_file"
+  fi
+fi
+rm -f confcache
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+# VPATH may cause trouble with some makes, so we remove $(srcdir),
+# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/;
+s/:*\${srcdir}:*/:/;
+s/:*@srcdir@:*/:/;
+s/^\([^=]*=[	 ]*\):*/\1/;
+s/:*$//;
+s/^[^=]*=[	 ]*$//;
+}'
+fi
+
+# Transform confdefs.h into DEFS.
+# Protect against shell expansion while executing Makefile rules.
+# Protect against Makefile macro expansion.
+#
+# If the first sed substitution is executed (which looks for macros that
+# take arguments), then we branch to the quote section.  Otherwise,
+# look for a macro that doesn't take arguments.
+cat >confdef2opt.sed <<\_ACEOF
+t clear
+: clear
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 (][^	 (]*([^)]*)\)[	 ]*\(.*\),-D\1=\2,g
+t quote
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 ][^	 ]*\)[	 ]*\(.*\),-D\1=\2,g
+t quote
+d
+: quote
+s,[	 `~#$^&*(){}\\|;'"<>?],\\&,g
+s,\[,\\&,g
+s,\],\\&,g
+s,\$,$$,g
+p
+_ACEOF
+# We use echo to avoid assuming a particular line-breaking character.
+# The extra dot is to prevent the shell from consuming trailing
+# line-breaks from the sub-command output.  A line-break within
+# single-quotes doesn't work because, if this script is created in a
+# platform that uses two characters for line-breaks (e.g., DOS), tr
+# would break.
+ac_LF_and_DOT=`echo; echo .`
+DEFS=`sed -n -f confdef2opt.sed confdefs.h | tr "$ac_LF_and_DOT" ' .'`
+rm -f confdef2opt.sed
+
+
+ac_libobjs=
+ac_ltlibobjs=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_i=`echo "$ac_i" |
+	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+
+: ${CONFIG_STATUS=./config.status}
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ echo "$as_me:$LINENO: creating $CONFIG_STATUS" >&5
+echo "$as_me: creating $CONFIG_STATUS" >&6;}
+cat >$CONFIG_STATUS <<_ACEOF
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+SHELL=\${CONFIG_SHELL-$SHELL}
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { { echo "$as_me:$LINENO: error: cannot find myself; rerun with an absolute path" >&5
+echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { { echo "$as_me:$LINENO: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&5
+echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2;}
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+exec 6>&1
+
+# Open the log real soon, to keep \$[0] and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.  Logging --version etc. is OK.
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+} >&5
+cat >&5 <<_CSEOF
+
+This file was extended by $as_me, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+_CSEOF
+echo "on `(hostname || uname -n) 2>/dev/null | sed 1q`" >&5
+echo >&5
+_ACEOF
+
+# Files that config.status was made for.
+if test -n "$ac_config_files"; then
+  echo "config_files=\"$ac_config_files\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_headers"; then
+  echo "config_headers=\"$ac_config_headers\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_links"; then
+  echo "config_links=\"$ac_config_links\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_commands"; then
+  echo "config_commands=\"$ac_config_commands\"" >>$CONFIG_STATUS
+fi
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+ac_cs_usage="\
+\`$as_me' instantiates files from templates according to the
+current configuration.
+
+Usage: $0 [OPTIONS] [FILE]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number, then exit
+  -q, --quiet      do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+  --file=FILE[:TEMPLATE]
+		   instantiate the configuration file FILE
+
+Configuration files:
+$config_files
+
+Report bugs to <bug-autoconf@gnu.org>."
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+ac_cs_version="\\
+config.status
+configured by $0, generated by GNU Autoconf 2.59,
+  with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
+
+Copyright (C) 2003 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+srcdir=$srcdir
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+# If no file are specified by the user, then we need to provide default
+# value.  By we need to know if files were specified by the user.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr "x$1" : 'x\([^=]*\)='`
+    ac_optarg=`expr "x$1" : 'x[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  -*)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  *) # This is not an option, so the user has probably given explicit
+     # arguments.
+     ac_option=$1
+     ac_need_defaults=false;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --vers* | -V )
+    echo "$ac_cs_version"; exit 0 ;;
+  --he | --h)
+    # Conflict between --help and --header
+    { { echo "$as_me:$LINENO: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; };;
+  --help | --hel | -h )
+    echo "$ac_cs_usage"; exit 0 ;;
+  --debug | --d* | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    CONFIG_FILES="$CONFIG_FILES $ac_optarg"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    CONFIG_HEADERS="$CONFIG_HEADERS $ac_optarg"
+    ac_need_defaults=false;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) { { echo "$as_me:$LINENO: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; } ;;
+
+  *) ac_config_targets="$ac_config_targets $1" ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+if \$ac_cs_recheck; then
+  echo "running $SHELL $0 " $ac_configure_args \$ac_configure_extra_args " --no-create --no-recursion" >&6
+  exec $SHELL $0 $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+fi
+
+_ACEOF
+
+
+
+
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+for ac_config_target in $ac_config_targets
+do
+  case "$ac_config_target" in
+  # Handling of arguments.
+  "Makefile" ) CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+  *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
+echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason to put it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Create a temporary directory, and hook for its removal unless debugging.
+$debug ||
+{
+  trap 'exit_status=$?; rm -rf $tmp && exit $exit_status' 0
+  trap '{ (exit 1); exit 1; }' 1 2 13 15
+}
+
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d -q "./confstatXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=./confstat$$-$RANDOM
+  (umask 077 && mkdir $tmp)
+} ||
+{
+   echo "$me: cannot create a temporary directory in ." >&2
+   { (exit 1); exit 1; }
+}
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+
+#
+# CONFIG_FILES section.
+#
+
+# No need to generate the scripts if there are no CONFIG_FILES.
+# This happens for instance when ./config.status config.h
+if test -n "\$CONFIG_FILES"; then
+  # Protect against being on the right side of a sed subst in config.status.
+  sed 's/,@/@@/; s/@,/@@/; s/,;t t\$/@;t t/; /@;t t\$/s/[\\\\&,]/\\\\&/g;
+   s/@@/,@/; s/@@/@,/; s/@;t t\$/,;t t/' >\$tmp/subs.sed <<\\CEOF
+s,@SHELL@,$SHELL,;t t
+s,@PATH_SEPARATOR@,$PATH_SEPARATOR,;t t
+s,@PACKAGE_NAME@,$PACKAGE_NAME,;t t
+s,@PACKAGE_TARNAME@,$PACKAGE_TARNAME,;t t
+s,@PACKAGE_VERSION@,$PACKAGE_VERSION,;t t
+s,@PACKAGE_STRING@,$PACKAGE_STRING,;t t
+s,@PACKAGE_BUGREPORT@,$PACKAGE_BUGREPORT,;t t
+s,@exec_prefix@,$exec_prefix,;t t
+s,@prefix@,$prefix,;t t
+s,@program_transform_name@,$program_transform_name,;t t
+s,@bindir@,$bindir,;t t
+s,@sbindir@,$sbindir,;t t
+s,@libexecdir@,$libexecdir,;t t
+s,@datadir@,$datadir,;t t
+s,@sysconfdir@,$sysconfdir,;t t
+s,@sharedstatedir@,$sharedstatedir,;t t
+s,@localstatedir@,$localstatedir,;t t
+s,@libdir@,$libdir,;t t
+s,@includedir@,$includedir,;t t
+s,@oldincludedir@,$oldincludedir,;t t
+s,@infodir@,$infodir,;t t
+s,@mandir@,$mandir,;t t
+s,@build_alias@,$build_alias,;t t
+s,@host_alias@,$host_alias,;t t
+s,@target_alias@,$target_alias,;t t
+s,@DEFS@,$DEFS,;t t
+s,@ECHO_C@,$ECHO_C,;t t
+s,@ECHO_N@,$ECHO_N,;t t
+s,@ECHO_T@,$ECHO_T,;t t
+s,@LIBS@,$LIBS,;t t
+s,@CC@,$CC,;t t
+s,@build@,$build,;t t
+s,@build_cpu@,$build_cpu,;t t
+s,@build_vendor@,$build_vendor,;t t
+s,@build_os@,$build_os,;t t
+s,@host@,$host,;t t
+s,@host_cpu@,$host_cpu,;t t
+s,@host_vendor@,$host_vendor,;t t
+s,@host_os@,$host_os,;t t
+s,@target@,$target,;t t
+s,@target_cpu@,$target_cpu,;t t
+s,@target_vendor@,$target_vendor,;t t
+s,@target_os@,$target_os,;t t
+s,@LIBOBJS@,$LIBOBJS,;t t
+s,@LTLIBOBJS@,$LTLIBOBJS,;t t
+CEOF
+
+_ACEOF
+
+  cat >>$CONFIG_STATUS <<\_ACEOF
+  # Split the substitutions into bite-sized pieces for seds with
+  # small command number limits, like on Digital OSF/1 and HP-UX.
+  ac_max_sed_lines=48
+  ac_sed_frag=1 # Number of current file.
+  ac_beg=1 # First line for current file.
+  ac_end=$ac_max_sed_lines # Line after last line for current file.
+  ac_more_lines=:
+  ac_sed_cmds=
+  while $ac_more_lines; do
+    if test $ac_beg -gt 1; then
+      sed "1,${ac_beg}d; ${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    else
+      sed "${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    fi
+    if test ! -s $tmp/subs.frag; then
+      ac_more_lines=false
+    else
+      # The purpose of the label and of the branching condition is to
+      # speed up the sed processing (if there are no `@' at all, there
+      # is no need to browse any of the substitutions).
+      # These are the two extra sed commands mentioned above.
+      (echo ':t
+  /@[a-zA-Z_][a-zA-Z_0-9]*@/!b' && cat $tmp/subs.frag) >$tmp/subs-$ac_sed_frag.sed
+      if test -z "$ac_sed_cmds"; then
+	ac_sed_cmds="sed -f $tmp/subs-$ac_sed_frag.sed"
+      else
+	ac_sed_cmds="$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed"
+      fi
+      ac_sed_frag=`expr $ac_sed_frag + 1`
+      ac_beg=$ac_end
+      ac_end=`expr $ac_end + $ac_max_sed_lines`
+    fi
+  done
+  if test -z "$ac_sed_cmds"; then
+    ac_sed_cmds=cat
+  fi
+fi # test -n "$CONFIG_FILES"
+
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+for ac_file in : $CONFIG_FILES; do test "x$ac_file" = x: && continue
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+	cat >$tmp/stdin
+	ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
+  esac
+
+  # Compute @srcdir@, @top_srcdir@, and @INSTALL@ for subdirectories.
+  ac_dir=`(dirname "$ac_file") 2>/dev/null ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+
+
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x"$ac_file" = x-; then
+    configure_input=
+  else
+    configure_input="$ac_file.  "
+  fi
+  configure_input=$configure_input"Generated from `echo $ac_file_in |
+				     sed 's,.*/,,'` by configure."
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+	 # Absolute (can't be DOS-style, as IFS=:)
+	 test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 echo "$f";;
+      *) # Relative
+	 if test -f "$f"; then
+	   # Build tree
+	   echo "$f"
+	 elif test -f "$srcdir/$f"; then
+	   # Source tree
+	   echo "$srcdir/$f"
+	 else
+	   # /dev/null tree
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+  sed "$ac_vpsub
+$extrasub
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s,@configure_input@,$configure_input,;t t
+s,@srcdir@,$ac_srcdir,;t t
+s,@abs_srcdir@,$ac_abs_srcdir,;t t
+s,@top_srcdir@,$ac_top_srcdir,;t t
+s,@abs_top_srcdir@,$ac_abs_top_srcdir,;t t
+s,@builddir@,$ac_builddir,;t t
+s,@abs_builddir@,$ac_abs_builddir,;t t
+s,@top_builddir@,$ac_top_builddir,;t t
+s,@abs_top_builddir@,$ac_abs_top_builddir,;t t
+" $ac_file_inputs | (eval "$ac_sed_cmds") >$tmp/out
+  rm -f $tmp/stdin
+  if test x"$ac_file" != x-; then
+    mv $tmp/out $ac_file
+  else
+    cat $tmp/out
+    rm -f $tmp/out
+  fi
+
+done
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+{ (exit 0); exit 0; }
+_ACEOF
+chmod +x $CONFIG_STATUS
+ac_clean_files=$ac_clean_files_save
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test "$no_create" != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
+  exec 5>/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5>>config.log
+  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || { (exit 1); exit 1; }
+fi
+
Index: sim/testsuite/brownie3264el-elf/configure.ac
===================================================================
RCS file: sim/testsuite/brownie3264el-elf/configure.ac
diff -N sim/testsuite/brownie3264el-elf/configure.ac
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/testsuite/brownie3264el-elf/configure.ac	8 Aug 2007 08:49:55 -0000	1.1
@@ -0,0 +1,19 @@
+dnl Process this file file with autoconf to produce a configure script.
+dnl This file is a shell script fragment that supplies the information
+dnl necessary to tailor a template configure script into the configure
+dnl script appropriate for this directory.  For more information, check
+dnl any existing configure script.
+
+AC_PREREQ(2.59)
+dnl FIXME - think of a truly uniq file to this directory
+AC_INIT(Makefile.in)
+
+CC=${CC-cc}
+AC_SUBST(CC)
+AC_CONFIG_AUX_DIR(`cd $srcdir;pwd`/../../..)
+AC_CANONICAL_SYSTEM
+
+AC_SUBST(target_cpu)
+
+
+AC_OUTPUT(Makefile)
Index: sim/testsuite/sim/brownie32/ChangeLog
===================================================================
RCS file: sim/testsuite/sim/brownie32/ChangeLog
diff -N sim/testsuite/sim/brownie32/ChangeLog
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/testsuite/sim/brownie32/ChangeLog	8 Aug 2007 08:49:55 -0000	1.1
@@ -0,0 +1,40 @@
+2004-04-11  Chris Demetriou  <cgd@broadcom.com>
+
+	* utils-fpu.inc (enable_fpu, ckm_fp_cc): New macros.
+	(clrset_fp_cc): Fix mask used for upper 7 condition codes.
+	* utils-mdmx.inc: Include utils-fpu.inc.
+	(enable_mdmx): Use enable_fpu.
+
+2004-04-10  Chris Demetriou  <cgd@broadcom.com>
+
+	* utils-fpu.inc: New file.
+	* utils-mdmx.inc: New file.
+	* mdmx-ob.s: New file.
+	* mdmx-ob-sb1.s: New file.
+	* basic.exp: Run new mdmx-ob and mdmx-ob-sb1 tests.
+
+2004-04-10  Chris Demetriou  <cgd@broadcom.com>
+
+	* fpu64-ps-sb1.s: New file.
+	* basic.exp: Recognize mipsisa64sb1 targets, and run fpu64-ps-sb1.s
+	if appropriate.
+
+2004-04-10  Chris Demetriou  <cgd@broadcom.com>
+
+	* fpu64-ps.s: New file.
+	* basic.exp: Run fpu64-ps.s.
+
+2004-03-29  Richard Sandiford  <rsandifo@redhat.com>
+
+	* hilo-hazard-[123].s: New files.
+	* basic.exp (run_hilo_test): New procedure.
+	(models): Only list models that are included in the configuration.
+	(submodels): New variable, set to submodels of the above.
+	(mips64vr-*-elf, mips64vrel-*-elf): New configuration stanza.
+	Run hilo-hazard-[123].s.
+
+2004-01-26  Chris Demetriou  <cgd@broadcom.com>
+
+	* basic.exp: New file.
+	* testutils.inc: New file.
+	* sanity.s: New file.
Index: sim/testsuite/sim/brownie32/basic.exp
===================================================================
RCS file: sim/testsuite/sim/brownie32/basic.exp
diff -N sim/testsuite/sim/brownie32/basic.exp
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/testsuite/sim/brownie32/basic.exp	8 Aug 2007 08:49:55 -0000	1.1
@@ -0,0 +1,74 @@
+# MIPS simulator instruction tests
+
+# As gross as it is, we unset the linker script specifid by the target
+# board.  The MIPS libgloss linker scripts include libgcc (and possibly
+# other libraries), which the linker (used to link these tests rather
+# than the compiler) can't necessarily find.
+unset_currtarget_info ldscript
+
+# Do "run_sim_test TESTFILE MODELS" for each combination of the
+# mf{lo,hi} -> mult/div/mt{lo,hi} hazard described in mips.igen.
+# Insert NOPS nops after the mflo or mfhi.
+proc run_hilo_test {testfile models nops} {
+    foreach reg {lo hi} {
+	foreach insn "{mult\t\$4,\$4} {div\t\$0,\$4,\$4} {mt$reg\t\$4}" {
+	    set contents ""
+	    append contents "\t.macro hilo\n"
+	    append contents "\tmf$reg\t\$4\n"
+	    append contents "\t.rept\t$nops\n"
+	    append contents "\tnop\n"
+	    append contents "\t.endr\n"
+	    append contents "\t$insn\n"
+	    append contents "\t.endm"
+
+	    verbose -log "HILO test:\n$contents"
+	    set file [open hilo-hazard.inc w]
+	    puts $file $contents
+	    close $file
+
+	    run_sim_test $testfile $models
+	}
+    }
+}
+
+
+# Only test mips*-elf (e.g., no mips-linux), and only test if the target
+# board really is a simulator (sim tests don't work on real HW).
+if {[istarget mips*-elf] && [board_info target exists is_simulator]} {
+
+    if {[istarget mipsisa64sb1*-elf]} {
+	set models "sb1"
+	set submodels "mips1 mips2 mips3 mips4 mips32 mips64"
+    } elseif {[istarget mipsisa64*-elf]} {
+	set models "mips32 mips64"
+	set submodels "mips1 mips2 mips3 mips4"
+    } elseif {[istarget mipsisa32*-elf]} {
+	set models "mips32"
+	set submodels "mips1 mips2"
+    } elseif {[istarget mips64vr-*-elf] || [istarget mips64vrel-*-elf]} {
+	set models "vr4100 vr4111 vr4120 vr5000 vr5400 vr5500"
+	set submodels "mips1 mips2 mips3 mips4"
+    } elseif {[istarget mips64*-elf]} {
+	set models "mips3"
+	set submodels "mips1 mips2"
+    } else {
+	# fall back to just testing mips1 code.
+	set models "mips1"
+	set submodels ""
+    }
+    append submodels " " $models
+    set cpu_option -march
+
+    run_sim_test sanity.s $submodels
+    foreach nops {0 1} {
+	run_hilo_test hilo-hazard-1.s $models $nops
+	run_hilo_test hilo-hazard-2.s $models $nops
+    }
+    run_hilo_test hilo-hazard-3.s $models 2
+
+    run_sim_test fpu64-ps.s $submodels
+    run_sim_test fpu64-ps-sb1.s $submodels
+
+    run_sim_test mdmx-ob.s $submodels
+    run_sim_test mdmx-ob-sb1.s $submodels
+}
Index: sim/testsuite/sim/brownie32/fpu64-ps-sb1.s
===================================================================
RCS file: sim/testsuite/sim/brownie32/fpu64-ps-sb1.s
diff -N sim/testsuite/sim/brownie32/fpu64-ps-sb1.s
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/testsuite/sim/brownie32/fpu64-ps-sb1.s	8 Aug 2007 08:49:55 -0000	1.1
@@ -0,0 +1,72 @@
+# mips test sanity, expected to pass.
+# mach:	 sb1
+# as:		-mabi=eabi
+# ld:		-N -Ttext=0x80010000
+# output:	*\\npass\\n
+
+	.include "testutils.inc"
+
+        .macro check_ps psval, upperval, lowerval
+	.set push
+	.set noreorder
+	cvt.s.pu	$f0, \psval		# upper
+	cvt.s.pl	$f2, \psval		# lower
+	li.s		$f4, \upperval
+	li.s		$f6, \lowerval
+	c.eq.s		$fcc0, $f0, $f4
+	bc1f		$fcc0, _fail
+	 c.eq.s		$fcc0, $f2, $f6
+	bc1f		$fcc0, _fail
+	 nop
+	.set pop
+        .endm
+
+	setup
+
+	.set noreorder
+
+	.ent DIAG
+DIAG:
+
+	# make sure that Status.FR, .CU1, and .SBX are set.
+	mfc0	$2, $12
+	or	$2, $2, (1 << 26) | (1 << 29) | (1 << 16)
+	mtc0	$2, $12
+
+
+	li.s	$f10, 4.0
+	li.s	$f12, 16.0
+	cvt.ps.s $f20, $f10, $f12		# $f20: u=4.0, l=16.0
+
+	li.s	$f10, -1.0
+	li.s	$f12, 2.0
+	cvt.ps.s $f22, $f10, $f12		# $f22: u=-1.0, l=2.0
+
+
+	writemsg "div.ps"
+
+	div.ps $f8, $f20, $f22
+	check_ps $f8, -4.0, 8.0
+
+
+	writemsg "recip.ps"
+
+	recip.ps $f8, $f20
+	check_ps $f8, 0.25, 0.0625
+
+
+	writemsg "rsqrt.ps"
+
+	rsqrt.ps $f8, $f20
+	check_ps $f8, 0.5, 0.25
+
+
+	writemsg "sqrt.ps"
+
+	sqrt.ps $f8, $f20
+	check_ps $f8, 2.0, 4.0
+
+
+	pass
+
+	.end DIAG
Index: sim/testsuite/sim/brownie32/fpu64-ps.s
===================================================================
RCS file: sim/testsuite/sim/brownie32/fpu64-ps.s
diff -N sim/testsuite/sim/brownie32/fpu64-ps.s
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/testsuite/sim/brownie32/fpu64-ps.s	8 Aug 2007 08:49:55 -0000	1.1
@@ -0,0 +1,367 @@
+# mips test sanity, expected to pass.
+# mach:	 mips64 sb1
+# as:		-mabi=eabi
+# ld:		-N -Ttext=0x80010000
+# output:	*\\npass\\n
+
+	.include "testutils.inc"
+
+        .macro check_ps psval, upperval, lowerval
+	.set push
+	.set noreorder
+	cvt.s.pu	$f0, \psval		# upper
+	cvt.s.pl	$f2, \psval		# lower
+	li.s		$f4, \upperval
+	li.s		$f6, \lowerval
+	c.eq.s		$fcc0, $f0, $f4
+	bc1f		$fcc0, _fail
+	 c.eq.s		$fcc0, $f2, $f6
+	bc1f		$fcc0, _fail
+	 nop
+	.set pop
+        .endm
+
+	setup
+
+	.set noreorder
+
+	.ent DIAG
+DIAG:
+
+	# make sure that Status.FR and .CU1 are set.
+	mfc0	$2, $12
+	or	$2, $2, (1 << 26) | (1 << 29)
+	mtc0	$2, $12
+
+
+	writemsg "ldc1"
+
+	.data
+1:	.dword	0xc1a8000042200000		# -21.0, 40.0
+	.text
+	la	$2, 1b
+	ldc1	$f8, 0($2)
+	check_ps $f8, -21.0, 40.0
+
+
+	writemsg "cvt.ps.s"
+
+	li.s	$f10, 1.0
+	li.s	$f12, 3.0
+	cvt.ps.s $f8, $f10, $f12		# upper, lower
+	check_ps $f8, 1.0, 3.0
+
+
+	writemsg "cvt.ps.s, sdc1, copy, ldc1"
+
+	.data
+1:	.dword	0
+	.dword	0
+	.text
+	la	$2, 1b
+	li.s	$f12, -4.0
+	li.s	$f14, 32.0
+	cvt.ps.s $f10, $f12, $f14		# upper, lower
+	sdc1	$f10, 8($2)
+	lw	$3, 8($2)
+	lw	$4, 12($2)
+	sw	$3, 0($2)
+	sw	$4, 4($2)
+	ldc1	$f8, 0($2)
+	check_ps $f8, -4.0, 32.0
+
+
+	# Load some constants for later use
+
+	li.s	$f10, 4.0
+	li.s	$f12, 16.0
+	cvt.ps.s $f20, $f10, $f12		# $f20: u=4.0, l=16.0
+
+	li.s	$f10, -1.0
+	li.s	$f12, 2.0
+	cvt.ps.s $f22, $f10, $f12		# $f22: u=-1.0, l=2.0
+
+	li.s	$f10, 17.0
+	li.s	$f12, -8.0
+	cvt.ps.s $f24, $f10, $f12		# $f24: u=17.0, l=-8.0
+
+
+	writemsg "pll.ps"
+
+	pll.ps	$f8, $f20, $f22
+	check_ps $f8, 16.0, 2.0
+
+
+	writemsg "plu.ps"
+
+	plu.ps	$f8, $f20, $f22
+	check_ps $f8, 16.0, -1.0
+
+
+	writemsg "pul.ps"
+
+	pul.ps	$f8, $f20, $f22
+	check_ps $f8, 4.0, 2.0
+
+
+	writemsg "puu.ps"
+
+	puu.ps	$f8, $f20, $f22
+	check_ps $f8, 4.0, -1.0
+
+
+	writemsg "abs.ps"
+
+	abs.ps	$f8, $f22
+	check_ps $f8, 1.0, 2.0
+
+
+	writemsg "mov.ps"
+
+	mov.ps	$f8, $f22
+	check_ps $f8, -1.0, 2.0
+
+
+	writemsg "neg.ps"
+
+	neg.ps	$f8, $f22
+	check_ps $f8, 1.0, -2.0
+
+
+	writemsg "add.ps"
+
+	add.ps	$f8, $f20, $f22
+	check_ps $f8, 3.0, 18.0
+
+
+	writemsg "mul.ps"
+
+	mul.ps	$f8, $f20, $f22
+	check_ps $f8, -4.0, 32.0
+
+
+	writemsg "sub.ps"
+
+	sub.ps	$f8, $f20, $f22
+	check_ps $f8, 5.0, 14.0
+
+
+	writemsg "madd.ps"
+
+	madd.ps	$f8, $f24, $f20, $f22
+	check_ps $f8, 13.0, 24.0
+
+
+	writemsg "msub.ps"
+
+	msub.ps	$f8, $f24, $f20, $f22
+	check_ps $f8, -21.0, 40.0
+
+
+	writemsg "nmadd.ps"
+
+	nmadd.ps $f8, $f24, $f20, $f22
+	check_ps $f8, -13.0, -24.0
+
+
+	writemsg "nmsub.ps"
+
+	nmsub.ps $f8, $f24, $f20, $f22
+	check_ps $f8, 21.0, -40.0
+
+
+	writemsg "movn.ps (n)"
+
+	li	$2, 0
+	mov.ps	$f8, $f20
+	movn.ps	$f8, $f22, $2		# doesn't move
+	check_ps $f8, 4.0, 16.0
+
+
+	writemsg "movn.ps (y)"
+
+	li	$2, 1
+	mov.ps	$f8, $f20
+	movn.ps	$f8, $f22, $2		# does move
+	check_ps $f8, -1.0, 2.0
+
+
+	writemsg "movz.ps (y)"
+
+	li	$2, 0
+	mov.ps	$f8, $f20
+	movz.ps	$f8, $f22, $2		# does move
+	check_ps $f8, -1.0, 2.0
+
+
+	writemsg "movz.ps (n)"
+
+	li	$2, 1
+	mov.ps	$f8, $f20
+	movz.ps	$f8, $f22, $2		# doesn't move
+	check_ps $f8, 4.0, 16.0
+
+
+	writemsg "movf.ps (y,y)"
+
+	cfc1	$2, $31	
+	or	$2, $2, (1 << 23) | (1 << 25)
+	xor	$2, $2, (1 << 23) | (1 << 25)
+	ctc1	$2, $31			# clear fcc0, clear fcc1
+	mov.ps	$f8, $f20
+	movf.ps	$f8, $f22, $fcc0	# moves both halves
+	check_ps $f8, -1.0, 2.0
+
+
+	writemsg "movf.ps (y,n)"
+
+	cfc1	$2, $31	
+	or	$2, $2, (1 << 23) | (1 << 25)
+	xor	$2, $2, (0 << 23) | (1 << 25)
+	ctc1	$2, $31			# set fcc0, clear fcc1
+	mov.ps	$f8, $f20
+	movf.ps	$f8, $f22, $fcc0	# moves upper half only
+	check_ps $f8, -1.0, 16.0
+
+
+	writemsg "movf.ps (n,y)"
+
+	cfc1	$2, $31	
+	or	$2, $2, (1 << 23) | (1 << 25)
+	xor	$2, $2, (1 << 23) | (0 << 25)
+	ctc1	$2, $31			# clear fcc0, set fcc1
+	mov.ps	$f8, $f20
+	movf.ps	$f8, $f22, $fcc0	# moves lower half only
+	check_ps $f8, 4.0, 2.0
+
+
+	writemsg "movf.ps (n,n)"
+
+	cfc1	$2, $31	
+	or	$2, $2, (1 << 23) | (1 << 25)
+	xor	$2, $2, (0 << 23) | (0 << 25)
+	ctc1	$2, $31			# set fcc0, set fcc1
+	mov.ps	$f8, $f20
+	movf.ps	$f8, $f22, $fcc0	# doesn't move either half
+	check_ps $f8, 4.0, 16.0
+
+
+	writemsg "movt.ps (n,n)"
+
+	cfc1	$2, $31	
+	or	$2, $2, (1 << 23) | (1 << 25)
+	xor	$2, $2, (1 << 23) | (1 << 25)
+	ctc1	$2, $31			# clear fcc0, clear fcc1
+	mov.ps	$f8, $f20
+	movt.ps	$f8, $f22, $fcc0	# doesn't move either half
+	check_ps $f8, 4.0, 16.0
+
+
+	writemsg "movt.ps (n,y)"
+
+	cfc1	$2, $31	
+	or	$2, $2, (1 << 23) | (1 << 25)
+	xor	$2, $2, (0 << 23) | (1 << 25)
+	ctc1	$2, $31			# set fcc0, clear fcc1
+	mov.ps	$f8, $f20
+	movt.ps	$f8, $f22, $fcc0	# moves lower half only
+	check_ps $f8, 4.0, 2.0
+
+
+	writemsg "movt.ps (y,n)"
+
+	cfc1	$2, $31	
+	or	$2, $2, (1 << 23) | (1 << 25)
+	xor	$2, $2, (1 << 23) | (0 << 25)
+	ctc1	$2, $31			# clear fcc0, set fcc1
+	mov.ps	$f8, $f20
+	movt.ps	$f8, $f22, $fcc0	# moves upper half only
+	check_ps $f8, -1.0, 16.0
+
+
+	writemsg "movt.ps (y,y)"
+
+	cfc1	$2, $31	
+	or	$2, $2, (1 << 23) | (1 << 25)
+	xor	$2, $2, (0 << 23) | (0 << 25)
+	ctc1	$2, $31			# set fcc0, set fcc1
+	mov.ps	$f8, $f20
+	movt.ps	$f8, $f22, $fcc0	# moves both halves
+	check_ps $f8, -1.0, 2.0
+
+
+	writemsg "alnv.ps (aligned)"
+
+	.data
+1:	.dword	0xc1a8000042200000		# -21.0, 40.0
+	.dword	0xc228000041a00000		# -42.0, 20.0
+	.text
+	la	$2, 1b
+	li	$3, 0
+	addu	$4, $3, 8
+	luxc1	$f10, $3($2)
+	luxc1	$f12, $4($2)
+	alnv.ps	$f8, $f10, $f12, $3
+	check_ps $f8, -21.0, 40.0
+
+
+	writemsg "alnv.ps (unaligned)"
+
+	.data
+1:	.dword	0xc1a8000042200000		# -21.0, 40.0
+	.dword	0xc228000041a00000		# -42.0, 20.0
+	.hword	0x0001
+	.text
+	la	$2, 1b
+	li	$3, 4
+	addu	$4, $3, 8
+	luxc1	$f10, $3($2)
+	luxc1	$f12, $4($2)
+	alnv.ps	$f8, $f10, $f12, $3
+
+	lb	$5, 16($2)
+	bnez	$5, 2f				# little endian
+	 nop
+
+	# big endian
+	check_ps $f8, 40.0, -42.0
+	b	3f
+	 nop
+2:
+	# little endian
+	check_ps $f8, 20.0, -21.0
+3:
+
+
+	# We test c.cond.ps only lightly, just to make sure it modifies
+	# two bits and compares the halves separately.  Perhaps it should
+	# be tested more thoroughly.
+
+	writemsg "c.f.ps"
+
+	cfc1	$2, $31	
+	or	$2, $2, (1 << 23) | (0x7f << 25)
+	ctc1	$2, $31			# set all fcc bits
+	c.f.ps	$fcc0, $f8, $f8		# -> f, f
+	bc1t	$fcc0, _fail
+	 nop
+	bc1t	$fcc1, _fail
+	 nop
+
+	
+	writemsg "c.olt.ps"
+
+	cfc1	$2, $31	
+	or	$2, $2, (1 << 23) | (0x7f << 25)
+	xor	$2, $2, (1 << 23) | (0x7f << 25)
+	ctc1	$2, $31			# clear all fcc bits
+	c.lt.ps $fcc0, $f22, $f24	# -> f, t
+	bc1t	$fcc0, _fail
+	 nop
+	bc1f	$fcc1, _fail
+	 nop
+	
+
+	pass
+
+	.end DIAG
Index: sim/testsuite/sim/brownie32/hilo-hazard-1.s
===================================================================
RCS file: sim/testsuite/sim/brownie32/hilo-hazard-1.s
diff -N sim/testsuite/sim/brownie32/hilo-hazard-1.s
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/testsuite/sim/brownie32/hilo-hazard-1.s	8 Aug 2007 08:49:55 -0000	1.1
@@ -0,0 +1,19 @@
+# Test for architectures with mf{hi,lo} -> mult/div/mt{hi,lo} hazards.
+#
+# mach:		mips1 mips2 mips3 mips4 vr4100 vr4111 vr4120 vr5000 vr5400
+# as:		-mabi=eabi
+# ld:		-N -Ttext=0x80010000
+# output:	HILO: * too close to MF at *\\n\\nprogram stopped*\\n
+# xerror:
+
+	.include "hilo-hazard.inc"
+	.include "testutils.inc"
+
+	setup
+
+	.set noreorder
+	.ent DIAG
+DIAG:
+	hilo
+	pass
+	.end DIAG
Index: sim/testsuite/sim/brownie32/hilo-hazard-2.s
===================================================================
RCS file: sim/testsuite/sim/brownie32/hilo-hazard-2.s
diff -N sim/testsuite/sim/brownie32/hilo-hazard-2.s
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/testsuite/sim/brownie32/hilo-hazard-2.s	8 Aug 2007 08:49:55 -0000	1.1
@@ -0,0 +1,18 @@
+# Test for architectures without mf{hi,lo} -> mult/div/mt{hi,lo} hazards.
+#
+# mach:		vr5500 mips32 mips64
+# as:		-mabi=eabi
+# ld:		-N -Ttext=0x80010000
+# output:	pass\\n
+
+	.include "hilo-hazard.inc"
+	.include "testutils.inc"
+
+	setup
+
+	.set noreorder
+	.ent DIAG
+DIAG:
+	hilo
+	pass
+	.end DIAG
Index: sim/testsuite/sim/brownie32/hilo-hazard-3.s
===================================================================
RCS file: sim/testsuite/sim/brownie32/hilo-hazard-3.s
diff -N sim/testsuite/sim/brownie32/hilo-hazard-3.s
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/testsuite/sim/brownie32/hilo-hazard-3.s	8 Aug 2007 08:49:55 -0000	1.1
@@ -0,0 +1,18 @@
+# Test for mf{hi,lo} -> mult/div/mt{hi,lo} with 2 nops inbetween.
+#
+# mach:		all
+# as:		-mabi=eabi
+# ld:		-N -Ttext=0x80010000
+# output:	pass\\n
+
+	.include "hilo-hazard.inc"
+	.include "testutils.inc"
+
+	setup
+
+	.set noreorder
+	.ent DIAG
+DIAG:
+	hilo
+	pass
+	.end DIAG
Index: sim/testsuite/sim/brownie32/mdmx-ob-sb1.s
===================================================================
RCS file: sim/testsuite/sim/brownie32/mdmx-ob-sb1.s
diff -N sim/testsuite/sim/brownie32/mdmx-ob-sb1.s
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/testsuite/sim/brownie32/mdmx-ob-sb1.s	8 Aug 2007 08:49:55 -0000	1.1
@@ -0,0 +1,102 @@
+# MDMX .OB op tests.
+# mach:	 sb1
+# as:		-mabi=eabi
+# ld:		-N -Ttext=0x80010000
+# output:	*\\npass\\n
+
+	.include "testutils.inc"
+	.include "utils-mdmx.inc"
+
+	setup
+
+	.set noreorder
+
+	.ent DIAG
+DIAG:
+
+	enable_mdmx
+
+	# set Status.SBX to enable SB-1 extensions.
+	mfc0	$2, $12
+	or	$2, $2, (1 << 16)
+	mtc0	$2, $12
+
+
+	###
+	### SB-1 Non-accumulator .ob format ops.
+	###
+	### Key: v = vector
+	###      ev = vector of single element
+	###      cv = vector of constant.
+	###
+
+
+	writemsg "pavg.ob (v)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	pavg.ob	$f10, $f8, $f9
+	ck_ob $f10, 0x3c4d5e6f8091a2b3
+
+	writemsg "pavg.ob (ev)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	pavg.ob	$f10, $f8, $f9[6]
+	ck_ob $f10, 0x444d555e666f7780
+
+	writemsg "pavg.ob (cv)"
+	ld_ob	$f8, 0x1122334455667788
+	pavg.ob	$f10, $f8, 0x10
+	ck_ob $f10, 0x1119222a333b444c
+
+
+	writemsg "pabsdiff.ob (v)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	pabsdiff.ob	$f10, $f8, $f9
+	ck_ob $f10, 0x5555555555555555
+
+	writemsg "pabsdiff.ob (ev)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	pabsdiff.ob	$f10, $f8, $f9[7]
+	ck_ob $f10, 0x5544332211001122
+
+	writemsg "pabsdiff.ob (cv)"
+	ld_ob	$f8, 0x0001020304050607
+	pabsdiff.ob	$f10, $f8, 0x04
+	ck_ob $f10, 0x0403020100010203
+
+
+	###
+	### SB-1 Accumulator .ob format ops
+	###
+	### Key: v = vector
+	###      ev = vector of single element
+	###      cv = vector of constant.
+	###
+
+
+	writemsg "pabsdiffc.ob (v)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	pabsdiffc.ob $f8, $f9
+	ck_acc_ob 0x0001020304050607, 0x0000000000000000, 0x5555555555555555
+
+	writemsg "pabsdiffc.ob (ev)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	pabsdiffc.ob $f8, $f9[7]
+	ck_acc_ob 0x0001020304050607, 0x0000000000000000, 0x5544332211001122
+
+	writemsg "pabsdiffc.ob (cv)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x0001020304050607
+	pabsdiffc.ob $f8, 0x04
+	ck_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0403020100010203
+
+
+	pass
+
+	.end DIAG
Index: sim/testsuite/sim/brownie32/mdmx-ob.s
===================================================================
RCS file: sim/testsuite/sim/brownie32/mdmx-ob.s
diff -N sim/testsuite/sim/brownie32/mdmx-ob.s
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/testsuite/sim/brownie32/mdmx-ob.s	8 Aug 2007 08:49:55 -0000	1.1
@@ -0,0 +1,631 @@
+# MDMX .OB op tests.
+# mach:	 mips64 sb1
+# as:		-mabi=eabi
+# as(mips64):	-mabi=eabi -mdmx
+# ld:		-N -Ttext=0x80010000
+# output:	*\\npass\\n
+
+	.include "testutils.inc"
+	.include "utils-fpu.inc"
+	.include "utils-mdmx.inc"
+
+	setup
+
+	.set noreorder
+
+	.ent DIAG
+DIAG:
+
+	enable_mdmx
+
+
+	###
+	### Non-accumulator, non-CC-using .ob format ops.
+	###
+	### Key: v = vector
+	###      ev = vector of single element
+	###      cv = vector of constant.
+	###
+
+
+	writemsg "add.ob (v)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	add.ob	$f10, $f8, $f9
+	ck_ob	$f10, 0x7799bbddffffffff
+
+	writemsg "add.ob (ev)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	add.ob	$f10, $f8, $f9[6]
+	ck_ob	$f10, 0x8899aabbccddeeff
+
+	writemsg "add.ob (cv)"
+	ld_ob	$f8, 0x1122334455667788
+	add.ob	$f10, $f8, 0x10
+	ck_ob	$f10, 0x2132435465768798
+
+
+	writemsg "alni.ob"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	alni.ob	$f10, $f8, $f9, 3
+	ck_ob	$f10, 0x4455667788667788
+
+
+	writemsg "alnv.ob"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	li	$4, 5
+	alnv.ob	$f10, $f8, $f9, $4
+	ck_ob	$f10, 0x66778866778899aa
+
+
+	writemsg "and.ob (v)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	and.ob	$f10, $f8, $f9
+	ck_ob	$f10, 0x0022000000224488
+
+	writemsg "and.ob (ev)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	and.ob	$f10, $f8, $f9[4]
+	ck_ob	$f10, 0x1100110011001188
+
+	writemsg "and.ob (cv)"
+	ld_ob	$f8, 0x1122334455667788
+	and.ob	$f10, $f8, 0x1e
+	ck_ob	$f10, 0x1002120414061608
+
+
+	writemsg "max.ob (v)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	max.ob	$f10, $f8, $f9
+	ck_ob	$f10, 0x66778899aabbccdd
+
+	writemsg "max.ob (ev)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	max.ob	$f10, $f8, $f9[7]
+	ck_ob	$f10, 0x6666666666667788
+
+	writemsg "max.ob (cv)"
+	ld_ob	$f8, 0x1122334455667788
+	max.ob	$f10, $f8, 0x15
+	ck_ob	$f10, 0x1522334455667788
+
+
+	writemsg "min.ob (v)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	min.ob	$f10, $f8, $f9
+	ck_ob	$f10, 0x1122334455667788
+
+	writemsg "min.ob (ev)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	min.ob	$f10, $f8, $f9[7]
+	ck_ob	$f10, 0x1122334455666666
+
+	writemsg "min.ob (cv)"
+	ld_ob	$f8, 0x1122334455667788
+	min.ob	$f10, $f8, 0x15
+	ck_ob	$f10, 0x1115151515151515
+
+
+	writemsg "mul.ob (v)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x0001020304050607
+	mul.ob	$f10, $f8, $f9
+	ck_ob	$f10, 0x002266ccffffffff
+
+	writemsg "mul.ob (ev)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x0001020304050607
+	mul.ob	$f10, $f8, $f9[4]
+	ck_ob	$f10, 0x336699ccffffffff
+
+	writemsg "mul.ob (cv)"
+	ld_ob	$f8, 0x1122334455667788
+	mul.ob	$f10, $f8, 2
+	ck_ob	$f10, 0x22446688aacceeff
+
+
+	writemsg "nor.ob (v)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	nor.ob	$f10, $f8, $f9
+	ck_ob	$f10, 0x8888442200000022
+
+	writemsg "nor.ob (ev)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	nor.ob	$f10, $f8, $f9[6]
+	ck_ob	$f10, 0x8888888888888800
+
+	writemsg "nor.ob (cv)"
+	ld_ob	$f8, 0x1122334455667788
+	nor.ob	$f10, $f8, 0x08
+	ck_ob	$f10, 0xe6d5c4b3a2918077
+
+
+	writemsg "or.ob (v)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	or.ob	$f10, $f8, $f9
+	ck_ob	$f10, 0x7777bbddffffffdd
+
+	writemsg "or.ob (ev)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	or.ob	$f10, $f8, $f9[6]
+	ck_ob	$f10, 0x77777777777777ff
+
+	writemsg "or.ob (cv)"
+	ld_ob	$f8, 0x1122334455667788
+	or.ob	$f10, $f8, 0x08
+	ck_ob	$f10, 0x192a3b4c5d6e7f88
+
+
+	writemsg "shfl.mixh.ob"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	shfl.mixh.ob	$f10, $f8, $f9
+	ck_ob	$f10, 0x1166227733884499
+
+
+	writemsg "shfl.mixl.ob"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	shfl.mixl.ob	$f10, $f8, $f9
+	ck_ob	$f10, 0x55aa66bb77cc88dd
+
+
+	writemsg "shfl.pach.ob"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	shfl.pach.ob	$f10, $f8, $f9
+	ck_ob	$f10, 0x113355776688aacc
+
+
+	writemsg "shfl.upsl.ob"
+	ld_ob	$f8, 0x1122334455667788
+	shfl.upsl.ob	$f10, $f8, $f8
+	ck_ob	$f10, 0x005500660077ff88
+
+
+	writemsg "sll.ob (v)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x0001020304050607
+	sll.ob	$f10, $f8, $f9
+	ck_ob	$f10, 0x1144cc2050c0c000
+
+	writemsg "sll.ob (ev)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x0001020304050607
+	sll.ob	$f10, $f8, $f9[3]
+	ck_ob	$f10, 0x1020304050607080
+
+	writemsg "sll.ob (cv)"
+	ld_ob	$f8, 0x1122334455667788
+	sll.ob	$f10, $f8, 1
+	ck_ob	$f10, 0x22446688aaccee10
+
+
+	writemsg "srl.ob (v)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x0001020304050607
+	srl.ob	$f10, $f8, $f9
+	ck_ob	$f10, 0x11110c0805030101
+
+	writemsg "srl.ob (ev)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x0001020304050607
+	srl.ob	$f10, $f8, $f9[3]
+	ck_ob	$f10, 0x0102030405060708
+
+	writemsg "srl.ob (cv)"
+	ld_ob	$f8, 0x1122334455667788
+	srl.ob	$f10, $f8, 1
+	ck_ob	$f10, 0x081119222a333b44
+
+
+	writemsg "sub.ob (v)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x0001020304050607
+	sub.ob	$f10, $f8, $f9
+	ck_ob	$f10, 0x1121314151617181
+
+	writemsg "sub.ob (ev)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	sub.ob	$f10, $f8, $f9[7]
+	ck_ob	$f10, 0x0000000000001122
+
+	writemsg "sub.ob (cv)"
+	ld_ob	$f8, 0x1122334455667788
+	sub.ob	$f10, $f8, 0x10
+	ck_ob	$f10, 0x0112233445566778
+
+
+	writemsg "xor.ob (v)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	xor.ob	$f10, $f8, $f9
+	ck_ob	$f10, 0x7755bbddffddbb55
+
+	writemsg "xor.ob (ev)"
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	xor.ob	$f10, $f8, $f9[6]
+	ck_ob	$f10, 0x66554433221100ff
+
+	writemsg "xor.ob (cv)"
+	ld_ob	$f8, 0x1122334455667788
+	xor.ob	$f10, $f8, 0x08
+	ck_ob	$f10, 0x192a3b4c5d6e7f80
+
+
+	###
+	### Accumulator .ob format ops (in order: rd/wr, math, scale/round)
+	###
+	### Key: v = vector
+	###      ev = vector of single element
+	###      cv = vector of constant.
+	###
+
+
+	writemsg "wacl.ob / rac[hml].ob"
+	ld_ob	$f8, 0x8001028304850687
+	ld_ob	$f9, 0x1011121314151617
+	wacl.ob	$f8, $f9
+	ck_acc_ob 0xff0000ff00ff00ff, 0x8001028304850687, 0x1011121314151617
+
+	# Note: relies on data left in accumulator by previous test.
+	writemsg "wach.ob / rac[hml].ob"
+	ld_ob	$f8, 0x2021222324252627
+	wach.ob	$f8
+	ck_acc_ob 0x2021222324252627, 0x8001028304850687, 0x1011121314151617
+
+
+	writemsg "adda.ob (v)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	adda.ob	$f8, $f9
+	ck_acc_ob 0x0001020304050607, 0x0000000000010101, 0x7799bbddff214365
+
+	writemsg "adda.ob (ev)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	adda.ob	$f8, $f9[2]
+	ck_acc_ob 0x0001020304050607, 0x0000000001010101, 0xccddeeff10213243
+
+	writemsg "adda.ob (cv)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	adda.ob	$f8, 0x1f
+	ck_acc_ob 0x0001020304050607, 0x0000000000000000, 0x30415263748596a7
+
+
+	writemsg "addl.ob (v)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	addl.ob	$f8, $f9
+	ck_acc_ob 0x0000000000000000, 0x0000000000010101, 0x7799bbddff214365
+
+	writemsg "addl.ob (ev)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	addl.ob	$f8, $f9[2]
+	ck_acc_ob 0x0000000000000000, 0x0000000001010101, 0xccddeeff10213243
+
+	writemsg "addl.ob (cv)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	addl.ob	$f8, 0x1f
+	ck_acc_ob 0x0000000000000000, 0x0000000000000000, 0x30415263748596a7
+
+
+	writemsg "mula.ob (v)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	mula.ob	$f8, $f9
+	ck_acc_ob 0x0001020304050607, 0x060f1b28384a5e75, 0xc6ce18a47282d468
+
+	writemsg "mula.ob (ev)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	mula.ob	$f8, $f9[2]
+	ck_acc_ob 0x0001020304050607, 0x0c1825313e4a5663, 0x6bd641ac1782ed58
+
+	writemsg "mula.ob (cv)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	mula.ob	$f8, 0x1f
+	ck_acc_ob 0x0001020304050607, 0x020406080a0c0e10, 0x0f1e2d3c4b5a6978
+
+
+	writemsg "mull.ob (v)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	mull.ob	$f8, $f9
+	ck_acc_ob 0x0000000000000000, 0x060f1b28384a5e75, 0xc6ce18a47282d468
+
+	writemsg "mull.ob (ev)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	mull.ob	$f8, $f9[2]
+	ck_acc_ob 0x0000000000000000, 0x0c1825313e4a5663, 0x6bd641ac1782ed58
+
+	writemsg "mull.ob (cv)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	mull.ob	$f8, 0x1f
+	ck_acc_ob 0x0000000000000000, 0x020406080a0c0e10, 0x0f1e2d3c4b5a6978
+
+
+	writemsg "muls.ob (v)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	muls.ob	$f8, $f9
+	ck_acc_ob 0xff00010203040506, 0xf9f0e4d7c7b5a18a, 0x3a32e85c8e7e2c98
+
+	writemsg "muls.ob (ev)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	muls.ob	$f8, $f9[2]
+	ck_acc_ob 0xff00010203040506, 0xf3e7dacec1b5a99c, 0x952abf54e97e13a8
+
+	writemsg "muls.ob (cv)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	muls.ob	$f8, 0x1f
+	ck_acc_ob 0xff00010203040506, 0xfdfbf9f7f5f3f1ef, 0xf1e2d3c4b5a69788
+
+
+	writemsg "mulsl.ob (v)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	mulsl.ob $f8, $f9
+	ck_acc_ob 0xffffffffffffffff, 0xf9f0e4d7c7b5a18a, 0x3a32e85c8e7e2c98
+
+	writemsg "mulsl.ob (ev)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	mulsl.ob $f8, $f9[2]
+	ck_acc_ob 0xffffffffffffffff, 0xf3e7dacec1b5a99c, 0x952abf54e97e13a8
+
+	writemsg "mulsl.ob (cv)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	mulsl.ob $f8, 0x1f
+	ck_acc_ob 0xffffffffffffffff, 0xfdfbf9f7f5f3f1ef, 0xf1e2d3c4b5a69788
+
+
+	writemsg "suba.ob (v)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	suba.ob	$f8, $f9
+	ck_acc_ob 0xff00010203040506, 0xffffffffffffffff, 0xabababababababab
+
+	writemsg "suba.ob (ev)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	suba.ob	$f8, $f9[2]
+	ck_acc_ob 0xff00010203040506, 0xffffffffffffffff, 0x566778899aabbccd
+
+	writemsg "suba.ob (cv)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	suba.ob	$f8, 0x1f
+	ck_acc_ob 0xff01020304050607, 0xff00000000000000, 0xf203142536475869
+
+
+	writemsg "subl.ob (v)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	subl.ob	$f8, $f9
+	ck_acc_ob 0xffffffffffffffff, 0xffffffffffffffff, 0xabababababababab
+
+	writemsg "subl.ob (ev)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	ld_ob	$f9, 0x66778899aabbccdd
+	subl.ob	$f8, $f9[2]
+	ck_acc_ob 0xffffffffffffffff, 0xffffffffffffffff, 0x566778899aabbccd
+
+	writemsg "subl.ob (cv)"
+	ld_acc_ob 0x0001020304050607, 0x0000000000000000, 0x0000000000000000
+	ld_ob	$f8, 0x1122334455667788
+	subl.ob	$f8, 0x1f
+	ck_acc_ob 0xff00000000000000, 0xff00000000000000, 0xf203142536475869
+
+
+	writemsg "rnau.ob (v)"
+	ld_acc_ob 0x0000000000000000, 0x0000000003030303, 0x40424446f8fafcfe
+	ld_ob	$f8, 0x0001020304050607
+	rnau.ob	$f9, $f8
+	ck_ob	$f9, 0x4021110940201008
+
+	writemsg "rnau.ob (ev)"
+	ld_acc_ob 0x0000000000000000, 0x0000000003030303, 0x40424446f8fafcfe
+	ld_ob	$f8, 0x0001020304050607
+	rnau.ob	$f9, $f8[4]
+	ck_ob	$f9, 0x080809097f7f8080
+
+	writemsg "rnau.ob (cv)"
+	ld_acc_ob 0x0000000000000000, 0x0000000003030303, 0x40424446f8fafcfe
+	rnau.ob	$f9, 2
+	ck_ob	$f9, 0x10111112feffffff
+
+
+	writemsg "rneu.ob (v)"
+	ld_acc_ob 0x0000000000000000, 0x0000000003030303, 0x40424446f8fafcfe
+	ld_ob	$f8, 0x0001020304050607
+	rneu.ob	$f9, $f8
+	ck_ob	$f9, 0x4021110940201008
+
+	writemsg "rneu.ob (ev)"
+	ld_acc_ob 0x0000000000000000, 0x0000000003030303, 0x40424446f8fafcfe
+	ld_ob	$f8, 0x0001020304050607
+	rneu.ob	$f9, $f8[4]
+	ck_ob	$f9, 0x080808097f7f8080
+
+	writemsg "rneu.ob (cv)"
+	ld_acc_ob 0x0000000000000000, 0x0000000003030303, 0x40424446f8fafcfe
+	rneu.ob	$f9, 2
+	ck_ob	$f9, 0x10101112fefeffff
+
+
+	writemsg "rzu.ob (v)"
+	ld_acc_ob 0x0000000000000000, 0x0000000003030303, 0x40424446f8fafcfe
+	ld_ob	$f8, 0x0001020304050607
+	rzu.ob	$f9, $f8
+	ck_ob	$f9, 0x402111083f1f0f07
+
+	writemsg "rzu.ob (ev)"
+	ld_acc_ob 0x0000000000000000, 0x0000000003030303, 0x40424446f8fafcfe
+	ld_ob	$f8, 0x0001020304050607
+	rzu.ob	$f9, $f8[4]
+	ck_ob	$f9, 0x080808087f7f7f7f
+
+	writemsg "rzu.ob (cv)"
+	ld_acc_ob 0x0000000000000000, 0x0000000003030303, 0x40424446f8fafcfe
+	rzu.ob	$f9, 2
+	ck_ob	$f9, 0x10101111fefeffff
+
+
+	###
+	### CC-using .ob format ops.
+	###
+	### Key: v = vector
+	###      ev = vector of single element
+	###      cv = vector of constant.
+	###
+
+
+	writemsg "c.eq.ob (v)"
+	ld_ob	$f8, 0x0001010202030304
+	ld_ob	$f9, 0x0101020203030404
+	clr_fp_cc 0xff
+	c.eq.ob	$f8, $f9
+	ck_fp_cc 0x55
+
+	writemsg "c.eq.ob (ev)"
+	ld_ob	$f8, 0x0001010202030304
+	ld_ob	$f9, 0x0101020203030404
+	clr_fp_cc 0xff
+	c.eq.ob	$f8, $f9[5]
+	ck_fp_cc 0x18
+
+	writemsg "c.eq.ob (cv)"
+	ld_ob	$f8, 0x0001010202030304
+	clr_fp_cc 0xff
+	c.eq.ob	$f8, 0x03
+	ck_fp_cc 0x06
+
+
+	writemsg "c.le.ob (v)"
+	ld_ob	$f8, 0x0001010202030304
+	ld_ob	$f9, 0x0101020203030404
+	clr_fp_cc 0xff
+	c.le.ob	$f8, $f9
+	ck_fp_cc 0xff
+
+	writemsg "c.le.ob (ev)"
+	ld_ob	$f8, 0x0001010202030304
+	ld_ob	$f9, 0x0101020203030404
+	clr_fp_cc 0xff
+	c.le.ob	$f8, $f9[5]
+	ck_fp_cc 0xf8
+
+	writemsg "c.le.ob (cv)"
+	ld_ob	$f8, 0x0001010202030304
+	clr_fp_cc 0xff
+	c.le.ob	$f8, 0x03
+	ck_fp_cc 0xfe
+
+
+	writemsg "c.lt.ob (v)"
+	ld_ob	$f8, 0x0001010202030304
+	ld_ob	$f9, 0x0101020203030404
+	clr_fp_cc 0xff
+	c.lt.ob	$f8, $f9
+	ck_fp_cc 0xaa
+
+	writemsg "c.lt.ob (ev)"
+	ld_ob	$f8, 0x0001010202030304
+	ld_ob	$f9, 0x0101020203030404
+	clr_fp_cc 0xff
+	c.lt.ob	$f8, $f9[5]
+	ck_fp_cc 0xe0
+
+	writemsg "c.lt.ob (cv)"
+	ld_ob	$f8, 0x0001010202030304
+	clr_fp_cc 0xff
+	c.lt.ob	$f8, 0x03
+	ck_fp_cc 0xf8
+
+
+	writemsg "pickf.ob (v)"
+	ld_ob	$f8, 0x0001020304050607
+	ld_ob	$f9, 0x08090a0b0c0d0e0f
+	clrset_fp_cc 0xff, 0xaa
+	pickf.ob $f10, $f8, $f9
+	ck_ob	$f10, 0x08010a030c050e07
+
+	writemsg "pickf.ob (ev)"
+	ld_ob	$f8, 0x0001020304050607
+	ld_ob	$f9, 0x08090a0b0c0d0e0f
+	clrset_fp_cc 0xff, 0xaa
+	pickf.ob $f10, $f8, $f9[4]
+	ck_ob	$f10, 0x0b010b030b050b07
+
+	writemsg "pickf.ob (cv)"
+	ld_ob	$f8, 0x0001020304050607
+	clrset_fp_cc 0xff, 0xaa
+	pickf.ob $f10, $f8, 0x10
+	ck_ob	$f10, 0x1001100310051007
+
+
+	writemsg "pickt.ob (v)"
+	ld_ob	$f8, 0x0001020304050607
+	ld_ob	$f9, 0x08090a0b0c0d0e0f
+	clrset_fp_cc 0xff, 0xaa
+	pickt.ob $f10, $f8, $f9
+	ck_ob	$f10, 0x0009020b040d060f
+
+	writemsg "pickt.ob (ev)"
+	ld_ob	$f8, 0x0001020304050607
+	ld_ob	$f9, 0x08090a0b0c0d0e0f
+	clrset_fp_cc 0xff, 0xaa
+	pickt.ob $f10, $f8, $f9[5]
+	ck_ob	$f10, 0x000a020a040a060a
+
+	writemsg "pickt.ob (cv)"
+	ld_ob	$f8, 0x0001020304050607
+	clrset_fp_cc 0xff, 0xaa
+	pickt.ob $f10, $f8, 0x10
+	ck_ob	$f10, 0x0010021004100610
+
+
+	pass
+
+	.end DIAG
Index: sim/testsuite/sim/brownie32/sanity.s
===================================================================
RCS file: sim/testsuite/sim/brownie32/sanity.s
diff -N sim/testsuite/sim/brownie32/sanity.s
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/testsuite/sim/brownie32/sanity.s	8 Aug 2007 08:49:55 -0000	1.1
@@ -0,0 +1,20 @@
+# mips test sanity, expected to pass.
+# mach:	 all
+# as:		-mabi=eabi
+# ld:		-N -Ttext=0x80010000
+# output:	*\\npass\\n
+
+	.include "testutils.inc"
+
+	setup
+
+	.set noreorder
+
+	.ent DIAG
+DIAG:
+
+	writemsg "Sanity is good!"
+
+	pass
+
+	.end DIAG
Index: sim/testsuite/sim/brownie32/testutils.inc
===================================================================
RCS file: sim/testsuite/sim/brownie32/testutils.inc
diff -N sim/testsuite/sim/brownie32/testutils.inc
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/testsuite/sim/brownie32/testutils.inc	8 Aug 2007 08:49:55 -0000	1.1
@@ -0,0 +1,149 @@
+# MIPS simulator testsuite utility functions.
+# Copyright (C) 2004 Free Software Foundation, Inc.
+# Contributed by Chris Demetriou of Broadcom Corporation.
+#
+# This file is part of the GNU simulators.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+
+# $1, $4, $5, %6, are used as temps by the macros defined here.
+
+	.macro writemsg msg
+	.data
+901:	.ascii	"\msg\n"
+902:
+	.previous
+	la	$5, 901b
+	li	$6, 902b - 901b
+	.set push
+	.set noreorder
+	jal	_dowrite
+	li	$4, 0
+	.set pop
+	.endm
+
+
+	# The MIPS simulator uses "break 0x3ff" as the code to exit,
+	# with the return value in $4 (a0).
+	.macro exit rc
+	li	$4, \rc
+	break	0x3ff
+	.endm
+
+
+	.macro setup
+
+	.global _start
+	.ent _start
+_start:
+	.set push
+	.set noreorder
+	j	DIAG
+	nop
+	.set pop
+	.end _start
+
+	.global _fail
+	.ent _fail
+_fail:
+	writemsg "fail"
+	exit 1
+	.end _fail
+
+	.global _pass
+	.ent _pass
+_pass:
+	writemsg "pass"
+	exit 0
+	.end _pass
+
+	# The MIPS simulator can use multiple different monitor types,
+	# so we hard-code the simulator "write" reserved instruction opcode,
+	# rather than jumping to a vector that invokes it.  The operation
+	# expects RA to point to the location at which to continue
+	# after writing.
+	.global _dowrite
+	.ent _dowrite
+_dowrite:
+	# Write opcode (reserved instruction).  See sim_monitor and its
+	# callers in sim/mips/interp.c.
+	.word	0x00000005 | ((8 << 1) << 6)
+	.end _dowrite
+
+	.endm	# setup
+
+
+	.macro pass
+	.set push
+	.set noreorder
+	j	_pass
+	nop	
+	.set pop
+	.endm
+
+
+	.macro fail
+	.set push
+	.set noreorder
+	j	_fail
+	nop	
+	.set pop
+	.endm
+
+
+	.macro load32 reg, val
+	li	\reg, \val
+	.endm
+
+
+	.macro load64 reg, val
+	dli	\reg, \val
+	.endm
+
+
+	.macro loadaddr reg, addr
+	la	\reg, \addr
+	.endm
+
+
+	.macro checkreg reg, expreg
+	.set push
+	.set noat
+	.set noreorder
+	beq	\expreg, \reg, 901f
+	nop
+	fail
+901:
+	.set pop
+	.endm
+
+
+	.macro check32 reg, val
+	.set push
+	.set noat
+	load32	$1, \val
+	checkreg \reg, $1
+	.set pop
+	.endm
+
+
+	.macro check64 reg, val
+	.set push
+	.set noat
+	load64	$1, \val
+	checkreg \reg, $1
+	.set pop
+	.endm
Index: sim/testsuite/sim/brownie32/utils-fpu.inc
===================================================================
RCS file: sim/testsuite/sim/brownie32/utils-fpu.inc
diff -N sim/testsuite/sim/brownie32/utils-fpu.inc
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/testsuite/sim/brownie32/utils-fpu.inc	8 Aug 2007 08:49:55 -0000	1.1
@@ -0,0 +1,105 @@
+# MIPS simulator testsuite FPU utility functions.
+# Copyright (C) 2004 Free Software Foundation, Inc.
+# Contributed by Chris Demetriou of Broadcom Corporation.
+#
+# This file is part of the GNU simulators.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+	.macro	enable_fpu fr
+        mfc0    $20, $12
+        or      $20, $20, (1 << 29) | (\fr << 26)
+        mtc0    $20, $20
+	.endm
+
+	###
+	### Data movement macros
+	###
+
+	.macro ld_fp_df r, v
+	.data
+1:	.double	\v
+	.previous
+	ldc1	\r, 1b
+	.endm
+
+	.macro ld_fp_di r, v
+	.data
+1:	.dword	\v
+	.previous
+	ldc1	\r, 1b
+	.endm
+
+	.macro ld_fp_sf r, v
+	.data
+1:	.float	\v
+	.previous
+	lwc1	\r, 1b
+	.endm
+
+	.macro ld_fp_si r, v
+	.data
+1:	.word	\v
+	.previous
+	lwc1	\r, 1b
+	.endm
+
+
+	###
+	### FP condition code manipulation macros
+	###
+
+	.macro clrset_fp_cc clr, set
+	cfc1	$20, $31	
+	or	$20, $20, (((\clr & 0xfe) << 24) | ((\clr & 0x01) << 23))
+	xor	$20, $20, (((\clr & 0xfe) << 24) | ((\clr & 0x01) << 23))
+	or	$20, $20, (((\set & 0xfe) << 24) | ((\set & 0x01) << 23))
+	ctc1	$20, $31
+	.endm
+
+	.macro clr_fp_cc clr
+	clrset_fp_cc \clr, 0
+	.endm
+
+	.macro set_fp_cc set
+	clrset_fp_cc 0, \set
+	.endm
+
+	.macro get_fp_cc r
+	.set push
+	.set noat
+	cfc1	$1, $31
+	srl	$1, $1, 23
+	andi	\r, $1, 0x1fc
+	andi	$1, $1, 0x1
+	srl	\r, \r, 1
+	or	\r, \r, $1
+	.set pop
+	.endm
+
+	.macro ck_fp_cc v
+	get_fp_cc $20
+	xori	$20, $20, \v
+	bnez	$20, _fail
+	 nop
+	.endm
+
+	.macro ckm_fp_cc v, mask
+	get_fp_cc $20
+	xori	$20, $20, \v
+	andi	$20, $20, \mask
+	bnez	$20, _fail
+	 nop
+	.endm
Index: sim/testsuite/sim/brownie32/utils-mdmx.inc
===================================================================
RCS file: sim/testsuite/sim/brownie32/utils-mdmx.inc
diff -N sim/testsuite/sim/brownie32/utils-mdmx.inc
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sim/testsuite/sim/brownie32/utils-mdmx.inc	8 Aug 2007 08:49:55 -0000	1.1
@@ -0,0 +1,72 @@
+# MIPS simulator testsuite MDMX utility functions.
+# Copyright (C) 2004 Free Software Foundation, Inc.
+# Contributed by Chris Demetriou of Broadcom Corporation.
+#
+# This file is part of the GNU simulators.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+	.include "utils-fpu.inc"
+
+	###
+	### Shared macros
+	###
+
+	# Enable MDMX: enable the FPU w/ FR=1, then set Status.MX
+	.macro	enable_mdmx
+	enable_fpu 1
+	mfc0	$20, $12
+	or	$20, $20, (1 << 24)
+	mtc0	$20, $12
+	.endm
+
+
+	###
+	### .OB-format macros
+	###
+
+	.macro ld_ob r, v
+	.data
+1:	.dword	\v
+	.previous
+	ldc1	\r, 1b
+	.endm
+
+	.macro ck_ob r, v
+	.data
+1:	.dword	\v
+	.previous
+	dmfc1	$20, \r
+	ld	$21, 1b
+	bne	$20, $21, _fail
+	 nop
+	.endm
+
+	.macro ld_acc_ob h, m, l
+	ld_ob	$f20, \m
+	ld_ob	$f21, \l
+	wacl.ob	$f20, $f21
+	ld_ob	$f20, \h
+	wach.ob	$f20
+	.endm
+
+	.macro ck_acc_ob h, m, l
+	rach.ob	$f20
+	ck_ob	$f20, \h
+	racm.ob	$f20
+	ck_ob	$f20, \m
+	racl.ob	$f20
+	ck_ob	$f20, \l
+	.endm
