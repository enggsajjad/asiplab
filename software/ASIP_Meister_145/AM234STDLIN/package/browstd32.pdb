// Copyright (C) 2009 ASIP Solutions, Inc. All rights reserved. 
// Generated by ASIP Meister 2.3 on 2009/11/16 13:39:11 
Version{
 2.3
}
FileType{
 Design
}
Database{
 path{
  ./peas3
 }
 sufix{
  pdb
 }
 type{
  PEAS3 DataFile
 }

}
Preference{
 Version{
  2.3
 }

}
AbsLevelArch{
 Complete{
  ON
 }
 CPUtype{
  midTitle{
   CPU_type
  }
  label{
   CPU type
  }
  method{
   radiobutton  Pipeline
  }
  select{
   Pipeline
  }
  Pipeline{
   midTitle{
    Pipeline_architecture
   }
   StageNum{
    midTitle{
     Number_of_stages
    }
    label{
     Num. of Stages
    }
    method{
     factor stage
    }
    unit{
     
    }
    select{
     4
    }

   }
   CommonStageNum{
    midTitle{
     Number_of_common_stages
    }
    label{
     Num. of Common Stages
    }
    method{
     integer
    }
    unit{
     
    }
    select{
     0
    }
    enable{
     false
    }

   }
   DecodeStage{
    midTitle{
     
    }
    label{
     Decode Stage
    }
    method{
     integer
    }
    unit{
     [-th]
    }
    select{
     2
    }

   }
   StageDef{
    midTitle{
     Stage_Definition
    }
    method{
     dylist stage
    }
    stage{
     midTitle{
      stage
     }
     1{
      midTitle{
       stage1
      }
      label{
       1
      }
      method{
       specified
      }
      unit{
       [cycle]
      }
      select{
       IF,1,fetch
      }

     }
     2{
      midTitle{
       stage2
      }
      label{
       2
      }
      method{
       specified
      }
      unit{
       [cycle]
      }
      select{
       ID,1,decode
      }

     }
     3{
      midTitle{
       stage3
      }
      label{
       3
      }
      method{
       specified
      }
      unit{
       [cycle]
      }
      select{
       EXE,1,exec
      }

     }
     4{
      midTitle{
       stage4
      }
      label{
       4
      }
      method{
       specified
      }
      unit{
       [cycle]
      }
      select{
       WB,1,memory_read & memory_write
      }

     }

    }

   }
   MultiscInterlock{
    midTitle{
     Multi_cycle_interlock
    }
    label{
     Multi cycle interlock
    }
    method{
     radiobutton Yes No
    }
    select{
     Yes
    }
    enable{
     false
    }

   }
   DataHazInterlock{
    midTitle{
     Data_hazard_interlock
    }
    label{
     Data hazard interlock
    }
    method{
     radiobutton Yes No
    }
    select{
     No
    }
    enable{
     false
    }

   }
   RegBypass{
    midTitle{
     Register_bypass
    }
    label{
     Register bypass
    }
    method{
     radiobutton Yes No
    }
    select{
     No
    }
    enable{
     false
    }

   }
   DlydBranch{
    midTitle{
     Delayed_branch
    }
    label{
     Delayed branch
    }
    method{
     radiobutton Yes No
    }
    select{
     No
    }
    Yes{
     midTitle{
      Number_of_exec_delayed_slot
     }
     DelaySlot{
      midTitle{
       number
      }
      label{
       Num. of delayed slot
      }
      method{
       integer
      }
      unit{
       [instruction]
      }
      select{
       1
      }

     }

    }

   }

  }

 }
 MAXInstBitWidth{
  midTitle{
   MAX_instruction_bit_width
  }
  label{
   Max inst. bit width
  }
  method{
   integer
  }
  unit{
   [bit]
  }
  select{
   32
  }

 }
 Projectname{
  midTitle{
   
  }
  label{
   Project name
  }
  method{
   entry
  }
  select{
   Brownie STD 32
  }

 }
 FhmWorkname{
  midTitle{
   Fhm_workname
  }
  label{
   Fhm workname
  }
  method{
   entry
  }
  select{
   FHM_work
  }
  enable{
   false
  }

 }
 Revision{
  midTitle{
   
  }
  label{
   Revision No.
  }
  method{
   message
  }
  select{
   ASIP Meister v.2.3.0 linux
  }

 }
 DesignConst{
  midTitle{
   
  }
  method{
   list Design_Goal
  }
  Design_Goal{
   midTitle{
    construciton
   }
   Area{
    midTitle{
     Goal_area
    }
    label{
     Goal Area
    }
    method{
     integer
    }
    unit{
     [gates]
    }
    select{
     30000
    }

   }
   Delay{
    midTitle{
     Goal_delay
    }
    label{
     Goal Delay
    }
    method{
     integer
    }
    unit{
     [ns]
    }
    select{
     5
    }

   }
   PowerS{
    midTitle{
     Goal_power_S
    }
    label{
     Goal Power S
    }
    method{
     integer
    }
    unit{
     [uW/MHz]
    }
    select{
     5000
    }

   }

  }

 }
 Priority{
  midTitle{
   Priority
  }
  label{
   Design Priority
  }
  method{
   radiobutton Area Performance Power
  }
  select{
   Area
  }

 }
 MAXDataBitWidth{
  midTitle{
   MAX_data_width
  }
  label{
   Max data bit width
  }
  method{
   integer
  }
  unit{
   [bit]
  }
  select{
   32
  }

 }
 ProcessorDesign{
  midTitle{
   Processor_design
  }
  label{
   Processor design
  }
  method{
   radiobuttonDesign \"New Design\" \"New Design with Base Processor\" \"Base Processor Design\"
  }
  select{
   Base Processor Design
  }

 }
 UseCompiler{
  midTitle{
   Use_compiler
  }
  label{
   Use compiler
  }
  method{
   radiobuttonCom Yes No
  }
  select{
   Yes
  }

 }

}
EntityDecl{
 Complete{
  ON
 }
 ComponentName{
  BrownieSTD32
 }
 Entity{
  1{
   valid{
    true
   }
   name{
    CLK
   }
   type{
    in
   }
   entity{
    1
   }
   attribute{
    clock
   }

  }
  2{
   valid{
    true
   }
   name{
    RESET
   }
   type{
    in
   }
   entity{
    1
   }
   attribute{
    reset
   }

  }
  3{
   valid{
    true
   }
   name{
    IMEM_ADDR_OUT
   }
   type{
    out
   }
   entity{
    32
   }
   attribute{
    instruction_memory_address_bus
   }

  }
  4{
   valid{
    true
   }
   name{
    IMEM_DATA_IN
   }
   type{
    in
   }
   entity{
    32
   }
   attribute{
    instruction_memory_data_in_bus
   }

  }
  5{
   valid{
    true
   }
   name{
    IMEM_ADDRERR_IN
   }
   type{
    in
   }
   entity{
    1
   }
   attribute{
    instruction_memory_address_error_bus
   }

  }
  6{
   valid{
    true
   }
   name{
    DMEM_ADDR_OUT
   }
   type{
    out
   }
   entity{
    32
   }
   attribute{
    data_memory_address_bus
   }

  }
  7{
   valid{
    true
   }
   name{
    DMEM_DATA_IN
   }
   type{
    in
   }
   entity{
    32
   }
   attribute{
    data_memory_data_in_bus
   }

  }
  8{
   valid{
    true
   }
   name{
    DMEM_DATA_OUT
   }
   type{
    out
   }
   entity{
    32
   }
   attribute{
    data_memory_data_out_bus
   }

  }
  9{
   valid{
    true
   }
   name{
    DMEM_REQ_OUT
   }
   type{
    out
   }
   entity{
    1
   }
   attribute{
    data_memory_request_bus
   }

  }
  10{
   valid{
    true
   }
   name{
    DMEM_ACK_IN
   }
   type{
    in
   }
   entity{
    1
   }
   attribute{
    data_memory_acknowledge_bus
   }

  }
  11{
   valid{
    true
   }
   name{
    DMEM_RW_OUT
   }
   type{
    out
   }
   entity{
    1
   }
   attribute{
    data_memory_rw_bus
   }

  }
  12{
   valid{
    true
   }
   name{
    DMEM_WMODE_OUT
   }
   type{
    out
   }
   entity{
    2
   }
   attribute{
    data_memory_write_mode_bus
   }

  }
  13{
   valid{
    true
   }
   name{
    DMEM_EMODE_OUT
   }
   type{
    out
   }
   entity{
    1
   }
   attribute{
    data_memory_ext_mode_bus
   }

  }
  14{
   valid{
    true
   }
   name{
    DMEM_ADDRERR_IN
   }
   type{
    in
   }
   entity{
    1
   }
   attribute{
    data_memory_address_error_bus
   }

  }
  15{
   valid{
    true
   }
   name{
    DMEM_CANCEL_OUT
   }
   type{
    out
   }
   entity{
    1
   }
   attribute{
    data_memory_cancel_bus
   }

  }
  16{
   valid{
    true
   }
   name{
    EXTINT_IN
   }
   type{
    in
   }
   entity{
    1
   }
   attribute{
    interrupt
   }

  }
  17{
   valid{
    true
   }
   name{
    EXTCATCH_OUT
   }
   type{
    out
   }
   entity{
    1
   }
   attribute{
    unspecified
   }

  }

 }

}
ResourceDecl{
 Complete{
  ON
 }
 Instance{
  PC{
   valid{
    true
   }
   class{
    name{
     pcu
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     Prog. Counter
    }
    parameter{
     bit_width{
      32
     }
     increment_step{
      4
     }
     adder_algorithm{
      default
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  IR{
   valid{
    true
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     Inst. Register
    }
    parameter{
     bit_width{
      32
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  IMAU{
   valid{
    true
   }
   class{
    name{
     mifu
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     Inst. Memory
    }
    parameter{
     bit_width{
      32
     }
     address_space{
      32
     }
     access_width{
      32
     }
     access_mode{
      single_cycle
     }
     type{
      read_only
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  DMAU{
   valid{
    true
   }
   class{
    name{
     mifu
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     Data Memory
    }
    parameter{
     bit_width{
      32
     }
     address_space{
      32
     }
     access_width{
      8
     }
     access_mode{
      multi_cycle
     }
     type{
      read_write
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  ALU{
   valid{
    true
   }
   class{
    name{
     alu
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     algorithm{
      default
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  MUL{
   valid{
    true
   }
   class{
    name{
     multiplier
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     algorithm{
      seq
     }
     adder_algorithm{
      default
     }
     data_type{
      two_complement
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  DIV{
   valid{
    true
   }
   class{
    name{
     divider
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     algorithm{
      seq
     }
     adder_algorithm{
      default
     }
     data_type{
      two_complement
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  EXT8TO32{
   valid{
    true
   }
   class{
    name{
     extender
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      8
     }
     bit_width_out{
      32
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  EXT16TO32{
   valid{
    true
   }
   class{
    name{
     extender
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      16
     }
     bit_width_out{
      32
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  EXT26TO32{
   valid{
    true
   }
   class{
    name{
     extender
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      26
     }
     bit_width_out{
      32
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  SFTvar{
   valid{
    true
   }
   class{
    name{
     shifter
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     amount{
      variable
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  EXTINT{
   valid{
    true
   }
   class{
    name{
     wire_in
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  EXTCATCH_OUT{
   valid{
    true
   }
   class{
    name{
     wire_out
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }
     default_output{
      fix_to_0
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  TRAP_HAND_REG{
   valid{
    true
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  FWU0{
   valid{
    true
   }
   class{
    name{
     fwu
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     addr_width{
      5
     }
     stage_number{
      2
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  FWU1{
   valid{
    true
   }
   class{
    name{
     fwu
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     addr_width{
      5
     }
     stage_number{
      2
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  DUMMY_STREG{
   valid{
    true
   }
   class{
    name{
     dummy_register
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     Mask Register
    }
    parameter{
     bit_width{
      32
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  GPR{
   valid{
    true
   }
   class{
    name{
     browregfile
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     Register File
    }
    parameter{
     bit_width{
      32
     }
     num_register{
      32
     }
     num_read_port{
      2
     }
     num_write_port{
      1
     }
     num_bank{
      1
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  EXT16TO32A{
   valid{
    true
   }
   class{
    name{
     extender
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      16
     }
     bit_width_out{
      32
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }

 }

}
StorageSpec{
 Complete{
  ON
 }
 RegisterFile{
  Before{
   0{
    Name{
     GPR[asc]
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     [bin-asc]
    }

   }

  }
  After{
   0{
    Name{
     GPR0
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     0
    }
    Usage{
     zero-reg
    }
    Location{
     original
    }
    Binary{
     00000
    }

   }
   1{
    Name{
     GPR1
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     1
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     00001
    }

   }
   2{
    Name{
     GPR2
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     2
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     00010
    }

   }
   3{
    Name{
     GPR3
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     3
    }
    Usage{
     link
    }
    Location{
     original
    }
    Binary{
     00011
    }

   }
   4{
    Name{
     GPR4
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     4
    }
    Usage{
     fp
    }
    Location{
     original
    }
    Binary{
     00100
    }

   }
   5{
    Name{
     GPR5
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     5
    }
    Usage{
     sp
    }
    Location{
     original
    }
    Binary{
     00101
    }

   }
   6{
    Name{
     GPR6
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     6
    }
    Usage{
     return
    }
    Location{
     original
    }
    Binary{
     00110
    }

   }
   7{
    Name{
     GPR7
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     7
    }
    Usage{
     return
    }
    Location{
     original
    }
    Binary{
     00111
    }

   }
   8{
    Name{
     GPR8
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     8
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     01000
    }

   }
   9{
    Name{
     GPR9
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     9
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     01001
    }

   }
   10{
    Name{
     GPR10
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     10
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     01010
    }

   }
   11{
    Name{
     GPR11
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     11
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     01011
    }

   }
   12{
    Name{
     GPR12
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     12
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     01100
    }

   }
   13{
    Name{
     GPR13
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     13
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     01101
    }

   }
   14{
    Name{
     GPR14
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     14
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     01110
    }

   }
   15{
    Name{
     GPR15
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     15
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     01111
    }

   }
   16{
    Name{
     GPR16
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     16
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     10000
    }

   }
   17{
    Name{
     GPR17
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     17
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     10001
    }

   }
   18{
    Name{
     GPR18
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     18
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     10010
    }

   }
   19{
    Name{
     GPR19
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     19
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     10011
    }

   }
   20{
    Name{
     GPR20
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     20
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     10100
    }

   }
   21{
    Name{
     GPR21
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     21
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     10101
    }

   }
   22{
    Name{
     GPR22
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     22
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     10110
    }

   }
   23{
    Name{
     GPR23
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     23
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     10111
    }

   }
   24{
    Name{
     GPR24
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     24
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     11000
    }

   }
   25{
    Name{
     GPR25
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     25
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     11001
    }

   }
   26{
    Name{
     GPR26
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     26
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     11010
    }

   }
   27{
    Name{
     GPR27
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     27
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     11011
    }

   }
   28{
    Name{
     GPR28
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     28
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     11100
    }

   }
   29{
    Name{
     GPR29
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     29
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     11101
    }

   }
   30{
    Name{
     GPR30
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     30
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     11110
    }

   }
   31{
    Name{
     GPR31
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     31
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     11111
    }

   }

  }

 }
 Register{
  0{
   Name{
    PC
   }
   Resource{
    PC
   }
   Width{
    32
   }
   Usage{
    pc
   }
   Location{
    original
   }

  }
  1{
   Name{
    IR
   }
   Resource{
    IR
   }
   Width{
    32
   }
   Usage{
    ireg
   }
   Location{
    original
   }

  }
  2{
   Name{
    DUMMY_STREG
   }
   Resource{
    DUMMY_STREG
   }
   Width{
    32
   }
   Usage{
    reg
   }
   Location{
    original
   }

  }

 }
 Memory{
  0{
   Name{
    IMAU
   }
   Resource{
    IMAU
   }
   Width{
    32
   }
   Usage{
    i-memory
   }
   Access{
    32
   }

  }
  1{
   Name{
    DMAU
   }
   Resource{
    DMAU
   }
   Width{
    32
   }
   Usage{
    d-memory
   }
   Access{
    8
   }

  }

 }

}
InstructionDecl{
 Complete{
  ON
 }
 MaxInstId{
  84
 }
 InstructionType{
  RR  #1{
   Valid{
    true
   }
   Name{
    RR
   }
   Entity{
    1{
     MSB{
      31
     }
     LSB{
      27
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      rs1
     }
     Addr_mode{
      RDirect
     }
     Operand_Name{
      rs1
     }
     Element{
      Resource
     }
     Reg_class{
      GPR
     }

    }
    2{
     MSB{
      26
     }
     LSB{
      22
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      rs2
     }
     Addr_mode{
      RDirect
     }
     Operand_Name{
      rs2
     }
     Element{
      Resource
     }
     Reg_class{
      GPR
     }

    }
    3{
     MSB{
      21
     }
     LSB{
      17
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      rd
     }
     Addr_mode{
      RDirect
     }
     Operand_Name{
      rd
     }
     Element{
      Resource
     }
     Reg_class{
      GPR
     }

    }
    4{
     MSB{
      16
     }
     LSB{
      14
     }
     FieldType{
      OP-code
     }
     FieldAttr{
      name
     }
     Value{
      f_type
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    5{
     MSB{
      13
     }
     LSB{
      6
     }
     FieldType{
      OP-code
     }
     FieldAttr{
      name
     }
     Value{
      func
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    6{
     MSB{
      5
     }
     LSB{
      0
     }
     FieldType{
      OP-code
     }
     FieldAttr{
      binary
     }
     Value{
      000001
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }

   }
   BaseProcessor{
    true
   }

  }
  RI  #1{
   Valid{
    true
   }
   Name{
    RI
   }
   Entity{
    1{
     MSB{
      31
     }
     LSB{
      16
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      const
     }
     Addr_mode{
      Immediate_data
     }
     Operand_Name{
      const
     }
     Element{
      Immediate
     }
     Reg_class{
      
     }

    }
    2{
     MSB{
      15
     }
     LSB{
      11
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      rs1
     }
     Addr_mode{
      RDirect
     }
     Operand_Name{
      rs1
     }
     Element{
      Resource
     }
     Reg_class{
      GPR
     }

    }
    3{
     MSB{
      10
     }
     LSB{
      6
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      rd
     }
     Addr_mode{
      RDirect
     }
     Operand_Name{
      rd
     }
     Element{
      Resource
     }
     Reg_class{
      GPR
     }

    }
    4{
     MSB{
      5
     }
     LSB{
      0
     }
     FieldType{
      OP-code
     }
     FieldAttr{
      name
     }
     Value{
      op
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }

   }
   BaseProcessor{
    true
   }

  }
  MA_ST  #1{
   Valid{
    true
   }
   Name{
    MA_ST
   }
   Entity{
    1{
     MSB{
      31
     }
     LSB{
      16
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      const
     }
     Addr_mode{
      RIwDisp
     }
     Operand_Name{
      addr
     }
     Element{
      Displacement
     }
     Reg_class{
      
     }

    }
    2{
     MSB{
      15
     }
     LSB{
      11
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      rs1
     }
     Addr_mode{
      RDirect
     }
     Operand_Name{
      rs1
     }
     Element{
      Resource
     }
     Reg_class{
      GPR
     }

    }
    3{
     MSB{
      10
     }
     LSB{
      6
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      rd
     }
     Addr_mode{
      RIwDisp
     }
     Operand_Name{
      addr
     }
     Element{
      Resource
     }
     Reg_class{
      GPR
     }

    }
    4{
     MSB{
      5
     }
     LSB{
      0
     }
     FieldType{
      OP-code
     }
     FieldAttr{
      name
     }
     Value{
      op
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }

   }
   BaseProcessor{
    true
   }

  }
  MA_LD  #1{
   Valid{
    true
   }
   Name{
    MA_LD
   }
   Entity{
    1{
     MSB{
      31
     }
     LSB{
      16
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      const
     }
     Addr_mode{
      RIwDisp
     }
     Operand_Name{
      addr
     }
     Element{
      Displacement
     }
     Reg_class{
      
     }

    }
    2{
     MSB{
      15
     }
     LSB{
      11
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      rs1
     }
     Addr_mode{
      RIwDisp
     }
     Operand_Name{
      addr
     }
     Element{
      Resource
     }
     Reg_class{
      GPR
     }

    }
    3{
     MSB{
      10
     }
     LSB{
      6
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      rd
     }
     Addr_mode{
      RDirect
     }
     Operand_Name{
      rd
     }
     Element{
      Resource
     }
     Reg_class{
      GPR
     }

    }
    4{
     MSB{
      5
     }
     LSB{
      0
     }
     FieldType{
      OP-code
     }
     FieldAttr{
      name
     }
     Value{
      op
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }

   }
   BaseProcessor{
    true
   }

  }
  BR  #1{
   Valid{
    true
   }
   Name{
    BR
   }
   Entity{
    1{
     MSB{
      31
     }
     LSB{
      16
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      const
     }
     Addr_mode{
      Immediate_data
     }
     Operand_Name{
      const
     }
     Element{
      Immediate
     }
     Reg_class{
      
     }

    }
    2{
     MSB{
      15
     }
     LSB{
      11
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      rs1
     }
     Addr_mode{
      RDirect
     }
     Operand_Name{
      rs1
     }
     Element{
      Resource
     }
     Reg_class{
      GPR
     }

    }
    3{
     MSB{
      10
     }
     LSB{
      6
     }
     FieldType{
      Dont_care
     }
     FieldAttr{
      name
     }
     Value{
      unused
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    4{
     MSB{
      5
     }
     LSB{
      0
     }
     FieldType{
      OP-code
     }
     FieldAttr{
      name
     }
     Value{
      op
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }

   }
   BaseProcessor{
    true
   }

  }
  JP  #1{
   Valid{
    true
   }
   Name{
    JP
   }
   Entity{
    1{
     MSB{
      31
     }
     LSB{
      6
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      const
     }
     Addr_mode{
      Immediate_data
     }
     Operand_Name{
      const
     }
     Element{
      Immediate
     }
     Reg_class{
      
     }

    }
    2{
     MSB{
      5
     }
     LSB{
      0
     }
     FieldType{
      OP-code
     }
     FieldAttr{
      name
     }
     Value{
      op
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }

   }
   BaseProcessor{
    true
   }

  }
  JPR  #1{
   Valid{
    true
   }
   Name{
    JPR
   }
   Entity{
    1{
     MSB{
      31
     }
     LSB{
      11
     }
     FieldType{
      Dont_care
     }
     FieldAttr{
      name
     }
     Value{
      unused
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    2{
     MSB{
      10
     }
     LSB{
      6
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      rs1
     }
     Addr_mode{
      RDirect
     }
     Operand_Name{
      rs1
     }
     Element{
      Resource
     }
     Reg_class{
      GPR
     }

    }
    3{
     MSB{
      5
     }
     LSB{
      0
     }
     FieldType{
      OP-code
     }
     FieldAttr{
      name
     }
     Value{
      op
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }

   }
   BaseProcessor{
    true
   }

  }
  SP  #1{
   Valid{
    true
   }
   Name{
    SP
   }
   Entity{
    1{
     MSB{
      31
     }
     LSB{
      11
     }
     FieldType{
      Dont_care
     }
     FieldAttr{
      name
     }
     Value{
      unused
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    2{
     MSB{
      10
     }
     LSB{
      6
     }
     FieldType{
      OP-code
     }
     FieldAttr{
      name
     }
     Value{
      func
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    3{
     MSB{
      5
     }
     LSB{
      0
     }
     FieldType{
      OP-code
     }
     FieldAttr{
      binary
     }
     Value{
      000000
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }

   }
   BaseProcessor{
    true
   }

  }
  RT  #1{
   Valid{
    true
   }
   Name{
    RT
   }
   Entity{
    1{
     MSB{
      31
     }
     LSB{
      27
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      rd
     }
     Addr_mode{
      RDirect
     }
     Operand_Name{
      rd
     }
     Element{
      Resource
     }
     Reg_class{
      GPR
     }

    }
    2{
     MSB{
      26
     }
     LSB{
      22
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      rs1
     }
     Addr_mode{
      RDirect
     }
     Operand_Name{
      rs1
     }
     Element{
      Resource
     }
     Reg_class{
      GPR
     }

    }
    3{
     MSB{
      21
     }
     LSB{
      11
     }
     FieldType{
      OP-code
     }
     FieldAttr{
      name
     }
     Value{
      func
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    4{
     MSB{
      10
     }
     LSB{
      6
     }
     FieldType{
      OP-code
     }
     FieldAttr{
      binary
     }
     Value{
      00010
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    5{
     MSB{
      5
     }
     LSB{
      0
     }
     FieldType{
      OP-code
     }
     FieldAttr{
      binary
     }
     Value{
      000000
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }

   }
   BaseProcessor{
    true
   }

  }

 }
 Instruction{
  ADD  #1{
   Type{
    RR  #1
   }
   Valid{
    true
   }
   Name{
    ADD
   }
   Id{
    10
   }
   EditField{
    1{
     rs1
    }
    2{
     rs2
    }
    3{
     rd
    }
    4{
     000
    }
    5{
     00000000
    }
    6{
     000001
    }

   }
   Format{
    ADD rd rs1 rs2
   }
   BaseProcessor{
    true
   }

  }
  SUB  #1{
   Type{
    RR  #1
   }
   Valid{
    true
   }
   Name{
    SUB
   }
   Id{
    15
   }
   EditField{
    1{
     rs1
    }
    2{
     rs2
    }
    3{
     rd
    }
    4{
     000
    }
    5{
     00000001
    }
    6{
     000001
    }

   }
   Format{
    SUB rd rs1 rs2
   }
   BaseProcessor{
    true
   }

  }
  MUL  #1{
   Type{
    RR  #1
   }
   Valid{
    true
   }
   Name{
    MUL
   }
   Id{
    12
   }
   EditField{
    1{
     rs1
    }
    2{
     rs2
    }
    3{
     rd
    }
    4{
     000
    }
    5{
     00000010
    }
    6{
     000001
    }

   }
   Format{
    MUL rd rs1 rs2
   }
   BaseProcessor{
    true
   }

  }
  DIV  #1{
   Type{
    RR  #1
   }
   Valid{
    true
   }
   Name{
    DIV
   }
   Id{
    59
   }
   EditField{
    1{
     rs1
    }
    2{
     rs2
    }
    3{
     rd
    }
    4{
     000
    }
    5{
     00000011
    }
    6{
     000001
    }

   }
   Format{
    DIV rd rs1 rs2
   }
   BaseProcessor{
    true
   }

  }
  DIVU  #1{
   Type{
    RR  #1
   }
   Valid{
    true
   }
   Name{
    DIVU
   }
   Id{
    73
   }
   EditField{
    1{
     rs1
    }
    2{
     rs2
    }
    3{
     rd
    }
    4{
     000
    }
    5{
     00000101
    }
    6{
     000001
    }

   }
   Format{
    DIVU rd rs1 rs2
   }
   BaseProcessor{
    true
   }

  }
  MOD  #1{
   Type{
    RR  #1
   }
   Valid{
    true
   }
   Name{
    MOD
   }
   Id{
    14
   }
   EditField{
    1{
     rs1
    }
    2{
     rs2
    }
    3{
     rd
    }
    4{
     000
    }
    5{
     00000100
    }
    6{
     000001
    }

   }
   Format{
    MOD rd rs1 rs2
   }
   BaseProcessor{
    true
   }

  }
  MODU  #1{
   Type{
    RR  #1
   }
   Valid{
    true
   }
   Name{
    MODU
   }
   Id{
    74
   }
   EditField{
    1{
     rs1
    }
    2{
     rs2
    }
    3{
     rd
    }
    4{
     000
    }
    5{
     00000110
    }
    6{
     000001
    }

   }
   Format{
    MODU rd rs1 rs2
   }
   BaseProcessor{
    true
   }

  }
  AND  #1{
   Type{
    RR  #1
   }
   Valid{
    true
   }
   Name{
    AND
   }
   Id{
    16
   }
   EditField{
    1{
     rs1
    }
    2{
     rs2
    }
    3{
     rd
    }
    4{
     001
    }
    5{
     00000000
    }
    6{
     000001
    }

   }
   Format{
    AND rd rs1 rs2
   }
   BaseProcessor{
    true
   }

  }
  NAND  #1{
   Type{
    RR  #1
   }
   Valid{
    true
   }
   Name{
    NAND
   }
   Id{
    75
   }
   EditField{
    1{
     rs1
    }
    2{
     rs2
    }
    3{
     rd
    }
    4{
     001
    }
    5{
     00000011
    }
    6{
     000001
    }

   }
   Format{
    NAND rd rs1 rs2
   }
   BaseProcessor{
    true
   }

  }
  OR  #1{
   Type{
    RR  #1
   }
   Valid{
    true
   }
   Name{
    OR
   }
   Id{
    17
   }
   EditField{
    1{
     rs1
    }
    2{
     rs2
    }
    3{
     rd
    }
    4{
     001
    }
    5{
     00000001
    }
    6{
     000001
    }

   }
   Format{
    OR rd rs1 rs2
   }
   BaseProcessor{
    true
   }

  }
  NOR  #1{
   Type{
    RR  #1
   }
   Valid{
    true
   }
   Name{
    NOR
   }
   Id{
    76
   }
   EditField{
    1{
     rs1
    }
    2{
     rs2
    }
    3{
     rd
    }
    4{
     001
    }
    5{
     00000100
    }
    6{
     000001
    }

   }
   Format{
    NOR rd rs1 rs2
   }
   BaseProcessor{
    true
   }

  }
  XOR  #1{
   Type{
    RR  #1
   }
   Valid{
    true
   }
   Name{
    XOR
   }
   Id{
    18
   }
   EditField{
    1{
     rs1
    }
    2{
     rs2
    }
    3{
     rd
    }
    4{
     001
    }
    5{
     00000010
    }
    6{
     000001
    }

   }
   Format{
    XOR rd rs1 rs2
   }
   BaseProcessor{
    true
   }

  }
  LLS  #1{
   Type{
    RR  #1
   }
   Valid{
    true
   }
   Name{
    LLS
   }
   Id{
    19
   }
   EditField{
    1{
     rs1
    }
    2{
     rs2
    }
    3{
     rd
    }
    4{
     010
    }
    5{
     00000000
    }
    6{
     000001
    }

   }
   Format{
    LLS rd rs1 rs2
   }
   BaseProcessor{
    true
   }

  }
  LRS  #1{
   Type{
    RR  #1
   }
   Valid{
    true
   }
   Name{
    LRS
   }
   Id{
    20
   }
   EditField{
    1{
     rs1
    }
    2{
     rs2
    }
    3{
     rd
    }
    4{
     010
    }
    5{
     00000001
    }
    6{
     000001
    }

   }
   Format{
    LRS rd rs1 rs2
   }
   BaseProcessor{
    true
   }

  }
  ARS  #1{
   Type{
    RR  #1
   }
   Valid{
    true
   }
   Name{
    ARS
   }
   Id{
    21
   }
   EditField{
    1{
     rs1
    }
    2{
     rs2
    }
    3{
     rd
    }
    4{
     010
    }
    5{
     00000010
    }
    6{
     000001
    }

   }
   Format{
    ARS rd rs1 rs2
   }
   BaseProcessor{
    true
   }

  }
  ELT  #1{
   Type{
    RR  #1
   }
   Valid{
    true
   }
   Name{
    ELT
   }
   Id{
    22
   }
   EditField{
    1{
     rs1
    }
    2{
     rs2
    }
    3{
     rd
    }
    4{
     011
    }
    5{
     00000000
    }
    6{
     000001
    }

   }
   Format{
    ELT rd rs1 rs2
   }
   BaseProcessor{
    true
   }

  }
  ELTU  #1{
   Type{
    RR  #1
   }
   Valid{
    true
   }
   Name{
    ELTU
   }
   Id{
    23
   }
   EditField{
    1{
     rs1
    }
    2{
     rs2
    }
    3{
     rd
    }
    4{
     011
    }
    5{
     00000001
    }
    6{
     000001
    }

   }
   Format{
    ELTU rd rs1 rs2
   }
   BaseProcessor{
    true
   }

  }
  EEQ  #1{
   Type{
    RR  #1
   }
   Valid{
    true
   }
   Name{
    EEQ
   }
   Id{
    24
   }
   EditField{
    1{
     rs1
    }
    2{
     rs2
    }
    3{
     rd
    }
    4{
     011
    }
    5{
     00000010
    }
    6{
     000001
    }

   }
   Format{
    EEQ rd rs1 rs2
   }
   BaseProcessor{
    true
   }

  }
  ENEQ  #1{
   Type{
    RR  #1
   }
   Valid{
    true
   }
   Name{
    ENEQ
   }
   Id{
    25
   }
   EditField{
    1{
     rs1
    }
    2{
     rs2
    }
    3{
     rd
    }
    4{
     011
    }
    5{
     00000011
    }
    6{
     000001
    }

   }
   Format{
    ENEQ rd rs1 rs2
   }
   BaseProcessor{
    true
   }

  }
  ADDI  #1{
   Type{
    RI  #1
   }
   Valid{
    true
   }
   Name{
    ADDI
   }
   Id{
    29
   }
   EditField{
    1{
     const
    }
    2{
     rs1
    }
    3{
     rd
    }
    4{
     100000
    }

   }
   Format{
    ADDI rd rs1 const
   }
   BaseProcessor{
    true
   }

  }
  SUBI  #1{
   Type{
    RI  #1
   }
   Valid{
    true
   }
   Name{
    SUBI
   }
   Id{
    28
   }
   EditField{
    1{
     const
    }
    2{
     rs1
    }
    3{
     rd
    }
    4{
     100001
    }

   }
   Format{
    SUBI rd rs1 const
   }
   BaseProcessor{
    true
   }

  }
  ANDI  #1{
   Type{
    RI  #1
   }
   Valid{
    true
   }
   Name{
    ANDI
   }
   Id{
    30
   }
   EditField{
    1{
     const
    }
    2{
     rs1
    }
    3{
     rd
    }
    4{
     100010
    }

   }
   Format{
    ANDI rd rs1 const
   }
   BaseProcessor{
    true
   }

  }
  ORI  #1{
   Type{
    RI  #1
   }
   Valid{
    true
   }
   Name{
    ORI
   }
   Id{
    31
   }
   EditField{
    1{
     const
    }
    2{
     rs1
    }
    3{
     rd
    }
    4{
     100011
    }

   }
   Format{
    ORI rd rs1 const
   }
   BaseProcessor{
    true
   }

  }
  XORI  #1{
   Type{
    RI  #1
   }
   Valid{
    true
   }
   Name{
    XORI
   }
   Id{
    32
   }
   EditField{
    1{
     const
    }
    2{
     rs1
    }
    3{
     rd
    }
    4{
     100100
    }

   }
   Format{
    XORI rd rs1 const
   }
   BaseProcessor{
    true
   }

  }
  LLSI  #1{
   Type{
    RI  #1
   }
   Valid{
    true
   }
   Name{
    LLSI
   }
   Id{
    33
   }
   EditField{
    1{
     const
    }
    2{
     rs1
    }
    3{
     rd
    }
    4{
     100101
    }

   }
   Format{
    LLSI rd rs1 const
   }
   BaseProcessor{
    true
   }

  }
  LRSI  #1{
   Type{
    RI  #1
   }
   Valid{
    true
   }
   Name{
    LRSI
   }
   Id{
    34
   }
   EditField{
    1{
     const
    }
    2{
     rs1
    }
    3{
     rd
    }
    4{
     100110
    }

   }
   Format{
    LRSI rd rs1 const
   }
   BaseProcessor{
    true
   }

  }
  ARSI  #1{
   Type{
    RI  #1
   }
   Valid{
    true
   }
   Name{
    ARSI
   }
   Id{
    35
   }
   EditField{
    1{
     const
    }
    2{
     rs1
    }
    3{
     rd
    }
    4{
     100111
    }

   }
   Format{
    ARSI rd rs1 const
   }
   BaseProcessor{
    true
   }

  }
  LSOI  #1{
   Type{
    RI  #1
   }
   Valid{
    true
   }
   Name{
    LSOI
   }
   Id{
    66
   }
   EditField{
    1{
     const
    }
    2{
     rs1
    }
    3{
     rd
    }
    4{
     101000
    }

   }
   Format{
    LSOI rd rs1 const
   }
   BaseProcessor{
    true
   }

  }
  LB  #1{
   Type{
    MA_LD  #1
   }
   Valid{
    true
   }
   Name{
    LB
   }
   Id{
    79
   }
   EditField{
    1{
     const
    }
    2{
     rs1
    }
    3{
     rd
    }
    4{
     000010
    }

   }
   Format{
    LB rd addr
   }
   BaseProcessor{
    true
   }

  }
  LH  #1{
   Type{
    MA_LD  #1
   }
   Valid{
    true
   }
   Name{
    LH
   }
   Id{
    80
   }
   EditField{
    1{
     const
    }
    2{
     rs1
    }
    3{
     rd
    }
    4{
     000011
    }

   }
   Format{
    LH rd addr
   }
   BaseProcessor{
    true
   }

  }
  LW  #1{
   Type{
    MA_LD  #1
   }
   Valid{
    true
   }
   Name{
    LW
   }
   Id{
    81
   }
   EditField{
    1{
     const
    }
    2{
     rs1
    }
    3{
     rd
    }
    4{
     000100
    }

   }
   Format{
    LW rd addr
   }
   BaseProcessor{
    true
   }

  }
  SB  #1{
   Type{
    MA_ST  #1
   }
   Valid{
    true
   }
   Name{
    SB
   }
   Id{
    82
   }
   EditField{
    1{
     const
    }
    2{
     rs1
    }
    3{
     rd
    }
    4{
     000101
    }

   }
   Format{
    SB addr rs1
   }
   BaseProcessor{
    true
   }

  }
  SH  #1{
   Type{
    MA_ST  #1
   }
   Valid{
    true
   }
   Name{
    SH
   }
   Id{
    83
   }
   EditField{
    1{
     const
    }
    2{
     rs1
    }
    3{
     rd
    }
    4{
     000110
    }

   }
   Format{
    SH addr rs1
   }
   BaseProcessor{
    true
   }

  }
  SW  #1{
   Type{
    MA_ST  #1
   }
   Valid{
    true
   }
   Name{
    SW
   }
   Id{
    84
   }
   EditField{
    1{
     const
    }
    2{
     rs1
    }
    3{
     rd
    }
    4{
     000111
    }

   }
   Format{
    SW addr rs1
   }
   BaseProcessor{
    true
   }

  }
  BRZ  #1{
   Type{
    BR  #1
   }
   Valid{
    true
   }
   Name{
    BRZ
   }
   Id{
    44
   }
   EditField{
    1{
     const
    }
    2{
     rs1
    }
    3{
     unused
    }
    4{
     001001
    }

   }
   Format{
    BRZ rs1 const
   }
   BaseProcessor{
    true
   }

  }
  BRNZ  #1{
   Type{
    BR  #1
   }
   Valid{
    true
   }
   Name{
    BRNZ
   }
   Id{
    45
   }
   EditField{
    1{
     const
    }
    2{
     rs1
    }
    3{
     unused
    }
    4{
     001010
    }

   }
   Format{
    BRNZ rs1 const
   }
   BaseProcessor{
    true
   }

  }
  JP  #1{
   Type{
    JP  #1
   }
   Valid{
    true
   }
   Name{
    JP
   }
   Id{
    46
   }
   EditField{
    1{
     const
    }
    2{
     001011
    }

   }
   Format{
    JP const
   }
   BaseProcessor{
    true
   }

  }
  JPL  #1{
   Type{
    JP  #1
   }
   Valid{
    true
   }
   Name{
    JPL
   }
   Id{
    47
   }
   EditField{
    1{
     const
    }
    2{
     001100
    }

   }
   Format{
    JPL const
   }
   BaseProcessor{
    true
   }

  }
  TRAP  #1{
   Type{
    JP  #1
   }
   Valid{
    true
   }
   Name{
    TRAP
   }
   Id{
    48
   }
   EditField{
    1{
     const
    }
    2{
     001101
    }

   }
   Format{
    TRAP const
   }
   BaseProcessor{
    true
   }

  }
  JPR  #1{
   Type{
    JPR  #1
   }
   Valid{
    true
   }
   Name{
    JPR
   }
   Id{
    49
   }
   EditField{
    1{
     unused
    }
    2{
     rs1
    }
    3{
     001110
    }

   }
   Format{
    JPR rs1
   }
   BaseProcessor{
    true
   }

  }
  JPRL  #1{
   Type{
    JPR  #1
   }
   Valid{
    true
   }
   Name{
    JPRL
   }
   Id{
    50
   }
   EditField{
    1{
     unused
    }
    2{
     rs1
    }
    3{
     001111
    }

   }
   Format{
    JPRL rs1
   }
   BaseProcessor{
    true
   }

  }
  NOP  #1{
   Type{
    SP  #1
   }
   Valid{
    true
   }
   Name{
    NOP
   }
   Id{
    51
   }
   EditField{
    1{
     unused
    }
    2{
     00000
    }
    3{
     000000
    }

   }
   Format{
    NOP
   }
   BaseProcessor{
    true
   }

  }
  RETI  #1{
   Type{
    SP  #1
   }
   Valid{
    true
   }
   Name{
    RETI
   }
   Id{
    52
   }
   EditField{
    1{
     unused
    }
    2{
     00001
    }
    3{
     000000
    }

   }
   Format{
    RETI
   }
   BaseProcessor{
    true
   }

  }
  EXBW  #1{
   Type{
    RT  #1
   }
   Valid{
    true
   }
   Name{
    EXBW
   }
   Id{
    77
   }
   EditField{
    1{
     rd
    }
    2{
     rs1
    }
    3{
     00000000000
    }
    4{
     00010
    }
    5{
     000000
    }

   }
   Format{
    EXBW rd rs1
   }
   BaseProcessor{
    true
   }

  }
  EXHW  #1{
   Type{
    RT  #1
   }
   Valid{
    true
   }
   Name{
    EXHW
   }
   Id{
    78
   }
   EditField{
    1{
     rd
    }
    2{
     rs1
    }
    3{
     00000000001
    }
    4{
     00010
    }
    5{
     000000
    }

   }
   Format{
    EXHW rd rs1
   }
   BaseProcessor{
    true
   }

  }

 }

}
OperationDesc{
 Complete{
  OFF
 }
 InstBehavior{
  
 }
 ExceptionBehavior{
  EXTINT{
   valid{
    true
   }
   type{
    External
   }
   cycle{
    1
   }
   description{
    
   }
   assertion{
    
   }
   comment{
    
   }
   condition{
    condition_type{
     Unselected
    }
    EXTINT_IN{
     valid{
      true
     }
     active_value{
      1
     }

    }

   }
   mask{
    maskable{
     YES
    }
    register_name{
     DUMMY_STREG
    }
    position{
     8
    }
    register_value{
     0
    }

   }

  }
  RESET{
   valid{
    true
   }
   type{
    Reset
   }
   cycle{
    1
   }
   description{
    
   }
   assertion{
    
   }
   comment{
    
   }
   condition{
    condition_type{
     Unselected
    }
    RESET{
     valid{
      true
     }
     active_value{
      1
     }

    }

   }
   mask{
    maskable{
     NO
    }
    register_name{
     Unselected
    }
    position{
     
    }
    register_value{
     
    }

   }

  }
  TRAPINT{
   valid{
    true
   }
   type{
    Internal
   }
   cycle{
    1
   }
   description{
    
   }
   assertion{
    
   }
   comment{
    
   }
   condition{
    condition_type{
     instr_specific
    }

   }
   mask{
    maskable{
     YES
    }
    register_name{
     DUMMY_STREG
    }
    position{
     9
    }
    register_value{
     0
    }

   }

  }

 }

}
CdefinitionDecl{
 Complete{
  ON
 }
 C_data_type{
  0{
   type{
    char
   }
   alignment{
    8
   }
   size{
    8
   }

  }
  1{
   type{
    short
   }
   alignment{
    16
   }
   size{
    16
   }

  }
  2{
   type{
    int
   }
   alignment{
    32
   }
   size{
    32
   }

  }
  3{
   type{
    long
   }
   alignment{
    32
   }
   size{
    32
   }

  }
  4{
   type{
    float
   }
   alignment{
    32
   }
   size{
    32
   }

  }
  5{
   type{
    double
   }
   alignment{
    64
   }
   size{
    64
   }

  }
  6{
   type{
    pointer
   }
   alignment{
    32
   }
   size{
    32
   }

  }
  7{
   type{
    struct
   }
   alignment{
    8
   }
   size{
    none
   }

  }
  8{
   type{
    stack
   }
   alignment{
    32
   }
   size{
    none
   }

  }
  9{
   type{
    data
   }
   alignment{
    8
   }
   size{
    none
   }

  }

 }
 Data_macro{
  Int7to0,
SInt7to0,
UInt7to0,
Int15to0,
SInt15to0,
UInt15to0,
Int31to0,
SInt31to0,
UInt31to0,
Int63to0,
SInt63to0,
UInt63to0,
 }
 C_ckf_prototype{
  
 }

}
MOD{
 Complete{
  ON
 }
 Common{
  COMMON{
   
  }

 }
 Instruction{
  ADD  #1{
   id{
    10
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRDoubleRead(rs1, rs2)
   }
   3{
    ALUExec(add, source1, source2)
UpdateSTRegFlag(alu_flag)

ForwardDataFromEXE(rd, alu_result)
   }
   4{
    WriteBack(rd, alu_result)

ForwardDataFromWB(rd, alu_result)
   }

  }
  SUB  #1{
   id{
    15
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRDoubleRead(rs1, rs2)
   }
   3{
    ALUExec(sub, source1, source2)
UpdateSTRegFlag(alu_flag)

ForwardDataFromEXE(rd, alu_result)
   }
   4{
    WriteBack(rd, alu_result)

ForwardDataFromWB(rd, alu_result)
   }

  }
  MUL  #1{
   id{
    12
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRDoubleRead(rs1, rs2)
   }
   3{
    MULExec(mul, source1, source2)

ForwardDataFromEXE(rd, mul_result)
   }
   4{
    WriteBack(rd, mul_result)

ForwardDataFromWB(rd, mul_result)
   }

  }
  DIV  #1{
   id{
    59
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRDoubleRead(rs1, rs2)
   }
   3{
    DIVExec(div, source1, source2)

ForwardDataFromEXE(rd, div_result)
   }
   4{
    WriteBack(rd, div_result)

ForwardDataFromWB(rd, div_result)
   }

  }
  DIVU  #1{
   id{
    73
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRDoubleRead(rs1, rs2)
   }
   3{
    DIVExec(divu, source1, source2)

ForwardDataFromEXE(rd, div_result)
   }
   4{
    WriteBack(rd, div_result)

ForwardDataFromWB(rd, div_result)
   }

  }
  MOD  #1{
   id{
    14
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRDoubleRead(rs1, rs2)
   }
   3{
    DIVExec(div, source1, source2)

ForwardDataFromEXE(rd, mod_result)
   }
   4{
    WriteBack(rd, mod_result)

ForwardDataFromWB(rd, mod_result)
   }

  }
  MODU  #1{
   id{
    74
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRDoubleRead(rs1, rs2)
   }
   3{
    DIVExec(divu, source1, source2)

ForwardDataFromEXE(rd, mod_result)
   }
   4{
    WriteBack(rd, mod_result)

ForwardDataFromWB(rd, mod_result)
   }

  }
  AND  #1{
   id{
    16
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRDoubleRead(rs1, rs2)
   }
   3{
    ALUExec(and, source1, source2)

ForwardDataFromEXE(rd, alu_result)
   }
   4{
    WriteBack(rd, alu_result)

ForwardDataFromWB(rd, alu_result)
   }

  }
  NAND  #1{
   id{
    75
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRDoubleRead(rs1, rs2)
   }
   3{
    ALUExec(nand, source1, source2)

ForwardDataFromEXE(rd, alu_result)
   }
   4{
    WriteBack(rd, alu_result)

ForwardDataFromWB(rd, alu_result)
   }

  }
  OR  #1{
   id{
    17
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRDoubleRead(rs1, rs2)
   }
   3{
    ALUExec(or, source1, source2)

ForwardDataFromEXE(rd, alu_result)
   }
   4{
    WriteBack(rd, alu_result)

ForwardDataFromWB(rd, alu_result)
   }

  }
  NOR  #1{
   id{
    76
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRDoubleRead(rs1, rs2)
   }
   3{
    ALUExec(nor, source1, source2)

ForwardDataFromEXE(rd, alu_result)
   }
   4{
    WriteBack(rd, alu_result)

ForwardDataFromWB(rd, alu_result)
   }

  }
  XOR  #1{
   id{
    18
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRDoubleRead(rs1, rs2)
   }
   3{
    ALUExec(xor, source1, source2)

ForwardDataFromEXE(rd, alu_result)
   }
   4{
    WriteBack(rd, alu_result)

ForwardDataFromWB(rd, alu_result)
   }

  }
  LLS  #1{
   id{
    19
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRDoubleRead(rs1, rs2)
sft_amt = source2[4:0];
   }
   3{
    SFTExec(sll, source1)

ForwardDataFromEXE(rd, sft_result)
   }
   4{
    WriteBack(rd, sft_result)

ForwardDataFromWB(rd, sft_result)
   }

  }
  LRS  #1{
   id{
    20
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRDoubleRead(rs1, rs2)
sft_amt = source2[4:0];
   }
   3{
    SFTExec(srl, source1)

ForwardDataFromEXE(rd, sft_result)
   }
   4{
    WriteBack(rd, sft_result)

ForwardDataFromWB(rd, sft_result)
   }

  }
  ARS  #1{
   id{
    21
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRDoubleRead(rs1, rs2)
sft_amt = source2[4:0];
   }
   3{
    SFTExec(sra, source1)

ForwardDataFromEXE(rd, sft_result)
   }
   4{
    WriteBack(rd, sft_result)

ForwardDataFromWB(rd, sft_result)
   }

  }
  ELT  #1{
   id{
    22
   }
   variable{
    wire [31:0] cmp_result;
   }
   1{
    Fetch()
   }
   2{
    GPRDoubleRead(rs1, rs2)
   }
   3{
    wire [30:0] zero;

ALUCmp(cmp, source1, source2)

zero       = \"0000000000000000000000000000000\"; // 31 bits zeros
cmp_result = <zero, cmp_lt>;                    // zero extension

ForwardDataFromEXE(rd, cmp_result)
   }
   4{
    WriteBack(rd, cmp_result)

ForwardDataFromWB(rd, cmp_result)
   }

  }
  ELTU  #1{
   id{
    23
   }
   variable{
    wire [31:0] cmp_result;
   }
   1{
    Fetch()
   }
   2{
    GPRDoubleRead(rs1, rs2)
   }
   3{
    wire [30:0] zero;

ALUCmp(cmp, source1, source2)

zero       = \"0000000000000000000000000000000\"; // 31 bits zeros
cmp_result = <zero, cmp_ult>;                   // zero extension

ForwardDataFromEXE(rd, cmp_result)
   }
   4{
    WriteBack(rd, cmp_result)

ForwardDataFromWB(rd, cmp_result)
   }

  }
  EEQ  #1{
   id{
    24
   }
   variable{
    wire [31:0] cmp_result;
   }
   1{
    Fetch()
   }
   2{
    GPRDoubleRead(rs1, rs2)
   }
   3{
    wire [30:0] zero;

ALUCmp(cmp, source1, source2)

zero       = \"0000000000000000000000000000000\"; // 31 bits zeros
cmp_result = <zero, cmp_equal>;                 // zero extension

ForwardDataFromEXE(rd, cmp_result)
   }
   4{
    WriteBack(rd, cmp_result)

ForwardDataFromWB(rd, cmp_result)
   }

  }
  ENEQ  #1{
   id{
    25
   }
   variable{
    wire [31:0] cmp_result;
   }
   1{
    Fetch()
   }
   2{
    GPRDoubleRead(rs1, rs2)
   }
   3{
    wire [30:0] zero;

ALUCmp(cmp, source1, source2)

zero       = \"0000000000000000000000000000000\"; // 31 bits zeros
cmp_result = <zero, cmp_nequal>;                // zero extension

ForwardDataFromEXE(rd, cmp_result)
   }
   4{
    WriteBack(rd, cmp_result)

ForwardDataFromWB(rd, cmp_result)
   }

  }
  ADDI  #1{
   id{
    29
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRReadExt16To32(sign, rs1, const)
   }
   3{
    ALUExec(add, source1, source2)
UpdateSTRegFlag(alu_flag)

ForwardDataFromEXE(rd, alu_result)
   }
   4{
    WriteBack(rd, alu_result)

ForwardDataFromWB(rd, alu_result)
   }

  }
  SUBI  #1{
   id{
    28
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRReadExt16To32(sign, rs1, const)
   }
   3{
    ALUExec(sub, source1, source2)
UpdateSTRegFlag(alu_flag)

ForwardDataFromEXE(rd, alu_result)
   }
   4{
    WriteBack(rd, alu_result)

ForwardDataFromWB(rd, alu_result)
   }

  }
  ANDI  #1{
   id{
    30
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRReadExt16To32(zero, rs1, const)
   }
   3{
    ALUExec(and, source1, source2)

ForwardDataFromEXE(rd, alu_result)
   }
   4{
    WriteBack(rd, alu_result)

ForwardDataFromWB(rd, alu_result)
   }

  }
  ORI  #1{
   id{
    31
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRReadExt16To32(zero, rs1, const)
   }
   3{
    ALUExec(or, source1, source2)

ForwardDataFromEXE(rd, alu_result)
   }
   4{
    WriteBack(rd, alu_result)

ForwardDataFromWB(rd, alu_result)
   }

  }
  XORI  #1{
   id{
    32
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRReadExt16To32(zero, rs1, const)
   }
   3{
    ALUExec(xor, source1, source2)

ForwardDataFromEXE(rd, alu_result)
   }
   4{
    WriteBack(rd, alu_result)

ForwardDataFromWB(rd, alu_result)
   }

  }
  LLSI  #1{
   id{
    33
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRRead(rs1)
sft_amt = const[4:0];
   }
   3{
    SFTExec(sll, source1)

ForwardDataFromEXE(rd, sft_result)
   }
   4{
    WriteBack(rd, sft_result)

ForwardDataFromWB(rd, sft_result)
   }

  }
  LRSI  #1{
   id{
    34
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRRead(rs1)
sft_amt = const[4:0];
   }
   3{
    SFTExec(srl, source1)

ForwardDataFromEXE(rd, sft_result)
   }
   4{
    WriteBack(rd, sft_result)

ForwardDataFromWB(rd, sft_result)
   }

  }
  ARSI  #1{
   id{
    35
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRRead(rs1)
sft_amt = const[4:0];
   }
   3{
    SFTExec(sra, source1)

ForwardDataFromEXE(rd, sft_result)
   }
   4{
    WriteBack(rd, sft_result)

ForwardDataFromWB(rd, sft_result)
   }

  }
  LSOI  #1{
   id{
    66
   }
   variable{
    wire [31:0] shifted_source1;
   }
   1{
    Fetch()
   }
   2{
    wire [15:0] lower_bits;
wire [15:0] zeros;

GPRReadExt16To32(zero, rs1, const)

// shift source data before OR
lower_bits      = source1[15:0];
zeros           = \"0000000000000000\";
shifted_source1 = <lower_bits, zeros>;
   }
   3{
    ALUExec(or, shifted_source1, source2)

ForwardDataFromEXE(rd, alu_result)
   }
   4{
    WriteBack(rd, alu_result)

ForwardDataFromWB(rd, alu_result)
   }

  }
  LB  #1{
   id{
    79
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRReadExt16To32(sign, rs1, const)
   }
   3{
    ALUExec(add, source1, source2)
   }
   4{
    Load(ld_8, alu_result)

WriteBack(rd, load_result)

ForwardDataFromWB(rd, load_result)
   }

  }
  LH  #1{
   id{
    80
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRReadExt16To32(sign, rs1, const)
   }
   3{
    ALUExec(add, source1, source2)
   }
   4{
    Load(ld_16, alu_result)

WriteBack(rd, load_result)

ForwardDataFromWB(rd, load_result)
   }

  }
  LW  #1{
   id{
    81
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRReadExt16To32(sign, rs1, const)
   }
   3{
    ALUExec(add, source1, source2)
   }
   4{
    Load(ld_32, alu_result)

WriteBack(rd, load_result)

ForwardDataFromWB(rd, load_result)
   }

  }
  SB  #1{
   id{
    82
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRDoubleReadExt16To32(sign, rd, rs1, const)
   }
   3{
    ALUExec(add, source1, source3)
   }
   4{
    Store(s_8, source2, alu_result)
   }

  }
  SH  #1{
   id{
    83
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRDoubleReadExt16To32(sign, rd, rs1, const)
   }
   3{
    ALUExec(add, source1, source3)
   }
   4{
    Store(s_16, source2, alu_result)
   }

  }
  SW  #1{
   id{
    84
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRDoubleReadExt16To32(sign, rd, rs1, const)
   }
   3{
    ALUExec(add, source1, source3)
   }
   4{
    Store(s_32, source2, alu_result)
   }

  }
  BRZ  #1{
   id{
    44
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    PCRead()
GPRReadExt16To32(sign, rs1, const)
   }
   3{
    RelativeBranchZ(==, source1, pcread_result, source2)
   }
   4{
    
   }

  }
  BRNZ  #1{
   id{
    45
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    PCRead()
GPRReadExt16To32(sign, rs1, const)
   }
   3{
    RelativeBranchZ(!=, source1, pcread_result, source2)
   }
   4{
    
   }

  }
  JP  #1{
   id{
    46
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    PCRead()
Ext26To32(sign, const)
   }
   3{
    RelativeJump(pcread_result, ext26to32_result)
   }
   4{
    
   }

  }
  JPL  #1{
   id{
    47
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    // read PC first in order to save 
// pc_read_result is [PC(address where this inst. is placed) + word_size(4)]
PCRead()
Ext26To32(sign, const)
   }
   3{
    wire [4:0] linkreg_idx;
linkreg_idx = \"00011\";

RelativeJump(pcread_result, ext26to32_result)

ForwardDataFromEXE(linkreg_idx, pcread_result)
   }
   4{
    wire [4:0] linkreg_idx;
linkreg_idx = \"00011\";

WriteBack(linkreg_idx, pcread_result)

ForwardDataFromWB(linkreg_idx, pcread_result)
   }

  }
  TRAP  #1{
   id{
    48
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    Ext26To32(zero, const)

// store handler address
// this address will be used in TRAP_INT
null = TRAP_HAND_REG.write(ext26to32_result);
   }
   3{
    // throw exception
throw TRAPINT;
   }
   4{
    
   }

  }
  JPR  #1{
   id{
    49
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    GPRRead(rs1)
   }
   3{
    AbsoluteJump(source1)
   }
   4{
    
   }

  }
  JPRL  #1{
   id{
    50
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    // read PC first in order to save 
// pc_read_result is [PC(address where this inst. is placed) + word_size(4)]
PCRead()
GPRRead(rs1)
   }
   3{
    wire [4:0] linkreg_idx;
linkreg_idx = \"00011\";

AbsoluteJump(source1)

ForwardDataFromEXE(linkreg_idx, pcread_result)
   }
   4{
    wire [4:0] linkreg_idx;
linkreg_idx = \"00011\";

WriteBack(linkreg_idx, pcread_result)

ForwardDataFromWB(linkreg_idx, pcread_result)
   }

  }
  NOP  #1{
   id{
    51
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    
   }
   3{
    
   }
   4{
    
   }

  }
  RETI  #1{
   id{
    52
   }
   variable{
    
   }
   1{
    Fetch()
   }
   2{
    wire [4:0] ret_idx;

ret_idx = \"00010\";                // interrupt return address is stored in GPR2
GPRRead(ret_idx)                  // get return address
STRegRead()                       // read status register
   }
   3{
    wire [31:0] new_st;
wire [31:0] mask;

mask         = \"00000000000000000100001100000000\"; // clear interrupt mask and move to user mode
new_st       = streg_read_result | mask;           // 
null         = GPR.status_write(new_st);           // update status register (interrupt will be enabled at next cycle)

AbsoluteJump(source1)
   }
   4{
    
   }

  }
  EXBW  #1{
   id{
    77
   }
   variable{
    wire [31:0] extended_data;
   }
   1{
    Fetch()
   }
   2{
    GPRRead(rs1)
   }
   3{
    wire [7:0] target;

target        = source1[7:0];
extended_data = EXT8TO32.sign(target);

ForwardDataFromEXE(rd, extended_data)
   }
   4{
    WriteBack(rd, extended_data)

ForwardDataFromWB(rd, extended_data)
   }

  }
  EXHW  #1{
   id{
    78
   }
   variable{
    wire [31:0] extended_data;
   }
   1{
    Fetch()
   }
   2{
    GPRRead(rs1)
   }
   3{
    wire [15:0] target;

target        = source1[15:0];
extended_data = EXT16TO32A.sign(target);

ForwardDataFromEXE(rd, extended_data)
   }
   4{
    WriteBack(rd, extended_data)

ForwardDataFromWB(rd, extended_data)
   }

  }

 }
 Exception{
  EXTINT{
   variable{
    wire [31:0] ret_addr;
wire [31:0] handler_addr;
wire [4:0]  rsave;
wire [4:0]  rstatus;
wire [31:0] mask;
wire [31:0] current_st;
wire [31:0] new_st;
wire        one;
   }
   1{
    ret_addr     = saved_pc;                           // Get saved pc
handler_addr = \"00001111111111100000010000000000\"; // 0x0FFE0400 (fixed)
mask         = \"11111111111111111011110011111111\"; // clear 8,9 bit and 14 bit (interrupt mask and set the mode kernel)
rsave        = \"00010\";                            // R2 (Interrupt Return)
rstatus      = \"00001\";                            // R1 (Status Register)
one          = '1';

current_st   = DUMMY_STREG.read();                 // load current status
new_st       = current_st & mask;                  // masking interrupts

null = EXTCATCH_OUT.write(one);                    // output catch signal for 1 cycle
null = GPR.write0(rsave, ret_addr);                // write return address
null = GPR.status_write(new_st);                   // write masked status
null = PC.write(handler_addr);                     // jump to the handler
   }

  }
  RESET{
   variable{
    wire [31:0] reset_handler;
   }
   1{
    // set the pc 0x0FFE0000
reset_handler = \"00001111111111100000000000000000\";
null = PC.write(reset_handler);

// reset all memories
null = GPR.reset();
null = IR.reset();
null = DIV.reset();
null = MUL.reset();
null = TRAP_HAND_REG.reset();
   }

  }
  TRAPINT{
   variable{
    wire [31:0] ret_addr;
wire [31:0] handler_addr;
wire [4:0]  rsave;
wire [4:0]  rstatus;
wire [31:0] mask;
wire [31:0] current_st;
wire [31:0] new_st;
wire [31:0] trap_factor;
wire [31:0] trap_base;
wire [3:0]  trap_alu_flag;
   }
   1{
    ret_addr     = saved_pc;                           // Get saved pc
trap_base    = \"00001111111111100000100000000000\"; // 0x0FFE0800 (fixed)
mask         = \"11111111111111111011110011111111\"; // clear 8,9 bit and 14 bit (interrupt mask and set the mode kernel)
rsave        = \"00010\";                            // R2 (Interrupt Return)
rstatus      = \"00001\";                            // R1 (Status Register)

current_st   = DUMMY_STREG.read();                 // load current status
new_st       = current_st & mask;                  // masking interrupts

trap_factor  = TRAP_HAND_REG.read();               // get trap factor
<handler_addr, trap_alu_flag>
             = ALU.add(trap_base, trap_factor);    // calculate dest. addr.


null = GPR.write0(rsave, ret_addr);                // write return address
null = GPR.status_write(new_st);                   // write masked status
null = PC.write(handler_addr);                     // jump to the handler
   }

  }

 }
 Macro{
  Fetch(){
   variable{
    /* these variables can be used in following stages of all instructions */
   }
   1{
    wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;                             // the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);
   }
   BaseProcessor{
    true
   }

  }
  PCRead(){
   variable{
    /* these variables can be used in following stages of all instructions */
wire [31:0] pcread_result;
   }
   1{
    pcread_result = PC.read();
   }
   BaseProcessor{
    true
   }

  }
  STRegRead(){
   variable{
    /* these variables can be used in following stages of all instructions */
wire [31:0] streg_read_result;
   }
   1{
    streg_read_result = DUMMY_STREG.read();
   }
   BaseProcessor{
    true
   }

  }
  UpdateSTRegFlag(flagin){
   variable{
    
   }
   1{
    wire [4:0] update_streg_flag_stfl_in;
wire       update_streg_flag_reserved_bits;

update_streg_flag_reserved_bits = '0';
update_streg_flag_stfl_in       = <update_streg_flag_reserved_bits, flagin>;

// we can update flag using the function of flag_update
null                            = GPR.flag_update(update_streg_flag_stfl_in);
   }
   BaseProcessor{
    true
   }

  }
  GPRRead(src1){
   variable{
    wire [31:0] source1;
   }
   1{
    wire [31:0] gpr_read_stmp1;

// prefetch data from GPR,
// then choose either the data or the forwarded one
gpr_read_stmp1 = GPR.read0(src1);
source1        = FWU0.forward(src1, gpr_read_stmp1);
   }
   BaseProcessor{
    true
   }

  }
  GPRReadExt16To32(extmode,src1,const){
   variable{
    wire [31:0]  source1;
wire [31:0]  source2;
   }
   1{
    // prefetched data
wire [31:0] gpr_read_ext16to32_stmp1;
wire [31:0] gpr_read_ext16to32_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_read_ext16to32_stmp1 = GPR.read0(src1);
gpr_read_ext16to32_stmp2 = EXT16TO32.extmode(const);

// get source value
// from GPR or forwarded value selectively
source1 = FWU0.forward(src1, gpr_read_ext16to32_stmp1);
source2 = gpr_read_ext16to32_stmp2;
   }
   BaseProcessor{
    true
   }

  }
  GPRDoubleRead(src1,src2){
   variable{
    wire [31:0]  source1;
wire [31:0]  source2;
   }
   1{
    // prefetched data
wire [31:0]  gpr_double_read_stmp1;
wire [31:0]  gpr_double_read_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_double_read_stmp1   = GPR.read0(src1);
gpr_double_read_stmp2   = GPR.read1(src2);

// get source value
// from GPR or forwarded value selectively
source1  = FWU0.forward(src1, gpr_double_read_stmp1);
source2  = FWU1.forward(src2, gpr_double_read_stmp2);
   }
   BaseProcessor{
    true
   }

  }
  GPRDoubleReadExt16To32(extmode,src1,src2,const){
   variable{
    wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  source3;
   }
   1{
    // prefetched data
wire [31:0]  gpr_double_read_ext16to32_stmp1;
wire [31:0]  gpr_double_read_ext16to32_stmp2;
wire [31:0]  gpr_double_read_ext16to32_stmp3;

// prefetch GPR data to stmp1/stmp2
// and also, STATUS_REG data to stmp3
gpr_double_read_ext16to32_stmp1 = GPR.read0(src1);
gpr_double_read_ext16to32_stmp2 = GPR.read1(src2);
gpr_double_read_ext16to32_stmp3 = EXT16TO32.extmode(const);

// get source value
// from GPR or forwarded value selectively
source1 = FWU0.forward(src1, gpr_double_read_ext16to32_stmp1);
source2 = FWU1.forward(src2, gpr_double_read_ext16to32_stmp2);
source3 = gpr_double_read_ext16to32_stmp3;
   }
   BaseProcessor{
    true
   }

  }
  WriteBack(dest,data){
   variable{
    
   }
   1{
    null = GPR.write0(dest, data);        // write data[arg2] to GPR[arg1]
   }
   BaseProcessor{
    true
   }

  }
  WriteBackStatus(data){
   variable{
    
   }
   1{
    null = GPR.status_write(data);
   }
   BaseProcessor{
    true
   }

  }
  ALUExec(ope,data1,data2){
   variable{
    wire [31:0]  alu_result;
wire [3:0]   alu_flag;
   }
   1{
    // execute operation[ope] using data arg1 and arg2
<alu_result, alu_flag> = ALU.ope(data1, data2);
   }
   BaseProcessor{
    true
   }

  }
  ALUCmp(ope,data1,data2){
   variable{
    /* we can use only cmp_flags corresponding chosen operation */

wire cmp_equal;  /* equal to */
wire cmp_nequal; /* not equal to */
wire cmp_lt;     /* less than */
wire cmp_ult;    /* unsigned less than */
   }
   1{
    wire [3:0] alu_cmp_alu_flag;
wire [1:0] alu_cmp_tmp_flag;
wire       alu_cmp_lt_cond1;
wire       alu_cmp_lt_cond2;
wire       alu_cmp_carry;

alu_cmp_alu_flag = ALU.ope(data1, data2);

// calculate each flag
// equal to is evaluated depending on zero flag
cmp_equal  = alu_cmp_alu_flag[2];

// not equal to is negative of cmp_equal
cmp_nequal = ~cmp_equal;

// signed less than is either sign bit is 1 with no overflow
//                     or     sign bit is 0 with overflow
alu_cmp_tmp_flag   = alu_cmp_alu_flag[1:0];

alu_cmp_lt_cond1   = alu_cmp_tmp_flag == \"10\";
alu_cmp_lt_cond2   = alu_cmp_tmp_flag == \"01\";
cmp_lt             = alu_cmp_lt_cond1 | alu_cmp_lt_cond2;

// unsigned less than is negative carry
alu_cmp_carry      = alu_cmp_alu_flag[3];
cmp_ult            = ~alu_cmp_carry;
   }
   BaseProcessor{
    true
   }

  }
  MULExec(ope,data1,data2){
   variable{
    wire [31:0]  mul_result;
   }
   1{
    wire [63:0]  mul_exec_tmp_result;

// multiplier execution
mul_exec_tmp_result = MUL.ope(data1, data2);
mul_result          = mul_exec_tmp_result[31:0];
   }
   BaseProcessor{
    true
   }

  }
  DIVExec(ope,data1,data2){
   variable{
    wire [31:0]  div_result;
wire [31:0]  mod_result;
   }
   1{
    wire div_exec_div_flag;

// division execution
<div_result, mod_result, div_exec_div_flag> = DIV.ope(data1, data2);
   }
   BaseProcessor{
    true
   }

  }
  SFTExec(ope,data1){
   variable{
    wire [31:0]  sft_result;
wire [4:0] sft_amt;
   }
   1{
    // shift execution
sft_result       = SFTvar.ope(data1, sft_amt);
   }
   BaseProcessor{
    true
   }

  }
  Ext26To32(extmode,const){
   variable{
    wire [31:0] ext26to32_result;
   }
   1{
    ext26to32_result = EXT26TO32.extmode(const);
   }
   BaseProcessor{
    true
   }

  }
  Load(ope,addr){
   variable{
    wire [31:0] load_result;
   }
   1{
    wire        load_addr_err;

// result is 32bit data. already extended
<load_result, load_addr_err> = DMAU.ope(addr);
   }
   BaseProcessor{
    true
   }

  }
  Store(ope,data,addr){
   variable{
    
   }
   1{
    wire         store_addr_err;

// result is 32bit data. already extended
store_addr_err = DMAU.ope(addr, data);
   }
   BaseProcessor{
    true
   }

  }
  AbsoluteJump(addr){
   variable{
    
   }
   1{
    null = PC.write(addr); // jump according to absolute address
   }
   BaseProcessor{
    true
   }

  }
  RelativeJump(current,offset){
   variable{
    
   }
   1{
    wire [31:0] relative_jump_abs_addr;
wire [3:0]  relative_jump_alu_flag;

<relative_jump_abs_addr, relative_jump_alu_flag> 
                     = ALU.add(current, offset);         // calu. absolute address
null                 = PC.write(relative_jump_abs_addr); // jump
   }
   BaseProcessor{
    true
   }

  }
  RelativeBranchZ(ope,refdata,current,offset){
   variable{
    
   }
   1{
    wire [31:0] relative_branchz_abs_addr;
wire [3:0]  relative_branchz_alu_flag;
wire        relative_branchz_cond;

// evaluate refdata equal or not equal to zero
relative_branchz_cond = refdata ope \"00000000000000000000000000000000\";

// branch according to the cond
<relative_branchz_abs_addr, relative_branchz_alu_flag> 
                     = ALU.add(current, offset);  // calu. absolute address
null                 = [relative_branchz_cond] PC.write(relative_branchz_abs_addr); // branch
   }
   BaseProcessor{
    true
   }

  }
  ForwardDataFromEXE(dest,data){
   variable{
    
   }
   1{
    // foward data to as GPR[dest] from stage EXE
null = FWU0.forward1(dest, data);
null = FWU1.forward1(dest, data);
   }
   BaseProcessor{
    true
   }

  }
  ForwardDataFromWB(dest,data){
   variable{
    
   }
   1{
    // foward data to as GPR[dest] from stage WB
null = FWU0.forward2(dest, data);
null = FWU1.forward2(dest, data);
   }
   BaseProcessor{
    true
   }

  }

 }

}
Estimation{
 ArchLevel{
  Complete{
   OFF
  }

 }
 BehaviorLevel{
  Complete{
   OFF
  }

 }
 RTLevel{
  Complete{
   OFF
  }

 }

}
Generation{
 ISSmodel{
  Complete{
   OFF
  }

 }
 Model{
  Complete{
   OFF
  }
  lang{
   0{
    VHDL
   }
   1{
    Verilog
   }
   2{
    SystemC
   }

  }

 }

}
SW_Generation{
 SWmodel{
  Complete{
   OFF
  }

 }

}
ASM_Generation{
 ASMmodel{
  Complete{
   OFF
  }

 }

}
